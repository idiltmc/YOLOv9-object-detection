/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fidilatmaca%2FDesktop%2Fuolu%2FYOLOv9-object-detection%2Fapp%2Fsrc%2Fapp%2Fcomponents%2FApp.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!":
/*!***************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fidilatmaca%2FDesktop%2Fuolu%2FYOLOv9-object-detection%2Fapp%2Fsrc%2Fapp%2Fcomponents%2FApp.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/components/App.tsx */ \"(app-pages-browser)/./src/app/components/App.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZpZGlsYXRtYWNhJTJGRGVza3RvcCUyRnVvbHUlMkZZT0xPdjktb2JqZWN0LWRldGVjdGlvbiUyRmFwcCUyRnNyYyUyRmFwcCUyRmNvbXBvbmVudHMlMkZBcHAudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyZGVmYXVsdCUyMiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLGtMQUF1SiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvP2QwNmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJkZWZhdWx0XCJdICovIFwiL1VzZXJzL2lkaWxhdG1hY2EvRGVza3RvcC91b2x1L1lPTE92OS1vYmplY3QtZGV0ZWN0aW9uL2FwcC9zcmMvYXBwL2NvbXBvbmVudHMvQXBwLnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fidilatmaca%2FDesktop%2Fuolu%2FYOLOv9-object-detection%2Fapp%2Fsrc%2Fapp%2Fcomponents%2FApp.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanM/ZTVlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"(app-pages-browser)/./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"(app-pages-browser)/./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIseUJBQXlCOztBQUV6QjtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcz85Yjg4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG5jb25zdCBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5jb25zdCBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuY29uc3QgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBjb25zdCBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGNvbnN0IGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgbGV0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgY29uc3QgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlWaWV3IChhcnJheVZpZXcpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgbGV0IGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICBjb25zdCBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICBsZXQgeCA9IGEubGVuZ3RoXG4gIGxldCB5ID0gYi5sZW5ndGhcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIGxldCBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgbGV0IHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIGJ1ZixcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICB9XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGNvbnN0IG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2VyY2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIGNvbnN0IGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIGxldCBzdHIgPSAnJ1xuICBjb25zdCBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICBsZXQgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgbGV0IHkgPSBlbmQgLSBzdGFydFxuICBjb25zdCBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIGNvbnN0IHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICBsZXQgaW5kZXhTaXplID0gMVxuICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICBsZXQgaVxuICBpZiAoZGlyKSB7XG4gICAgbGV0IGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICBjb25zdCByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIGNvbnN0IHJlcyA9IFtdXG5cbiAgbGV0IGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIGxldCBjb2RlUG9pbnQgPSBudWxsXG4gICAgbGV0IGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5jb25zdCBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgY29uc3QgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgbGV0IG91dCA9ICcnXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgbGV0IHJlcyA9ICcnXG4gIC8vIElmIGJ5dGVzLmxlbmd0aCBpcyBvZGQsIHRoZSBsYXN0IDggYml0cyBtdXN0IGJlIGlnbm9yZWQgKHNhbWUgYXMgbm9kZS5qcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICBsZXQgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGxvID0gZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNFxuXG4gIGNvbnN0IGhpID0gdGhpc1srK29mZnNldF0gK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIGxhc3QgKiAyICoqIDI0XG5cbiAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgY29uc3QgbG8gPSB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3RcblxuICByZXR1cm4gKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobG8pXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoXG4gIGxldCBtdWwgPSAxXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICtcbiAgICB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICtcbiAgICB0aGlzW29mZnNldCArIDZdICogMiAqKiAxNiArXG4gICAgKGxhc3QgPDwgMjQpIC8vIE92ZXJmbG93XG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gKGZpcnN0IDw8IDI0KSArIC8vIE92ZXJmbG93XG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQodGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRMRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICByZXR1cm4gb2Zmc2V0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyA3XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNl0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDVdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA0XSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgM10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDJdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAxXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0XSA9IGhpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gMFxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgY29uc3QgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICBsZXQgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBDVVNUT00gRVJST1JTXG4vLyA9PT09PT09PT09PT09XG5cbi8vIFNpbXBsaWZpZWQgdmVyc2lvbnMgZnJvbSBOb2RlLCBjaGFuZ2VkIGZvciBCdWZmZXItb25seSB1c2FnZVxuY29uc3QgZXJyb3JzID0ge31cbmZ1bmN0aW9uIEUgKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkge1xuICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHN1cGVyKClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KVxuXG4gICAgICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG4gICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske3N5bX1dYFxuICAgICAgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgICAgIC8vIGZyb20gdGhlIG5hbWUuXG4gICAgICB0aGlzLnN0YWNrIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgICAvLyBSZXNldCB0aGUgbmFtZSB0byB0aGUgYWN0dWFsIG5hbWUuXG4gICAgICBkZWxldGUgdGhpcy5uYW1lXG4gICAgfVxuXG4gICAgZ2V0IGNvZGUgKCkge1xuICAgICAgcmV0dXJuIHN5bVxuICAgIH1cblxuICAgIHNldCBjb2RlICh2YWx1ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2RlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgIH1cbiAgfVxufVxuXG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLFxuICBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gYCR7bmFtZX0gaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzYFxuICAgIH1cblxuICAgIHJldHVybiAnQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcydcbiAgfSwgUmFuZ2VFcnJvcilcbkUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJyxcbiAgZnVuY3Rpb24gKG5hbWUsIGFjdHVhbCkge1xuICAgIHJldHVybiBgVGhlIFwiJHtuYW1lfVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWBcbiAgfSwgVHlwZUVycm9yKVxuRSgnRVJSX09VVF9PRl9SQU5HRScsXG4gIGZ1bmN0aW9uIChzdHIsIHJhbmdlLCBpbnB1dCkge1xuICAgIGxldCBtc2cgPSBgVGhlIHZhbHVlIG9mIFwiJHtzdHJ9XCIgaXMgb3V0IG9mIHJhbmdlLmBcbiAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dFxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7XG4gICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpXG4gICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7XG4gICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKVxuICAgICAgfVxuICAgICAgcmVjZWl2ZWQgKz0gJ24nXG4gICAgfVxuICAgIG1zZyArPSBgIEl0IG11c3QgYmUgJHtyYW5nZX0uIFJlY2VpdmVkICR7cmVjZWl2ZWR9YFxuICAgIHJldHVybiBtc2dcbiAgfSwgUmFuZ2VFcnJvcilcblxuZnVuY3Rpb24gYWRkTnVtZXJpY2FsU2VwYXJhdG9yICh2YWwpIHtcbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gdmFsLmxlbmd0aFxuICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gJy0nID8gMSA6IDBcbiAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHtcbiAgICByZXMgPSBgXyR7dmFsLnNsaWNlKGkgLSAzLCBpKX0ke3Jlc31gXG4gIH1cbiAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gXG59XG5cbi8vIENIRUNLIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGNoZWNrQm91bmRzIChidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBpZiAoYnVmW29mZnNldF0gPT09IHVuZGVmaW5lZCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoICsgMSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRCSSAodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHtcbiAgICBjb25zdCBuID0gdHlwZW9mIG1pbiA9PT0gJ2JpZ2ludCcgPyAnbicgOiAnJ1xuICAgIGxldCByYW5nZVxuICAgIGlmIChieXRlTGVuZ3RoID4gMykge1xuICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4gPT09IEJpZ0ludCgwKSkge1xuICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4fSR7bn1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn0pIGFuZCA8IDIgKiogYCArXG4gICAgICAgICAgICAgICAgYCR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn1gXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlID0gYD49ICR7bWlufSR7bn0gYW5kIDw9ICR7bWF4fSR7bn1gXG4gICAgfVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSgndmFsdWUnLCByYW5nZSwgdmFsdWUpXG4gIH1cbiAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyICh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ251bWJlcicsIHZhbHVlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0Vycm9yICh2YWx1ZSwgbGVuZ3RoLCB0eXBlKSB7XG4gIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcbiAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSlcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JywgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgfVxuXG4gIGlmIChsZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKVxuICB9XG5cbiAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgPj0gJHt0eXBlID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUpXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuY29uc3QgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIGxldCBjb2RlUG9pbnRcbiAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgY29uc3QgYnl0ZXMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIGxldCBjLCBoaSwgbG9cbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxuY29uc3QgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgY29uc3QgaTE2ID0gaSAqIDE2XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG5cbi8vIFJldHVybiBub3QgZnVuY3Rpb24gd2l0aCBFcnJvciBpZiBCaWdJbnQgbm90IHN1cHBvcnRlZFxuZnVuY3Rpb24gZGVmaW5lQmlnSW50TWV0aG9kIChmbikge1xuICByZXR1cm4gdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyBCdWZmZXJCaWdJbnROb3REZWZpbmVkIDogZm5cbn1cblxuZnVuY3Rpb24gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQmlnSW50IG5vdCBzdXBwb3J0ZWQnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/cwise-compiler/compiler.js":
/*!*************************************************!*\
  !*** ./node_modules/cwise-compiler/compiler.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar createThunk = __webpack_require__(/*! ./lib/thunk.js */ \"(app-pages-browser)/./node_modules/cwise-compiler/lib/thunk.js\")\n\nfunction Procedure() {\n  this.argTypes = []\n  this.shimArgs = []\n  this.arrayArgs = []\n  this.arrayBlockIndices = []\n  this.scalarArgs = []\n  this.offsetArgs = []\n  this.offsetArgIndex = []\n  this.indexArgs = []\n  this.shapeArgs = []\n  this.funcName = \"\"\n  this.pre = null\n  this.body = null\n  this.post = null\n  this.debug = false\n}\n\nfunction compileCwise(user_args) {\n  //Create procedure\n  var proc = new Procedure()\n  \n  //Parse blocks\n  proc.pre    = user_args.pre\n  proc.body   = user_args.body\n  proc.post   = user_args.post\n\n  //Parse arguments\n  var proc_args = user_args.args.slice(0)\n  proc.argTypes = proc_args\n  for(var i=0; i<proc_args.length; ++i) {\n    var arg_type = proc_args[i]\n    if(arg_type === \"array\" || (typeof arg_type === \"object\" && arg_type.blockIndices)) {\n      proc.argTypes[i] = \"array\"\n      proc.arrayArgs.push(i)\n      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0)\n      proc.shimArgs.push(\"array\" + i)\n      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {\n        throw new Error(\"cwise: pre() block may not reference array args\")\n      }\n      if(i < proc.post.args.length && proc.post.args[i].count>0) {\n        throw new Error(\"cwise: post() block may not reference array args\")\n      }\n    } else if(arg_type === \"scalar\") {\n      proc.scalarArgs.push(i)\n      proc.shimArgs.push(\"scalar\" + i)\n    } else if(arg_type === \"index\") {\n      proc.indexArgs.push(i)\n      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {\n        throw new Error(\"cwise: pre() block may not reference array index\")\n      }\n      if(i < proc.body.args.length && proc.body.args[i].lvalue) {\n        throw new Error(\"cwise: body() block may not write to array index\")\n      }\n      if(i < proc.post.args.length && proc.post.args[i].count > 0) {\n        throw new Error(\"cwise: post() block may not reference array index\")\n      }\n    } else if(arg_type === \"shape\") {\n      proc.shapeArgs.push(i)\n      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {\n        throw new Error(\"cwise: pre() block may not write to array shape\")\n      }\n      if(i < proc.body.args.length && proc.body.args[i].lvalue) {\n        throw new Error(\"cwise: body() block may not write to array shape\")\n      }\n      if(i < proc.post.args.length && proc.post.args[i].lvalue) {\n        throw new Error(\"cwise: post() block may not write to array shape\")\n      }\n    } else if(typeof arg_type === \"object\" && arg_type.offset) {\n      proc.argTypes[i] = \"offset\"\n      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })\n      proc.offsetArgIndex.push(i)\n    } else {\n      throw new Error(\"cwise: Unknown argument type \" + proc_args[i])\n    }\n  }\n  \n  //Make sure at least one array argument was specified\n  if(proc.arrayArgs.length <= 0) {\n    throw new Error(\"cwise: No array arguments specified\")\n  }\n  \n  //Make sure arguments are correct\n  if(proc.pre.args.length > proc_args.length) {\n    throw new Error(\"cwise: Too many arguments in pre() block\")\n  }\n  if(proc.body.args.length > proc_args.length) {\n    throw new Error(\"cwise: Too many arguments in body() block\")\n  }\n  if(proc.post.args.length > proc_args.length) {\n    throw new Error(\"cwise: Too many arguments in post() block\")\n  }\n\n  //Check debug flag\n  proc.debug = !!user_args.printCode || !!user_args.debug\n  \n  //Retrieve name\n  proc.funcName = user_args.funcName || \"cwise\"\n  \n  //Read in block size\n  proc.blockSize = user_args.blockSize || 64\n\n  return createThunk(proc)\n}\n\nmodule.exports = compileCwise\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9jb21waWxlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBZ0I7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw2QkFBNkIsK0NBQStDO0FBQzVFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvY29tcGlsZXIuanM/ZDE0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG52YXIgY3JlYXRlVGh1bmsgPSByZXF1aXJlKFwiLi9saWIvdGh1bmsuanNcIilcblxuZnVuY3Rpb24gUHJvY2VkdXJlKCkge1xuICB0aGlzLmFyZ1R5cGVzID0gW11cbiAgdGhpcy5zaGltQXJncyA9IFtdXG4gIHRoaXMuYXJyYXlBcmdzID0gW11cbiAgdGhpcy5hcnJheUJsb2NrSW5kaWNlcyA9IFtdXG4gIHRoaXMuc2NhbGFyQXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJnSW5kZXggPSBbXVxuICB0aGlzLmluZGV4QXJncyA9IFtdXG4gIHRoaXMuc2hhcGVBcmdzID0gW11cbiAgdGhpcy5mdW5jTmFtZSA9IFwiXCJcbiAgdGhpcy5wcmUgPSBudWxsXG4gIHRoaXMuYm9keSA9IG51bGxcbiAgdGhpcy5wb3N0ID0gbnVsbFxuICB0aGlzLmRlYnVnID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY29tcGlsZUN3aXNlKHVzZXJfYXJncykge1xuICAvL0NyZWF0ZSBwcm9jZWR1cmVcbiAgdmFyIHByb2MgPSBuZXcgUHJvY2VkdXJlKClcbiAgXG4gIC8vUGFyc2UgYmxvY2tzXG4gIHByb2MucHJlICAgID0gdXNlcl9hcmdzLnByZVxuICBwcm9jLmJvZHkgICA9IHVzZXJfYXJncy5ib2R5XG4gIHByb2MucG9zdCAgID0gdXNlcl9hcmdzLnBvc3RcblxuICAvL1BhcnNlIGFyZ3VtZW50c1xuICB2YXIgcHJvY19hcmdzID0gdXNlcl9hcmdzLmFyZ3Muc2xpY2UoMClcbiAgcHJvYy5hcmdUeXBlcyA9IHByb2NfYXJnc1xuICBmb3IodmFyIGk9MDsgaTxwcm9jX2FyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYXJnX3R5cGUgPSBwcm9jX2FyZ3NbaV1cbiAgICBpZihhcmdfdHlwZSA9PT0gXCJhcnJheVwiIHx8ICh0eXBlb2YgYXJnX3R5cGUgPT09IFwib2JqZWN0XCIgJiYgYXJnX3R5cGUuYmxvY2tJbmRpY2VzKSkge1xuICAgICAgcHJvYy5hcmdUeXBlc1tpXSA9IFwiYXJyYXlcIlxuICAgICAgcHJvYy5hcnJheUFyZ3MucHVzaChpKVxuICAgICAgcHJvYy5hcnJheUJsb2NrSW5kaWNlcy5wdXNoKGFyZ190eXBlLmJsb2NrSW5kaWNlcyA/IGFyZ190eXBlLmJsb2NrSW5kaWNlcyA6IDApXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJhcnJheVwiICsgaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50PjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQ+MCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcG9zdCgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2NhbGFyXCIpIHtcbiAgICAgIHByb2Muc2NhbGFyQXJncy5wdXNoKGkpXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJzY2FsYXJcIiArIGkpXG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcImluZGV4XCIpIHtcbiAgICAgIHByb2MuaW5kZXhBcmdzLnB1c2goaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50ID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcHJlKCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5jb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJzaGFwZVwiKSB7XG4gICAgICBwcm9jLnNoYXBlQXJncy5wdXNoKGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBhcmdfdHlwZSA9PT0gXCJvYmplY3RcIiAmJiBhcmdfdHlwZS5vZmZzZXQpIHtcbiAgICAgIHByb2MuYXJnVHlwZXNbaV0gPSBcIm9mZnNldFwiXG4gICAgICBwcm9jLm9mZnNldEFyZ3MucHVzaCh7IGFycmF5OiBhcmdfdHlwZS5hcnJheSwgb2Zmc2V0OmFyZ190eXBlLm9mZnNldCB9KVxuICAgICAgcHJvYy5vZmZzZXRBcmdJbmRleC5wdXNoKGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBVbmtub3duIGFyZ3VtZW50IHR5cGUgXCIgKyBwcm9jX2FyZ3NbaV0pXG4gICAgfVxuICB9XG4gIFxuICAvL01ha2Ugc3VyZSBhdCBsZWFzdCBvbmUgYXJyYXkgYXJndW1lbnQgd2FzIHNwZWNpZmllZFxuICBpZihwcm9jLmFycmF5QXJncy5sZW5ndGggPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBObyBhcnJheSBhcmd1bWVudHMgc3BlY2lmaWVkXCIpXG4gIH1cbiAgXG4gIC8vTWFrZSBzdXJlIGFyZ3VtZW50cyBhcmUgY29ycmVjdFxuICBpZihwcm9jLnByZS5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHByZSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5ib2R5LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gYm9keSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5wb3N0LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gcG9zdCgpIGJsb2NrXCIpXG4gIH1cblxuICAvL0NoZWNrIGRlYnVnIGZsYWdcbiAgcHJvYy5kZWJ1ZyA9ICEhdXNlcl9hcmdzLnByaW50Q29kZSB8fCAhIXVzZXJfYXJncy5kZWJ1Z1xuICBcbiAgLy9SZXRyaWV2ZSBuYW1lXG4gIHByb2MuZnVuY05hbWUgPSB1c2VyX2FyZ3MuZnVuY05hbWUgfHwgXCJjd2lzZVwiXG4gIFxuICAvL1JlYWQgaW4gYmxvY2sgc2l6ZVxuICBwcm9jLmJsb2NrU2l6ZSA9IHVzZXJfYXJncy5ibG9ja1NpemUgfHwgNjRcblxuICByZXR1cm4gY3JlYXRlVGh1bmsocHJvYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlQ3dpc2VcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/cwise-compiler/compiler.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/cwise-compiler/lib/compile.js":
/*!****************************************************!*\
  !*** ./node_modules/cwise-compiler/lib/compile.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar uniq = __webpack_require__(/*! uniq */ \"(app-pages-browser)/./node_modules/uniq/uniq.js\")\n\n// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)\n// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of \"pointers\" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.\nfunction innerFill(order, proc, body) {\n  var dimension = order.length\n    , nargs = proc.arrayArgs.length\n    , has_index = proc.indexArgs.length>0\n    , code = []\n    , vars = []\n    , idx=0, pidx=0, i, j\n  for(i=0; i<dimension; ++i) { // Iteration variables\n    vars.push([\"i\",i,\"=0\"].join(\"\"))\n  }\n  //Compute scan deltas\n  for(j=0; j<nargs; ++j) {\n    for(i=0; i<dimension; ++i) {\n      pidx = idx\n      idx = order[i]\n      if(i === 0) { // The innermost/fastest dimension's delta is simply its stride\n        vars.push([\"d\",j,\"s\",i,\"=t\",j,\"p\",idx].join(\"\"))\n      } else { // For other dimensions the delta is basically the stride minus something which essentially \"rewinds\" the previous (more inner) dimension\n        vars.push([\"d\",j,\"s\",i,\"=(t\",j,\"p\",idx,\"-s\",pidx,\"*t\",j,\"p\",pidx,\")\"].join(\"\"))\n      }\n    }\n  }\n  if (vars.length > 0) {\n    code.push(\"var \" + vars.join(\",\"))\n  }  \n  //Scan loop\n  for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards\n    idx = order[i]\n    code.push([\"for(i\",i,\"=0;i\",i,\"<s\",idx,\";++i\",i,\"){\"].join(\"\"))\n  }\n  //Push body of inner loop\n  code.push(body)\n  //Advance scan pointers\n  for(i=0; i<dimension; ++i) {\n    pidx = idx\n    idx = order[i]\n    for(j=0; j<nargs; ++j) {\n      code.push([\"p\",j,\"+=d\",j,\"s\",i].join(\"\"))\n    }\n    if(has_index) {\n      if(i > 0) {\n        code.push([\"index[\",pidx,\"]-=s\",pidx].join(\"\"))\n      }\n      code.push([\"++index[\",idx,\"]\"].join(\"\"))\n    }\n    code.push(\"}\")\n  }\n  return code.join(\"\\n\")\n}\n\n// Generate \"outer\" loops that loop over blocks of data, applying \"inner\" loops to the blocks by manipulating the local variables in such a way that the inner loop only \"sees\" the current block.\n// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.\n//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and \"shape\" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.\nfunction outerFill(matched, order, proc, body) {\n  var dimension = order.length\n    , nargs = proc.arrayArgs.length\n    , blockSize = proc.blockSize\n    , has_index = proc.indexArgs.length > 0\n    , code = []\n  for(var i=0; i<nargs; ++i) {\n    code.push([\"var offset\",i,\"=p\",i].join(\"\"))\n  }\n  //Generate loops for unmatched dimensions\n  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)\n  // TODO: It would be nice if the order in which these loops are placed would also be somehow \"optimal\" (at the very least we should check that it really doesn't hurt us if they're not).\n  for(var i=matched; i<dimension; ++i) {\n    code.push([\"for(var j\"+i+\"=SS[\", order[i], \"]|0;j\", i, \">0;){\"].join(\"\")) // Iterate back to front\n    code.push([\"if(j\",i,\"<\",blockSize,\"){\"].join(\"\")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).\n    code.push([\"s\",order[i],\"=j\",i].join(\"\"))\n    code.push([\"j\",i,\"=0\"].join(\"\"))\n    code.push([\"}else{s\",order[i],\"=\",blockSize].join(\"\"))\n    code.push([\"j\",i,\"-=\",blockSize,\"}\"].join(\"\"))\n    if(has_index) {\n      code.push([\"index[\",order[i],\"]=j\",i].join(\"\"))\n    }\n  }\n  for(var i=0; i<nargs; ++i) {\n    var indexStr = [\"offset\"+i]\n    for(var j=matched; j<dimension; ++j) {\n      indexStr.push([\"j\",j,\"*t\",i,\"p\",order[j]].join(\"\"))\n    }\n    code.push([\"p\",i,\"=(\",indexStr.join(\"+\"),\")\"].join(\"\"))\n  }\n  code.push(innerFill(order, proc, body))\n  for(var i=matched; i<dimension; ++i) {\n    code.push(\"}\")\n  }\n  return code.join(\"\\n\")\n}\n\n//Count the number of compatible inner orders\n// This is the length of the longest common prefix of the arrays in orders.\n// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.\n// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.\nfunction countMatches(orders) {\n  var matched = 0, dimension = orders[0].length\n  while(matched < dimension) {\n    for(var j=1; j<orders.length; ++j) {\n      if(orders[j][matched] !== orders[0][matched]) {\n        return matched\n      }\n    }\n    ++matched\n  }\n  return matched\n}\n\n//Processes a block according to the given data types\n// Replaces variable names by different ones, either \"local\" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.\nfunction processBlock(block, proc, dtypes) {\n  var code = block.body\n  var pre = []\n  var post = []\n  for(var i=0; i<block.args.length; ++i) {\n    var carg = block.args[i]\n    if(carg.count <= 0) {\n      continue\n    }\n    var re = new RegExp(carg.name, \"g\")\n    var ptrStr = \"\"\n    var arrNum = proc.arrayArgs.indexOf(i)\n    switch(proc.argTypes[i]) {\n      case \"offset\":\n        var offArgIndex = proc.offsetArgIndex.indexOf(i)\n        var offArg = proc.offsetArgs[offArgIndex]\n        arrNum = offArg.array\n        ptrStr = \"+q\" + offArgIndex // Adds offset to the \"pointer\" in the array\n      case \"array\":\n        ptrStr = \"p\" + arrNum + ptrStr\n        var localStr = \"l\" + i\n        var arrStr = \"a\" + arrNum\n        if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array\n          if(carg.count === 1) { // Argument/array used only once(?)\n            if(dtypes[arrNum] === \"generic\") {\n              if(carg.lvalue) {\n                pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)\n                code = code.replace(re, localStr)\n                post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n              } else {\n                code = code.replace(re, [arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\n              }\n            } else {\n              code = code.replace(re, [arrStr, \"[\", ptrStr, \"]\"].join(\"\"))\n            }\n          } else if(dtypes[arrNum] === \"generic\") {\n            pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\")) // TODO: Could we optimize by checking for carg.rvalue?\n            code = code.replace(re, localStr)\n            if(carg.lvalue) {\n              post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n            }\n          } else {\n            pre.push([\"var \", localStr, \"=\", arrStr, \"[\", ptrStr, \"]\"].join(\"\")) // TODO: Could we optimize by checking for carg.rvalue?\n            code = code.replace(re, localStr)\n            if(carg.lvalue) {\n              post.push([arrStr, \"[\", ptrStr, \"]=\", localStr].join(\"\"))\n            }\n          }\n        } else { // Argument to body is a \"block\"\n          var reStrArr = [carg.name], ptrStrArr = [ptrStr]\n          for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {\n            reStrArr.push(\"\\\\s*\\\\[([^\\\\]]+)\\\\]\")\n            ptrStrArr.push(\"$\" + (j+1) + \"*t\" + arrNum + \"b\" + j) // Matched index times stride\n          }\n          re = new RegExp(reStrArr.join(\"\"), \"g\")\n          ptrStr = ptrStrArr.join(\"+\")\n          if(dtypes[arrNum] === \"generic\") {\n            /*if(carg.lvalue) {\n              pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)\n              code = code.replace(re, localStr)\n              post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n            } else {\n              code = code.replace(re, [arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\n            }*/\n            throw new Error(\"cwise: Generic arrays not supported in combination with blocks!\")\n          } else {\n            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.\n            code = code.replace(re, [arrStr, \"[\", ptrStr, \"]\"].join(\"\"))\n          }\n        }\n      break\n      case \"scalar\":\n        code = code.replace(re, \"Y\" + proc.scalarArgs.indexOf(i))\n      break\n      case \"index\":\n        code = code.replace(re, \"index\")\n      break\n      case \"shape\":\n        code = code.replace(re, \"shape\")\n      break\n    }\n  }\n  return [pre.join(\"\\n\"), code, post.join(\"\\n\")].join(\"\\n\").trim()\n}\n\nfunction typeSummary(dtypes) {\n  var summary = new Array(dtypes.length)\n  var allEqual = true\n  for(var i=0; i<dtypes.length; ++i) {\n    var t = dtypes[i]\n    var digits = t.match(/\\d+/)\n    if(!digits) {\n      digits = \"\"\n    } else {\n      digits = digits[0]\n    }\n    if(t.charAt(0) === 0) {\n      summary[i] = \"u\" + t.charAt(1) + digits\n    } else {\n      summary[i] = t.charAt(0) + digits\n    }\n    if(i > 0) {\n      allEqual = allEqual && summary[i] === summary[i-1]\n    }\n  }\n  if(allEqual) {\n    return summary[0]\n  }\n  return summary.join(\"\")\n}\n\n//Generates a cwise operator\nfunction generateCWiseOp(proc, typesig) {\n\n  //Compute dimension\n  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.\n  var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0\n  var orders = new Array(proc.arrayArgs.length)\n  var dtypes = new Array(proc.arrayArgs.length)\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    dtypes[i] = typesig[2*i]\n    orders[i] = typesig[2*i+1]\n  }\n  \n  //Determine where block and loop indices start and end\n  var blockBegin = [], blockEnd = [] // These indices are exposed as blocks\n  var loopBegin = [], loopEnd = [] // These indices are iterated over\n  var loopOrders = [] // orders restricted to the loop indices\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    if (proc.arrayBlockIndices[i]<0) {\n      loopBegin.push(0)\n      loopEnd.push(dimension)\n      blockBegin.push(dimension)\n      blockEnd.push(dimension+proc.arrayBlockIndices[i])\n    } else {\n      loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative\n      loopEnd.push(proc.arrayBlockIndices[i]+dimension)\n      blockBegin.push(0)\n      blockEnd.push(proc.arrayBlockIndices[i])\n    }\n    var newOrder = []\n    for(var j=0; j<orders[i].length; j++) {\n      if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {\n        newOrder.push(orders[i][j]-loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.\n      }\n    }\n    loopOrders.push(newOrder)\n  }\n\n  //First create arguments for procedure\n  var arglist = [\"SS\"] // SS is the overall shape over which we iterate\n  var code = [\"'use strict'\"]\n  var vars = []\n  \n  for(var j=0; j<dimension; ++j) {\n    vars.push([\"s\", j, \"=SS[\", j, \"]\"].join(\"\")) // The limits for each dimension.\n  }\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    arglist.push(\"a\"+i) // Actual data array\n    arglist.push(\"t\"+i) // Strides\n    arglist.push(\"p\"+i) // Offset in the array at which the data starts (also used for iterating over the data)\n    \n    for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping\n      vars.push([\"t\",i,\"p\",j,\"=t\",i,\"[\",loopBegin[i]+j,\"]\"].join(\"\"))\n    }\n    \n    for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration\n      vars.push([\"t\",i,\"b\",j,\"=t\",i,\"[\",blockBegin[i]+j,\"]\"].join(\"\"))\n    }\n  }\n  for(var i=0; i<proc.scalarArgs.length; ++i) {\n    arglist.push(\"Y\" + i)\n  }\n  if(proc.shapeArgs.length > 0) {\n    vars.push(\"shape=SS.slice(0)\") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)\n  }\n  if(proc.indexArgs.length > 0) {\n    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.\n    var zeros = new Array(dimension)\n    for(var i=0; i<dimension; ++i) {\n      zeros[i] = \"0\"\n    }\n    vars.push([\"index=[\", zeros.join(\",\"), \"]\"].join(\"\"))\n  }\n  for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations\n    var off_arg = proc.offsetArgs[i]\n    var init_string = []\n    for(var j=0; j<off_arg.offset.length; ++j) {\n      if(off_arg.offset[j] === 0) {\n        continue\n      } else if(off_arg.offset[j] === 1) {\n        init_string.push([\"t\", off_arg.array, \"p\", j].join(\"\"))      \n      } else {\n        init_string.push([off_arg.offset[j], \"*t\", off_arg.array, \"p\", j].join(\"\"))\n      }\n    }\n    if(init_string.length === 0) {\n      vars.push(\"q\" + i + \"=0\")\n    } else {\n      vars.push([\"q\", i, \"=\", init_string.join(\"+\")].join(\"\"))\n    }\n  }\n\n  //Prepare this variables\n  var thisVars = uniq([].concat(proc.pre.thisVars)\n                      .concat(proc.body.thisVars)\n                      .concat(proc.post.thisVars))\n  vars = vars.concat(thisVars)\n  if (vars.length > 0) {\n    code.push(\"var \" + vars.join(\",\"))\n  }\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    code.push(\"p\"+i+\"|=0\")\n  }\n  \n  //Inline prelude\n  if(proc.pre.body.length > 3) {\n    code.push(processBlock(proc.pre, proc, dtypes))\n  }\n\n  //Process body\n  var body = processBlock(proc.body, proc, dtypes)\n  var matched = countMatches(loopOrders)\n  if(matched < dimension) {\n    code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.\n  } else {\n    code.push(innerFill(loopOrders[0], proc, body))\n  }\n\n  //Inline epilog\n  if(proc.post.body.length > 3) {\n    code.push(processBlock(proc.post, proc, dtypes))\n  }\n  \n  if(proc.debug) {\n    console.log(\"-----Generated cwise routine for \", typesig, \":\\n\" + code.join(\"\\n\") + \"\\n----------\")\n  }\n  \n  var loopName = [(proc.funcName||\"unnamed\"), \"_cwise_loop_\", orders[0].join(\"s\"),\"m\",matched,typeSummary(dtypes)].join(\"\")\n  var f = new Function([\"function \",loopName,\"(\", arglist.join(\",\"),\"){\", code.join(\"\\n\"),\"} return \", loopName].join(\"\"))\n  return f()\n}\nmodule.exports = generateCWiseOp\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9saWIvY29tcGlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsNkRBQU07O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYSxPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTSxPQUFPO0FBQ2xDO0FBQ0EsNkJBQTZCLGdCQUFnQixVQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQyxvREFBb0QsV0FBVyxFQUFFO0FBQ2pFLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEIsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQSx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWEsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUNBQXVDLE9BQU87QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEIsT0FBTztBQUNoRDtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsc0JBQXNCO0FBQzdGO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL2NvbXBpbGUuanM/OGViMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG52YXIgdW5pcSA9IHJlcXVpcmUoXCJ1bmlxXCIpXG5cbi8vIFRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIHZlcnkgc2ltcGxlIGxvb3BzIGFuYWxvZ291cyB0byBob3cgeW91IHR5cGljYWxseSB0cmF2ZXJzZSBhcnJheXMgKHRoZSBvdXRlcm1vc3QgbG9vcCBjb3JyZXNwb25kcyB0byB0aGUgc2xvd2VzdCBjaGFuZ2luZyBpbmRleCwgdGhlIGlubmVybW9zdCBsb29wIHRvIHRoZSBmYXN0ZXN0IGNoYW5naW5nIGluZGV4KVxuLy8gVE9ETzogSWYgdHdvIGFycmF5cyBoYXZlIHRoZSBzYW1lIHN0cmlkZXMgKGFuZCBvZmZzZXRzKSB0aGVyZSBpcyBwb3RlbnRpYWwgZm9yIGRlY3JlYXNpbmcgdGhlIG51bWJlciBvZiBcInBvaW50ZXJzXCIgYW5kIHJlbGF0ZWQgdmFyaWFibGVzLiBUaGUgZHJhd2JhY2sgaXMgdGhhdCB0aGUgdHlwZSBzaWduYXR1cmUgd291bGQgYmVjb21lIG1vcmUgc3BlY2lmaWMgYW5kIHRoYXQgdGhlcmUgd291bGQgdGh1cyBiZSBsZXNzIHBvdGVudGlhbCBmb3IgY2FjaGluZywgYnV0IGl0IG1pZ2h0IHN0aWxsIGJlIHdvcnRoIGl0LCBlc3BlY2lhbGx5IHdoZW4gZGVhbGluZyB3aXRoIGxhcmdlIG51bWJlcnMgb2YgYXJndW1lbnRzLlxuZnVuY3Rpb24gaW5uZXJGaWxsKG9yZGVyLCBwcm9jLCBib2R5KSB7XG4gIHZhciBkaW1lbnNpb24gPSBvcmRlci5sZW5ndGhcbiAgICAsIG5hcmdzID0gcHJvYy5hcnJheUFyZ3MubGVuZ3RoXG4gICAgLCBoYXNfaW5kZXggPSBwcm9jLmluZGV4QXJncy5sZW5ndGg+MFxuICAgICwgY29kZSA9IFtdXG4gICAgLCB2YXJzID0gW11cbiAgICAsIGlkeD0wLCBwaWR4PTAsIGksIGpcbiAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkgeyAvLyBJdGVyYXRpb24gdmFyaWFibGVzXG4gICAgdmFycy5wdXNoKFtcImlcIixpLFwiPTBcIl0uam9pbihcIlwiKSlcbiAgfVxuICAvL0NvbXB1dGUgc2NhbiBkZWx0YXNcbiAgZm9yKGo9MDsgajxuYXJnczsgKytqKSB7XG4gICAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgcGlkeCA9IGlkeFxuICAgICAgaWR4ID0gb3JkZXJbaV1cbiAgICAgIGlmKGkgPT09IDApIHsgLy8gVGhlIGlubmVybW9zdC9mYXN0ZXN0IGRpbWVuc2lvbidzIGRlbHRhIGlzIHNpbXBseSBpdHMgc3RyaWRlXG4gICAgICAgIHZhcnMucHVzaChbXCJkXCIsaixcInNcIixpLFwiPXRcIixqLFwicFwiLGlkeF0uam9pbihcIlwiKSlcbiAgICAgIH0gZWxzZSB7IC8vIEZvciBvdGhlciBkaW1lbnNpb25zIHRoZSBkZWx0YSBpcyBiYXNpY2FsbHkgdGhlIHN0cmlkZSBtaW51cyBzb21ldGhpbmcgd2hpY2ggZXNzZW50aWFsbHkgXCJyZXdpbmRzXCIgdGhlIHByZXZpb3VzIChtb3JlIGlubmVyKSBkaW1lbnNpb25cbiAgICAgICAgdmFycy5wdXNoKFtcImRcIixqLFwic1wiLGksXCI9KHRcIixqLFwicFwiLGlkeCxcIi1zXCIscGlkeCxcIip0XCIsaixcInBcIixwaWR4LFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodmFycy5sZW5ndGggPiAwKSB7XG4gICAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgfSAgXG4gIC8vU2NhbiBsb29wXG4gIGZvcihpPWRpbWVuc2lvbi0xOyBpPj0wOyAtLWkpIHsgLy8gU3RhcnQgYXQgbGFyZ2VzdCBzdHJpZGUgYW5kIHdvcmsgeW91ciB3YXkgaW53YXJkc1xuICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgY29kZS5wdXNoKFtcImZvcihpXCIsaSxcIj0wO2lcIixpLFwiPHNcIixpZHgsXCI7KytpXCIsaSxcIil7XCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgLy9QdXNoIGJvZHkgb2YgaW5uZXIgbG9vcFxuICBjb2RlLnB1c2goYm9keSlcbiAgLy9BZHZhbmNlIHNjYW4gcG9pbnRlcnNcbiAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHBpZHggPSBpZHhcbiAgICBpZHggPSBvcmRlcltpXVxuICAgIGZvcihqPTA7IGo8bmFyZ3M7ICsraikge1xuICAgICAgY29kZS5wdXNoKFtcInBcIixqLFwiKz1kXCIsaixcInNcIixpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBpZihoYXNfaW5kZXgpIHtcbiAgICAgIGlmKGkgPiAwKSB7XG4gICAgICAgIGNvZGUucHVzaChbXCJpbmRleFtcIixwaWR4LFwiXS09c1wiLHBpZHhdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgICBjb2RlLnB1c2goW1wiKytpbmRleFtcIixpZHgsXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuICByZXR1cm4gY29kZS5qb2luKFwiXFxuXCIpXG59XG5cbi8vIEdlbmVyYXRlIFwib3V0ZXJcIiBsb29wcyB0aGF0IGxvb3Agb3ZlciBibG9ja3Mgb2YgZGF0YSwgYXBwbHlpbmcgXCJpbm5lclwiIGxvb3BzIHRvIHRoZSBibG9ja3MgYnkgbWFuaXB1bGF0aW5nIHRoZSBsb2NhbCB2YXJpYWJsZXMgaW4gc3VjaCBhIHdheSB0aGF0IHRoZSBpbm5lciBsb29wIG9ubHkgXCJzZWVzXCIgdGhlIGN1cnJlbnQgYmxvY2suXG4vLyBUT0RPOiBJZiB0aGlzIGlzIHVzZWQsIHRoZW4gdGhlIHByZXZpb3VzIGRlY2xhcmF0aW9uIChkb25lIGJ5IGdlbmVyYXRlQ3dpc2VPcCkgb2YgcyogaXMgZXNzZW50aWFsbHkgdW5uZWNlc3NhcnkuXG4vLyAgICAgICBJIGJlbGlldmUgdGhlIHMqIGFyZSBub3QgdXNlZCBlbHNld2hlcmUgKGluIHBhcnRpY3VsYXIsIEkgZG9uJ3QgdGhpbmsgdGhleSdyZSB1c2VkIGluIHRoZSBwcmUvcG9zdCBwYXJ0cyBhbmQgXCJzaGFwZVwiIGlzIGRlZmluZWQgaW5kZXBlbmRlbnRseSksIHNvIGl0IHdvdWxkIGJlIHBvc3NpYmxlIHRvIG1ha2UgZGVmaW5pbmcgdGhlIHMqIGRlcGVuZGVudCBvbiB3aGF0IGxvb3AgbWV0aG9kIGlzIGJlaW5nIHVzZWQuXG5mdW5jdGlvbiBvdXRlckZpbGwobWF0Y2hlZCwgb3JkZXIsIHByb2MsIGJvZHkpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IG9yZGVyLmxlbmd0aFxuICAgICwgbmFyZ3MgPSBwcm9jLmFycmF5QXJncy5sZW5ndGhcbiAgICAsIGJsb2NrU2l6ZSA9IHByb2MuYmxvY2tTaXplXG4gICAgLCBoYXNfaW5kZXggPSBwcm9jLmluZGV4QXJncy5sZW5ndGggPiAwXG4gICAgLCBjb2RlID0gW11cbiAgZm9yKHZhciBpPTA7IGk8bmFyZ3M7ICsraSkge1xuICAgIGNvZGUucHVzaChbXCJ2YXIgb2Zmc2V0XCIsaSxcIj1wXCIsaV0uam9pbihcIlwiKSlcbiAgfVxuICAvL0dlbmVyYXRlIGxvb3BzIGZvciB1bm1hdGNoZWQgZGltZW5zaW9uc1xuICAvLyBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlc2UgZGltZW5zaW9ucyBhcmUgdHJhdmVyc2VkIGlzIGZhaXJseSBhcmJpdHJhcnkgKGZyb20gc21hbGwgc3RyaWRlIHRvIGxhcmdlIHN0cmlkZSwgZm9yIHRoZSBmaXJzdCBhcmd1bWVudClcbiAgLy8gVE9ETzogSXQgd291bGQgYmUgbmljZSBpZiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlc2UgbG9vcHMgYXJlIHBsYWNlZCB3b3VsZCBhbHNvIGJlIHNvbWVob3cgXCJvcHRpbWFsXCIgKGF0IHRoZSB2ZXJ5IGxlYXN0IHdlIHNob3VsZCBjaGVjayB0aGF0IGl0IHJlYWxseSBkb2Vzbid0IGh1cnQgdXMgaWYgdGhleSdyZSBub3QpLlxuICBmb3IodmFyIGk9bWF0Y2hlZDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChbXCJmb3IodmFyIGpcIitpK1wiPVNTW1wiLCBvcmRlcltpXSwgXCJdfDA7alwiLCBpLCBcIj4wOyl7XCJdLmpvaW4oXCJcIikpIC8vIEl0ZXJhdGUgYmFjayB0byBmcm9udFxuICAgIGNvZGUucHVzaChbXCJpZihqXCIsaSxcIjxcIixibG9ja1NpemUsXCIpe1wiXS5qb2luKFwiXCIpKSAvLyBFaXRoZXIgZGVjcmVhc2UgaiBieSBibG9ja1NpemUgKHMgPSBibG9ja1NpemUpLCBvciBzZXQgaXQgdG8gemVybyAoYWZ0ZXIgc2V0dGluZyBzID0gaikuXG4gICAgY29kZS5wdXNoKFtcInNcIixvcmRlcltpXSxcIj1qXCIsaV0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wialwiLGksXCI9MFwiXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJ9ZWxzZXtzXCIsb3JkZXJbaV0sXCI9XCIsYmxvY2tTaXplXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJqXCIsaSxcIi09XCIsYmxvY2tTaXplLFwifVwiXS5qb2luKFwiXCIpKVxuICAgIGlmKGhhc19pbmRleCkge1xuICAgICAgY29kZS5wdXNoKFtcImluZGV4W1wiLG9yZGVyW2ldLFwiXT1qXCIsaV0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8bmFyZ3M7ICsraSkge1xuICAgIHZhciBpbmRleFN0ciA9IFtcIm9mZnNldFwiK2ldXG4gICAgZm9yKHZhciBqPW1hdGNoZWQ7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICAgIGluZGV4U3RyLnB1c2goW1wialwiLGosXCIqdFwiLGksXCJwXCIsb3JkZXJbal1dLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGNvZGUucHVzaChbXCJwXCIsaSxcIj0oXCIsaW5kZXhTdHIuam9pbihcIitcIiksXCIpXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgY29kZS5wdXNoKGlubmVyRmlsbChvcmRlciwgcHJvYywgYm9keSkpXG4gIGZvcih2YXIgaT1tYXRjaGVkOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG4gIHJldHVybiBjb2RlLmpvaW4oXCJcXG5cIilcbn1cblxuLy9Db3VudCB0aGUgbnVtYmVyIG9mIGNvbXBhdGlibGUgaW5uZXIgb3JkZXJzXG4vLyBUaGlzIGlzIHRoZSBsZW5ndGggb2YgdGhlIGxvbmdlc3QgY29tbW9uIHByZWZpeCBvZiB0aGUgYXJyYXlzIGluIG9yZGVycy5cbi8vIEVhY2ggYXJyYXkgaW4gb3JkZXJzIGxpc3RzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBjb3JyZXNwb25kIG5kYXJyYXkgaW4gb3JkZXIgb2YgaW5jcmVhc2luZyBzdHJpZGUuXG4vLyBUaGlzIGlzIHRodXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGRpbWVuc2lvbnMgdGhhdCBjYW4gYmUgZWZmaWNpZW50bHkgdHJhdmVyc2VkIGJ5IHNpbXBsZSBuZXN0ZWQgbG9vcHMgZm9yIGFsbCBhcnJheXMuXG5mdW5jdGlvbiBjb3VudE1hdGNoZXMob3JkZXJzKSB7XG4gIHZhciBtYXRjaGVkID0gMCwgZGltZW5zaW9uID0gb3JkZXJzWzBdLmxlbmd0aFxuICB3aGlsZShtYXRjaGVkIDwgZGltZW5zaW9uKSB7XG4gICAgZm9yKHZhciBqPTE7IGo8b3JkZXJzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZihvcmRlcnNbal1bbWF0Y2hlZF0gIT09IG9yZGVyc1swXVttYXRjaGVkXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlZFxuICAgICAgfVxuICAgIH1cbiAgICArK21hdGNoZWRcbiAgfVxuICByZXR1cm4gbWF0Y2hlZFxufVxuXG4vL1Byb2Nlc3NlcyBhIGJsb2NrIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZGF0YSB0eXBlc1xuLy8gUmVwbGFjZXMgdmFyaWFibGUgbmFtZXMgYnkgZGlmZmVyZW50IG9uZXMsIGVpdGhlciBcImxvY2FsXCIgb25lcyAodGhhdCBhcmUgdGhlbiBmZXJyaWVkIGluIGFuZCBvdXQgb2YgdGhlIGdpdmVuIGFycmF5KSBvciBvbmVzIG1hdGNoaW5nIHRoZSBhcmd1bWVudHMgdGhhdCB0aGUgZnVuY3Rpb24gcGVyZm9ybWluZyB0aGUgdWx0aW1hdGUgbG9vcCB3aWxsIGFjY2VwdC5cbmZ1bmN0aW9uIHByb2Nlc3NCbG9jayhibG9jaywgcHJvYywgZHR5cGVzKSB7XG4gIHZhciBjb2RlID0gYmxvY2suYm9keVxuICB2YXIgcHJlID0gW11cbiAgdmFyIHBvc3QgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxibG9jay5hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNhcmcgPSBibG9jay5hcmdzW2ldXG4gICAgaWYoY2FyZy5jb3VudCA8PSAwKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKGNhcmcubmFtZSwgXCJnXCIpXG4gICAgdmFyIHB0clN0ciA9IFwiXCJcbiAgICB2YXIgYXJyTnVtID0gcHJvYy5hcnJheUFyZ3MuaW5kZXhPZihpKVxuICAgIHN3aXRjaChwcm9jLmFyZ1R5cGVzW2ldKSB7XG4gICAgICBjYXNlIFwib2Zmc2V0XCI6XG4gICAgICAgIHZhciBvZmZBcmdJbmRleCA9IHByb2Mub2Zmc2V0QXJnSW5kZXguaW5kZXhPZihpKVxuICAgICAgICB2YXIgb2ZmQXJnID0gcHJvYy5vZmZzZXRBcmdzW29mZkFyZ0luZGV4XVxuICAgICAgICBhcnJOdW0gPSBvZmZBcmcuYXJyYXlcbiAgICAgICAgcHRyU3RyID0gXCIrcVwiICsgb2ZmQXJnSW5kZXggLy8gQWRkcyBvZmZzZXQgdG8gdGhlIFwicG9pbnRlclwiIGluIHRoZSBhcnJheVxuICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgIHB0clN0ciA9IFwicFwiICsgYXJyTnVtICsgcHRyU3RyXG4gICAgICAgIHZhciBsb2NhbFN0ciA9IFwibFwiICsgaVxuICAgICAgICB2YXIgYXJyU3RyID0gXCJhXCIgKyBhcnJOdW1cbiAgICAgICAgaWYgKHByb2MuYXJyYXlCbG9ja0luZGljZXNbYXJyTnVtXSA9PT0gMCkgeyAvLyBBcmd1bWVudCB0byBib2R5IGlzIGp1c3QgYSBzaW5nbGUgdmFsdWUgZnJvbSB0aGlzIGFycmF5XG4gICAgICAgICAgaWYoY2FyZy5jb3VudCA9PT0gMSkgeyAvLyBBcmd1bWVudC9hcnJheSB1c2VkIG9ubHkgb25jZSg/KVxuICAgICAgICAgICAgaWYoZHR5cGVzW2Fyck51bV0gPT09IFwiZ2VuZXJpY1wiKSB7XG4gICAgICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKSAvLyBJcyB0aGlzIG5lY2Vzc2FyeSBpZiB0aGUgYXJndW1lbnQgaXMgT05MWSB1c2VkIGFzIGFuIGx2YWx1ZT8gKGtlZXAgaW4gbWluZCB0aGF0IHdlIGNhbiBoYXZlIGEgKz0gc29tZXRoaW5nLCBzbyB3ZSB3b3VsZCBhY3R1YWxseSBuZWVkIHRvIGNoZWNrIGNhcmcucnZhbHVlKVxuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKSAvLyBUT0RPOiBDb3VsZCB3ZSBvcHRpbWl6ZSBieSBjaGVja2luZyBmb3IgY2FyZy5ydmFsdWU/XG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSkgLy8gVE9ETzogQ291bGQgd2Ugb3B0aW1pemUgYnkgY2hlY2tpbmcgZm9yIGNhcmcucnZhbHVlP1xuICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICBpZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdPVwiLCBsb2NhbFN0cl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIEFyZ3VtZW50IHRvIGJvZHkgaXMgYSBcImJsb2NrXCJcbiAgICAgICAgICB2YXIgcmVTdHJBcnIgPSBbY2FyZy5uYW1lXSwgcHRyU3RyQXJyID0gW3B0clN0cl1cbiAgICAgICAgICBmb3IodmFyIGo9MDsgajxNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2Fyck51bV0pOyBqKyspIHtcbiAgICAgICAgICAgIHJlU3RyQXJyLnB1c2goXCJcXFxccypcXFxcWyhbXlxcXFxdXSspXFxcXF1cIilcbiAgICAgICAgICAgIHB0clN0ckFyci5wdXNoKFwiJFwiICsgKGorMSkgKyBcIip0XCIgKyBhcnJOdW0gKyBcImJcIiArIGopIC8vIE1hdGNoZWQgaW5kZXggdGltZXMgc3RyaWRlXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlID0gbmV3IFJlZ0V4cChyZVN0ckFyci5qb2luKFwiXCIpLCBcImdcIilcbiAgICAgICAgICBwdHJTdHIgPSBwdHJTdHJBcnIuam9pbihcIitcIilcbiAgICAgICAgICBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgIC8qaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKSAvLyBJcyB0aGlzIG5lY2Vzc2FyeSBpZiB0aGUgYXJndW1lbnQgaXMgT05MWSB1c2VkIGFzIGFuIGx2YWx1ZT8gKGtlZXAgaW4gbWluZCB0aGF0IHdlIGNhbiBoYXZlIGEgKz0gc29tZXRoaW5nLCBzbyB3ZSB3b3VsZCBhY3R1YWxseSBuZWVkIHRvIGNoZWNrIGNhcmcucnZhbHVlKVxuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBHZW5lcmljIGFycmF5cyBub3Qgc3VwcG9ydGVkIGluIGNvbWJpbmF0aW9uIHdpdGggYmxvY2tzIVwiKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGRvZXMgbm90IHByb2R1Y2UgYW55IGxvY2FsIHZhcmlhYmxlcywgZXZlbiBpZiB2YXJpYWJsZXMgYXJlIHVzZWQgbXVsdGlwbGUgdGltZXMuIEl0IHdvdWxkIGJlIHBvc3NpYmxlIHRvIGRvIHNvLCBidXQgaXQgd291bGQgY29tcGxpY2F0ZSB0aGluZ3MgcXVpdGUgYSBiaXQuXG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiWVwiICsgcHJvYy5zY2FsYXJBcmdzLmluZGV4T2YoaSkpXG4gICAgICBicmVha1xuICAgICAgY2FzZSBcImluZGV4XCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiaW5kZXhcIilcbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2hhcGVcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJzaGFwZVwiKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtwcmUuam9pbihcIlxcblwiKSwgY29kZSwgcG9zdC5qb2luKFwiXFxuXCIpXS5qb2luKFwiXFxuXCIpLnRyaW0oKVxufVxuXG5mdW5jdGlvbiB0eXBlU3VtbWFyeShkdHlwZXMpIHtcbiAgdmFyIHN1bW1hcnkgPSBuZXcgQXJyYXkoZHR5cGVzLmxlbmd0aClcbiAgdmFyIGFsbEVxdWFsID0gdHJ1ZVxuICBmb3IodmFyIGk9MDsgaTxkdHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgdCA9IGR0eXBlc1tpXVxuICAgIHZhciBkaWdpdHMgPSB0Lm1hdGNoKC9cXGQrLylcbiAgICBpZighZGlnaXRzKSB7XG4gICAgICBkaWdpdHMgPSBcIlwiXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZ2l0cyA9IGRpZ2l0c1swXVxuICAgIH1cbiAgICBpZih0LmNoYXJBdCgwKSA9PT0gMCkge1xuICAgICAgc3VtbWFyeVtpXSA9IFwidVwiICsgdC5jaGFyQXQoMSkgKyBkaWdpdHNcbiAgICB9IGVsc2Uge1xuICAgICAgc3VtbWFyeVtpXSA9IHQuY2hhckF0KDApICsgZGlnaXRzXG4gICAgfVxuICAgIGlmKGkgPiAwKSB7XG4gICAgICBhbGxFcXVhbCA9IGFsbEVxdWFsICYmIHN1bW1hcnlbaV0gPT09IHN1bW1hcnlbaS0xXVxuICAgIH1cbiAgfVxuICBpZihhbGxFcXVhbCkge1xuICAgIHJldHVybiBzdW1tYXJ5WzBdXG4gIH1cbiAgcmV0dXJuIHN1bW1hcnkuam9pbihcIlwiKVxufVxuXG4vL0dlbmVyYXRlcyBhIGN3aXNlIG9wZXJhdG9yXG5mdW5jdGlvbiBnZW5lcmF0ZUNXaXNlT3AocHJvYywgdHlwZXNpZykge1xuXG4gIC8vQ29tcHV0ZSBkaW1lbnNpb25cbiAgLy8gQXJyYXlzIGdldCBwdXQgZmlyc3QgaW4gdHlwZXNpZywgYW5kIHRoZXJlIGFyZSB0d28gZW50cmllcyBwZXIgYXJyYXkgKGR0eXBlIGFuZCBvcmRlciksIHNvIHRoaXMgZ2V0cyB0aGUgbnVtYmVyIG9mIGRpbWVuc2lvbnMgaW4gdGhlIGZpcnN0IGFycmF5IGFyZy5cbiAgdmFyIGRpbWVuc2lvbiA9ICh0eXBlc2lnWzFdLmxlbmd0aCAtIE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pKXwwXG4gIHZhciBvcmRlcnMgPSBuZXcgQXJyYXkocHJvYy5hcnJheUFyZ3MubGVuZ3RoKVxuICB2YXIgZHR5cGVzID0gbmV3IEFycmF5KHByb2MuYXJyYXlBcmdzLmxlbmd0aClcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBkdHlwZXNbaV0gPSB0eXBlc2lnWzIqaV1cbiAgICBvcmRlcnNbaV0gPSB0eXBlc2lnWzIqaSsxXVxuICB9XG4gIFxuICAvL0RldGVybWluZSB3aGVyZSBibG9jayBhbmQgbG9vcCBpbmRpY2VzIHN0YXJ0IGFuZCBlbmRcbiAgdmFyIGJsb2NrQmVnaW4gPSBbXSwgYmxvY2tFbmQgPSBbXSAvLyBUaGVzZSBpbmRpY2VzIGFyZSBleHBvc2VkIGFzIGJsb2Nrc1xuICB2YXIgbG9vcEJlZ2luID0gW10sIGxvb3BFbmQgPSBbXSAvLyBUaGVzZSBpbmRpY2VzIGFyZSBpdGVyYXRlZCBvdmVyXG4gIHZhciBsb29wT3JkZXJzID0gW10gLy8gb3JkZXJzIHJlc3RyaWN0ZWQgdG8gdGhlIGxvb3AgaW5kaWNlc1xuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldPDApIHtcbiAgICAgIGxvb3BCZWdpbi5wdXNoKDApXG4gICAgICBsb29wRW5kLnB1c2goZGltZW5zaW9uKVxuICAgICAgYmxvY2tCZWdpbi5wdXNoKGRpbWVuc2lvbilcbiAgICAgIGJsb2NrRW5kLnB1c2goZGltZW5zaW9uK3Byb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGxvb3BCZWdpbi5wdXNoKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pIC8vIE5vbi1uZWdhdGl2ZVxuICAgICAgbG9vcEVuZC5wdXNoKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0rZGltZW5zaW9uKVxuICAgICAgYmxvY2tCZWdpbi5wdXNoKDApXG4gICAgICBibG9ja0VuZC5wdXNoKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pXG4gICAgfVxuICAgIHZhciBuZXdPcmRlciA9IFtdXG4gICAgZm9yKHZhciBqPTA7IGo8b3JkZXJzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAobG9vcEJlZ2luW2ldPD1vcmRlcnNbaV1bal0gJiYgb3JkZXJzW2ldW2pdPGxvb3BFbmRbaV0pIHtcbiAgICAgICAgbmV3T3JkZXIucHVzaChvcmRlcnNbaV1bal0tbG9vcEJlZ2luW2ldKSAvLyBJZiB0aGlzIGlzIGEgbG9vcCBpbmRleCwgcHV0IGl0IGluIG5ld09yZGVyLCBzdWJ0cmFjdGluZyBsb29wQmVnaW4sIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCBsb29wT3JkZXJzIGFyZSB1c2luZyBhIGNvbW1vbiBzZXQgb2YgaW5kaWNlcy5cbiAgICAgIH1cbiAgICB9XG4gICAgbG9vcE9yZGVycy5wdXNoKG5ld09yZGVyKVxuICB9XG5cbiAgLy9GaXJzdCBjcmVhdGUgYXJndW1lbnRzIGZvciBwcm9jZWR1cmVcbiAgdmFyIGFyZ2xpc3QgPSBbXCJTU1wiXSAvLyBTUyBpcyB0aGUgb3ZlcmFsbCBzaGFwZSBvdmVyIHdoaWNoIHdlIGl0ZXJhdGVcbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIl1cbiAgdmFyIHZhcnMgPSBbXVxuICBcbiAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICB2YXJzLnB1c2goW1wic1wiLCBqLCBcIj1TU1tcIiwgaiwgXCJdXCJdLmpvaW4oXCJcIikpIC8vIFRoZSBsaW1pdHMgZm9yIGVhY2ggZGltZW5zaW9uLlxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgYXJnbGlzdC5wdXNoKFwiYVwiK2kpIC8vIEFjdHVhbCBkYXRhIGFycmF5XG4gICAgYXJnbGlzdC5wdXNoKFwidFwiK2kpIC8vIFN0cmlkZXNcbiAgICBhcmdsaXN0LnB1c2goXCJwXCIraSkgLy8gT2Zmc2V0IGluIHRoZSBhcnJheSBhdCB3aGljaCB0aGUgZGF0YSBzdGFydHMgKGFsc28gdXNlZCBmb3IgaXRlcmF0aW5nIG92ZXIgdGhlIGRhdGEpXG4gICAgXG4gICAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHsgLy8gVW5wYWNrIHRoZSBzdHJpZGVzIGludG8gdmFycyBmb3IgbG9vcGluZ1xuICAgICAgdmFycy5wdXNoKFtcInRcIixpLFwicFwiLGosXCI9dFwiLGksXCJbXCIsbG9vcEJlZ2luW2ldK2osXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIFxuICAgIGZvcih2YXIgaj0wOyBqPE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pOyArK2opIHsgLy8gVW5wYWNrIHRoZSBzdHJpZGVzIGludG8gdmFycyBmb3IgYmxvY2sgaXRlcmF0aW9uXG4gICAgICB2YXJzLnB1c2goW1widFwiLGksXCJiXCIsaixcIj10XCIsaSxcIltcIixibG9ja0JlZ2luW2ldK2osXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2Muc2NhbGFyQXJncy5sZW5ndGg7ICsraSkge1xuICAgIGFyZ2xpc3QucHVzaChcIllcIiArIGkpXG4gIH1cbiAgaWYocHJvYy5zaGFwZUFyZ3MubGVuZ3RoID4gMCkge1xuICAgIHZhcnMucHVzaChcInNoYXBlPVNTLnNsaWNlKDApXCIpIC8vIE1ha2VzIHRoZSBzaGFwZSBvdmVyIHdoaWNoIHdlIGl0ZXJhdGUgYXZhaWxhYmxlIHRvIHRoZSB1c2VyIGRlZmluZWQgZnVuY3Rpb25zIChzbyB5b3UgY2FuIHVzZSB3aWR0aC9oZWlnaHQgZm9yIGV4YW1wbGUpXG4gIH1cbiAgaWYocHJvYy5pbmRleEFyZ3MubGVuZ3RoID4gMCkge1xuICAgIC8vIFByZXBhcmUgYW4gYXJyYXkgdG8ga2VlcCB0cmFjayBvZiB0aGUgKGxvZ2ljYWwpIGluZGljZXMsIGluaXRpYWxpemVkIHRvIGRpbWVuc2lvbiB6ZXJvZXMuXG4gICAgdmFyIHplcm9zID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgemVyb3NbaV0gPSBcIjBcIlxuICAgIH1cbiAgICB2YXJzLnB1c2goW1wiaW5kZXg9W1wiLCB6ZXJvcy5qb2luKFwiLFwiKSwgXCJdXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5vZmZzZXRBcmdzLmxlbmd0aDsgKytpKSB7IC8vIE9mZnNldCBhcmd1bWVudHMgdXNlZCBmb3Igc3RlbmNpbCBvcGVyYXRpb25zXG4gICAgdmFyIG9mZl9hcmcgPSBwcm9jLm9mZnNldEFyZ3NbaV1cbiAgICB2YXIgaW5pdF9zdHJpbmcgPSBbXVxuICAgIGZvcih2YXIgaj0wOyBqPG9mZl9hcmcub2Zmc2V0Lmxlbmd0aDsgKytqKSB7XG4gICAgICBpZihvZmZfYXJnLm9mZnNldFtqXSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmKG9mZl9hcmcub2Zmc2V0W2pdID09PSAxKSB7XG4gICAgICAgIGluaXRfc3RyaW5nLnB1c2goW1widFwiLCBvZmZfYXJnLmFycmF5LCBcInBcIiwgal0uam9pbihcIlwiKSkgICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRfc3RyaW5nLnB1c2goW29mZl9hcmcub2Zmc2V0W2pdLCBcIip0XCIsIG9mZl9hcmcuYXJyYXksIFwicFwiLCBqXS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihpbml0X3N0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhcnMucHVzaChcInFcIiArIGkgKyBcIj0wXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhcnMucHVzaChbXCJxXCIsIGksIFwiPVwiLCBpbml0X3N0cmluZy5qb2luKFwiK1wiKV0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cblxuICAvL1ByZXBhcmUgdGhpcyB2YXJpYWJsZXNcbiAgdmFyIHRoaXNWYXJzID0gdW5pcShbXS5jb25jYXQocHJvYy5wcmUudGhpc1ZhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChwcm9jLmJvZHkudGhpc1ZhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChwcm9jLnBvc3QudGhpc1ZhcnMpKVxuICB2YXJzID0gdmFycy5jb25jYXQodGhpc1ZhcnMpXG4gIGlmICh2YXJzLmxlbmd0aCA+IDApIHtcbiAgICBjb2RlLnB1c2goXCJ2YXIgXCIgKyB2YXJzLmpvaW4oXCIsXCIpKVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwicFwiK2krXCJ8PTBcIilcbiAgfVxuICBcbiAgLy9JbmxpbmUgcHJlbHVkZVxuICBpZihwcm9jLnByZS5ib2R5Lmxlbmd0aCA+IDMpIHtcbiAgICBjb2RlLnB1c2gocHJvY2Vzc0Jsb2NrKHByb2MucHJlLCBwcm9jLCBkdHlwZXMpKVxuICB9XG5cbiAgLy9Qcm9jZXNzIGJvZHlcbiAgdmFyIGJvZHkgPSBwcm9jZXNzQmxvY2socHJvYy5ib2R5LCBwcm9jLCBkdHlwZXMpXG4gIHZhciBtYXRjaGVkID0gY291bnRNYXRjaGVzKGxvb3BPcmRlcnMpXG4gIGlmKG1hdGNoZWQgPCBkaW1lbnNpb24pIHtcbiAgICBjb2RlLnB1c2gob3V0ZXJGaWxsKG1hdGNoZWQsIGxvb3BPcmRlcnNbMF0sIHByb2MsIGJvZHkpKSAvLyBUT0RPOiBSYXRoZXIgdGhhbiBwYXNzaW5nIGxvb3BPcmRlcnNbMF0sIGl0IG1pZ2h0IGJlIGludGVyZXN0aW5nIHRvIGxvb2sgYXQgcGFzc2luZyBhbiBvcmRlciB0aGF0IHJlcHJlc2VudHMgdGhlIG1ham9yaXR5IG9mIHRoZSBhcmd1bWVudHMgZm9yIGV4YW1wbGUuXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKGlubmVyRmlsbChsb29wT3JkZXJzWzBdLCBwcm9jLCBib2R5KSlcbiAgfVxuXG4gIC8vSW5saW5lIGVwaWxvZ1xuICBpZihwcm9jLnBvc3QuYm9keS5sZW5ndGggPiAzKSB7XG4gICAgY29kZS5wdXNoKHByb2Nlc3NCbG9jayhwcm9jLnBvc3QsIHByb2MsIGR0eXBlcykpXG4gIH1cbiAgXG4gIGlmKHByb2MuZGVidWcpIHtcbiAgICBjb25zb2xlLmxvZyhcIi0tLS0tR2VuZXJhdGVkIGN3aXNlIHJvdXRpbmUgZm9yIFwiLCB0eXBlc2lnLCBcIjpcXG5cIiArIGNvZGUuam9pbihcIlxcblwiKSArIFwiXFxuLS0tLS0tLS0tLVwiKVxuICB9XG4gIFxuICB2YXIgbG9vcE5hbWUgPSBbKHByb2MuZnVuY05hbWV8fFwidW5uYW1lZFwiKSwgXCJfY3dpc2VfbG9vcF9cIiwgb3JkZXJzWzBdLmpvaW4oXCJzXCIpLFwibVwiLG1hdGNoZWQsdHlwZVN1bW1hcnkoZHR5cGVzKV0uam9pbihcIlwiKVxuICB2YXIgZiA9IG5ldyBGdW5jdGlvbihbXCJmdW5jdGlvbiBcIixsb29wTmFtZSxcIihcIiwgYXJnbGlzdC5qb2luKFwiLFwiKSxcIil7XCIsIGNvZGUuam9pbihcIlxcblwiKSxcIn0gcmV0dXJuIFwiLCBsb29wTmFtZV0uam9pbihcIlwiKSlcbiAgcmV0dXJuIGYoKVxufVxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZUNXaXNlT3BcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/cwise-compiler/lib/compile.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/cwise-compiler/lib/thunk.js":
/*!**************************************************!*\
  !*** ./node_modules/cwise-compiler/lib/thunk.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\n// The function below is called when constructing a cwise function object, and does the following:\n// A function object is constructed which accepts as argument a compilation function and returns another function.\n// It is this other function that is eventually returned by createThunk, and this function is the one that actually\n// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.\n// The compilation passed to the first function object is used for compiling new functions.\n// Once this function object is created, it is called with compile as argument, where the first argument of compile\n// is bound to \"proc\" (essentially containing a preprocessed version of the user arguments to cwise).\n// So createThunk roughly works like this:\n// function createThunk(proc) {\n//   var thunk = function(compileBound) {\n//     var CACHED = {}\n//     return function(arrays and scalars) {\n//       if (dtype and order of arrays in CACHED) {\n//         var func = CACHED[dtype and order of arrays]\n//       } else {\n//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)\n//       }\n//       return func(arrays and scalars)\n//     }\n//   }\n//   return thunk(compile.bind1(proc))\n// }\n\nvar compile = __webpack_require__(/*! ./compile.js */ \"(app-pages-browser)/./node_modules/cwise-compiler/lib/compile.js\")\n\nfunction createThunk(proc) {\n  var code = [\"'use strict'\", \"var CACHED={}\"]\n  var vars = []\n  var thunkName = proc.funcName + \"_cwise_thunk\"\n  \n  //Build thunk\n  code.push([\"return function \", thunkName, \"(\", proc.shimArgs.join(\",\"), \"){\"].join(\"\"))\n  var typesig = []\n  var string_typesig = []\n  var proc_args = [[\"array\",proc.arrayArgs[0],\".shape.slice(\", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).\n                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(\",\"+proc.arrayBlockIndices[0]+\")\"):\")\"].join(\"\")]\n  var shapeLengthConditions = [], shapeConditions = []\n  // Process array arguments\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    var j = proc.arrayArgs[i]\n    vars.push([\"t\", j, \"=array\", j, \".dtype,\",\n               \"r\", j, \"=array\", j, \".order\"].join(\"\"))\n    typesig.push(\"t\" + j)\n    typesig.push(\"r\" + j)\n    string_typesig.push(\"t\"+j)\n    string_typesig.push(\"r\"+j+\".join()\")\n    proc_args.push(\"array\" + j + \".data\")\n    proc_args.push(\"array\" + j + \".stride\")\n    proc_args.push(\"array\" + j + \".offset|0\")\n    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)\n      shapeLengthConditions.push(\"array\" + proc.arrayArgs[0] + \".shape.length===array\" + j + \".shape.length+\" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))\n      shapeConditions.push(\"array\" + proc.arrayArgs[0] + \".shape[shapeIndex+\" + Math.max(0,proc.arrayBlockIndices[0]) + \"]===array\" + j + \".shape[shapeIndex+\" + Math.max(0,proc.arrayBlockIndices[i]) + \"]\")\n    }\n  }\n  // Check for shape equality\n  if (proc.arrayArgs.length > 1) {\n    code.push(\"if (!(\" + shapeLengthConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same dimensionality!')\")\n    code.push(\"for(var shapeIndex=array\" + proc.arrayArgs[0] + \".shape.length-\" + Math.abs(proc.arrayBlockIndices[0]) + \"; shapeIndex-->0;) {\")\n    code.push(\"if (!(\" + shapeConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same shape!')\")\n    code.push(\"}\")\n  }\n  // Process scalar arguments\n  for(var i=0; i<proc.scalarArgs.length; ++i) {\n    proc_args.push(\"scalar\" + proc.scalarArgs[i])\n  }\n  // Check for cached function (and if not present, generate it)\n  vars.push([\"type=[\", string_typesig.join(\",\"), \"].join()\"].join(\"\"))\n  vars.push(\"proc=CACHED[type]\")\n  code.push(\"var \" + vars.join(\",\"))\n  \n  code.push([\"if(!proc){\",\n             \"CACHED[type]=proc=compile([\", typesig.join(\",\"), \"])}\",\n             \"return proc(\", proc_args.join(\",\"), \")}\"].join(\"\"))\n\n  if(proc.debug) {\n    console.log(\"-----Generated thunk:\\n\" + code.join(\"\\n\") + \"\\n----------\")\n  }\n  \n  //Compile thunk\n  var thunk = new Function(\"compile\", code.join(\"\\n\"))\n  return thunk(compile.bind(undefined, proc))\n}\n\nmodule.exports = createThunk\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9saWIvdGh1bmsuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG1CQUFPLENBQUMsc0ZBQWM7O0FBRXBDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkhBQTJILGVBQWUsR0FBRztBQUM3STtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsbUVBQW1FO0FBQ25FLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL3RodW5rLmpzP2Y0NzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuLy8gVGhlIGZ1bmN0aW9uIGJlbG93IGlzIGNhbGxlZCB3aGVuIGNvbnN0cnVjdGluZyBhIGN3aXNlIGZ1bmN0aW9uIG9iamVjdCwgYW5kIGRvZXMgdGhlIGZvbGxvd2luZzpcbi8vIEEgZnVuY3Rpb24gb2JqZWN0IGlzIGNvbnN0cnVjdGVkIHdoaWNoIGFjY2VwdHMgYXMgYXJndW1lbnQgYSBjb21waWxhdGlvbiBmdW5jdGlvbiBhbmQgcmV0dXJucyBhbm90aGVyIGZ1bmN0aW9uLlxuLy8gSXQgaXMgdGhpcyBvdGhlciBmdW5jdGlvbiB0aGF0IGlzIGV2ZW50dWFsbHkgcmV0dXJuZWQgYnkgY3JlYXRlVGh1bmssIGFuZCB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBvbmUgdGhhdCBhY3R1YWxseVxuLy8gY2hlY2tzIHdoZXRoZXIgYSBjZXJ0YWluIHBhdHRlcm4gb2YgYXJndW1lbnRzIGhhcyBhbHJlYWR5IGJlZW4gdXNlZCBiZWZvcmUgYW5kIGNvbXBpbGVzIG5ldyBsb29wcyBhcyBuZWVkZWQuXG4vLyBUaGUgY29tcGlsYXRpb24gcGFzc2VkIHRvIHRoZSBmaXJzdCBmdW5jdGlvbiBvYmplY3QgaXMgdXNlZCBmb3IgY29tcGlsaW5nIG5ldyBmdW5jdGlvbnMuXG4vLyBPbmNlIHRoaXMgZnVuY3Rpb24gb2JqZWN0IGlzIGNyZWF0ZWQsIGl0IGlzIGNhbGxlZCB3aXRoIGNvbXBpbGUgYXMgYXJndW1lbnQsIHdoZXJlIHRoZSBmaXJzdCBhcmd1bWVudCBvZiBjb21waWxlXG4vLyBpcyBib3VuZCB0byBcInByb2NcIiAoZXNzZW50aWFsbHkgY29udGFpbmluZyBhIHByZXByb2Nlc3NlZCB2ZXJzaW9uIG9mIHRoZSB1c2VyIGFyZ3VtZW50cyB0byBjd2lzZSkuXG4vLyBTbyBjcmVhdGVUaHVuayByb3VnaGx5IHdvcmtzIGxpa2UgdGhpczpcbi8vIGZ1bmN0aW9uIGNyZWF0ZVRodW5rKHByb2MpIHtcbi8vICAgdmFyIHRodW5rID0gZnVuY3Rpb24oY29tcGlsZUJvdW5kKSB7XG4vLyAgICAgdmFyIENBQ0hFRCA9IHt9XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5cyBhbmQgc2NhbGFycykge1xuLy8gICAgICAgaWYgKGR0eXBlIGFuZCBvcmRlciBvZiBhcnJheXMgaW4gQ0FDSEVEKSB7XG4vLyAgICAgICAgIHZhciBmdW5jID0gQ0FDSEVEW2R0eXBlIGFuZCBvcmRlciBvZiBhcnJheXNdXG4vLyAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICB2YXIgZnVuYyA9IENBQ0hFRFtkdHlwZSBhbmQgb3JkZXIgb2YgYXJyYXlzXSA9IGNvbXBpbGVCb3VuZChkdHlwZSBhbmQgb3JkZXIgb2YgYXJyYXlzKVxuLy8gICAgICAgfVxuLy8gICAgICAgcmV0dXJuIGZ1bmMoYXJyYXlzIGFuZCBzY2FsYXJzKVxuLy8gICAgIH1cbi8vICAgfVxuLy8gICByZXR1cm4gdGh1bmsoY29tcGlsZS5iaW5kMShwcm9jKSlcbi8vIH1cblxudmFyIGNvbXBpbGUgPSByZXF1aXJlKFwiLi9jb21waWxlLmpzXCIpXG5cbmZ1bmN0aW9uIGNyZWF0ZVRodW5rKHByb2MpIHtcbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIiwgXCJ2YXIgQ0FDSEVEPXt9XCJdXG4gIHZhciB2YXJzID0gW11cbiAgdmFyIHRodW5rTmFtZSA9IHByb2MuZnVuY05hbWUgKyBcIl9jd2lzZV90aHVua1wiXG4gIFxuICAvL0J1aWxkIHRodW5rXG4gIGNvZGUucHVzaChbXCJyZXR1cm4gZnVuY3Rpb24gXCIsIHRodW5rTmFtZSwgXCIoXCIsIHByb2Muc2hpbUFyZ3Muam9pbihcIixcIiksIFwiKXtcIl0uam9pbihcIlwiKSlcbiAgdmFyIHR5cGVzaWcgPSBbXVxuICB2YXIgc3RyaW5nX3R5cGVzaWcgPSBbXVxuICB2YXIgcHJvY19hcmdzID0gW1tcImFycmF5XCIscHJvYy5hcnJheUFyZ3NbMF0sXCIuc2hhcGUuc2xpY2UoXCIsIC8vIFNsaWNlIHNoYXBlIHNvIHRoYXQgd2Ugb25seSByZXRhaW4gdGhlIHNoYXBlIG92ZXIgd2hpY2ggd2UgaXRlcmF0ZSAod2hpY2ggZ2V0cyBwYXNzZWQgdG8gdGhlIGN3aXNlIG9wZXJhdG9yIGFzIFNTKS5cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCxwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSxwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdPDA/KFwiLFwiK3Byb2MuYXJyYXlCbG9ja0luZGljZXNbMF0rXCIpXCIpOlwiKVwiXS5qb2luKFwiXCIpXVxuICB2YXIgc2hhcGVMZW5ndGhDb25kaXRpb25zID0gW10sIHNoYXBlQ29uZGl0aW9ucyA9IFtdXG4gIC8vIFByb2Nlc3MgYXJyYXkgYXJndW1lbnRzXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGogPSBwcm9jLmFycmF5QXJnc1tpXVxuICAgIHZhcnMucHVzaChbXCJ0XCIsIGosIFwiPWFycmF5XCIsIGosIFwiLmR0eXBlLFwiLFxuICAgICAgICAgICAgICAgXCJyXCIsIGosIFwiPWFycmF5XCIsIGosIFwiLm9yZGVyXCJdLmpvaW4oXCJcIikpXG4gICAgdHlwZXNpZy5wdXNoKFwidFwiICsgailcbiAgICB0eXBlc2lnLnB1c2goXCJyXCIgKyBqKVxuICAgIHN0cmluZ190eXBlc2lnLnB1c2goXCJ0XCIrailcbiAgICBzdHJpbmdfdHlwZXNpZy5wdXNoKFwiclwiK2orXCIuam9pbigpXCIpXG4gICAgcHJvY19hcmdzLnB1c2goXCJhcnJheVwiICsgaiArIFwiLmRhdGFcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIuc3RyaWRlXCIpXG4gICAgcHJvY19hcmdzLnB1c2goXCJhcnJheVwiICsgaiArIFwiLm9mZnNldHwwXCIpXG4gICAgaWYgKGk+MCkgeyAvLyBHYXRoZXIgY29uZGl0aW9ucyB0byBjaGVjayBmb3Igc2hhcGUgZXF1YWxpdHkgKGlnbm9yaW5nIGJsb2NrIGluZGljZXMpXG4gICAgICBzaGFwZUxlbmd0aENvbmRpdGlvbnMucHVzaChcImFycmF5XCIgKyBwcm9jLmFycmF5QXJnc1swXSArIFwiLnNoYXBlLmxlbmd0aD09PWFycmF5XCIgKyBqICsgXCIuc2hhcGUubGVuZ3RoK1wiICsgKE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pLU1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pKSlcbiAgICAgIHNoYXBlQ29uZGl0aW9ucy5wdXNoKFwiYXJyYXlcIiArIHByb2MuYXJyYXlBcmdzWzBdICsgXCIuc2hhcGVbc2hhcGVJbmRleCtcIiArIE1hdGgubWF4KDAscHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkgKyBcIl09PT1hcnJheVwiICsgaiArIFwiLnNoYXBlW3NoYXBlSW5kZXgrXCIgKyBNYXRoLm1heCgwLHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pICsgXCJdXCIpXG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBzaGFwZSBlcXVhbGl0eVxuICBpZiAocHJvYy5hcnJheUFyZ3MubGVuZ3RoID4gMSkge1xuICAgIGNvZGUucHVzaChcImlmICghKFwiICsgc2hhcGVMZW5ndGhDb25kaXRpb25zLmpvaW4oXCIgJiYgXCIpICsgXCIpKSB0aHJvdyBuZXcgRXJyb3IoJ2N3aXNlOiBBcnJheXMgZG8gbm90IGFsbCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbmFsaXR5IScpXCIpXG4gICAgY29kZS5wdXNoKFwiZm9yKHZhciBzaGFwZUluZGV4PWFycmF5XCIgKyBwcm9jLmFycmF5QXJnc1swXSArIFwiLnNoYXBlLmxlbmd0aC1cIiArIE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pICsgXCI7IHNoYXBlSW5kZXgtLT4wOykge1wiKVxuICAgIGNvZGUucHVzaChcImlmICghKFwiICsgc2hhcGVDb25kaXRpb25zLmpvaW4oXCIgJiYgXCIpICsgXCIpKSB0aHJvdyBuZXcgRXJyb3IoJ2N3aXNlOiBBcnJheXMgZG8gbm90IGFsbCBoYXZlIHRoZSBzYW1lIHNoYXBlIScpXCIpXG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG4gIC8vIFByb2Nlc3Mgc2NhbGFyIGFyZ3VtZW50c1xuICBmb3IodmFyIGk9MDsgaTxwcm9jLnNjYWxhckFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBwcm9jX2FyZ3MucHVzaChcInNjYWxhclwiICsgcHJvYy5zY2FsYXJBcmdzW2ldKVxuICB9XG4gIC8vIENoZWNrIGZvciBjYWNoZWQgZnVuY3Rpb24gKGFuZCBpZiBub3QgcHJlc2VudCwgZ2VuZXJhdGUgaXQpXG4gIHZhcnMucHVzaChbXCJ0eXBlPVtcIiwgc3RyaW5nX3R5cGVzaWcuam9pbihcIixcIiksIFwiXS5qb2luKClcIl0uam9pbihcIlwiKSlcbiAgdmFycy5wdXNoKFwicHJvYz1DQUNIRURbdHlwZV1cIilcbiAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgXG4gIGNvZGUucHVzaChbXCJpZighcHJvYyl7XCIsXG4gICAgICAgICAgICAgXCJDQUNIRURbdHlwZV09cHJvYz1jb21waWxlKFtcIiwgdHlwZXNpZy5qb2luKFwiLFwiKSwgXCJdKX1cIixcbiAgICAgICAgICAgICBcInJldHVybiBwcm9jKFwiLCBwcm9jX2FyZ3Muam9pbihcIixcIiksIFwiKX1cIl0uam9pbihcIlwiKSlcblxuICBpZihwcm9jLmRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coXCItLS0tLUdlbmVyYXRlZCB0aHVuazpcXG5cIiArIGNvZGUuam9pbihcIlxcblwiKSArIFwiXFxuLS0tLS0tLS0tLVwiKVxuICB9XG4gIFxuICAvL0NvbXBpbGUgdGh1bmtcbiAgdmFyIHRodW5rID0gbmV3IEZ1bmN0aW9uKFwiY29tcGlsZVwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIHJldHVybiB0aHVuayhjb21waWxlLmJpbmQodW5kZWZpbmVkLCBwcm9jKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUaHVua1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/cwise-compiler/lib/thunk.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBLFNBQVMsVUFBVTs7QUFFbkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz84ZTI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/iota-array/iota.js":
/*!*****************************************!*\
  !*** ./node_modules/iota-array/iota.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pb3RhLWFycmF5L2lvdGEuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaW90YS1hcnJheS9pb3RhLmpzPzYxYjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gaW90YShuKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobilcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gaVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpb3RhIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/iota-array/iota.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanM/MDE4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/is-buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ndarray-ops/ndarray-ops.js":
/*!*************************************************!*\
  !*** ./node_modules/ndarray-ops/ndarray-ops.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar compile = __webpack_require__(/*! cwise-compiler */ \"(app-pages-browser)/./node_modules/cwise-compiler/compiler.js\")\n\nvar EmptyProc = {\n  body: \"\",\n  args: [],\n  thisVars: [],\n  localVars: []\n}\n\nfunction fixup(x) {\n  if(!x) {\n    return EmptyProc\n  }\n  for(var i=0; i<x.args.length; ++i) {\n    var a = x.args[i]\n    if(i === 0) {\n      x.args[i] = {name: a, lvalue:true, rvalue: !!x.rvalue, count:x.count||1 }\n    } else {\n      x.args[i] = {name: a, lvalue:false, rvalue:true, count: 1}\n    }\n  }\n  if(!x.thisVars) {\n    x.thisVars = []\n  }\n  if(!x.localVars) {\n    x.localVars = []\n  }\n  return x\n}\n\nfunction pcompile(user_args) {\n  return compile({\n    args:     user_args.args,\n    pre:      fixup(user_args.pre),\n    body:     fixup(user_args.body),\n    post:     fixup(user_args.proc),\n    funcName: user_args.funcName\n  })\n}\n\nfunction makeOp(user_args) {\n  var args = []\n  for(var i=0; i<user_args.args.length; ++i) {\n    args.push(\"a\"+i)\n  }\n  var wrapper = new Function(\"P\", [\n    \"return function \", user_args.funcName, \"_ndarrayops(\", args.join(\",\"), \") {P(\", args.join(\",\"), \");return a0}\"\n  ].join(\"\"))\n  return wrapper(pcompile(user_args))\n}\n\nvar assign_ops = {\n  add:  \"+\",\n  sub:  \"-\",\n  mul:  \"*\",\n  div:  \"/\",\n  mod:  \"%\",\n  band: \"&\",\n  bor:  \"|\",\n  bxor: \"^\",\n  lshift: \"<<\",\n  rshift: \">>\",\n  rrshift: \">>>\"\n}\n;(function(){\n  for(var id in assign_ops) {\n    var op = assign_ops[id]\n    exports[id] = makeOp({\n      args: [\"array\",\"array\",\"array\"],\n      body: {args:[\"a\",\"b\",\"c\"],\n             body: \"a=b\"+op+\"c\"},\n      funcName: id\n    })\n    exports[id+\"eq\"] = makeOp({\n      args: [\"array\",\"array\"],\n      body: {args:[\"a\",\"b\"],\n             body:\"a\"+op+\"=b\"},\n      rvalue: true,\n      funcName: id+\"eq\"\n    })\n    exports[id+\"s\"] = makeOp({\n      args: [\"array\", \"array\", \"scalar\"],\n      body: {args:[\"a\",\"b\",\"s\"],\n             body:\"a=b\"+op+\"s\"},\n      funcName: id+\"s\"\n    })\n    exports[id+\"seq\"] = makeOp({\n      args: [\"array\",\"scalar\"],\n      body: {args:[\"a\",\"s\"],\n             body:\"a\"+op+\"=s\"},\n      rvalue: true,\n      funcName: id+\"seq\"\n    })\n  }\n})();\n\nvar unary_ops = {\n  not: \"!\",\n  bnot: \"~\",\n  neg: \"-\",\n  recip: \"1.0/\"\n}\n;(function(){\n  for(var id in unary_ops) {\n    var op = unary_ops[id]\n    exports[id] = makeOp({\n      args: [\"array\", \"array\"],\n      body: {args:[\"a\",\"b\"],\n             body:\"a=\"+op+\"b\"},\n      funcName: id\n    })\n    exports[id+\"eq\"] = makeOp({\n      args: [\"array\"],\n      body: {args:[\"a\"],\n             body:\"a=\"+op+\"a\"},\n      rvalue: true,\n      count: 2,\n      funcName: id+\"eq\"\n    })\n  }\n})();\n\nvar binary_ops = {\n  and: \"&&\",\n  or: \"||\",\n  eq: \"===\",\n  neq: \"!==\",\n  lt: \"<\",\n  gt: \">\",\n  leq: \"<=\",\n  geq: \">=\"\n}\n;(function() {\n  for(var id in binary_ops) {\n    var op = binary_ops[id]\n    exports[id] = makeOp({\n      args: [\"array\",\"array\",\"array\"],\n      body: {args:[\"a\", \"b\", \"c\"],\n             body:\"a=b\"+op+\"c\"},\n      funcName: id\n    })\n    exports[id+\"s\"] = makeOp({\n      args: [\"array\",\"array\",\"scalar\"],\n      body: {args:[\"a\", \"b\", \"s\"],\n             body:\"a=b\"+op+\"s\"},\n      funcName: id+\"s\"\n    })\n    exports[id+\"eq\"] = makeOp({\n      args: [\"array\", \"array\"],\n      body: {args:[\"a\", \"b\"],\n             body:\"a=a\"+op+\"b\"},\n      rvalue:true,\n      count:2,\n      funcName: id+\"eq\"\n    })\n    exports[id+\"seq\"] = makeOp({\n      args: [\"array\", \"scalar\"],\n      body: {args:[\"a\",\"s\"],\n             body:\"a=a\"+op+\"s\"},\n      rvalue:true,\n      count:2,\n      funcName: id+\"seq\"\n    })\n  }\n})();\n\nvar math_unary = [\n  \"abs\",\n  \"acos\",\n  \"asin\",\n  \"atan\",\n  \"ceil\",\n  \"cos\",\n  \"exp\",\n  \"floor\",\n  \"log\",\n  \"round\",\n  \"sin\",\n  \"sqrt\",\n  \"tan\"\n]\n;(function() {\n  for(var i=0; i<math_unary.length; ++i) {\n    var f = math_unary[i]\n    exports[f] = makeOp({\n                    args: [\"array\", \"array\"],\n                    pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                    body: {args:[\"a\",\"b\"], body:\"a=this_f(b)\", thisVars:[\"this_f\"]},\n                    funcName: f\n                  })\n    exports[f+\"eq\"] = makeOp({\n                      args: [\"array\"],\n                      pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                      body: {args: [\"a\"], body:\"a=this_f(a)\", thisVars:[\"this_f\"]},\n                      rvalue: true,\n                      count: 2,\n                      funcName: f+\"eq\"\n                    })\n  }\n})();\n\nvar math_comm = [\n  \"max\",\n  \"min\",\n  \"atan2\",\n  \"pow\"\n]\n;(function(){\n  for(var i=0; i<math_comm.length; ++i) {\n    var f= math_comm[i]\n    exports[f] = makeOp({\n                  args:[\"array\", \"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(b,c)\", thisVars:[\"this_f\"]},\n                  funcName: f\n                })\n    exports[f+\"s\"] = makeOp({\n                  args:[\"array\", \"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(b,c)\", thisVars:[\"this_f\"]},\n                  funcName: f+\"s\"\n                  })\n    exports[f+\"eq\"] = makeOp({ args:[\"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(a,b)\", thisVars:[\"this_f\"]},\n                  rvalue: true,\n                  count: 2,\n                  funcName: f+\"eq\"\n                  })\n    exports[f+\"seq\"] = makeOp({ args:[\"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(a,b)\", thisVars:[\"this_f\"]},\n                  rvalue:true,\n                  count:2,\n                  funcName: f+\"seq\"\n                  })\n  }\n})();\n\nvar math_noncomm = [\n  \"atan2\",\n  \"pow\"\n]\n;(function(){\n  for(var i=0; i<math_noncomm.length; ++i) {\n    var f= math_noncomm[i]\n    exports[f+\"op\"] = makeOp({\n                  args:[\"array\", \"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(c,b)\", thisVars:[\"this_f\"]},\n                  funcName: f+\"op\"\n                })\n    exports[f+\"ops\"] = makeOp({\n                  args:[\"array\", \"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(c,b)\", thisVars:[\"this_f\"]},\n                  funcName: f+\"ops\"\n                  })\n    exports[f+\"opeq\"] = makeOp({ args:[\"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(b,a)\", thisVars:[\"this_f\"]},\n                  rvalue: true,\n                  count: 2,\n                  funcName: f+\"opeq\"\n                  })\n    exports[f+\"opseq\"] = makeOp({ args:[\"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(b,a)\", thisVars:[\"this_f\"]},\n                  rvalue:true,\n                  count:2,\n                  funcName: f+\"opseq\"\n                  })\n  }\n})();\n\nexports.any = compile({\n  args:[\"array\"],\n  pre: EmptyProc,\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:1}], body: \"if(a){return true}\", localVars: [], thisVars: []},\n  post: {args:[], localVars:[], thisVars:[], body:\"return false\"},\n  funcName: \"any\"\n})\n\nexports.all = compile({\n  args:[\"array\"],\n  pre: EmptyProc,\n  body: {args:[{name:\"x\", lvalue:false, rvalue:true, count:1}], body: \"if(!x){return false}\", localVars: [], thisVars: []},\n  post: {args:[], localVars:[], thisVars:[], body:\"return true\"},\n  funcName: \"all\"\n})\n\nexports.sum = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:1}], body: \"this_s+=a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"sum\"\n})\n\nexports.prod = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=1\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:1}], body: \"this_s*=a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"prod\"\n})\n\nexports.norm2squared = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:2}], body: \"this_s+=a*a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"norm2squared\"\n})\n  \nexports.norm2 = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:2}], body: \"this_s+=a*a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return Math.sqrt(this_s)\"},\n  funcName: \"norm2\"\n})\n  \n\nexports.norminf = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:4}], body:\"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"norminf\"\n})\n\nexports.norm1 = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:3}], body: \"this_s+=a<0?-a:a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"norm1\"\n})\n\nexports.sup = compile({\n  args: [ \"array\" ],\n  pre:\n   { body: \"this_h=-Infinity\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  body:\n   { body: \"if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_\",\n     args: [{\"name\":\"_inline_1_arg0_\",\"lvalue\":false,\"rvalue\":true,\"count\":2} ],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  post:\n   { body: \"return this_h\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] }\n })\n\nexports.inf = compile({\n  args: [ \"array\" ],\n  pre:\n   { body: \"this_h=Infinity\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  body:\n   { body: \"if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_\",\n     args: [{\"name\":\"_inline_1_arg0_\",\"lvalue\":false,\"rvalue\":true,\"count\":2} ],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  post:\n   { body: \"return this_h\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] }\n })\n\nexports.argmin = compile({\n  args:[\"index\",\"array\",\"shape\"],\n  pre:{\n    body:\"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}\",\n    args:[\n      {name:\"_inline_0_arg0_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg1_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg2_\",lvalue:false,rvalue:true,count:1}\n      ],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[]},\n  body:{\n    body:\"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}\",\n    args:[\n      {name:\"_inline_1_arg0_\",lvalue:false,rvalue:true,count:2},\n      {name:\"_inline_1_arg1_\",lvalue:false,rvalue:true,count:2}],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[\"_inline_1_k\"]},\n  post:{\n    body:\"{return this_i}\",\n    args:[],\n    thisVars:[\"this_i\"],\n    localVars:[]}\n})\n\nexports.argmax = compile({\n  args:[\"index\",\"array\",\"shape\"],\n  pre:{\n    body:\"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}\",\n    args:[\n      {name:\"_inline_0_arg0_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg1_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg2_\",lvalue:false,rvalue:true,count:1}\n      ],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[]},\n  body:{\n    body:\"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}\",\n    args:[\n      {name:\"_inline_1_arg0_\",lvalue:false,rvalue:true,count:2},\n      {name:\"_inline_1_arg1_\",lvalue:false,rvalue:true,count:2}],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[\"_inline_1_k\"]},\n  post:{\n    body:\"{return this_i}\",\n    args:[],\n    thisVars:[\"this_i\"],\n    localVars:[]}\n})  \n\nexports.random = makeOp({\n  args: [\"array\"],\n  pre: {args:[], body:\"this_f=Math.random\", thisVars:[\"this_f\"]},\n  body: {args: [\"a\"], body:\"a=this_f()\", thisVars:[\"this_f\"]},\n  funcName: \"random\"\n})\n\nexports.assign = makeOp({\n  args:[\"array\", \"array\"],\n  body: {args:[\"a\", \"b\"], body:\"a=b\"},\n  funcName: \"assign\" })\n\nexports.assigns = makeOp({\n  args:[\"array\", \"scalar\"],\n  body: {args:[\"a\", \"b\"], body:\"a=b\"},\n  funcName: \"assigns\" })\n\n\nexports.equals = compile({\n  args:[\"array\", \"array\"],\n  pre: EmptyProc,\n  body: {args:[{name:\"x\", lvalue:false, rvalue:true, count:1},\n               {name:\"y\", lvalue:false, rvalue:true, count:1}], \n        body: \"if(x!==y){return false}\", \n        localVars: [], \n        thisVars: []},\n  post: {args:[], localVars:[], thisVars:[], body:\"return true\"},\n  funcName: \"equals\"\n})\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZGFycmF5LW9wcy9uZGFycmF5LW9wcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMscUZBQWdCOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLE1BQU07QUFDTixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRix3QkFBd0IsVUFBVTtBQUNsSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYiwrQkFBK0I7QUFDL0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDhCQUE4QjtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLCtCQUErQjtBQUMvQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiLCtCQUErQjtBQUMvQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9EQUFvRDtBQUM5RSwyQkFBMkIsd0RBQXdEO0FBQ25GO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSw0QkFBNEIsb0RBQW9EO0FBQ2hGLDZCQUE2QixxREFBcUQ7QUFDbEY7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9EQUFvRDtBQUM1RSx5QkFBeUIsOERBQThEO0FBQ3ZGO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx3QkFBd0Isb0RBQW9EO0FBQzVFLHlCQUF5Qiw4REFBOEQ7QUFDdkY7QUFDQSxtQkFBbUI7QUFDbkIsK0JBQStCO0FBQy9CLHdCQUF3QixvREFBb0Q7QUFDNUUseUJBQXlCLDBEQUEwRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsZ0NBQWdDO0FBQ2hDLHdCQUF3QixvREFBb0Q7QUFDNUUseUJBQXlCLDBEQUEwRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvREFBb0Q7QUFDNUUseUJBQXlCLDhEQUE4RDtBQUN2RjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esd0JBQXdCLG9EQUFvRDtBQUM1RSx5QkFBeUIsOERBQThEO0FBQ3ZGO0FBQ0EsbUJBQW1CO0FBQ25CLGlDQUFpQztBQUNqQyx3QkFBd0Isb0RBQW9EO0FBQzVFLHlCQUF5QiwwREFBMEQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGtDQUFrQztBQUNsQyx3QkFBd0Isb0RBQW9EO0FBQzVFLHlCQUF5QiwwREFBMEQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsQ0FBQzs7QUFFRCxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVMsT0FBTyw2Q0FBNkMsZ0JBQWdCLFlBQVksK0JBQStCO0FBQ3hILFNBQVMsd0RBQXdEO0FBQ2pFO0FBQ0EsQ0FBQzs7QUFFRCxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVMsT0FBTyw2Q0FBNkMsaUJBQWlCLGFBQWEsK0JBQStCO0FBQzFILFNBQVMsdURBQXVEO0FBQ2hFO0FBQ0EsQ0FBQzs7QUFFRCxXQUFXO0FBQ1g7QUFDQSxRQUFRLDREQUE0RDtBQUNwRSxTQUFTLE9BQU8sNkNBQTZDLDBEQUEwRDtBQUN2SCxTQUFTLGlFQUFpRTtBQUMxRTtBQUNBLENBQUM7O0FBRUQsWUFBWTtBQUNaO0FBQ0EsUUFBUSw0REFBNEQ7QUFDcEUsU0FBUyxPQUFPLDZDQUE2QywwREFBMEQ7QUFDdkgsU0FBUyxpRUFBaUU7QUFDMUU7QUFDQSxDQUFDOztBQUVELG9CQUFvQjtBQUNwQjtBQUNBLFFBQVEsNERBQTREO0FBQ3BFLFNBQVMsT0FBTyw2Q0FBNkMsNERBQTREO0FBQ3pILFNBQVMsaUVBQWlFO0FBQzFFO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsUUFBUSw0REFBNEQ7QUFDcEUsU0FBUyxPQUFPLDZDQUE2Qyw0REFBNEQ7QUFDekgsU0FBUyw0RUFBNEU7QUFDckY7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsZUFBZTtBQUNmO0FBQ0EsUUFBUSw0REFBNEQ7QUFDcEUsU0FBUyxPQUFPLDZDQUE2Qyx1QkFBdUIsVUFBVSxrQkFBa0IsU0FBUyx1Q0FBdUM7QUFDaEssU0FBUyxpRUFBaUU7QUFDMUU7QUFDQSxDQUFDOztBQUVELGFBQWE7QUFDYjtBQUNBLFFBQVEsNERBQTREO0FBQ3BFLFNBQVMsT0FBTyw2Q0FBNkMsaUVBQWlFO0FBQzlILFNBQVMsaUVBQWlFO0FBQzFFO0FBQ0EsQ0FBQzs7QUFFRCxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsS0FBSztBQUNMLGFBQWEsaUVBQWlFO0FBQzlFO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLEtBQUs7QUFDTCxhQUFhLGlFQUFpRTtBQUM5RTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0IsZ0NBQWdDO0FBQzNEO0FBQ0EsT0FBTyx5REFBeUQ7QUFDaEUsT0FBTyx5REFBeUQ7QUFDaEUsT0FBTztBQUNQO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxXQUFXLDJCQUEyQix1QkFBdUIsc0JBQXNCLG1DQUFtQyxlQUFlLG1EQUFtRDtBQUN4TDtBQUNBLE9BQU8sd0RBQXdEO0FBQy9ELE9BQU8sd0RBQXdEO0FBQy9EO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQixnQ0FBZ0M7QUFDNUQ7QUFDQSxPQUFPLHlEQUF5RDtBQUNoRSxPQUFPLHlEQUF5RDtBQUNoRSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFdBQVcsMkJBQTJCLHVCQUF1QixzQkFBc0IsbUNBQW1DLGVBQWUsbURBQW1EO0FBQ3hMO0FBQ0EsT0FBTyx3REFBd0Q7QUFDL0QsT0FBTyx3REFBd0Q7QUFDL0Q7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxjQUFjO0FBQ2Q7QUFDQSxRQUFRLHdEQUF3RDtBQUNoRSxTQUFTLG9EQUFvRDtBQUM3RDtBQUNBLENBQUM7O0FBRUQsY0FBYztBQUNkO0FBQ0EsU0FBUyw0QkFBNEI7QUFDckMsc0JBQXNCOztBQUV0QixlQUFlO0FBQ2Y7QUFDQSxTQUFTLDRCQUE0QjtBQUNyQyx1QkFBdUI7OztBQUd2QixjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVMsT0FBTyw2Q0FBNkM7QUFDN0QsZ0JBQWdCLDZDQUE2QztBQUM3RCx5QkFBeUIsYUFBYTtBQUN0QztBQUNBLHFCQUFxQjtBQUNyQixTQUFTLHVEQUF1RDtBQUNoRTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25kYXJyYXktb3BzL25kYXJyYXktb3BzLmpzPzI5OTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGNvbXBpbGUgPSByZXF1aXJlKFwiY3dpc2UtY29tcGlsZXJcIilcblxudmFyIEVtcHR5UHJvYyA9IHtcbiAgYm9keTogXCJcIixcbiAgYXJnczogW10sXG4gIHRoaXNWYXJzOiBbXSxcbiAgbG9jYWxWYXJzOiBbXVxufVxuXG5mdW5jdGlvbiBmaXh1cCh4KSB7XG4gIGlmKCF4KSB7XG4gICAgcmV0dXJuIEVtcHR5UHJvY1xuICB9XG4gIGZvcih2YXIgaT0wOyBpPHguYXJncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBhID0geC5hcmdzW2ldXG4gICAgaWYoaSA9PT0gMCkge1xuICAgICAgeC5hcmdzW2ldID0ge25hbWU6IGEsIGx2YWx1ZTp0cnVlLCBydmFsdWU6ICEheC5ydmFsdWUsIGNvdW50OnguY291bnR8fDEgfVxuICAgIH0gZWxzZSB7XG4gICAgICB4LmFyZ3NbaV0gPSB7bmFtZTogYSwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6IDF9XG4gICAgfVxuICB9XG4gIGlmKCF4LnRoaXNWYXJzKSB7XG4gICAgeC50aGlzVmFycyA9IFtdXG4gIH1cbiAgaWYoIXgubG9jYWxWYXJzKSB7XG4gICAgeC5sb2NhbFZhcnMgPSBbXVxuICB9XG4gIHJldHVybiB4XG59XG5cbmZ1bmN0aW9uIHBjb21waWxlKHVzZXJfYXJncykge1xuICByZXR1cm4gY29tcGlsZSh7XG4gICAgYXJnczogICAgIHVzZXJfYXJncy5hcmdzLFxuICAgIHByZTogICAgICBmaXh1cCh1c2VyX2FyZ3MucHJlKSxcbiAgICBib2R5OiAgICAgZml4dXAodXNlcl9hcmdzLmJvZHkpLFxuICAgIHBvc3Q6ICAgICBmaXh1cCh1c2VyX2FyZ3MucHJvYyksXG4gICAgZnVuY05hbWU6IHVzZXJfYXJncy5mdW5jTmFtZVxuICB9KVxufVxuXG5mdW5jdGlvbiBtYWtlT3AodXNlcl9hcmdzKSB7XG4gIHZhciBhcmdzID0gW11cbiAgZm9yKHZhciBpPTA7IGk8dXNlcl9hcmdzLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdzLnB1c2goXCJhXCIraSlcbiAgfVxuICB2YXIgd3JhcHBlciA9IG5ldyBGdW5jdGlvbihcIlBcIiwgW1xuICAgIFwicmV0dXJuIGZ1bmN0aW9uIFwiLCB1c2VyX2FyZ3MuZnVuY05hbWUsIFwiX25kYXJyYXlvcHMoXCIsIGFyZ3Muam9pbihcIixcIiksIFwiKSB7UChcIiwgYXJncy5qb2luKFwiLFwiKSwgXCIpO3JldHVybiBhMH1cIlxuICBdLmpvaW4oXCJcIikpXG4gIHJldHVybiB3cmFwcGVyKHBjb21waWxlKHVzZXJfYXJncykpXG59XG5cbnZhciBhc3NpZ25fb3BzID0ge1xuICBhZGQ6ICBcIitcIixcbiAgc3ViOiAgXCItXCIsXG4gIG11bDogIFwiKlwiLFxuICBkaXY6ICBcIi9cIixcbiAgbW9kOiAgXCIlXCIsXG4gIGJhbmQ6IFwiJlwiLFxuICBib3I6ICBcInxcIixcbiAgYnhvcjogXCJeXCIsXG4gIGxzaGlmdDogXCI8PFwiLFxuICByc2hpZnQ6IFwiPj5cIixcbiAgcnJzaGlmdDogXCI+Pj5cIlxufVxuOyhmdW5jdGlvbigpe1xuICBmb3IodmFyIGlkIGluIGFzc2lnbl9vcHMpIHtcbiAgICB2YXIgb3AgPSBhc3NpZ25fb3BzW2lkXVxuICAgIGV4cG9ydHNbaWRdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLFxuICAgICAgICAgICAgIGJvZHk6IFwiYT1iXCIrb3ArXCJjXCJ9LFxuICAgICAgZnVuY05hbWU6IGlkXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wiZXFcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIixcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSxcbiAgICAgICAgICAgICBib2R5OlwiYVwiK29wK1wiPWJcIn0sXG4gICAgICBydmFsdWU6IHRydWUsXG4gICAgICBmdW5jTmFtZTogaWQrXCJlcVwiXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wic1wiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLCBcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwic1wiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1iXCIrb3ArXCJzXCJ9LFxuICAgICAgZnVuY05hbWU6IGlkK1wic1wiXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wic2VxXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJzY2FsYXJcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJzXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhXCIrb3ArXCI9c1wifSxcbiAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgIGZ1bmNOYW1lOiBpZCtcInNlcVwiXG4gICAgfSlcbiAgfVxufSkoKTtcblxudmFyIHVuYXJ5X29wcyA9IHtcbiAgbm90OiBcIiFcIixcbiAgYm5vdDogXCJ+XCIsXG4gIG5lZzogXCItXCIsXG4gIHJlY2lwOiBcIjEuMC9cIlxufVxuOyhmdW5jdGlvbigpe1xuICBmb3IodmFyIGlkIGluIHVuYXJ5X29wcykge1xuICAgIHZhciBvcCA9IHVuYXJ5X29wc1tpZF1cbiAgICBleHBvcnRzW2lkXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1cIitvcCtcImJcIn0sXG4gICAgICBmdW5jTmFtZTogaWRcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJlcVwiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9XCIrb3ArXCJhXCJ9LFxuICAgICAgcnZhbHVlOiB0cnVlLFxuICAgICAgY291bnQ6IDIsXG4gICAgICBmdW5jTmFtZTogaWQrXCJlcVwiXG4gICAgfSlcbiAgfVxufSkoKTtcblxudmFyIGJpbmFyeV9vcHMgPSB7XG4gIGFuZDogXCImJlwiLFxuICBvcjogXCJ8fFwiLFxuICBlcTogXCI9PT1cIixcbiAgbmVxOiBcIiE9PVwiLFxuICBsdDogXCI8XCIsXG4gIGd0OiBcIj5cIixcbiAgbGVxOiBcIjw9XCIsXG4gIGdlcTogXCI+PVwiXG59XG47KGZ1bmN0aW9uKCkge1xuICBmb3IodmFyIGlkIGluIGJpbmFyeV9vcHMpIHtcbiAgICB2YXIgb3AgPSBiaW5hcnlfb3BzW2lkXVxuICAgIGV4cG9ydHNbaWRdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsIFwiYlwiLCBcImNcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YlwiK29wK1wiY1wifSxcbiAgICAgIGZ1bmNOYW1lOiBpZFxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcInNcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIixcImFycmF5XCIsXCJzY2FsYXJcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsIFwiYlwiLCBcInNcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YlwiK29wK1wic1wifSxcbiAgICAgIGZ1bmNOYW1lOiBpZCtcInNcIlxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcImVxXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsIFwiYlwiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1hXCIrb3ArXCJiXCJ9LFxuICAgICAgcnZhbHVlOnRydWUsXG4gICAgICBjb3VudDoyLFxuICAgICAgZnVuY05hbWU6IGlkK1wiZXFcIlxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcInNlcVwiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIixcInNcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YVwiK29wK1wic1wifSxcbiAgICAgIHJ2YWx1ZTp0cnVlLFxuICAgICAgY291bnQ6MixcbiAgICAgIGZ1bmNOYW1lOiBpZCtcInNlcVwiXG4gICAgfSlcbiAgfVxufSkoKTtcblxudmFyIG1hdGhfdW5hcnkgPSBbXG4gIFwiYWJzXCIsXG4gIFwiYWNvc1wiLFxuICBcImFzaW5cIixcbiAgXCJhdGFuXCIsXG4gIFwiY2VpbFwiLFxuICBcImNvc1wiLFxuICBcImV4cFwiLFxuICBcImZsb29yXCIsXG4gIFwibG9nXCIsXG4gIFwicm91bmRcIixcbiAgXCJzaW5cIixcbiAgXCJzcXJ0XCIsXG4gIFwidGFuXCJcbl1cbjsoZnVuY3Rpb24oKSB7XG4gIGZvcih2YXIgaT0wOyBpPG1hdGhfdW5hcnkubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZiA9IG1hdGhfdW5hcnlbaV1cbiAgICBleHBvcnRzW2ZdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sIGJvZHk6XCJhPXRoaXNfZihiKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJlcVwiXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICAgICAgYXJnczogW1wiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6IFtcImFcIl0sIGJvZHk6XCJhPXRoaXNfZihhKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBjb3VudDogMixcbiAgICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcImVxXCJcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgfVxufSkoKTtcblxudmFyIG1hdGhfY29tbSA9IFtcbiAgXCJtYXhcIixcbiAgXCJtaW5cIixcbiAgXCJhdGFuMlwiLFxuICBcInBvd1wiXG5dXG47KGZ1bmN0aW9uKCl7XG4gIGZvcih2YXIgaT0wOyBpPG1hdGhfY29tbS5sZW5ndGg7ICsraSkge1xuICAgIHZhciBmPSBtYXRoX2NvbW1baV1cbiAgICBleHBvcnRzW2ZdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLCBib2R5OlwiYT10aGlzX2YoYixjKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGZcbiAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcInNcIl0gPSBtYWtlT3Aoe1xuICAgICAgICAgICAgICAgICAgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLCBib2R5OlwiYT10aGlzX2YoYixjKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJzXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wiZXFcIl0gPSBtYWtlT3AoeyBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sIGJvZHk6XCJhPXRoaXNfZihhLGIpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBydmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb3VudDogMixcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wiZXFcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJzZXFcIl0gPSBtYWtlT3AoeyBhcmdzOltcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLCBib2R5OlwiYT10aGlzX2YoYSxiKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgcnZhbHVlOnRydWUsXG4gICAgICAgICAgICAgICAgICBjb3VudDoyLFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJzZXFcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgfVxufSkoKTtcblxudmFyIG1hdGhfbm9uY29tbSA9IFtcbiAgXCJhdGFuMlwiLFxuICBcInBvd1wiXG5dXG47KGZ1bmN0aW9uKCl7XG4gIGZvcih2YXIgaT0wOyBpPG1hdGhfbm9uY29tbS5sZW5ndGg7ICsraSkge1xuICAgIHZhciBmPSBtYXRoX25vbmNvbW1baV1cbiAgICBleHBvcnRzW2YrXCJvcFwiXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSwgYm9keTpcImE9dGhpc19mKGMsYilcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wib3BcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wib3BzXCJdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSwgYm9keTpcImE9dGhpc19mKGMsYilcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wib3BzXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wib3BlcVwiXSA9IG1ha2VPcCh7IGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSwgYm9keTpcImE9dGhpc19mKGIsYSlcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvdW50OiAyLFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJvcGVxXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wib3BzZXFcIl0gPSBtYWtlT3AoeyBhcmdzOltcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLCBib2R5OlwiYT10aGlzX2YoYixhKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgcnZhbHVlOnRydWUsXG4gICAgICAgICAgICAgICAgICBjb3VudDoyLFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJvcHNlcVwiXG4gICAgICAgICAgICAgICAgICB9KVxuICB9XG59KSgpO1xuXG5leHBvcnRzLmFueSA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IEVtcHR5UHJvYyxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfV0sIGJvZHk6IFwiaWYoYSl7cmV0dXJuIHRydWV9XCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltdLCBib2R5OlwicmV0dXJuIGZhbHNlXCJ9LFxuICBmdW5jTmFtZTogXCJhbnlcIlxufSlcblxuZXhwb3J0cy5hbGwgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiBFbXB0eVByb2MsXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcInhcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6MX1dLCBib2R5OiBcImlmKCF4KXtyZXR1cm4gZmFsc2V9XCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltdLCBib2R5OlwicmV0dXJuIHRydWVcIn0sXG4gIGZ1bmNOYW1lOiBcImFsbFwiXG59KVxuXG5leHBvcnRzLnN1bSA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0wXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9XSwgYm9keTogXCJ0aGlzX3MrPWFcIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtcInRoaXNfc1wiXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInJldHVybiB0aGlzX3NcIn0sXG4gIGZ1bmNOYW1lOiBcInN1bVwiXG59KVxuXG5leHBvcnRzLnByb2QgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MVwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfV0sIGJvZHk6IFwidGhpc19zKj1hXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJwcm9kXCJcbn0pXG5cbmV4cG9ydHMubm9ybTJzcXVhcmVkID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTBcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6Mn1dLCBib2R5OiBcInRoaXNfcys9YSphXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJub3JtMnNxdWFyZWRcIlxufSlcbiAgXG5leHBvcnRzLm5vcm0yID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTBcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6Mn1dLCBib2R5OiBcInRoaXNfcys9YSphXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gTWF0aC5zcXJ0KHRoaXNfcylcIn0sXG4gIGZ1bmNOYW1lOiBcIm5vcm0yXCJcbn0pXG4gIFxuXG5leHBvcnRzLm5vcm1pbmYgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MFwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDo0fV0sIGJvZHk6XCJpZigtYT50aGlzX3Mpe3RoaXNfcz0tYX1lbHNlIGlmKGE+dGhpc19zKXt0aGlzX3M9YX1cIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtcInRoaXNfc1wiXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInJldHVybiB0aGlzX3NcIn0sXG4gIGZ1bmNOYW1lOiBcIm5vcm1pbmZcIlxufSlcblxuZXhwb3J0cy5ub3JtMSA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0wXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjN9XSwgYm9keTogXCJ0aGlzX3MrPWE8MD8tYTphXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJub3JtMVwiXG59KVxuXG5leHBvcnRzLnN1cCA9IGNvbXBpbGUoe1xuICBhcmdzOiBbIFwiYXJyYXlcIiBdLFxuICBwcmU6XG4gICB7IGJvZHk6IFwidGhpc19oPS1JbmZpbml0eVwiLFxuICAgICBhcmdzOiBbXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH0sXG4gIGJvZHk6XG4gICB7IGJvZHk6IFwiaWYoX2lubGluZV8xX2FyZzBfPnRoaXNfaCl0aGlzX2g9X2lubGluZV8xX2FyZzBfXCIsXG4gICAgIGFyZ3M6IFt7XCJuYW1lXCI6XCJfaW5saW5lXzFfYXJnMF9cIixcImx2YWx1ZVwiOmZhbHNlLFwicnZhbHVlXCI6dHJ1ZSxcImNvdW50XCI6Mn0gXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH0sXG4gIHBvc3Q6XG4gICB7IGJvZHk6IFwicmV0dXJuIHRoaXNfaFwiLFxuICAgICBhcmdzOiBbXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH1cbiB9KVxuXG5leHBvcnRzLmluZiA9IGNvbXBpbGUoe1xuICBhcmdzOiBbIFwiYXJyYXlcIiBdLFxuICBwcmU6XG4gICB7IGJvZHk6IFwidGhpc19oPUluZmluaXR5XCIsXG4gICAgIGFyZ3M6IFtdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfSxcbiAgYm9keTpcbiAgIHsgYm9keTogXCJpZihfaW5saW5lXzFfYXJnMF88dGhpc19oKXRoaXNfaD1faW5saW5lXzFfYXJnMF9cIixcbiAgICAgYXJnczogW3tcIm5hbWVcIjpcIl9pbmxpbmVfMV9hcmcwX1wiLFwibHZhbHVlXCI6ZmFsc2UsXCJydmFsdWVcIjp0cnVlLFwiY291bnRcIjoyfSBdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfSxcbiAgcG9zdDpcbiAgIHsgYm9keTogXCJyZXR1cm4gdGhpc19oXCIsXG4gICAgIGFyZ3M6IFtdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfVxuIH0pXG5cbmV4cG9ydHMuYXJnbWluID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiaW5kZXhcIixcImFycmF5XCIsXCJzaGFwZVwiXSxcbiAgcHJlOntcbiAgICBib2R5Olwie3RoaXNfdj1JbmZpbml0eTt0aGlzX2k9X2lubGluZV8wX2FyZzJfLnNsaWNlKDApfVwiLFxuICAgIGFyZ3M6W1xuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMF9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOmZhbHNlLGNvdW50OjB9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMV9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOmZhbHNlLGNvdW50OjB9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMl9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6MX1cbiAgICAgIF0sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCIsXCJ0aGlzX3ZcIl0sXG4gICAgbG9jYWxWYXJzOltdfSxcbiAgYm9keTp7XG4gICAgYm9keTpcIntpZihfaW5saW5lXzFfYXJnMV88dGhpc192KXt0aGlzX3Y9X2lubGluZV8xX2FyZzFfO2Zvcih2YXIgX2lubGluZV8xX2s9MDtfaW5saW5lXzFfazxfaW5saW5lXzFfYXJnMF8ubGVuZ3RoOysrX2lubGluZV8xX2spe3RoaXNfaVtfaW5saW5lXzFfa109X2lubGluZV8xX2FyZzBfW19pbmxpbmVfMV9rXX19fVwiLFxuICAgIGFyZ3M6W1xuICAgICAge25hbWU6XCJfaW5saW5lXzFfYXJnMF9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6Mn0sXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMV9hcmcxX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6dHJ1ZSxjb3VudDoyfV0sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCIsXCJ0aGlzX3ZcIl0sXG4gICAgbG9jYWxWYXJzOltcIl9pbmxpbmVfMV9rXCJdfSxcbiAgcG9zdDp7XG4gICAgYm9keTpcIntyZXR1cm4gdGhpc19pfVwiLFxuICAgIGFyZ3M6W10sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCJdLFxuICAgIGxvY2FsVmFyczpbXX1cbn0pXG5cbmV4cG9ydHMuYXJnbWF4ID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiaW5kZXhcIixcImFycmF5XCIsXCJzaGFwZVwiXSxcbiAgcHJlOntcbiAgICBib2R5Olwie3RoaXNfdj0tSW5maW5pdHk7dGhpc19pPV9pbmxpbmVfMF9hcmcyXy5zbGljZSgwKX1cIixcbiAgICBhcmdzOltcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzBfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTpmYWxzZSxjb3VudDowfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzFfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTpmYWxzZSxjb3VudDowfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzJfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjF9XG4gICAgICBdLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiLFwidGhpc192XCJdLFxuICAgIGxvY2FsVmFyczpbXX0sXG4gIGJvZHk6e1xuICAgIGJvZHk6XCJ7aWYoX2lubGluZV8xX2FyZzFfPnRoaXNfdil7dGhpc192PV9pbmxpbmVfMV9hcmcxXztmb3IodmFyIF9pbmxpbmVfMV9rPTA7X2lubGluZV8xX2s8X2lubGluZV8xX2FyZzBfLmxlbmd0aDsrK19pbmxpbmVfMV9rKXt0aGlzX2lbX2lubGluZV8xX2tdPV9pbmxpbmVfMV9hcmcwX1tfaW5saW5lXzFfa119fX1cIixcbiAgICBhcmdzOltcbiAgICAgIHtuYW1lOlwiX2lubGluZV8xX2FyZzBfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjJ9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzFfYXJnMV9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6Mn1dLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiLFwidGhpc192XCJdLFxuICAgIGxvY2FsVmFyczpbXCJfaW5saW5lXzFfa1wiXX0sXG4gIHBvc3Q6e1xuICAgIGJvZHk6XCJ7cmV0dXJuIHRoaXNfaX1cIixcbiAgICBhcmdzOltdLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiXSxcbiAgICBsb2NhbFZhcnM6W119XG59KSAgXG5cbmV4cG9ydHMucmFuZG9tID0gbWFrZU9wKHtcbiAgYXJnczogW1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5yYW5kb21cIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgYm9keToge2FyZ3M6IFtcImFcIl0sIGJvZHk6XCJhPXRoaXNfZigpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gIGZ1bmNOYW1lOiBcInJhbmRvbVwiXG59KVxuXG5leHBvcnRzLmFzc2lnbiA9IG1ha2VPcCh7XG4gIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgYm9keToge2FyZ3M6W1wiYVwiLCBcImJcIl0sIGJvZHk6XCJhPWJcIn0sXG4gIGZ1bmNOYW1lOiBcImFzc2lnblwiIH0pXG5cbmV4cG9ydHMuYXNzaWducyA9IG1ha2VPcCh7XG4gIGFyZ3M6W1wiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gIGJvZHk6IHthcmdzOltcImFcIiwgXCJiXCJdLCBib2R5OlwiYT1iXCJ9LFxuICBmdW5jTmFtZTogXCJhc3NpZ25zXCIgfSlcblxuXG5leHBvcnRzLmVxdWFscyA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gIHByZTogRW1wdHlQcm9jLFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJ4XCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9LFxuICAgICAgICAgICAgICAge25hbWU6XCJ5XCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9XSwgXG4gICAgICAgIGJvZHk6IFwiaWYoeCE9PXkpe3JldHVybiBmYWxzZX1cIiwgXG4gICAgICAgIGxvY2FsVmFyczogW10sIFxuICAgICAgICB0aGlzVmFyczogW119LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXSwgYm9keTpcInJldHVybiB0cnVlXCJ9LFxuICBmdW5jTmFtZTogXCJlcXVhbHNcIlxufSlcblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ndarray-ops/ndarray-ops.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ndarray/ndarray.js":
/*!*****************************************!*\
  !*** ./node_modules/ndarray/ndarray.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var iota = __webpack_require__(/*! iota-array */ \"(app-pages-browser)/./node_modules/iota-array/iota.js\")\nvar isBuffer = __webpack_require__(/*! is-buffer */ \"(app-pages-browser)/./node_modules/is-buffer/index.js\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n      case \"[object BigInt64Array]\":\n        return \"bigint64\"\n      case \"[object BigUint64Array]\":\n        return \"biguint64\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"bigint64\": [],\n  \"biguint64\": [],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZGFycmF5L25kYXJyYXkuanMiLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxtQkFBTyxDQUFDLHlFQUFZO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0Msa0NBQWtDO0FBQ2xDLHdCQUF3QjtBQUN4Qix1QkFBdUIsV0FBVztBQUNsQyxhQUFhO0FBQ2IsbUJBQW1CO0FBQ25CLHdDQUF3QztBQUN4QztBQUNBLFdBQVcsc0NBQXNDO0FBQ2pELGlDQUFpQztBQUNqQyxzQkFBc0IsYUFBYTtBQUNuQywyQ0FBMkMsNkJBQTZCO0FBQ3hFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxjQUFjO0FBQ2Q7QUFDQSxFQUFFO0FBQ0Ysa0NBQWtDO0FBQ2xDLHdCQUF3QjtBQUN4Qix1QkFBdUIsb0JBQW9CO0FBQzNDLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxFQUFFO0FBQ0YseUNBQXlDO0FBQ3pDLCtCQUErQjtBQUMvQixFQUFFO0FBQ0YscURBQXFEO0FBQ3JEO0FBQ0EsR0FBRztBQUNILHdDQUF3QztBQUN4QztBQUNBLEVBQUU7QUFDRixpREFBaUQsOEJBQThCO0FBQy9FO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxL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QUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZGFycmF5L25kYXJyYXkuanM/MTkzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaW90YSA9IHJlcXVpcmUoXCJpb3RhLWFycmF5XCIpXG52YXIgaXNCdWZmZXIgPSByZXF1aXJlKFwiaXMtYnVmZmVyXCIpXG5cbnZhciBoYXNUeXBlZEFycmF5cyAgPSAoKHR5cGVvZiBGbG9hdDY0QXJyYXkpICE9PSBcInVuZGVmaW5lZFwiKVxuXG5mdW5jdGlvbiBjb21wYXJlMXN0KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdXG59XG5cbmZ1bmN0aW9uIG9yZGVyKCkge1xuICB2YXIgc3RyaWRlID0gdGhpcy5zdHJpZGVcbiAgdmFyIHRlcm1zID0gbmV3IEFycmF5KHN0cmlkZS5sZW5ndGgpXG4gIHZhciBpXG4gIGZvcihpPTA7IGk8dGVybXMubGVuZ3RoOyArK2kpIHtcbiAgICB0ZXJtc1tpXSA9IFtNYXRoLmFicyhzdHJpZGVbaV0pLCBpXVxuICB9XG4gIHRlcm1zLnNvcnQoY29tcGFyZTFzdClcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh0ZXJtcy5sZW5ndGgpXG4gIGZvcihpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gdGVybXNbaV1bMV1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgZGltZW5zaW9uKSB7XG4gIHZhciBjbGFzc05hbWUgPSBbXCJWaWV3XCIsIGRpbWVuc2lvbiwgXCJkXCIsIGR0eXBlXS5qb2luKFwiXCIpXG4gIGlmKGRpbWVuc2lvbiA8IDApIHtcbiAgICBjbGFzc05hbWUgPSBcIlZpZXdfTmlsXCIgKyBkdHlwZVxuICB9XG4gIHZhciB1c2VHZXR0ZXJzID0gKGR0eXBlID09PSBcImdlbmVyaWNcIilcblxuICBpZihkaW1lbnNpb24gPT09IC0xKSB7XG4gICAgLy9TcGVjaWFsIGNhc2UgZm9yIHRyaXZpYWwgYXJyYXlzXG4gICAgdmFyIGNvZGUgPVxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSl7dGhpcy5kYXRhPWE7fTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIC0xfTtcXFxucHJvdG8uc2l6ZT0wO1xcXG5wcm90by5kaW1lbnNpb249LTE7XFxcbnByb3RvLnNoYXBlPXByb3RvLnN0cmlkZT1wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89cHJvdG8uaGk9cHJvdG8udHJhbnNwb3NlPXByb3RvLnN0ZXA9XFxcbmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhKTt9O1xcXG5wcm90by5nZXQ9cHJvdG8uc2V0PWZ1bmN0aW9uKCl7fTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbigpe3JldHVybiBudWxsfTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSk7fVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoKVxuICB9IGVsc2UgaWYoZGltZW5zaW9uID09PSAwKSB7XG4gICAgLy9TcGVjaWFsIGNhc2UgZm9yIDBkIGFycmF5c1xuICAgIHZhciBjb2RlID1cbiAgICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEsZCkge1xcXG50aGlzLmRhdGEgPSBhO1xcXG50aGlzLm9mZnNldCA9IGRcXFxufTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2Zmc2V0fTtcXFxucHJvdG8uZGltZW5zaW9uPTA7XFxcbnByb3RvLnNpemU9MTtcXFxucHJvdG8uc2hhcGU9XFxcbnByb3RvLnN0cmlkZT1cXFxucHJvdG8ub3JkZXI9W107XFxcbnByb3RvLmxvPVxcXG5wcm90by5oaT1cXFxucHJvdG8udHJhbnNwb3NlPVxcXG5wcm90by5zdGVwPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9jb3B5KCkge1xcXG5yZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsdGhpcy5vZmZzZXQpXFxcbn07XFxcbnByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soKXtcXFxucmV0dXJuIFRyaXZpYWxBcnJheSh0aGlzLmRhdGEpO1xcXG59O1xcXG5wcm90by52YWx1ZU9mPXByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KCl7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLmdldCh0aGlzLm9mZnNldClcIiA6IFwidGhpcy5kYXRhW3RoaXMub2Zmc2V0XVwiKStcblwifTtcXFxucHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQodil7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLnNldCh0aGlzLm9mZnNldCx2KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdPXZcIikrXCJcXFxufTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSxiLGMsZCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSxkKX1cIlxuICAgIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJUcml2aWFsQXJyYXlcIiwgY29kZSlcbiAgICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdWzBdKVxuICB9XG5cbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIl1cblxuICAvL0NyZWF0ZSBjb25zdHJ1Y3RvciBmb3Igdmlld1xuICB2YXIgaW5kaWNlcyA9IGlvdGEoZGltZW5zaW9uKVxuICB2YXIgYXJncyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiaVwiK2kgfSlcbiAgdmFyIGluZGV4X3N0ciA9IFwidGhpcy5vZmZzZXQrXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBcInRoaXMuc3RyaWRlW1wiICsgaSArIFwiXSppXCIgKyBpXG4gICAgICB9KS5qb2luKFwiK1wiKVxuICB2YXIgc2hhcGVBcmcgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpXG4gIHZhciBzdHJpZGVBcmcgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJjXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpXG4gIGNvZGUucHVzaChcbiAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhLFwiICsgc2hhcGVBcmcgKyBcIixcIiArIHN0cmlkZUFyZyArIFwiLGQpe3RoaXMuZGF0YT1hXCIsXG4gICAgICBcInRoaXMuc2hhcGU9W1wiICsgc2hhcGVBcmcgKyBcIl1cIixcbiAgICAgIFwidGhpcy5zdHJpZGU9W1wiICsgc3RyaWRlQXJnICsgXCJdXCIsXG4gICAgICBcInRoaXMub2Zmc2V0PWR8MH1cIixcbiAgICBcInZhciBwcm90bz1cIitjbGFzc05hbWUrXCIucHJvdG90eXBlXCIsXG4gICAgXCJwcm90by5kdHlwZT0nXCIrZHR5cGUrXCInXCIsXG4gICAgXCJwcm90by5kaW1lbnNpb249XCIrZGltZW5zaW9uKVxuXG4gIC8vdmlldy5zaXplOlxuICBjb2RlLnB1c2goXCJPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sJ3NpemUnLHtnZXQ6ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NpemUoKXtcXFxucmV0dXJuIFwiK2luZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwidGhpcy5zaGFwZVtcIitpK1wiXVwiIH0pLmpvaW4oXCIqXCIpLFxuXCJ9fSlcIilcblxuICAvL3ZpZXcub3JkZXI6XG4gIGlmKGRpbWVuc2lvbiA9PT0gMSkge1xuICAgIGNvZGUucHVzaChcInByb3RvLm9yZGVyPVswXVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnb3JkZXInLHtnZXQ6XCIpXG4gICAgaWYoZGltZW5zaW9uIDwgNCkge1xuICAgICAgY29kZS5wdXNoKFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX29yZGVyKCl7XCIpXG4gICAgICBpZihkaW1lbnNpb24gPT09IDIpIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIChNYXRoLmFicyh0aGlzLnN0cmlkZVswXSk+TWF0aC5hYnModGhpcy5zdHJpZGVbMV0pKT9bMSwwXTpbMCwxXX19KVwiKVxuICAgICAgfSBlbHNlIGlmKGRpbWVuc2lvbiA9PT0gMykge1xuICAgICAgICBjb2RlLnB1c2goXG5cInZhciBzMD1NYXRoLmFicyh0aGlzLnN0cmlkZVswXSksczE9TWF0aC5hYnModGhpcy5zdHJpZGVbMV0pLHMyPU1hdGguYWJzKHRoaXMuc3RyaWRlWzJdKTtcXFxuaWYoczA+czEpe1xcXG5pZihzMT5zMil7XFxcbnJldHVybiBbMiwxLDBdO1xcXG59ZWxzZSBpZihzMD5zMil7XFxcbnJldHVybiBbMSwyLDBdO1xcXG59ZWxzZXtcXFxucmV0dXJuIFsxLDAsMl07XFxcbn1cXFxufWVsc2UgaWYoczA+czIpe1xcXG5yZXR1cm4gWzIsMCwxXTtcXFxufWVsc2UgaWYoczI+czEpe1xcXG5yZXR1cm4gWzAsMSwyXTtcXFxufWVsc2V7XFxcbnJldHVybiBbMCwyLDFdO1xcXG59fX0pXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUucHVzaChcIk9SREVSfSlcIilcbiAgICB9XG4gIH1cblxuICAvL3ZpZXcuc2V0KGkwLCAuLi4sIHYpOlxuICBjb2RlLnB1c2goXG5cInByb3RvLnNldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIsdil7XCIpXG4gIGlmKHVzZUdldHRlcnMpIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhLnNldChcIitpbmRleF9zdHIrXCIsdil9XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIitpbmRleF9zdHIrXCJdPXZ9XCIpXG4gIH1cblxuICAvL3ZpZXcuZ2V0KGkwLCAuLi4pOlxuICBjb2RlLnB1c2goXCJwcm90by5nZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2dldChcIithcmdzLmpvaW4oXCIsXCIpK1wiKXtcIilcbiAgaWYodXNlR2V0dGVycykge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuZ2V0KFwiK2luZGV4X3N0citcIil9XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIitpbmRleF9zdHIrXCJdfVwiKVxuICB9XG5cbiAgLy92aWV3LmluZGV4OlxuICBjb2RlLnB1c2goXG4gICAgXCJwcm90by5pbmRleD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfaW5kZXgoXCIsIGFyZ3Muam9pbigpLCBcIil7cmV0dXJuIFwiK2luZGV4X3N0citcIn1cIilcblxuICAvL3ZpZXcuaGkoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uaGk9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2hpKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gW1wiKHR5cGVvZiBpXCIsaSxcIiE9PSdudW1iZXInfHxpXCIsaSxcIjwwKT90aGlzLnNoYXBlW1wiLCBpLCBcIl06aVwiLCBpLFwifDBcIl0uam9pbihcIlwiKVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInRoaXMuc3RyaWRlW1wiK2kgKyBcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLHRoaXMub2Zmc2V0KX1cIilcblxuICAvL3ZpZXcubG8oKTpcbiAgdmFyIGFfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5zaGFwZVtcIitpK1wiXVwiIH0pXG4gIHZhciBjX3ZhcnMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImNcIitpK1wiPXRoaXMuc3RyaWRlW1wiK2krXCJdXCIgfSlcbiAgY29kZS5wdXNoKFwicHJvdG8ubG89ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2xvKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3ZhciBiPXRoaXMub2Zmc2V0LGQ9MCxcIithX3ZhcnMuam9pbihcIixcIikrXCIsXCIrY192YXJzLmpvaW4oXCIsXCIpKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcblwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtcXFxuZD1pXCIraStcInwwO1xcXG5iKz1jXCIraStcIipkO1xcXG5hXCIraStcIi09ZH1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2lcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJjXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGIpfVwiKVxuXG4gIC8vdmlldy5zdGVwKCk6XG4gIGNvZGUucHVzaChcInByb3RvLnN0ZXA9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3N0ZXAoXCIrYXJncy5qb2luKFwiLFwiKStcIil7dmFyIFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIitpK1wiPXRoaXMuc2hhcGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIitpK1wiPXRoaXMuc3RyaWRlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixjPXRoaXMub2Zmc2V0LGQ9MCxjZWlsPU1hdGguY2VpbFwiKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcblwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicpe1xcXG5kPWlcIitpK1wifDA7XFxcbmlmKGQ8MCl7XFxcbmMrPWJcIitpK1wiKihhXCIraStcIi0xKTtcXFxuYVwiK2krXCI9Y2VpbCgtYVwiK2krXCIvZClcXFxufWVsc2V7XFxcbmFcIitpK1wiPWNlaWwoYVwiK2krXCIvZClcXFxufVxcXG5iXCIraStcIio9ZFxcXG59XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwicmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIiArIGlcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIgKyBpXG4gICAgfSkuam9pbihcIixcIikrXCIsYyl9XCIpXG5cbiAgLy92aWV3LnRyYW5zcG9zZSgpOlxuICB2YXIgdFNoYXBlID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgdmFyIHRTdHJpZGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHRTaGFwZVtpXSA9IFwiYVtpXCIraStcIl1cIlxuICAgIHRTdHJpZGVbaV0gPSBcImJbaVwiK2krXCJdXCJcbiAgfVxuICBjb2RlLnB1c2goXCJwcm90by50cmFuc3Bvc2U9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3RyYW5zcG9zZShcIithcmdzK1wiKXtcIitcbiAgICBhcmdzLm1hcChmdW5jdGlvbihuLGlkeCkgeyByZXR1cm4gbiArIFwiPShcIiArIG4gKyBcIj09PXVuZGVmaW5lZD9cIiArIGlkeCArIFwiOlwiICsgbiArIFwifDApXCJ9KS5qb2luKFwiO1wiKSxcbiAgICBcInZhciBhPXRoaXMuc2hhcGUsYj10aGlzLnN0cmlkZTtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrdFNoYXBlLmpvaW4oXCIsXCIpK1wiLFwiK3RTdHJpZGUuam9pbihcIixcIikrXCIsdGhpcy5vZmZzZXQpfVwiKVxuXG4gIC8vdmlldy5waWNrKCk6XG4gIGNvZGUucHVzaChcInByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soXCIrYXJncytcIil7dmFyIGE9W10sYj1bXSxjPXRoaXMub2Zmc2V0XCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtjPShjK3RoaXMuc3RyaWRlW1wiK2krXCJdKmlcIitpK1wiKXwwfWVsc2V7YS5wdXNoKHRoaXMuc2hhcGVbXCIraStcIl0pO2IucHVzaCh0aGlzLnN0cmlkZVtcIitpK1wiXSl9XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwidmFyIGN0b3I9Q1RPUl9MSVNUW2EubGVuZ3RoKzFdO3JldHVybiBjdG9yKHRoaXMuZGF0YSxhLGIsYyl9XCIpXG5cbiAgLy9BZGQgcmV0dXJuIHN0YXRlbWVudFxuICBjb2RlLnB1c2goXCJyZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihkYXRhLHNoYXBlLHN0cmlkZSxvZmZzZXQpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKGRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwic2hhcGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInN0cmlkZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsb2Zmc2V0KX1cIilcblxuICAvL0NvbXBpbGUgcHJvY2VkdXJlXG4gIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJDVE9SX0xJU1RcIiwgXCJPUkRFUlwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV0sIG9yZGVyKVxufVxuXG5mdW5jdGlvbiBhcnJheURUeXBlKGRhdGEpIHtcbiAgaWYoaXNCdWZmZXIoZGF0YSkpIHtcbiAgICByZXR1cm4gXCJidWZmZXJcIlxuICB9XG4gIGlmKGhhc1R5cGVkQXJyYXlzKSB7XG4gICAgc3dpdGNoKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSkge1xuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJmbG9hdDY0XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiZmxvYXQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQ4QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDhcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50MTZBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50MTZcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDhcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDE2QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQxNlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50OF9jbGFtcGVkXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEJpZ0ludDY0QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImJpZ2ludDY0XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEJpZ1VpbnQ2NEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJiaWd1aW50NjRcIlxuICAgIH1cbiAgfVxuICBpZihBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIlxuICB9XG4gIHJldHVybiBcImdlbmVyaWNcIlxufVxuXG52YXIgQ0FDSEVEX0NPTlNUUlVDVE9SUyA9IHtcbiAgXCJmbG9hdDMyXCI6W10sXG4gIFwiZmxvYXQ2NFwiOltdLFxuICBcImludDhcIjpbXSxcbiAgXCJpbnQxNlwiOltdLFxuICBcImludDMyXCI6W10sXG4gIFwidWludDhcIjpbXSxcbiAgXCJ1aW50MTZcIjpbXSxcbiAgXCJ1aW50MzJcIjpbXSxcbiAgXCJhcnJheVwiOltdLFxuICBcInVpbnQ4X2NsYW1wZWRcIjpbXSxcbiAgXCJiaWdpbnQ2NFwiOiBbXSxcbiAgXCJiaWd1aW50NjRcIjogW10sXG4gIFwiYnVmZmVyXCI6W10sXG4gIFwiZ2VuZXJpY1wiOltdXG59XG5cbjsoZnVuY3Rpb24oKSB7XG4gIGZvcih2YXIgaWQgaW4gQ0FDSEVEX0NPTlNUUlVDVE9SUykge1xuICAgIENBQ0hFRF9DT05TVFJVQ1RPUlNbaWRdLnB1c2goY29tcGlsZUNvbnN0cnVjdG9yKGlkLCAtMSkpXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB3cmFwcGVkTkRBcnJheUN0b3IoZGF0YSwgc2hhcGUsIHN0cmlkZSwgb2Zmc2V0KSB7XG4gIGlmKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBjdG9yID0gQ0FDSEVEX0NPTlNUUlVDVE9SUy5hcnJheVswXVxuICAgIHJldHVybiBjdG9yKFtdKVxuICB9IGVsc2UgaWYodHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICBkYXRhID0gW2RhdGFdXG4gIH1cbiAgaWYoc2hhcGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHNoYXBlID0gWyBkYXRhLmxlbmd0aCBdXG4gIH1cbiAgdmFyIGQgPSBzaGFwZS5sZW5ndGhcbiAgaWYoc3RyaWRlID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHJpZGUgPSBuZXcgQXJyYXkoZClcbiAgICBmb3IodmFyIGk9ZC0xLCBzej0xOyBpPj0wOyAtLWkpIHtcbiAgICAgIHN0cmlkZVtpXSA9IHN6XG4gICAgICBzeiAqPSBzaGFwZVtpXVxuICAgIH1cbiAgfVxuICBpZihvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIG9mZnNldCA9IDBcbiAgICBmb3IodmFyIGk9MDsgaTxkOyArK2kpIHtcbiAgICAgIGlmKHN0cmlkZVtpXSA8IDApIHtcbiAgICAgICAgb2Zmc2V0IC09IChzaGFwZVtpXS0xKSpzdHJpZGVbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGR0eXBlID0gYXJyYXlEVHlwZShkYXRhKVxuICB2YXIgY3Rvcl9saXN0ID0gQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV1cbiAgd2hpbGUoY3Rvcl9saXN0Lmxlbmd0aCA8PSBkKzEpIHtcbiAgICBjdG9yX2xpc3QucHVzaChjb21waWxlQ29uc3RydWN0b3IoZHR5cGUsIGN0b3JfbGlzdC5sZW5ndGgtMSkpXG4gIH1cbiAgdmFyIGN0b3IgPSBjdG9yX2xpc3RbZCsxXVxuICByZXR1cm4gY3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHBlZE5EQXJyYXlDdG9yXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ndarray/ndarray.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyw0R0FBNEI7O0FBRXpQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/NGQ2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz8yYzZmIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uniq/uniq.js":
/*!***********************************!*\
  !*** ./node_modules/uniq/uniq.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nfunction unique_pred(list, compare) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b=list[0]\n  for(var i=1; i<len; ++i) {\n    b = a\n    a = list[i]\n    if(compare(a, b)) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique_eq(list) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b = list[0]\n  for(var i=1; i<len; ++i, b=a) {\n    b = a\n    a = list[i]\n    if(a !== b) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique(list, compare, sorted) {\n  if(list.length === 0) {\n    return list\n  }\n  if(compare) {\n    if(!sorted) {\n      list.sort(compare)\n    }\n    return unique_pred(list, compare)\n  }\n  if(!sorted) {\n    list.sort()\n  }\n  return unique_eq(list)\n}\n\nmodule.exports = unique\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91bmlxL3VuaXEuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91bmlxL3VuaXEuanM/YTQ4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiB1bmlxdWVfcHJlZChsaXN0LCBjb21wYXJlKSB7XG4gIHZhciBwdHIgPSAxXG4gICAgLCBsZW4gPSBsaXN0Lmxlbmd0aFxuICAgICwgYT1saXN0WzBdLCBiPWxpc3RbMF1cbiAgZm9yKHZhciBpPTE7IGk8bGVuOyArK2kpIHtcbiAgICBiID0gYVxuICAgIGEgPSBsaXN0W2ldXG4gICAgaWYoY29tcGFyZShhLCBiKSkge1xuICAgICAgaWYoaSA9PT0gcHRyKSB7XG4gICAgICAgIHB0cisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsaXN0W3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgbGlzdC5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGxpc3Rcbn1cblxuZnVuY3Rpb24gdW5pcXVlX2VxKGxpc3QpIHtcbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGxpc3QubGVuZ3RoXG4gICAgLCBhPWxpc3RbMF0sIGIgPSBsaXN0WzBdXG4gIGZvcih2YXIgaT0xOyBpPGxlbjsgKytpLCBiPWEpIHtcbiAgICBiID0gYVxuICAgIGEgPSBsaXN0W2ldXG4gICAgaWYoYSAhPT0gYikge1xuICAgICAgaWYoaSA9PT0gcHRyKSB7XG4gICAgICAgIHB0cisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsaXN0W3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgbGlzdC5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGxpc3Rcbn1cblxuZnVuY3Rpb24gdW5pcXVlKGxpc3QsIGNvbXBhcmUsIHNvcnRlZCkge1xuICBpZihsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBsaXN0XG4gIH1cbiAgaWYoY29tcGFyZSkge1xuICAgIGlmKCFzb3J0ZWQpIHtcbiAgICAgIGxpc3Quc29ydChjb21wYXJlKVxuICAgIH1cbiAgICByZXR1cm4gdW5pcXVlX3ByZWQobGlzdCwgY29tcGFyZSlcbiAgfVxuICBpZighc29ydGVkKSB7XG4gICAgbGlzdC5zb3J0KClcbiAgfVxuICByZXR1cm4gdW5pcXVlX2VxKGxpc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcXVlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uniq/uniq.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/components/App.css":
/*!************************************!*\
  !*** ./src/app/components/App.css ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"afc62f1d1803\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcG9uZW50cy9BcHAuY3NzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL2NvbXBvbmVudHMvQXBwLmNzcz83N2I4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiYWZjNjJmMWQxODAzXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/components/App.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/components/App.tsx":
/*!************************************!*\
  !*** ./src/app/components/App.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ App; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ui_Card__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui/Card */ \"(app-pages-browser)/./src/app/components/ui/Card.tsx\");\n/* harmony import */ var _ui_Button__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ui/Button */ \"(app-pages-browser)/./src/app/components/ui/Button.tsx\");\n/* harmony import */ var _App_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./App.css */ \"(app-pages-browser)/./src/app/components/App.css\");\n/* harmony import */ var _ui_Progress__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ui/Progress */ \"(app-pages-browser)/./src/app/components/ui/Progress.tsx\");\n/* harmony import */ var _ObjectDetection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ObjectDetection */ \"(app-pages-browser)/./src/app/components/ObjectDetection.tsx\");\n/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ndarray */ \"(app-pages-browser)/./node_modules/ndarray/ndarray.js\");\n/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(ndarray__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var ndarray_ops__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ndarray-ops */ \"(app-pages-browser)/./node_modules/ndarray-ops/ndarray-ops.js\");\n/* harmony import */ var ndarray_ops__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(ndarray_ops__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var onnxruntime_web__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! onnxruntime-web */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/esm/ort.min.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nfunction App() {\n    _s();\n    const [imageSrc, setImageSrc] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [darkMode, setDarkMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const imageInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [isDataReady, setIsDataReady] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [progress, setProgress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [isCameraOn, setIsCameraOn] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false); // Track camera state\n    // Set the dark mode\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const container = containerRef.current;\n        if (container) {\n            if (darkMode) {\n                container.classList.add(\"dark\");\n            } else {\n                container.classList.remove(\"dark\");\n            }\n        }\n    }, [\n        darkMode\n    ]);\n    // Upload image\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [inputData, setInputData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const uploadImage = (file)=>{\n        if (file && file.type.startsWith(\"image\")) {\n            const reader = new FileReader();\n            reader.onload = (e)=>{\n                var _e_target;\n                // Check if result is a string before assigning it\n                if (typeof ((_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.result) === \"string\") {\n                    setImageSrc(e.target.result);\n                } else {\n                    console.error(\"Expected a string, but received a different type\");\n                }\n            };\n            reader.readAsDataURL(file);\n        }\n    };\n    // Toggle webcam on/off\n    const toggleCamera = ()=>{\n        if (!isCameraOn) {\n            navigator.mediaDevices.getUserMedia({\n                video: true\n            }).then((stream)=>{\n                if (videoRef.current) {\n                    videoRef.current.srcObject = stream;\n                }\n                setIsCameraOn(true);\n            }).catch((err)=>{\n                console.error(\"Something went wrong!\", err);\n            });\n        } else {\n            var _videoRef_current_srcObject, _videoRef_current;\n            const tracks = (_videoRef_current = videoRef.current) === null || _videoRef_current === void 0 ? void 0 : (_videoRef_current_srcObject = _videoRef_current.srcObject) === null || _videoRef_current_srcObject === void 0 ? void 0 : _videoRef_current_srcObject.getTracks();\n            tracks === null || tracks === void 0 ? void 0 : tracks.forEach((track)=>track.stop());\n            if (videoRef.current) videoRef.current.srcObject = null;\n            setIsCameraOn(false);\n        }\n    };\n    const handleImageUpload = (event)=>{\n        const file = event.target.files && event.target.files[0];\n        if (!file) return;\n        uploadImage(file);\n        console.log(\"is canvas be set? \", canvasRef.current);\n        const canvas = canvasRef.current;\n        console.log(\"canvas dimensions w:\", canvas === null || canvas === void 0 ? void 0 : canvas.width, \" h: \", canvas === null || canvas === void 0 ? void 0 : canvas.height);\n        const ctx = canvas.getContext(\"2d\");\n        const img = new Image();\n        img.src = URL.createObjectURL(file);\n        img.onload = ()=>{\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height); // Resize image\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n            console.log(\"draw the image to canvas\");\n            processImageData(imageData);\n        };\n    };\n    function processImageData(imageData) {\n        const { data, width, height } = imageData;\n        // Create an ndarray for RGBA\n        const dataTensor = ndarray__WEBPACK_IMPORTED_MODULE_7___default()(new Float32Array(data), [\n            height,\n            width,\n            4\n        ]);\n        // get rid of the alpha in RGBA (we do not have to work with the transparency)\n        const dataProcessedTensor = ndarray__WEBPACK_IMPORTED_MODULE_7___default()(new Float32Array(width * height * 3), [\n            1,\n            3,\n            height,\n            width\n        ]);\n        ndarray_ops__WEBPACK_IMPORTED_MODULE_8___default().assign(dataProcessedTensor.pick(0, 0), dataTensor.pick(null, null, 0));\n        ndarray_ops__WEBPACK_IMPORTED_MODULE_8___default().assign(dataProcessedTensor.pick(0, 1), dataTensor.pick(null, null, 1));\n        ndarray_ops__WEBPACK_IMPORTED_MODULE_8___default().assign(dataProcessedTensor.pick(0, 2), dataTensor.pick(null, null, 2));\n        // Normalize\n        ndarray_ops__WEBPACK_IMPORTED_MODULE_8___default().divseq(dataProcessedTensor, 255);\n        // Convert to Tensor form\n        const tensor = new onnxruntime_web__WEBPACK_IMPORTED_MODULE_9__.Tensor(\"float32\", dataProcessedTensor.data, [\n            1,\n            3,\n            height,\n            width\n        ]);\n        if (tensor) {\n            console.log(\"tensor is set\");\n            setInputData(tensor);\n            setIsDataReady(true);\n        } else {\n            console.log(\"tensor is NULL\");\n        }\n    }\n    const handleImageSelectClick = ()=>{\n        var _imageInputRef_current;\n        (_imageInputRef_current = imageInputRef.current) === null || _imageInputRef_current === void 0 ? void 0 : _imageInputRef_current.click();\n        setProgress(0);\n    };\n    const removeImage = ()=>{\n        setImageSrc(null);\n        canvasRef.current.getContext(\"2d\").clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n        setIsDataReady(false);\n        setProgress(0);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"app\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_Card__WEBPACK_IMPORTED_MODULE_2__.Card, {\n            className: \"container\",\n            ref: containerRef,\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"state-text\",\n                    children: isDataReady ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ObjectDetection__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                                inputData: inputData,\n                                canvas: canvasRef,\n                                setProgress: setProgress\n                            }, void 0, false, {\n                                fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/App.tsx\",\n                                lineNumber: 149,\n                                columnNumber: 9\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_Progress__WEBPACK_IMPORTED_MODULE_5__.Progress, {\n                                value: progress\n                            }, void 0, false, {\n                                fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/App.tsx\",\n                                lineNumber: 150,\n                                columnNumber: 9\n                            }, this)\n                        ]\n                    }, void 0, true) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: \"Upload an image or open the camera to start detection.\"\n                    }, void 0, false, {\n                        fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/App.tsx\",\n                        lineNumber: 153,\n                        columnNumber: 10\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/App.tsx\",\n                    lineNumber: 146,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_Card__WEBPACK_IMPORTED_MODULE_2__.Card, {\n                    className: \"camera-card\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                            className: \"canvas\",\n                            ref: canvasRef,\n                            width: \"640\",\n                            height: \"640\",\n                            style: {\n                                display: \"visible\"\n                            }\n                        }, void 0, false, {\n                            fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/App.tsx\",\n                            lineNumber: 161,\n                            columnNumber: 13\n                        }, this),\n                        imageSrc ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                    className: \"image\",\n                                    src: imageSrc,\n                                    alt: \"Uploaded\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/App.tsx\",\n                                    lineNumber: 165,\n                                    columnNumber: 19\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_Button__WEBPACK_IMPORTED_MODULE_3__.Button, {\n                                    className: \"button-remove\",\n                                    onClick: removeImage,\n                                    children: \"Remove Image\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/App.tsx\",\n                                    lineNumber: 166,\n                                    columnNumber: 19\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/App.tsx\",\n                            lineNumber: 164,\n                            columnNumber: 17\n                        }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"video\", {\n                                className: \"video\",\n                                ref: videoRef,\n                                autoPlay: true,\n                                style: {\n                                    width: \"100%\"\n                                }\n                            }, void 0, false, {\n                                fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/App.tsx\",\n                                lineNumber: 170,\n                                columnNumber: 19\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/App.tsx\",\n                            lineNumber: 169,\n                            columnNumber: 17\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/App.tsx\",\n                    lineNumber: 158,\n                    columnNumber: 13\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"button-group\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_Button__WEBPACK_IMPORTED_MODULE_3__.Button, {\n                            onClick: handleImageSelectClick,\n                            children: \"Select Image\"\n                        }, void 0, false, {\n                            fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/App.tsx\",\n                            lineNumber: 175,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            type: \"file\",\n                            ref: imageInputRef,\n                            onChange: handleImageUpload,\n                            accept: \"image/*\",\n                            style: {\n                                display: \"none\"\n                            }\n                        }, void 0, false, {\n                            fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/App.tsx\",\n                            lineNumber: 176,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_Button__WEBPACK_IMPORTED_MODULE_3__.Button, {\n                            onClick: toggleCamera,\n                            children: isCameraOn ? \"Close Camera\" : \"Start Camera\"\n                        }, void 0, false, {\n                            fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/App.tsx\",\n                            lineNumber: 183,\n                            columnNumber: 15\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/App.tsx\",\n                    lineNumber: 174,\n                    columnNumber: 13\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/App.tsx\",\n            lineNumber: 144,\n            columnNumber: 11\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/App.tsx\",\n        lineNumber: 143,\n        columnNumber: 9\n    }, this);\n}\n_s(App, \"oVmZAPHFpa1QJRiGHOIBfC/MLgg=\");\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcG9uZW50cy9BcHAudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDMkQ7QUFDMUI7QUFDSTtBQUNsQjtBQUNxQjtBQUNRO0FBRWxCO0FBQ0E7QUFDUztBQUV4QixTQUFTVzs7SUFDdEIsTUFBTSxDQUFDQyxVQUFVQyxZQUFZLEdBQUdaLCtDQUFRQSxDQUFnQjtJQUN4RCxNQUFNLENBQUNhLFVBQVVDLFlBQVksR0FBR2QsK0NBQVFBLENBQUM7SUFDekMsTUFBTWUsZUFBZWQsNkNBQU1BLENBQWlCO0lBQzVDLE1BQU1lLGdCQUFnQmYsNkNBQU1BLENBQW1CO0lBQy9DLE1BQU0sQ0FBQ2dCLGFBQWFDLGVBQWUsR0FBR2xCLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ21CLFVBQVVDLFlBQVksR0FBR3BCLCtDQUFRQSxDQUFDO0lBQ3pDLE1BQU1xQixXQUFXcEIsNkNBQU1BLENBQW1CO0lBQzFDLE1BQU0sQ0FBQ3FCLFlBQVlDLGNBQWMsR0FBR3ZCLCtDQUFRQSxDQUFDLFFBQVEscUJBQXFCO0lBQzFFLG9CQUFvQjtJQUNwQkUsZ0RBQVNBLENBQUM7UUFDUixNQUFNc0IsWUFBWVQsYUFBYVUsT0FBTztRQUN0QyxJQUFJRCxXQUFXO1lBQ2IsSUFBSVgsVUFBVTtnQkFDWlcsVUFBVUUsU0FBUyxDQUFDQyxHQUFHLENBQUM7WUFDMUIsT0FBTztnQkFDTEgsVUFBVUUsU0FBUyxDQUFDRSxNQUFNLENBQUM7WUFDN0I7UUFDRjtJQUNGLEdBQUc7UUFBQ2Y7S0FBUztJQUViLGVBQWU7SUFDZixNQUFNZ0IsWUFBWTVCLDZDQUFNQSxDQUFvQjtJQUM1QyxNQUFNLENBQUM2QixXQUFXQyxhQUFhLEdBQUcvQiwrQ0FBUUEsQ0FBQztJQUV6QyxNQUFNZ0MsY0FBYyxDQUFDQztRQUVyQixJQUFJQSxRQUFRQSxLQUFLQyxJQUFJLENBQUNDLFVBQVUsQ0FBQyxVQUFVO1lBQ3pDLE1BQU1DLFNBQVMsSUFB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Ozs7OEJBS0EsOERBQUM1RiwwQ0FBSUE7b0JBQUN5RixXQUFVOztzQ0FHaEIsOERBQUM1Qjs0QkFBTzRCLFdBQVU7NEJBQVNDLEtBQUtoRTs0QkFBV29DLE9BQU07NEJBQU1DLFFBQU87NEJBQU04QixPQUFPO2dDQUFFQyxTQUFTOzRCQUFVOzs7Ozs7d0JBRTdGdEYseUJBQ0MsOERBQUNnRjs7OENBQ0MsOERBQUN0QjtvQ0FBSXVCLFdBQVU7b0NBQVFyQixLQUFLNUQ7b0NBQVV1RixLQUFJOzs7Ozs7OENBQzFDLDhEQUFDOUYsOENBQU1BO29DQUFDd0YsV0FBVTtvQ0FBZ0JPLFNBQVNWOzhDQUFhOzs7Ozs7Ozs7OztpREFHMUQsOERBQUNFO3NDQUNDLDRFQUFDMUM7Z0NBQU0yQyxXQUFVO2dDQUFRQyxLQUFLeEU7Z0NBQVUrRSxRQUFRO2dDQUFDSixPQUFPO29DQUFFL0IsT0FBTztnQ0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7OEJBSTlFLDhEQUFDMEI7b0JBQUlDLFdBQVU7O3NDQUNiLDhEQUFDeEYsOENBQU1BOzRCQUFDK0YsU0FBU1o7c0NBQXdCOzs7Ozs7c0NBQ3pDLDhEQUFDYzs0QkFDQ25FLE1BQUs7NEJBQ0wyRCxLQUFLN0U7NEJBQ0xzRixVQUFVMUM7NEJBQ1YyQyxRQUFPOzRCQUNQUCxPQUFPO2dDQUFFQyxTQUFTOzRCQUFPOzs7Ozs7c0NBRTNCLDhEQUFDN0YsOENBQU1BOzRCQUFDK0YsU0FBU3REO3NDQUFldkIsYUFBYSxpQkFBaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTTVFO0dBaEx3Qlo7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9jb21wb25lbnRzL0FwcC50c3g/ZTJmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDYXJkIH0gZnJvbSAnLi91aS9DYXJkJztcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gJy4vdWkvQnV0dG9uJztcbmltcG9ydCBcIi4vQXBwLmNzc1wiO1xuaW1wb3J0IHsgUHJvZ3Jlc3MgfSBmcm9tIFwiLi91aS9Qcm9ncmVzc1wiXG5pbXBvcnQgT2JqZWN0RGV0ZWN0aW9uIGZyb20gJy4vT2JqZWN0RGV0ZWN0aW9uJztcbmltcG9ydCB7IFVwbG9hZCB9IGZyb20gJ2x1Y2lkZS1yZWFjdCc7XG5pbXBvcnQgbmRhcnJheSBmcm9tICduZGFycmF5JztcbmltcG9ydCBvcHMgZnJvbSAnbmRhcnJheS1vcHMnO1xuaW1wb3J0ICogYXMgb3J0IGZyb20gJ29ubnhydW50aW1lLXdlYic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFwcCgpIHtcbiAgY29uc3QgW2ltYWdlU3JjLCBzZXRJbWFnZVNyY10gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2RhcmtNb2RlLCBzZXREYXJrTW9kZV0gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgaW1hZ2VJbnB1dFJlZiA9IHVzZVJlZjxIVE1MSW5wdXRFbGVtZW50PihudWxsKTtcbiAgY29uc3QgW2lzRGF0YVJlYWR5LCBzZXRJc0RhdGFSZWFkeV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtwcm9ncmVzcywgc2V0UHJvZ3Jlc3NdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IHZpZGVvUmVmID0gdXNlUmVmPEhUTUxWaWRlb0VsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBbaXNDYW1lcmFPbiwgc2V0SXNDYW1lcmFPbl0gPSB1c2VTdGF0ZShmYWxzZSk7IC8vIFRyYWNrIGNhbWVyYSBzdGF0ZVxuICAvLyBTZXQgdGhlIGRhcmsgbW9kZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIGlmIChkYXJrTW9kZSkge1xuICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZGFyaycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2RhcmsnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtkYXJrTW9kZV0pO1xuXG4gIC8vIFVwbG9hZCBpbWFnZVxuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBbaW5wdXREYXRhLCBzZXRJbnB1dERhdGFdID0gdXNlU3RhdGUobnVsbCk7XG5cbiAgICBjb25zdCB1cGxvYWRJbWFnZSA9IChmaWxlKSA9PiB7XG5cbiAgICBpZiAoZmlsZSAmJiBmaWxlLnR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UnKSkge1xuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSAoZTogUHJvZ3Jlc3NFdmVudDxGaWxlUmVhZGVyPikgPT4ge1xuICAgICAgICAvLyBDaGVjayBpZiByZXN1bHQgaXMgYSBzdHJpbmcgYmVmb3JlIGFzc2lnbmluZyBpdFxuICAgICAgICBpZiAodHlwZW9mIGUudGFyZ2V0Py5yZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgc2V0SW1hZ2VTcmMoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFeHBlY3RlZCBhIHN0cmluZywgYnV0IHJlY2VpdmVkIGEgZGlmZmVyZW50IHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgIH1cbiAgfTtcblxuXG4gICAgLy8gVG9nZ2xlIHdlYmNhbSBvbi9vZmZcbiAgY29uc3QgdG9nZ2xlQ2FtZXJhID0gKCkgPT4ge1xuICAgIGlmICghaXNDYW1lcmFPbikge1xuICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyB2aWRlbzogdHJ1ZSB9KVxuICAgICAgICAudGhlbihzdHJlYW0gPT4ge1xuICAgICAgICAgIGlmICh2aWRlb1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICB2aWRlb1JlZi5jdXJyZW50LnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0SXNDYW1lcmFPbih0cnVlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlNvbWV0aGluZyB3ZW50IHdyb25nIVwiLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHJhY2tzID0gdmlkZW9SZWYuY3VycmVudD8uc3JjT2JqZWN0Py5nZXRUcmFja3MoKTtcbiAgICAgIHRyYWNrcz8uZm9yRWFjaCh0cmFjayA9PiB0cmFjay5zdG9wKCkpO1xuICAgICAgaWYgKHZpZGVvUmVmLmN1cnJlbnQpIHZpZGVvUmVmLmN1cnJlbnQuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICAgIHNldElzQ2FtZXJhT24oZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuXG4gIGNvbnN0IGhhbmRsZUltYWdlVXBsb2FkID0gKGV2ZW50OiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IGZpbGUgPSAgZXZlbnQudGFyZ2V0LmZpbGVzICYmIGV2ZW50LnRhcmdldC5maWxlc1swXTtcbiAgICBpZiAoIWZpbGUpIHJldHVybjtcblxuICAgIHVwbG9hZEltYWdlKGZpbGUpXG5cbiAgICBjb25zb2xlLmxvZyhcImlzIGNhbnZhcyBiZSBzZXQ/IFwiLCBjYW52YXNSZWYuY3VycmVudClcbiAgICBcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcblxuICAgIGNvbnNvbGUubG9nKCdjYW52YXMgZGltZW5zaW9ucyB3OicsIGNhbnZhcz8ud2lkdGgsIFwiIGg6IFwiLCBjYW52YXM/LmhlaWdodClcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcbiAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7IC8vIFJlc2l6ZSBpbWFnZVxuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgY29uc29sZS5sb2coXCJkcmF3IHRoZSBpbWFnZSB0byBjYW52YXNcIilcbiAgICAgIHByb2Nlc3NJbWFnZURhdGEoaW1hZ2VEYXRhKTtcbiAgICAgIFxuICAgIH07XG4gIH07XG5cblxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NJbWFnZURhdGEoaW1hZ2VEYXRhKSB7XG4gICAgY29uc3QgeyBkYXRhLCB3aWR0aCwgaGVpZ2h0IH0gPSBpbWFnZURhdGE7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGFuIG5kYXJyYXkgZm9yIFJHQkFcbiAgICBjb25zdCBkYXRhVGVuc29yID0gbmRhcnJheShuZXcgRmxvYXQzMkFycmF5KGRhdGEpLCBbaGVpZ2h0LCB3aWR0aCwgNF0pO1xuXG4gICAgLy8gZ2V0IHJpZCBvZiB0aGUgYWxwaGEgaW4gUkdCQSAod2UgZG8gbm90IGhhdmUgdG8gd29yayB3aXRoIHRoZSB0cmFuc3BhcmVuY3kpXG4gICAgY29uc3QgZGF0YVByb2Nlc3NlZFRlbnNvciA9IG5kYXJyYXkobmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDMpLCBbMSwgMywgaGVpZ2h0LCB3aWR0aF0pO1xuICAgIG9wcy5hc3NpZ24oZGF0YVByb2Nlc3NlZFRlbnNvci5waWNrKDAsIDApLCBkYXRhVGVuc29yLnBpY2sobnVsbCwgbnVsbCwgMCkpO1xuICAgIG9wcy5hc3NpZ24oZGF0YVByb2Nlc3NlZFRlbnNvci5waWNrKDAsIDEpLCBkYXRhVGVuc29yLnBpY2sobnVsbCwgbnVsbCwgMSkpO1xuICAgIG9wcy5hc3NpZ24oZGF0YVByb2Nlc3NlZFRlbnNvci5waWNrKDAsIDIpLCBkYXRhVGVuc29yLnBpY2sobnVsbCwgbnVsbCwgMikpO1xuICBcbiAgICAvLyBOb3JtYWxpemVcbiAgICBvcHMuZGl2c2VxKGRhdGFQcm9jZXNzZWRUZW5zb3IsIDI1NSk7XG4gICAgXG4gICAgLy8gQ29udmVydCB0byBUZW5zb3IgZm9ybVxuICAgIGNvbnN0IHRlbnNvciA9IG5ldyBvcnQuVGVuc29yKCdmbG9hdDMyJywgZGF0YVByb2Nlc3NlZFRlbnNvci5kYXRhLCBbMSwgMywgaGVpZ2h0LCB3aWR0aF0pO1xuICAgIFxuICAgIGlmKHRlbnNvcil7XG4gICAgICBjb25zb2xlLmxvZyhcInRlbnNvciBpcyBzZXRcIilcbiAgICAgIHNldElucHV0RGF0YSh0ZW5zb3IpO1xuICAgICAgc2V0SXNEYXRhUmVhZHkodHJ1ZSlcbiAgICB9XG4gICBcbiAgICBlbHNle1xuICAgICAgY29uc29sZS5sb2coXCJ0ZW5zb3IgaXMgTlVMTFwiKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGhhbmRsZUltYWdlU2VsZWN0Q2xpY2sgPSAoKSA9PiB7XG4gICAgaW1hZ2VJbnB1dFJlZi5jdXJyZW50Py5jbGljaygpO1xuICAgIHNldFByb2dyZXNzKDApXG4gIH1cbiAgY29uc3QgcmVtb3ZlSW1hZ2UgPSAoKSA9PiB7XG4gICAgc2V0SW1hZ2VTcmMobnVsbCk7XG4gICAgY2FudmFzUmVmLmN1cnJlbnQuZ2V0Q29udGV4dCgnMmQnKS5jbGVhclJlY3QoMCwgMCwgY2FudmFzUmVmLmN1cnJlbnQud2lkdGgsIGNhbnZhc1JlZi5jdXJyZW50LmhlaWdodCk7XG4gICAgc2V0SXNEYXRhUmVhZHkoZmFsc2UpXG4gICAgc2V0UHJvZ3Jlc3MoMClcbiAgfTtcblxuICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFwcFwiPlxuICAgICAgICAgIDxDYXJkIGNsYXNzTmFtZT0nY29udGFpbmVyJyByZWY9e2NvbnRhaW5lclJlZn0+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nc3RhdGUtdGV4dCc+XG4gICAgICAgIHtpc0RhdGFSZWFkeSA/ICAoXG4gICAgICAgICAgPD5cbiAgICAgICAgPE9iamVjdERldGVjdGlvbiBpbnB1dERhdGE9e2lucHV0RGF0YX0gY2FudmFzID17Y2FudmFzUmVmfSBzZXRQcm9ncmVzcz0ge3NldFByb2dyZXNzfS8+XG4gICAgICAgIDxQcm9ncmVzcyB2YWx1ZT17cHJvZ3Jlc3N9PjwvUHJvZ3Jlc3M+XG4gICAgICAgIDwvPlxuICAgICAgICApOlxuICAgICAgICAgPHA+VXBsb2FkIGFuIGltYWdlIG9yIG9wZW4gdGhlIGNhbWVyYSB0byBzdGFydCBkZXRlY3Rpb24uPC9wPlxuICAgICAgICBcbiAgICAgIH1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICAgICAgPENhcmQgY2xhc3NOYW1lPVwiY2FtZXJhLWNhcmRcIj5cbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICAgIDxjYW52YXMgY2xhc3NOYW1lPVwiY2FudmFzXCIgcmVmPXtjYW52YXNSZWZ9IHdpZHRoPVwiNjQwXCIgaGVpZ2h0PVwiNjQwXCIgc3R5bGU9e3sgZGlzcGxheTogJ3Zpc2libGUnIH19IC8+XG4gICAgICAgICAgIFxuICAgICAgICAgICAgICB7aW1hZ2VTcmMgPyAoXG4gICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3NOYW1lPSdpbWFnZScgc3JjPXtpbWFnZVNyY30gYWx0PVwiVXBsb2FkZWRcIi8+XG4gICAgICAgICAgICAgICAgICA8QnV0dG9uIGNsYXNzTmFtZT0nYnV0dG9uLXJlbW92ZScgb25DbGljaz17cmVtb3ZlSW1hZ2V9PlJlbW92ZSBJbWFnZTwvQnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICA8dmlkZW8gY2xhc3NOYW1lPSd2aWRlbycgcmVmPXt2aWRlb1JlZn0gYXV0b1BsYXkgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJyB9fT48L3ZpZGVvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9DYXJkPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJidXR0b24tZ3JvdXBcIj5cbiAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXtoYW5kbGVJbWFnZVNlbGVjdENsaWNrfT5TZWxlY3QgSW1hZ2U8L0J1dHRvbj5cbiAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgdHlwZT1cImZpbGVcIlxuICAgICAgICAgICAgICAgIHJlZj17aW1hZ2VJbnB1dFJlZn1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlSW1hZ2VVcGxvYWR9XG4gICAgICAgICAgICAgICAgYWNjZXB0PVwiaW1hZ2UvKlwiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgZGlzcGxheTogJ25vbmUnIH19XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17dG9nZ2xlQ2FtZXJhfT57aXNDYW1lcmFPbiA/ICdDbG9zZSBDYW1lcmEnIDogJ1N0YXJ0IENhbWVyYSd9PC9CdXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L0NhcmQ+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKTtcblxufVxuXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZVJlZiIsInVzZUVmZmVjdCIsIkNhcmQiLCJCdXR0b24iLCJQcm9ncmVzcyIsIk9iamVjdERldGVjdGlvbiIsIm5kYXJyYXkiLCJvcHMiLCJvcnQiLCJBcHAiLCJpbWFnZVNyYyIsInNldEltYWdlU3JjIiwiZGFya01vZGUiLCJzZXREYXJrTW9kZSIsImNvbnRhaW5lclJlZiIsImltYWdlSW5wdXRSZWYiLCJpc0RhdGFSZWFkeSIsInNldElzRGF0YVJlYWR5IiwicHJvZ3Jlc3MiLCJzZXRQcm9ncmVzcyIsInZpZGVvUmVmIiwiaXNDYW1lcmFPbiIsInNldElzQ2FtZXJhT24iLCJjb250YWluZXIiLCJjdXJyZW50IiwiY2xhc3NMaXN0IiwiYWRkIiwicmVtb3ZlIiwiY2FudmFzUmVmIiwiaW5wdXREYXRhIiwic2V0SW5wdXREYXRhIiwidXBsb2FkSW1hZ2UiLCJmaWxlIiwidHlwZSIsInN0YXJ0c1dpdGgiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwiZSIsInRhcmdldCIsInJlc3VsdCIsImNvbnNvbGUiLCJlcnJvciIsInJlYWRBc0RhdGFVUkwiLCJ0b2dnbGVDYW1lcmEiLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJ2aWRlbyIsInRoZW4iLCJzdHJlYW0iLCJzcmNPYmplY3QiLCJjYXRjaCIsImVyciIsInRyYWNrcyIsImdldFRyYWNrcyIsImZvckVhY2giLCJ0cmFjayIsInN0b3AiLCJoYW5kbGVJbWFnZVVwbG9hZCIsImV2ZW50IiwiZmlsZXMiLCJsb2ciLCJjYW52YXMiLCJ3aWR0aCIsImhlaWdodCIsImN0eCIsImdldENvbnRleHQiLCJpbWciLCJJbWFnZSIsInNyYyIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImRyYXdJbWFnZSIsImltYWdlRGF0YSIsImdldEltYWdlRGF0YSIsInByb2Nlc3NJbWFnZURhdGEiLCJkYXRhIiwiZGF0YVRlbnNvciIsIkZsb2F0MzJBcnJheSIsImRhdGFQcm9jZXNzZWRUZW5zb3IiLCJhc3NpZ24iLCJwaWNrIiwiZGl2c2VxIiwidGVuc29yIiwiVGVuc29yIiwiaGFuZGxlSW1hZ2VTZWxlY3RDbGljayIsImNsaWNrIiwicmVtb3ZlSW1hZ2UiLCJjbGVhclJlY3QiLCJkaXYiLCJjbGFzc05hbWUiLCJyZWYiLCJ2YWx1ZSIsInAiLCJzdHlsZSIsImRpc3BsYXkiLCJhbHQiLCJvbkNsaWNrIiwiYXV0b1BsYXkiLCJpbnB1dCIsIm9uQ2hhbmdlIiwiYWNjZXB0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/components/App.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/components/ObjectDetection.tsx":
/*!************************************************!*\
  !*** ./src/app/components/ObjectDetection.tsx ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var onnxruntime_web__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! onnxruntime-web */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/esm/ort.min.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst ObjectDetection = (param)=>{\n    let { inputData, canvas, setProgress } = param;\n    _s();\n    const [session, setSession] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [modelLoaded, setModelLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [detectionMade, setDetectionMade] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Load the model asynchronously when the component mounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        async function loadModel() {\n            //initilize the backend for the ONNX\n            try {\n                onnxruntime_web__WEBPACK_IMPORTED_MODULE_2__.env.wasm.wasmPaths = {\n                    \"ort-wasm-simd.wasm\": \"/wasm/ort-wasm-simd.wasm\",\n                    \"ort-wasm.wasm\": \"/wasm/ort-wasm.wasm\"\n                };\n                //get the model and load as the session\n                const modelPath = \"/model/yolo_post_640x640.onnx\";\n                const loadedSession = await onnxruntime_web__WEBPACK_IMPORTED_MODULE_2__.InferenceSession.create(modelPath);\n                setSession(loadedSession);\n                setProgress(33);\n                setModelLoaded(true);\n            } catch (error) {\n                console.error(\"Failed to load the model:\", error);\n            }\n        }\n        loadModel();\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        async function runDetection() {\n            if (modelLoaded && inputData && session) {\n                try {\n                    console.log(\"given input data is \", inputData) //check if the input data is initinized properly\n                    ;\n                    setProgress(66) //set the progress\n                    ;\n                    //feed the input into the model\n                    const feeds = {\n                        images: inputData\n                    };\n                    const output = await session.run(feeds);\n                    //extract the prediction and confidence from the output and draw the results to the cnavas\n                    const detections = processDetections(output);\n                    drawDetection(canvas.current, detections);\n                } catch (error) {\n                    console.error(\"Error running detection:\", error);\n                }\n            }\n        }\n        runDetection();\n    }, [\n        inputData,\n        modelLoaded,\n        session\n    ]);\n    // Extract the outputs of the model to somethign meaningfull\n    function processDetections(output) {\n        //extract the output\n        const scores = output.score.data; // corresponding confidence for the classes in the above output\n        const detections = output.batchno_classid_x1y1x2y2.data; // we have the format [0 class_name x1 y1 x2 y2]\n        const formattedDetections = [];\n        for(let i = 0; i < scores.length; i++){\n            const score = scores[i];\n            const index = i * 6;\n            const batchId = detections[index];\n            const classId = detections[index + 1];\n            const bbox = {\n                x1: detections[index + 2],\n                y1: detections[index + 3],\n                x2: detections[index + 4],\n                y2: detections[index + 5]\n            };\n            if (score > 0.5) {\n                const className = COCO_CLASSES[classId]; //find the actual class name using the class id\n                formattedDetections.push({\n                    batchId,\n                    classId,\n                    className,\n                    bbox,\n                    score\n                });\n            }\n        }\n        return formattedDetections;\n    }\n    function drawDetection(canvas, detections) {\n        const ctx = canvas.getContext(\"2d\");\n        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas\n        //extract the box values\n        const { x1, y1, x2, y2 } = detections[0].bbox;\n        const x1_ = Number(x1);\n        const y1_ = Number(y1);\n        const x2_ = Number(x2);\n        const y2_ = Number(y2);\n        //prepare the text (containes the class name and the confidance rate)\n        const text = \"\".concat(detections[0].className, \" (\").concat((detections[0].score * 100).toFixed(1), \"%)\");\n        console.log(\"SCORE IS: \", text);\n        setDetectionMade(true);\n        setProgress(100);\n        drawRect(ctx, x1_, y1_, x2_, y2_, text, \"#FF0000\");\n    }\n    //using the infromation, draw it into the canvas\n    function drawRect(ctx, x, y, w, h) {\n        let text = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"\", color = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : \"red\";\n        ctx.beginPath();\n        ctx.strokeStyle = color;\n        ctx.lineWidth = 2;\n        ctx.rect(x, y, w, h);\n        ctx.stroke();\n        if (text) {\n            ctx.fillStyle = color;\n            ctx.font = \"40px Arial\";\n            ctx.fillText(text, x + 15, y + 45);\n        }\n    }\n    // Classes to extract the actual class name in the given id (following COCO convention)\n    const COCO_CLASSES = [\n        \"person\",\n        \"bicycle\",\n        \"car\",\n        \"motorcycle\",\n        \"airplane\",\n        \"bus\",\n        \"train\",\n        \"truck\",\n        \"boat\",\n        \"traffic light\",\n        \"fire hydrant\",\n        \"stop sign\",\n        \"parking meter\",\n        \"bench\",\n        \"bird\",\n        \"cat\",\n        \"dog\",\n        \"horse\",\n        \"sheep\",\n        \"cow\",\n        \"elephant\",\n        \"bear\",\n        \"zebra\",\n        \"giraffe\",\n        \"backpack\",\n        \"umbrella\",\n        \"handbag\",\n        \"tie\",\n        \"suitcase\",\n        \"frisbee\",\n        \"skis\",\n        \"snowboard\",\n        \"sports ball\",\n        \"kite\",\n        \"baseball bat\",\n        \"baseball glove\",\n        \"skateboard\",\n        \"surfboard\",\n        \"tennis racket\",\n        \"bottle\",\n        \"wine glass\",\n        \"cup\",\n        \"fork\",\n        \"knife\",\n        \"spoon\",\n        \"bowl\",\n        \"banana\",\n        \"apple\",\n        \"sandwich\",\n        \"orange\",\n        \"broccoli\",\n        \"carrot\",\n        \"hot dog\",\n        \"pizza\",\n        \"donut\",\n        \"cake\",\n        \"chair\",\n        \"sofa\",\n        \"pottedplant\",\n        \"bed\",\n        \"diningtable\",\n        \"toilet\",\n        \"tvmonitor\",\n        \"laptop\",\n        \"mouse\",\n        \"remote\",\n        \"keyboard\",\n        \"cell phone\",\n        \"microwave\",\n        \"oven\",\n        \"toaster\",\n        \"sink\",\n        \"refrigerator\",\n        \"book\",\n        \"clock\",\n        \"vase\",\n        \"scissors\",\n        \"teddy bear\",\n        \"hair drier\",\n        \"toothbrush\"\n    ];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n        children: modelLoaded ? detectionMade ? \"Detection is made...\" : \"Model loaded, detecting objects...\" : \"Loading model...\"\n    }, void 0, false, {\n        fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/ObjectDetection.tsx\",\n        lineNumber: 159,\n        columnNumber: 12\n    }, undefined);\n};\n_s(ObjectDetection, \"xvHPWRuK2hDO1/jT+4VifirwFmE=\");\n_c = ObjectDetection;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ObjectDetection);\nvar _c;\n$RefreshReg$(_c, \"ObjectDetection\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcG9uZW50cy9PYmplY3REZXRlY3Rpb24udHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBbUQ7QUFDWjtBQUV2QyxNQUFNSSxrQkFBa0I7UUFBQyxFQUFFQyxTQUFTLEVBQUdDLE1BQU0sRUFBRUMsV0FBVyxFQUFDOztJQUN2RCxNQUFNLENBQUNDLFNBQVNDLFdBQVcsR0FBR1AsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDUSxhQUFhQyxlQUFlLEdBQUdULCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ1UsZUFBZUMsaUJBQWlCLEdBQUdYLCtDQUFRQSxDQUFDO0lBRW5ELDBEQUEwRDtJQUMxREQsZ0RBQVNBLENBQUM7UUFDTixlQUFlYTtZQUVYLG9DQUFvQztZQUNwQyxJQUFJO2dCQUNBWCxnREFBTyxDQUFDYSxJQUFJLENBQUNDLFNBQVMsR0FBRztvQkFDckIsc0JBQXNCO29CQUN0QixpQkFBaUI7Z0JBQ3JCO2dCQUVBLHVDQUF1QztnQkFDdkMsTUFBTUMsWUFBYTtnQkFDbkIsTUFBTUMsZ0JBQWdCLE1BQU1oQiw2REFBb0IsQ0FBQ2tCLE1BQU0sQ0FBQ0g7Z0JBQ3hEVCxXQUFXVTtnQkFDWFosWUFBWTtnQkFDWkksZUFBZTtZQUNuQixFQUFFLE9BQU9XLE9BQU87Z0JBQ1pDLFFBQVFELEtBQUssQ0FBQyw2QkFBNkJBO1lBQy9DO1FBQ0o7UUFDQVI7SUFDSixHQUFHLEVBQUU7SUFFTGIsZ0RBQVNBLENBQUM7UUFDUixlQUFldUI7WUFDWCxJQUFJZCxlQUFlTCxhQUFhRyxTQUFTO2dCQUNyQyxJQUFJO29CQUVBZSxRQUFRRSxHQUFHLENBQUMsd0JBQXdCcEIsV0FBVyxnREFBZ0Q7O29CQUMvRkUsWUFBWSxJQUFJLGtCQUFrQjs7b0JBR2xDLCtCQUErQjtvQkFDL0IsTUFBTW1CLFFBQVE7d0JBQUVDLFFBQVF0QjtvQkFBVTtvQkFDbEMsTUFBTXVCLFNBQVMsTUFBTXBCLFFBQVFxQixHQUFHLENBQUNI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SUFBSSxHQUFHO1lBQ1h4QixJQUFJeUIsUUFBUSxDQUFDZixNQUFNRyxJQUFJLElBQUlDLElBQUk7UUFDakM7SUFDRjtJQUdGLHVGQUF1RjtJQUN2RixNQUFNaEIsZUFBZTtRQUNuQjtRQUFVO1FBQVc7UUFBTztRQUFjO1FBQzFDO1FBQU87UUFBUztRQUFTO1FBQVE7UUFDakM7UUFBZ0I7UUFBYTtRQUFpQjtRQUFTO1FBQ3ZEO1FBQU87UUFBTztRQUFTO1FBQVM7UUFDaEM7UUFBWTtRQUFRO1FBQVM7UUFBVztRQUN4QztRQUFZO1FBQVc7UUFBTztRQUFZO1FBQzFDO1FBQVE7UUFBYTtRQUFlO1FBQVE7UUFDNUM7UUFBa0I7UUFBYztRQUFhO1FBQWlCO1FBQzlEO1FBQWM7UUFBTztRQUFRO1FBQVM7UUFDdEM7UUFBUTtRQUFVO1FBQVM7UUFBWTtRQUN2QztRQUFZO1FBQVU7UUFBVztRQUFTO1FBQzFDO1FBQVE7UUFBUztRQUFRO1FBQWU7UUFDeEM7UUFBZTtRQUFVO1FBQWE7UUFBVTtRQUNoRDtRQUFVO1FBQVk7UUFBYztRQUFhO1FBQ2pEO1FBQVc7UUFBUTtRQUFnQjtRQUFRO1FBQzNDO1FBQVE7UUFBWTtRQUFjO1FBQWM7S0FDakQ7SUFFRyxxQkFBTyw4REFBQzRCO2tCQUFJcEUsY0FBZUUsZ0JBQWdCLHlCQUF3Qix1Q0FBd0M7Ozs7OztBQUMvRztHQTVKTVI7S0FBQUE7QUE4Sk4sK0RBQWVBLGVBQWVBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9jb21wb25lbnRzL09iamVjdERldGVjdGlvbi50c3g/YzRiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIG9ydCBmcm9tICdvbm54cnVudGltZS13ZWInO1xuXG5jb25zdCBPYmplY3REZXRlY3Rpb24gPSAoeyBpbnB1dERhdGEgLCBjYW52YXMsIHNldFByb2dyZXNzfSkgPT4ge1xuICAgIGNvbnN0IFtzZXNzaW9uLCBzZXRTZXNzaW9uXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFttb2RlbExvYWRlZCwgc2V0TW9kZWxMb2FkZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtkZXRlY3Rpb25NYWRlLCBzZXREZXRlY3Rpb25NYWRlXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIC8vIExvYWQgdGhlIG1vZGVsIGFzeW5jaHJvbm91c2x5IHdoZW4gdGhlIGNvbXBvbmVudCBtb3VudHNcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBsb2FkTW9kZWwoKSB7XG5cbiAgICAgICAgICAgIC8vaW5pdGlsaXplIHRoZSBiYWNrZW5kIGZvciB0aGUgT05OWFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvcnQuZW52Lndhc20ud2FzbVBhdGhzID0ge1xuICAgICAgICAgICAgICAgICAgICAnb3J0LXdhc20tc2ltZC53YXNtJzogJy93YXNtL29ydC13YXNtLXNpbWQud2FzbScsXG4gICAgICAgICAgICAgICAgICAgICdvcnQtd2FzbS53YXNtJzogJy93YXNtL29ydC13YXNtLndhc20nLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvL2dldCB0aGUgbW9kZWwgYW5kIGxvYWQgYXMgdGhlIHNlc3Npb25cbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbFBhdGggPSBgL21vZGVsL3lvbG9fcG9zdF82NDB4NjQwLm9ubnhgO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRlZFNlc3Npb24gPSBhd2FpdCBvcnQuSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUobW9kZWxQYXRoKTtcbiAgICAgICAgICAgICAgICBzZXRTZXNzaW9uKGxvYWRlZFNlc3Npb24pO1xuICAgICAgICAgICAgICAgIHNldFByb2dyZXNzKDMzKVxuICAgICAgICAgICAgICAgIHNldE1vZGVsTG9hZGVkKHRydWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCB0aGUgbW9kZWw6JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxvYWRNb2RlbCgpO1xuICAgIH0sIFtdKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBhc3luYyBmdW5jdGlvbiBydW5EZXRlY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKG1vZGVsTG9hZGVkICYmIGlucHV0RGF0YSAmJiBzZXNzaW9uKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZ2l2ZW4gaW5wdXQgZGF0YSBpcyBcIiwgaW5wdXREYXRhKSAvL2NoZWNrIGlmIHRoZSBpbnB1dCBkYXRhIGlzIGluaXRpbml6ZWQgcHJvcGVybHlcbiAgICAgICAgICAgICAgICAgIHNldFByb2dyZXNzKDY2KSAvL3NldCB0aGUgcHJvZ3Jlc3NcblxuXG4gICAgICAgICAgICAgICAgICAvL2ZlZWQgdGhlIGlucHV0IGludG8gdGhlIG1vZGVsXG4gICAgICAgICAgICAgICAgICBjb25zdCBmZWVkcyA9IHsgaW1hZ2VzOiBpbnB1dERhdGEgfTsgXG4gICAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBzZXNzaW9uLnJ1bihmZWVkcyk7XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vZXh0cmFjdCB0aGUgcHJlZGljdGlvbiBhbmQgY29uZmlkZW5jZSBmcm9tIHRoZSBvdXRwdXQgYW5kIGRyYXcgdGhlIHJlc3VsdHMgdG8gdGhlIGNuYXZhc1xuICAgICAgICAgICAgICAgICAgY29uc3QgZGV0ZWN0aW9ucyA9IHByb2Nlc3NEZXRlY3Rpb25zKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgZHJhd0RldGVjdGlvbihjYW52YXMuY3VycmVudCwgZGV0ZWN0aW9ucylcblxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBydW5uaW5nIGRldGVjdGlvbjonLCBlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gIFxuICAgICAgcnVuRGV0ZWN0aW9uKCk7XG4gIH0sIFtpbnB1dERhdGEsIG1vZGVsTG9hZGVkLCBzZXNzaW9uXSk7XG5cblxuICAvLyBFeHRyYWN0IHRoZSBvdXRwdXRzIG9mIHRoZSBtb2RlbCB0byBzb21ldGhpZ24gbWVhbmluZ2Z1bGxcbiAgZnVuY3Rpb24gcHJvY2Vzc0RldGVjdGlvbnMob3V0cHV0KSB7XG5cbiAgICAvL2V4dHJhY3QgdGhlIG91dHB1dFxuICAgIGNvbnN0IHNjb3JlcyA9IG91dHB1dC5zY29yZS5kYXRhOyAvLyBjb3JyZXNwb25kaW5nIGNvbmZpZGVuY2UgZm9yIHRoZSBjbGFzc2VzIGluIHRoZSBhYm92ZSBvdXRwdXRcbiAgICBjb25zdCBkZXRlY3Rpb25zID0gb3V0cHV0LmJhdGNobm9fY2xhc3NpZF94MXkxeDJ5Mi5kYXRhOyAvLyB3ZSBoYXZlIHRoZSBmb3JtYXQgWzAgY2xhc3NfbmFtZSB4MSB5MSB4MiB5Ml1cbiAgICBjb25zdCBmb3JtYXR0ZWREZXRlY3Rpb25zID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjb3Jlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzY29yZSA9IHNjb3Jlc1tpXTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpICogNjtcbiAgICAgICAgY29uc3QgYmF0Y2hJZCA9IGRldGVjdGlvbnNbaW5kZXhdO1xuICAgICAgICBjb25zdCBjbGFzc0lkID0gZGV0ZWN0aW9uc1tpbmRleCArIDFdO1xuICAgICAgICBjb25zdCBiYm94ID0ge1xuICAgICAgICAgICAgeDE6IGRldGVjdGlvbnNbaW5kZXggKyAyXSxcbiAgICAgICAgICAgIHkxOiBkZXRlY3Rpb25zW2luZGV4ICsgM10sXG4gICAgICAgICAgICB4MjogZGV0ZWN0aW9uc1tpbmRleCArIDRdLFxuICAgICAgICAgICAgeTI6IGRldGVjdGlvbnNbaW5kZXggKyA1XVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChzY29yZSA+IDAuNSkgeyAvLyBDb25maWRlbmNlIHRocmVzaG9sZFxuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gQ09DT19DTEFTU0VTW2NsYXNzSWRdOyAvL2ZpbmQgdGhlIGFjdHVhbCBjbGFzcyBuYW1lIHVzaW5nIHRoZSBjbGFzcyBpZFxuICAgICAgICAgICAgZm9ybWF0dGVkRGV0ZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBiYXRjaElkLFxuICAgICAgICAgICAgICAgIGNsYXNzSWQsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIGJib3gsXG4gICAgICAgICAgICAgICAgc2NvcmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXR0ZWREZXRlY3Rpb25zO1xufVxuXG5cblxuZnVuY3Rpb24gZHJhd0RldGVjdGlvbihjYW52YXMsIGRldGVjdGlvbnMpIHtcbiBcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7IC8vIENsZWFyIGNhbnZhc1xuXG4gICAgLy9leHRyYWN0IHRoZSBib3ggdmFsdWVzXG4gICAgY29uc3Qge3gxLCB5MSwgeDIsIHkyfSA9IGRldGVjdGlvbnNbMF0uYmJveDtcblxuICAgIGNvbnN0IHgxXyA9IE51bWJlcih4MSk7XG4gICAgY29uc3QgeTFfID0gTnVtYmVyKHkxKTtcbiAgICBjb25zdCB4Ml8gPSBOdW1iZXIoeDIpO1xuICAgIGNvbnN0IHkyXyA9IE51bWJlcih5Mik7XG5cbiAgICAvL3ByZXBhcmUgdGhlIHRleHQgKGNvbnRhaW5lcyB0aGUgY2xhc3MgbmFtZSBhbmQgdGhlIGNvbmZpZGFuY2UgcmF0ZSlcbiAgICBjb25zdCB0ZXh0ID0gYCR7ZGV0ZWN0aW9uc1swXS5jbGFzc05hbWV9ICgkeyhkZXRlY3Rpb25zWzBdLnNjb3JlICogMTAwKS50b0ZpeGVkKDEpfSUpYDtcblxuICAgIGNvbnNvbGUubG9nKFwiU0NPUkUgSVM6IFwiLCB0ZXh0KVxuICAgIHNldERldGVjdGlvbk1hZGUodHJ1ZSlcbiAgICBzZXRQcm9ncmVzcygxMDApXG5cbiAgICBkcmF3UmVjdChjdHgsIHgxXyx5MV8seDJfLHkyXyx0ZXh0LCBcIiNGRjAwMDBcIilcblxuICAgIFxufVxuXG5cbi8vdXNpbmcgdGhlIGluZnJvbWF0aW9uLCBkcmF3IGl0IGludG8gdGhlIGNhbnZhc1xuZnVuY3Rpb24gZHJhd1JlY3QoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCB3OiBudW1iZXIsIGg6IG51bWJlciwgdGV4dCA9IFwiXCIsIGNvbG9yID0gXCJyZWRcIikge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICBjdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIFxuICAgIGlmICh0ZXh0KSB7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICBjdHguZm9udCA9IFwiNDBweCBBcmlhbFwiO1xuICAgICAgY3R4LmZpbGxUZXh0KHRleHQsIHggKyAxNSwgeSArIDQ1KTtcbiAgICB9XG4gIH1cbiAgXG5cbi8vIENsYXNzZXMgdG8gZXh0cmFjdCB0aGUgYWN0dWFsIGNsYXNzIG5hbWUgaW4gdGhlIGdpdmVuIGlkIChmb2xsb3dpbmcgQ09DTyBjb252ZW50aW9uKVxuY29uc3QgQ09DT19DTEFTU0VTID0gW1xuICBcInBlcnNvblwiLCBcImJpY3ljbGVcIiwgXCJjYXJcIiwgXCJtb3RvcmN5Y2xlXCIsIFwiYWlycGxhbmVcIixcbiAgXCJidXNcIiwgXCJ0cmFpblwiLCBcInRydWNrXCIsIFwiYm9hdFwiLCBcInRyYWZmaWMgbGlnaHRcIixcbiAgXCJmaXJlIGh5ZHJhbnRcIiwgXCJzdG9wIHNpZ25cIiwgXCJwYXJraW5nIG1ldGVyXCIsIFwiYmVuY2hcIiwgXCJiaXJkXCIsXG4gIFwiY2F0XCIsIFwiZG9nXCIsIFwiaG9yc2VcIiwgXCJzaGVlcFwiLCBcImNvd1wiLFxuICBcImVsZXBoYW50XCIsIFwiYmVhclwiLCBcInplYnJhXCIsIFwiZ2lyYWZmZVwiLCBcImJhY2twYWNrXCIsXG4gIFwidW1icmVsbGFcIiwgXCJoYW5kYmFnXCIsIFwidGllXCIsIFwic3VpdGNhc2VcIiwgXCJmcmlzYmVlXCIsXG4gIFwic2tpc1wiLCBcInNub3dib2FyZFwiLCBcInNwb3J0cyBiYWxsXCIsIFwia2l0ZVwiLCBcImJhc2ViYWxsIGJhdFwiLFxuICBcImJhc2ViYWxsIGdsb3ZlXCIsIFwic2thdGVib2FyZFwiLCBcInN1cmZib2FyZFwiLCBcInRlbm5pcyByYWNrZXRcIiwgXCJib3R0bGVcIixcbiAgXCJ3aW5lIGdsYXNzXCIsIFwiY3VwXCIsIFwiZm9ya1wiLCBcImtuaWZlXCIsIFwic3Bvb25cIixcbiAgXCJib3dsXCIsIFwiYmFuYW5hXCIsIFwiYXBwbGVcIiwgXCJzYW5kd2ljaFwiLCBcIm9yYW5nZVwiLFxuICBcImJyb2Njb2xpXCIsIFwiY2Fycm90XCIsIFwiaG90IGRvZ1wiLCBcInBpenphXCIsIFwiZG9udXRcIixcbiAgXCJjYWtlXCIsIFwiY2hhaXJcIiwgXCJzb2ZhXCIsIFwicG90dGVkcGxhbnRcIiwgXCJiZWRcIixcbiAgXCJkaW5pbmd0YWJsZVwiLCBcInRvaWxldFwiLCBcInR2bW9uaXRvclwiLCBcImxhcHRvcFwiLCBcIm1vdXNlXCIsXG4gIFwicmVtb3RlXCIsIFwia2V5Ym9hcmRcIiwgXCJjZWxsIHBob25lXCIsIFwibWljcm93YXZlXCIsIFwib3ZlblwiLFxuICBcInRvYXN0ZXJcIiwgXCJzaW5rXCIsIFwicmVmcmlnZXJhdG9yXCIsIFwiYm9va1wiLCBcImNsb2NrXCIsXG4gIFwidmFzZVwiLCBcInNjaXNzb3JzXCIsIFwidGVkZHkgYmVhclwiLCBcImhhaXIgZHJpZXJcIiwgXCJ0b290aGJydXNoXCJcbl07XG5cbiAgICByZXR1cm4gPGgyPnttb2RlbExvYWRlZCA/IChkZXRlY3Rpb25NYWRlID8gXCJEZXRlY3Rpb24gaXMgbWFkZS4uLlwiOiAnTW9kZWwgbG9hZGVkLCBkZXRlY3Rpbmcgb2JqZWN0cy4uLicpIDogJ0xvYWRpbmcgbW9kZWwuLi4nfTwvaDI+O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgT2JqZWN0RGV0ZWN0aW9uO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJvcnQiLCJPYmplY3REZXRlY3Rpb24iLCJpbnB1dERhdGEiLCJjYW52YXMiLCJzZXRQcm9ncmVzcyIsInNlc3Npb24iLCJzZXRTZXNzaW9uIiwibW9kZWxMb2FkZWQiLCJzZXRNb2RlbExvYWRlZCIsImRldGVjdGlvbk1hZGUiLCJzZXREZXRlY3Rpb25NYWRlIiwibG9hZE1vZGVsIiwiZW52Iiwid2FzbSIsIndhc21QYXRocyIsIm1vZGVsUGF0aCIsImxvYWRlZFNlc3Npb24iLCJJbmZlcmVuY2VTZXNzaW9uIiwiY3JlYXRlIiwiZXJyb3IiLCJjb25zb2xlIiwicnVuRGV0ZWN0aW9uIiwibG9nIiwiZmVlZHMiLCJpbWFnZXMiLCJvdXRwdXQiLCJydW4iLCJkZXRlY3Rpb25zIiwicHJvY2Vzc0RldGVjdGlvbnMiLCJkcmF3RGV0ZWN0aW9uIiwiY3VycmVudCIsInNjb3JlcyIsInNjb3JlIiwiZGF0YSIsImJhdGNobm9fY2xhc3NpZF94MXkxeDJ5MiIsImZvcm1hdHRlZERldGVjdGlvbnMiLCJpIiwibGVuZ3RoIiwiaW5kZXgiLCJiYXRjaElkIiwiY2xhc3NJZCIsImJib3giLCJ4MSIsInkxIiwieDIiLCJ5MiIsImNsYXNzTmFtZSIsIkNPQ09fQ0xBU1NFUyIsInB1c2giLCJjdHgiLCJnZXRDb250ZXh0IiwiY2xlYXJSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJ4MV8iLCJOdW1iZXIiLCJ5MV8iLCJ4Ml8iLCJ5Ml8iLCJ0ZXh0IiwidG9GaXhlZCIsImRyYXdSZWN0IiwieCIsInkiLCJ3IiwiaCIsImNvbG9yIiwiYmVnaW5QYXRoIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJyZWN0Iiwic3Ryb2tlIiwiZmlsbFN0eWxlIiwiZm9udCIsImZpbGxUZXh0IiwiaDIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/components/ObjectDetection.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/components/ui/Button.tsx":
/*!******************************************!*\
  !*** ./src/app/components/ui/Button.tsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: function() { return /* binding */ Button; },\n/* harmony export */   buttonVariants: function() { return /* binding */ buttonVariants; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @radix-ui/react-slot */ \"(app-pages-browser)/./node_modules/@radix-ui/react-slot/dist/index.mjs\");\n/* harmony import */ var class_variance_authority__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! class-variance-authority */ \"(app-pages-browser)/./node_modules/class-variance-authority/dist/index.mjs\");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./src/lib/utils.ts\");\n\n\n\n\n\nconst buttonVariants = (0,class_variance_authority__WEBPACK_IMPORTED_MODULE_2__.cva)(\"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50\", {\n    variants: {\n        variant: {\n            default: \"bg-primary text-primary-foreground shadow hover:bg-primary/90\",\n            destructive: \"bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90\",\n            outline: \"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground\",\n            secondary: \"bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80\",\n            ghost: \"hover:bg-accent hover:text-accent-foreground\",\n            link: \"text-primary underline-offset-4 hover:underline\"\n        },\n        size: {\n            default: \"h-9 px-4 py-2\",\n            sm: \"h-8 rounded-md px-3 text-xs\",\n            lg: \"h-10 rounded-md px-8\",\n            icon: \"h-9 w-9\"\n        }\n    },\n    defaultVariants: {\n        variant: \"default\",\n        size: \"default\"\n    }\n});\nconst Button = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c = (param, ref)=>{\n    let { className, variant, size, asChild = false, ...props } = param;\n    const Comp = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_4__.Slot : \"button\";\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Comp, {\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.cn)(buttonVariants({\n            variant,\n            size,\n            className\n        })),\n        ref: ref,\n        ...props\n    }, void 0, false, {\n        fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/ui/Button.tsx\",\n        lineNumber: 47,\n        columnNumber: 7\n    }, undefined);\n});\n_c1 = Button;\nButton.displayName = \"Button\";\n\nvar _c, _c1;\n$RefreshReg$(_c, \"Button$React.forwardRef\");\n$RefreshReg$(_c1, \"Button\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcG9uZW50cy91aS9CdXR0b24udHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUE4QjtBQUNhO0FBQ3NCO0FBRWpDO0FBRWhDLE1BQU1JLGlCQUFpQkYsNkRBQUdBLENBQ3hCLHVPQUNBO0lBQ0VHLFVBQVU7UUFDUkMsU0FBUztZQUNQQyxTQUNFO1lBQ0ZDLGFBQ0U7WUFDRkMsU0FDRTtZQUNGQyxXQUNFO1lBQ0ZDLE9BQU87WUFDUEMsTUFBTTtRQUNSO1FBQ0FDLE1BQU07WUFDSk4sU0FBUztZQUNUTyxJQUFJO1lBQ0pDLElBQUk7WUFDSkMsTUFBTTtRQUNSO0lBQ0Y7SUFDQUMsaUJBQWlCO1FBQ2ZYLFNBQVM7UUFDVE8sTUFBTTtJQUNSO0FBQ0Y7QUFTRixNQUFNSyx1QkFBU2xCLDZDQUFnQixNQUM3QixRQUEwRG9CO1FBQXpELEVBQUVDLFNBQVMsRUFBRWYsT0FBTyxFQUFFTyxJQUFJLEVBQUVTLFVBQVUsS0FBSyxFQUFFLEdBQUdDLE9BQU87SUFDdEQsTUFBTUMsT0FBT0YsVUFBVXJCLHNEQUFJQSxHQUFHO0lBQzlCLHFCQUNFLDhEQUFDdUI7UUFDQ0gsV0FBV2xCLDhDQUFFQSxDQUFDQyxlQUFlO1lBQUVFO1lBQVNPO1lBQU1RO1FBQVU7UUFDeERELEtBQUtBO1FBQ0osR0FBR0csS0FBSzs7Ozs7O0FBR2Y7O0FBRUZMLE9BQU9PLFdBQVcsR0FBRztBQUVZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvY29tcG9uZW50cy91aS9CdXR0b24udHN4P2E2Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCJcbmltcG9ydCB7IFNsb3QgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXNsb3RcIlxuaW1wb3J0IHsgY3ZhLCB0eXBlIFZhcmlhbnRQcm9wcyB9IGZyb20gXCJjbGFzcy12YXJpYW5jZS1hdXRob3JpdHlcIlxuXG5pbXBvcnQgeyBjbiB9IGZyb20gXCJAL2xpYi91dGlsc1wiXG5cbmNvbnN0IGJ1dHRvblZhcmlhbnRzID0gY3ZhKFxuICBcImlubGluZS1mbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciB3aGl0ZXNwYWNlLW5vd3JhcCByb3VuZGVkLW1kIHRleHQtc20gZm9udC1tZWRpdW0gdHJhbnNpdGlvbi1jb2xvcnMgZm9jdXMtdmlzaWJsZTpvdXRsaW5lLW5vbmUgZm9jdXMtdmlzaWJsZTpyaW5nLTEgZm9jdXMtdmlzaWJsZTpyaW5nLXJpbmcgZGlzYWJsZWQ6cG9pbnRlci1ldmVudHMtbm9uZSBkaXNhYmxlZDpvcGFjaXR5LTUwXCIsXG4gIHtcbiAgICB2YXJpYW50czoge1xuICAgICAgdmFyaWFudDoge1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIFwiYmctcHJpbWFyeSB0ZXh0LXByaW1hcnktZm9yZWdyb3VuZCBzaGFkb3cgaG92ZXI6YmctcHJpbWFyeS85MFwiLFxuICAgICAgICBkZXN0cnVjdGl2ZTpcbiAgICAgICAgICBcImJnLWRlc3RydWN0aXZlIHRleHQtZGVzdHJ1Y3RpdmUtZm9yZWdyb3VuZCBzaGFkb3ctc20gaG92ZXI6YmctZGVzdHJ1Y3RpdmUvOTBcIixcbiAgICAgICAgb3V0bGluZTpcbiAgICAgICAgICBcImJvcmRlciBib3JkZXItaW5wdXQgYmctYmFja2dyb3VuZCBzaGFkb3ctc20gaG92ZXI6YmctYWNjZW50IGhvdmVyOnRleHQtYWNjZW50LWZvcmVncm91bmRcIixcbiAgICAgICAgc2Vjb25kYXJ5OlxuICAgICAgICAgIFwiYmctc2Vjb25kYXJ5IHRleHQtc2Vjb25kYXJ5LWZvcmVncm91bmQgc2hhZG93LXNtIGhvdmVyOmJnLXNlY29uZGFyeS84MFwiLFxuICAgICAgICBnaG9zdDogXCJob3ZlcjpiZy1hY2NlbnQgaG92ZXI6dGV4dC1hY2NlbnQtZm9yZWdyb3VuZFwiLFxuICAgICAgICBsaW5rOiBcInRleHQtcHJpbWFyeSB1bmRlcmxpbmUtb2Zmc2V0LTQgaG92ZXI6dW5kZXJsaW5lXCIsXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBkZWZhdWx0OiBcImgtOSBweC00IHB5LTJcIixcbiAgICAgICAgc206IFwiaC04IHJvdW5kZWQtbWQgcHgtMyB0ZXh0LXhzXCIsXG4gICAgICAgIGxnOiBcImgtMTAgcm91bmRlZC1tZCBweC04XCIsXG4gICAgICAgIGljb246IFwiaC05IHctOVwiLFxuICAgICAgfSxcbiAgICB9LFxuICAgIGRlZmF1bHRWYXJpYW50czoge1xuICAgICAgdmFyaWFudDogXCJkZWZhdWx0XCIsXG4gICAgICBzaXplOiBcImRlZmF1bHRcIixcbiAgICB9LFxuICB9XG4pXG5cbmV4cG9ydCBpbnRlcmZhY2UgQnV0dG9uUHJvcHNcbiAgZXh0ZW5kcyBSZWFjdC5CdXR0b25IVE1MQXR0cmlidXRlczxIVE1MQnV0dG9uRWxlbWVudD4sXG4gICAgVmFyaWFudFByb3BzPHR5cGVvZiBidXR0b25WYXJpYW50cz4ge1xuICBhc0NoaWxkPzogYm9vbGVhblxufVxuXG5jb25zdCBCdXR0b24gPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxCdXR0b25FbGVtZW50LCBCdXR0b25Qcm9wcz4oXG4gICh7IGNsYXNzTmFtZSwgdmFyaWFudCwgc2l6ZSwgYXNDaGlsZCA9IGZhbHNlLCAuLi5wcm9wcyB9LCByZWYpID0+IHtcbiAgICBjb25zdCBDb21wID0gYXNDaGlsZCA/IFNsb3QgOiBcImJ1dHRvblwiXG4gICAgcmV0dXJuIChcbiAgICAgIDxDb21wXG4gICAgICAgIGNsYXNzTmFtZT17Y24oYnV0dG9uVmFyaWFudHMoeyB2YXJpYW50LCBzaXplLCBjbGFzc05hbWUgfSkpfVxuICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgLz5cbiAgICApXG4gIH1cbilcbkJ1dHRvbi5kaXNwbGF5TmFtZSA9IFwiQnV0dG9uXCJcblxuZXhwb3J0IHsgQnV0dG9uLCBidXR0b25WYXJpYW50cyB9XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJTbG90IiwiY3ZhIiwiY24iLCJidXR0b25WYXJpYW50cyIsInZhcmlhbnRzIiwidmFyaWFudCIsImRlZmF1bHQiLCJkZXN0cnVjdGl2ZSIsIm91dGxpbmUiLCJzZWNvbmRhcnkiLCJnaG9zdCIsImxpbmsiLCJzaXplIiwic20iLCJsZyIsImljb24iLCJkZWZhdWx0VmFyaWFudHMiLCJCdXR0b24iLCJmb3J3YXJkUmVmIiwicmVmIiwiY2xhc3NOYW1lIiwiYXNDaGlsZCIsInByb3BzIiwiQ29tcCIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/components/ui/Button.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/components/ui/Card.tsx":
/*!****************************************!*\
  !*** ./src/app/components/ui/Card.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Card: function() { return /* binding */ Card; },\n/* harmony export */   CardContent: function() { return /* binding */ CardContent; },\n/* harmony export */   CardDescription: function() { return /* binding */ CardDescription; },\n/* harmony export */   CardFooter: function() { return /* binding */ CardFooter; },\n/* harmony export */   CardHeader: function() { return /* binding */ CardHeader; },\n/* harmony export */   CardTitle: function() { return /* binding */ CardTitle; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./src/lib/utils.ts\");\n\n\n\nconst Card = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c = (param, ref)=>{\n    let { className, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: ref,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"rounded-xl border bg-card text-card-foreground shadow\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/ui/Card.tsx\",\n        lineNumber: 9,\n        columnNumber: 3\n    }, undefined);\n});\n_c1 = Card;\nCard.displayName = \"Card\";\nconst CardHeader = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c2 = (param, ref)=>{\n    let { className, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: ref,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"flex flex-col space-y-1.5 p-6\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/ui/Card.tsx\",\n        lineNumber: 24,\n        columnNumber: 3\n    }, undefined);\n});\n_c3 = CardHeader;\nCardHeader.displayName = \"CardHeader\";\nconst CardTitle = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c4 = (param, ref)=>{\n    let { className, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n        ref: ref,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"font-semibold leading-none tracking-tight\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/ui/Card.tsx\",\n        lineNumber: 36,\n        columnNumber: 3\n    }, undefined);\n});\n_c5 = CardTitle;\nCardTitle.displayName = \"CardTitle\";\nconst CardDescription = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c6 = (param, ref)=>{\n    let { className, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n        ref: ref,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"text-sm text-muted-foreground\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/ui/Card.tsx\",\n        lineNumber: 48,\n        columnNumber: 3\n    }, undefined);\n});\n_c7 = CardDescription;\nCardDescription.displayName = \"CardDescription\";\nconst CardContent = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c8 = (param, ref)=>{\n    let { className, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: ref,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"p-6 pt-0\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/ui/Card.tsx\",\n        lineNumber: 60,\n        columnNumber: 3\n    }, undefined);\n});\n_c9 = CardContent;\nCardContent.displayName = \"CardContent\";\nconst CardFooter = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c10 = (param, ref)=>{\n    let { className, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: ref,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"flex items-center p-6 pt-0\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/ui/Card.tsx\",\n        lineNumber: 68,\n        columnNumber: 3\n    }, undefined);\n});\n_c11 = CardFooter;\nCardFooter.displayName = \"CardFooter\";\n\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11;\n$RefreshReg$(_c, \"Card$React.forwardRef\");\n$RefreshReg$(_c1, \"Card\");\n$RefreshReg$(_c2, \"CardHeader$React.forwardRef\");\n$RefreshReg$(_c3, \"CardHeader\");\n$RefreshReg$(_c4, \"CardTitle$React.forwardRef\");\n$RefreshReg$(_c5, \"CardTitle\");\n$RefreshReg$(_c6, \"CardDescription$React.forwardRef\");\n$RefreshReg$(_c7, \"CardDescription\");\n$RefreshReg$(_c8, \"CardContent$React.forwardRef\");\n$RefreshReg$(_c9, \"CardContent\");\n$RefreshReg$(_c10, \"CardFooter$React.forwardRef\");\n$RefreshReg$(_c11, \"CardFooter\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcG9uZW50cy91aS9DYXJkLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUE4QjtBQUVFO0FBRWhDLE1BQU1FLHFCQUFPRiw2Q0FBZ0IsTUFHM0IsUUFBMEJJO1FBQXpCLEVBQUVDLFNBQVMsRUFBRSxHQUFHQyxPQUFPO3lCQUN4Qiw4REFBQ0M7UUFDQ0gsS0FBS0E7UUFDTEMsV0FBV0osOENBQUVBLENBQ1gseURBQ0FJO1FBRUQsR0FBR0MsS0FBSzs7Ozs7Ozs7QUFHYkosS0FBS00sV0FBVyxHQUFHO0FBRW5CLE1BQU1DLDJCQUFhVCw2Q0FBZ0IsT0FHakMsUUFBMEJJO1FBQXpCLEVBQUVDLFNBQVMsRUFBRSxHQUFHQyxPQUFPO3lCQUN4Qiw4REFBQ0M7UUFDQ0gsS0FBS0E7UUFDTEMsV0FBV0osOENBQUVBLENBQUMsaUNBQWlDSTtRQUM5QyxHQUFHQyxLQUFLOzs7Ozs7OztBQUdiRyxXQUFXRCxXQUFXLEdBQUc7QUFFekIsTUFBTUUsMEJBQVlWLDZDQUFnQixPQUdoQyxRQUEwQkk7UUFBekIsRUFBRUMsU0FBUyxFQUFFLEdBQUdDLE9BQU87eUJBQ3hCLDhEQUFDSztRQUNDUCxLQUFLQTtRQUNMQyxXQUFXSiw4Q0FBRUEsQ0FBQyw2Q0FBNkNJO1FBQzFELEdBQUdDLEtBQUs7Ozs7Ozs7O0FBR2JJLFVBQVVGLFdBQVcsR0FBRztBQUV4QixNQUFNSSxnQ0FBa0JaLDZDQUFnQixPQUd0QyxRQUEwQkk7UUFBekIsRUFBRUMsU0FBUyxFQUFFLEdBQUdDLE9BQU87eUJBQ3hCLDhEQUFDTztRQUNDVCxLQUFLQTtRQUNMQyxXQUFXSiw4Q0FBRUEsQ0FBQyxpQ0FBaUNJO1FBQzlDLEdBQUdDLEtBQUs7Ozs7Ozs7O0FBR2JNLGdCQUFnQkosV0FBVyxHQUFHO0FBRTlCLE1BQU1NLDRCQUFjZCw2Q0FBZ0IsT0FHbEMsUUFBMEJJO1FBQXpCLEVBQUVDLFNBQVMsRUFBRSxHQUFHQyxPQUFPO3lCQUN4Qiw4REFBQ0M7UUFBSUgsS0FBS0E7UUFBS0MsV0FBV0osOENBQUVBLENBQUMsWUFBWUk7UUFBYSxHQUFHQyxLQUFLOzs7Ozs7OztBQUVoRVEsWUFBWU4sV0FBVyxHQUFHO0FBRTFCLE1BQU1PLDJCQUFhZiw2Q0FBZ0IsUUFHakMsUUFBMEJJO1FBQXpCLEVBQUVDLFNBQVMsRUFBRSxHQUFHQyxPQUFPO3lCQUN4Qiw4REFBQ0M7UUFDQ0gsS0FBS0E7UUFDTEMsV0FBV0osOENBQUVBLENBQUMsOEJBQThCSTtRQUMzQyxHQUFHQyxLQUFLOzs7Ozs7OztBQUdiUyxXQUFXUCxXQUFXLEdBQUc7QUFFdUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9jb21wb25lbnRzL3VpL0NhcmQudHN4PzI4NGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCJcblxuaW1wb3J0IHsgY24gfSBmcm9tIFwiQC9saWIvdXRpbHNcIlxuXG5jb25zdCBDYXJkID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgSFRNTERpdkVsZW1lbnQsXG4gIFJlYWN0LkhUTUxBdHRyaWJ1dGVzPEhUTUxEaXZFbGVtZW50PlxuPigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4gKFxuICA8ZGl2XG4gICAgcmVmPXtyZWZ9XG4gICAgY2xhc3NOYW1lPXtjbihcbiAgICAgIFwicm91bmRlZC14bCBib3JkZXIgYmctY2FyZCB0ZXh0LWNhcmQtZm9yZWdyb3VuZCBzaGFkb3dcIixcbiAgICAgIGNsYXNzTmFtZVxuICAgICl9XG4gICAgey4uLnByb3BzfVxuICAvPlxuKSlcbkNhcmQuZGlzcGxheU5hbWUgPSBcIkNhcmRcIlxuXG5jb25zdCBDYXJkSGVhZGVyID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgSFRNTERpdkVsZW1lbnQsXG4gIFJlYWN0LkhUTUxBdHRyaWJ1dGVzPEhUTUxEaXZFbGVtZW50PlxuPigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4gKFxuICA8ZGl2XG4gICAgcmVmPXtyZWZ9XG4gICAgY2xhc3NOYW1lPXtjbihcImZsZXggZmxleC1jb2wgc3BhY2UteS0xLjUgcC02XCIsIGNsYXNzTmFtZSl9XG4gICAgey4uLnByb3BzfVxuICAvPlxuKSlcbkNhcmRIZWFkZXIuZGlzcGxheU5hbWUgPSBcIkNhcmRIZWFkZXJcIlxuXG5jb25zdCBDYXJkVGl0bGUgPSBSZWFjdC5mb3J3YXJkUmVmPFxuICBIVE1MUGFyYWdyYXBoRWxlbWVudCxcbiAgUmVhY3QuSFRNTEF0dHJpYnV0ZXM8SFRNTEhlYWRpbmdFbGVtZW50PlxuPigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4gKFxuICA8aDNcbiAgICByZWY9e3JlZn1cbiAgICBjbGFzc05hbWU9e2NuKFwiZm9udC1zZW1pYm9sZCBsZWFkaW5nLW5vbmUgdHJhY2tpbmctdGlnaHRcIiwgY2xhc3NOYW1lKX1cbiAgICB7Li4ucHJvcHN9XG4gIC8+XG4pKVxuQ2FyZFRpdGxlLmRpc3BsYXlOYW1lID0gXCJDYXJkVGl0bGVcIlxuXG5jb25zdCBDYXJkRGVzY3JpcHRpb24gPSBSZWFjdC5mb3J3YXJkUmVmPFxuICBIVE1MUGFyYWdyYXBoRWxlbWVudCxcbiAgUmVhY3QuSFRNTEF0dHJpYnV0ZXM8SFRNTFBhcmFncmFwaEVsZW1lbnQ+XG4+KCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiAoXG4gIDxwXG4gICAgcmVmPXtyZWZ9XG4gICAgY2xhc3NOYW1lPXtjbihcInRleHQtc20gdGV4dC1tdXRlZC1mb3JlZ3JvdW5kXCIsIGNsYXNzTmFtZSl9XG4gICAgey4uLnByb3BzfVxuICAvPlxuKSlcbkNhcmREZXNjcmlwdGlvbi5kaXNwbGF5TmFtZSA9IFwiQ2FyZERlc2NyaXB0aW9uXCJcblxuY29uc3QgQ2FyZENvbnRlbnQgPSBSZWFjdC5mb3J3YXJkUmVmPFxuICBIVE1MRGl2RWxlbWVudCxcbiAgUmVhY3QuSFRNTEF0dHJpYnV0ZXM8SFRNTERpdkVsZW1lbnQ+XG4+KCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiAoXG4gIDxkaXYgcmVmPXtyZWZ9IGNsYXNzTmFtZT17Y24oXCJwLTYgcHQtMFwiLCBjbGFzc05hbWUpfSB7Li4ucHJvcHN9IC8+XG4pKVxuQ2FyZENvbnRlbnQuZGlzcGxheU5hbWUgPSBcIkNhcmRDb250ZW50XCJcblxuY29uc3QgQ2FyZEZvb3RlciA9IFJlYWN0LmZvcndhcmRSZWY8XG4gIEhUTUxEaXZFbGVtZW50LFxuICBSZWFjdC5IVE1MQXR0cmlidXRlczxIVE1MRGl2RWxlbWVudD5cbj4oKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IChcbiAgPGRpdlxuICAgIHJlZj17cmVmfVxuICAgIGNsYXNzTmFtZT17Y24oXCJmbGV4IGl0ZW1zLWNlbnRlciBwLTYgcHQtMFwiLCBjbGFzc05hbWUpfVxuICAgIHsuLi5wcm9wc31cbiAgLz5cbikpXG5DYXJkRm9vdGVyLmRpc3BsYXlOYW1lID0gXCJDYXJkRm9vdGVyXCJcblxuZXhwb3J0IHsgQ2FyZCwgQ2FyZEhlYWRlciwgQ2FyZEZvb3RlciwgQ2FyZFRpdGxlLCBDYXJkRGVzY3JpcHRpb24sIENhcmRDb250ZW50IH1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNuIiwiQ2FyZCIsImZvcndhcmRSZWYiLCJyZWYiLCJjbGFzc05hbWUiLCJwcm9wcyIsImRpdiIsImRpc3BsYXlOYW1lIiwiQ2FyZEhlYWRlciIsIkNhcmRUaXRsZSIsImgzIiwiQ2FyZERlc2NyaXB0aW9uIiwicCIsIkNhcmRDb250ZW50IiwiQ2FyZEZvb3RlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/components/ui/Card.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/components/ui/Progress.tsx":
/*!********************************************!*\
  !*** ./src/app/components/ui/Progress.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Progress: function() { return /* binding */ Progress; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _radix_ui_react_progress__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @radix-ui/react-progress */ \"(app-pages-browser)/./node_modules/@radix-ui/react-progress/dist/index.mjs\");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./src/lib/utils.ts\");\n/* __next_internal_client_entry_do_not_use__ Progress auto */ \n\n\n\nconst Progress = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c = (param, ref)=>{\n    let { className, value, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_radix_ui_react_progress__WEBPACK_IMPORTED_MODULE_3__.Root, {\n        ref: ref,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"relative h-2 w-full overflow-hidden rounded-full bg-primary/20\", className),\n        ...props,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_radix_ui_react_progress__WEBPACK_IMPORTED_MODULE_3__.Indicator, {\n            className: \"h-full w-full flex-1 bg-primary transition-all\",\n            style: {\n                transform: \"translateX(-\".concat(100 - (value || 0), \"%)\")\n            }\n        }, void 0, false, {\n            fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/ui/Progress.tsx\",\n            lineNumber: 20,\n            columnNumber: 5\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/idilatmaca/Desktop/uolu/YOLOv9-object-detection/app/src/app/components/ui/Progress.tsx\",\n        lineNumber: 12,\n        columnNumber: 3\n    }, undefined);\n});\n_c1 = Progress;\nProgress.displayName = _radix_ui_react_progress__WEBPACK_IMPORTED_MODULE_3__.Root.displayName;\n\nvar _c, _c1;\n$RefreshReg$(_c, \"Progress$React.forwardRef\");\n$RefreshReg$(_c1, \"Progress\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcG9uZW50cy91aS9Qcm9ncmVzcy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUU4QjtBQUMrQjtBQUU3QjtBQUVoQyxNQUFNRyx5QkFBV0gsNkNBQWdCLE1BRy9CLFFBQWlDSztRQUFoQyxFQUFFQyxTQUFTLEVBQUVDLEtBQUssRUFBRSxHQUFHQyxPQUFPO3lCQUMvQiw4REFBQ1AsMERBQXNCO1FBQ3JCSSxLQUFLQTtRQUNMQyxXQUFXSiw4Q0FBRUEsQ0FDWCxrRUFDQUk7UUFFRCxHQUFHRSxLQUFLO2tCQUVULDRFQUFDUCwrREFBMkI7WUFDMUJLLFdBQVU7WUFDVkssT0FBTztnQkFBRUMsV0FBVyxlQUFrQyxPQUFuQixNQUFPTCxDQUFBQSxTQUFTLElBQUc7WUFBSTs7Ozs7Ozs7Ozs7OztBQUloRUosU0FBU1UsV0FBVyxHQUFHWiwwREFBc0IsQ0FBQ1ksV0FBVztBQUV0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL2NvbXBvbmVudHMvdWkvUHJvZ3Jlc3MudHN4PzAzOWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCJcbmltcG9ydCAqIGFzIFByb2dyZXNzUHJpbWl0aXZlIGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcHJvZ3Jlc3NcIlxuXG5pbXBvcnQgeyBjbiB9IGZyb20gXCJAL2xpYi91dGlsc1wiXG5cbmNvbnN0IFByb2dyZXNzID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgUHJvZ3Jlc3NQcmltaXRpdmUuUm9vdD4sXG4gIFJlYWN0LkNvbXBvbmVudFByb3BzV2l0aG91dFJlZjx0eXBlb2YgUHJvZ3Jlc3NQcmltaXRpdmUuUm9vdD5cbj4oKHsgY2xhc3NOYW1lLCB2YWx1ZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiAoXG4gIDxQcm9ncmVzc1ByaW1pdGl2ZS5Sb290XG4gICAgcmVmPXtyZWZ9XG4gICAgY2xhc3NOYW1lPXtjbihcbiAgICAgIFwicmVsYXRpdmUgaC0yIHctZnVsbCBvdmVyZmxvdy1oaWRkZW4gcm91bmRlZC1mdWxsIGJnLXByaW1hcnkvMjBcIixcbiAgICAgIGNsYXNzTmFtZVxuICAgICl9XG4gICAgey4uLnByb3BzfVxuICA+XG4gICAgPFByb2dyZXNzUHJpbWl0aXZlLkluZGljYXRvclxuICAgICAgY2xhc3NOYW1lPVwiaC1mdWxsIHctZnVsbCBmbGV4LTEgYmctcHJpbWFyeSB0cmFuc2l0aW9uLWFsbFwiXG4gICAgICBzdHlsZT17eyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKC0kezEwMCAtICh2YWx1ZSB8fCAwKX0lKWAgfX1cbiAgICAvPlxuICA8L1Byb2dyZXNzUHJpbWl0aXZlLlJvb3Q+XG4pKVxuUHJvZ3Jlc3MuZGlzcGxheU5hbWUgPSBQcm9ncmVzc1ByaW1pdGl2ZS5Sb290LmRpc3BsYXlOYW1lXG5cbmV4cG9ydCB7IFByb2dyZXNzIH1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlByb2dyZXNzUHJpbWl0aXZlIiwiY24iLCJQcm9ncmVzcyIsImZvcndhcmRSZWYiLCJyZWYiLCJjbGFzc05hbWUiLCJ2YWx1ZSIsInByb3BzIiwiUm9vdCIsIkluZGljYXRvciIsInN0eWxlIiwidHJhbnNmb3JtIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/components/ui/Progress.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/utils.ts":
/*!**************************!*\
  !*** ./src/lib/utils.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cn: function() { return /* binding */ cn; }\n/* harmony export */ });\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var tailwind_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tailwind-merge */ \"(app-pages-browser)/./node_modules/tailwind-merge/dist/bundle-mjs.mjs\");\n\n\nfunction cn() {\n    for(var _len = arguments.length, inputs = new Array(_len), _key = 0; _key < _len; _key++){\n        inputs[_key] = arguments[_key];\n    }\n    return (0,tailwind_merge__WEBPACK_IMPORTED_MODULE_1__.twMerge)((0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(inputs));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRDO0FBQ0o7QUFFakMsU0FBU0U7SUFBRztRQUFHQyxPQUFILHVCQUF1Qjs7SUFDeEMsT0FBT0YsdURBQU9BLENBQUNELDBDQUFJQSxDQUFDRztBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3V0aWxzLnRzPzdjMWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdHlwZSBDbGFzc1ZhbHVlLCBjbHN4IH0gZnJvbSBcImNsc3hcIlxuaW1wb3J0IHsgdHdNZXJnZSB9IGZyb20gXCJ0YWlsd2luZC1tZXJnZVwiXG5cbmV4cG9ydCBmdW5jdGlvbiBjbiguLi5pbnB1dHM6IENsYXNzVmFsdWVbXSkge1xuICByZXR1cm4gdHdNZXJnZShjbHN4KGlucHV0cykpXG59XG4iXSwibmFtZXMiOlsiY2xzeCIsInR3TWVyZ2UiLCJjbiIsImlucHV0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/utils.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz8xMjBjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/YTlmMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _extends; }\n/* harmony export */ });\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzP2M2ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@radix-ui/react-compose-refs/dist/index.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@radix-ui/react-compose-refs/dist/index.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   composeRefs: function() { return /* binding */ $6ed0406888f73fc4$export$43e446d32b3d21af; },\n/* harmony export */   useComposedRefs: function() { return /* binding */ $6ed0406888f73fc4$export$c7b2cbe3552a0d05; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */ function $6ed0406888f73fc4$var$setRef(ref, value) {\n    if (typeof ref === 'function') ref(value);\n    else if (ref !== null && ref !== undefined) ref.current = value;\n}\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */ function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {\n    return (node)=>refs.forEach((ref)=>$6ed0406888f73fc4$var$setRef(ref, node)\n        )\n    ;\n}\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */ function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af(...refs), refs);\n}\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtY29tcG9zZS1yZWZzL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3RDs7O0FBR3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtEQUFrQjtBQUM3Qjs7Ozs7QUFLZ0k7QUFDaEkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1jb21wb3NlLXJlZnMvZGlzdC9pbmRleC5tanM/NGNhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZUNhbGxiYWNrIGFzICQzdnFtciR1c2VDYWxsYmFja30gZnJvbSBcInJlYWN0XCI7XG5cblxuLyoqXG4gKiBTZXQgYSBnaXZlbiByZWYgdG8gYSBnaXZlbiB2YWx1ZVxuICogVGhpcyB1dGlsaXR5IHRha2VzIGNhcmUgb2YgZGlmZmVyZW50IHR5cGVzIG9mIHJlZnM6IGNhbGxiYWNrIHJlZnMgYW5kIFJlZk9iamVjdChzKVxuICovIGZ1bmN0aW9uICQ2ZWQwNDA2ODg4ZjczZmM0JHZhciRzZXRSZWYocmVmLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSByZWYodmFsdWUpO1xuICAgIGVsc2UgaWYgKHJlZiAhPT0gbnVsbCAmJiByZWYgIT09IHVuZGVmaW5lZCkgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbn1cbi8qKlxuICogQSB1dGlsaXR5IHRvIGNvbXBvc2UgbXVsdGlwbGUgcmVmcyB0b2dldGhlclxuICogQWNjZXB0cyBjYWxsYmFjayByZWZzIGFuZCBSZWZPYmplY3QocylcbiAqLyBmdW5jdGlvbiAkNmVkMDQwNjg4OGY3M2ZjNCRleHBvcnQkNDNlNDQ2ZDMyYjNkMjFhZiguLi5yZWZzKSB7XG4gICAgcmV0dXJuIChub2RlKT0+cmVmcy5mb3JFYWNoKChyZWYpPT4kNmVkMDQwNjg4OGY3M2ZjNCR2YXIkc2V0UmVmKHJlZiwgbm9kZSlcbiAgICAgICAgKVxuICAgIDtcbn1cbi8qKlxuICogQSBjdXN0b20gaG9vayB0aGF0IGNvbXBvc2VzIG11bHRpcGxlIHJlZnNcbiAqIEFjY2VwdHMgY2FsbGJhY2sgcmVmcyBhbmQgUmVmT2JqZWN0KHMpXG4gKi8gZnVuY3Rpb24gJDZlZDA0MDY4ODhmNzNmYzQkZXhwb3J0JGM3YjJjYmUzNTUyYTBkMDUoLi4ucmVmcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICByZXR1cm4gJDN2cW1yJHVzZUNhbGxiYWNrKCQ2ZWQwNDA2ODg4ZjczZmM0JGV4cG9ydCQ0M2U0NDZkMzJiM2QyMWFmKC4uLnJlZnMpLCByZWZzKTtcbn1cblxuXG5cblxuZXhwb3J0IHskNmVkMDQwNjg4OGY3M2ZjNCRleHBvcnQkNDNlNDQ2ZDMyYjNkMjFhZiBhcyBjb21wb3NlUmVmcywgJDZlZDA0MDY4ODhmNzNmYzQkZXhwb3J0JGM3YjJjYmUzNTUyYTBkMDUgYXMgdXNlQ29tcG9zZWRSZWZzfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@radix-ui/react-compose-refs/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@radix-ui/react-context/dist/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@radix-ui/react-context/dist/index.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createContext: function() { return /* binding */ $c512c27ab02ef895$export$fd42f52fd3ae1109; },\n/* harmony export */   createContextScope: function() { return /* binding */ $c512c27ab02ef895$export$50c7b4e9d9f19c1; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\n\nfunction $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {\n    const Context = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultContext);\n    function Provider(props) {\n        const { children: children , ...context } = props; // Only re-memoize when prop values change\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>context\n        , Object.values(context));\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Context.Provider, {\n            value: value\n        }, children);\n    }\n    function useContext(consumerName) {\n        const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n        if (context) return context;\n        if (defaultContext !== undefined) return defaultContext; // if a defaultContext wasn't specified, it's a required context.\n        throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n    }\n    Provider.displayName = rootComponentName + 'Provider';\n    return [\n        Provider,\n        useContext\n    ];\n}\n/* -------------------------------------------------------------------------------------------------\n * createContextScope\n * -----------------------------------------------------------------------------------------------*/ function $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {\n    let defaultContexts = [];\n    /* -----------------------------------------------------------------------------------------------\n   * createContext\n   * ---------------------------------------------------------------------------------------------*/ function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {\n        const BaseContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultContext);\n        const index = defaultContexts.length;\n        defaultContexts = [\n            ...defaultContexts,\n            defaultContext\n        ];\n        function Provider(props) {\n            const { scope: scope , children: children , ...context } = props;\n            const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index]) || BaseContext; // Only re-memoize when prop values change\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n            const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>context\n            , Object.values(context));\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Context.Provider, {\n                value: value\n            }, children);\n        }\n        function useContext(consumerName, scope) {\n            const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index]) || BaseContext;\n            const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n            if (context) return context;\n            if (defaultContext !== undefined) return defaultContext; // if a defaultContext wasn't specified, it's a required context.\n            throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n        }\n        Provider.displayName = rootComponentName + 'Provider';\n        return [\n            Provider,\n            useContext\n        ];\n    }\n    /* -----------------------------------------------------------------------------------------------\n   * createScope\n   * ---------------------------------------------------------------------------------------------*/ const createScope = ()=>{\n        const scopeContexts = defaultContexts.map((defaultContext)=>{\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultContext);\n        });\n        return function useScope(scope) {\n            const contexts = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;\n            return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                    [`__scope${scopeName}`]: {\n                        ...scope,\n                        [scopeName]: contexts\n                    }\n                })\n            , [\n                scope,\n                contexts\n            ]);\n        };\n    };\n    createScope.scopeName = scopeName;\n    return [\n        $c512c27ab02ef895$export$fd42f52fd3ae1109,\n        $c512c27ab02ef895$var$composeContextScopes(createScope, ...createContextScopeDeps)\n    ];\n}\n/* -------------------------------------------------------------------------------------------------\n * composeContextScopes\n * -----------------------------------------------------------------------------------------------*/ function $c512c27ab02ef895$var$composeContextScopes(...scopes) {\n    const baseScope = scopes[0];\n    if (scopes.length === 1) return baseScope;\n    const createScope1 = ()=>{\n        const scopeHooks = scopes.map((createScope)=>({\n                useScope: createScope(),\n                scopeName: createScope.scopeName\n            })\n        );\n        return function useComposedScopes(overrideScopes) {\n            const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope: useScope , scopeName: scopeName  })=>{\n                // We are calling a hook inside a callback which React warns against to avoid inconsistent\n                // renders, however, scoping doesn't have render side effects so we ignore the rule.\n                // eslint-disable-next-line react-hooks/rules-of-hooks\n                const scopeProps = useScope(overrideScopes);\n                const currentScope = scopeProps[`__scope${scopeName}`];\n                return {\n                    ...nextScopes,\n                    ...currentScope\n                };\n            }, {});\n            return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                    [`__scope${baseScope.scopeName}`]: nextScopes1\n                })\n            , [\n                nextScopes1\n            ]);\n        };\n    };\n    createScope1.scopeName = baseScope.scopeName;\n    return createScope1;\n}\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtY29udGV4dC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0o7OztBQUcvSjtBQUNBLGtDQUFrQyxvREFBb0I7QUFDdEQ7QUFDQSxnQkFBZ0Isa0NBQWtDLFNBQVM7QUFDM0Q7QUFDQSxzQkFBc0IsOENBQWM7QUFDcEM7QUFDQSw2QkFBNkIsb0RBQW9CO0FBQ2pEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0IsaURBQWlCO0FBQ3pDO0FBQ0EsaUVBQWlFO0FBQ2pFLDZCQUE2QixhQUFhLDJCQUEyQixrQkFBa0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvREFBb0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlEQUFpRDtBQUNyRSxvSEFBb0g7QUFDcEg7QUFDQSwwQkFBMEIsOENBQWM7QUFDeEM7QUFDQSxpQ0FBaUMsb0RBQW9CO0FBQ3JEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpREFBaUI7QUFDN0M7QUFDQSxxRUFBcUU7QUFDckUsaUNBQWlDLGFBQWEsMkJBQTJCLGtCQUFrQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9EQUFvQjtBQUNyRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBYztBQUNqQywrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpRUFBaUUsNENBQTRDO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFVBQVU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakIsbUJBQW1CLDhDQUFjO0FBQ2pDLCtCQUErQixvQkFBb0I7QUFDbkQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS29JO0FBQ3BJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtY29udGV4dC9kaXN0L2luZGV4Lm1qcz85ZWY3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y3JlYXRlQ29udGV4dCBhcyAkM2JrQUskY3JlYXRlQ29udGV4dCwgdXNlTWVtbyBhcyAkM2JrQUskdXNlTWVtbywgY3JlYXRlRWxlbWVudCBhcyAkM2JrQUskY3JlYXRlRWxlbWVudCwgdXNlQ29udGV4dCBhcyAkM2JrQUskdXNlQ29udGV4dH0gZnJvbSBcInJlYWN0XCI7XG5cblxuZnVuY3Rpb24gJGM1MTJjMjdhYjAyZWY4OTUkZXhwb3J0JGZkNDJmNTJmZDNhZTExMDkocm9vdENvbXBvbmVudE5hbWUsIGRlZmF1bHRDb250ZXh0KSB7XG4gICAgY29uc3QgQ29udGV4dCA9IC8qI19fUFVSRV9fKi8gJDNia0FLJGNyZWF0ZUNvbnRleHQoZGVmYXVsdENvbnRleHQpO1xuICAgIGZ1bmN0aW9uIFByb3ZpZGVyKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IGNoaWxkcmVuICwgLi4uY29udGV4dCB9ID0gcHJvcHM7IC8vIE9ubHkgcmUtbWVtb2l6ZSB3aGVuIHByb3AgdmFsdWVzIGNoYW5nZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgIGNvbnN0IHZhbHVlID0gJDNia0FLJHVzZU1lbW8oKCk9PmNvbnRleHRcbiAgICAgICAgLCBPYmplY3QudmFsdWVzKGNvbnRleHQpKTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gJDNia0FLJGNyZWF0ZUVsZW1lbnQoQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlQ29udGV4dChjb25zdW1lck5hbWUpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9ICQzYmtBSyR1c2VDb250ZXh0KENvbnRleHQpO1xuICAgICAgICBpZiAoY29udGV4dCkgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgIGlmIChkZWZhdWx0Q29udGV4dCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZGVmYXVsdENvbnRleHQ7IC8vIGlmIGEgZGVmYXVsdENvbnRleHQgd2Fzbid0IHNwZWNpZmllZCwgaXQncyBhIHJlcXVpcmVkIGNvbnRleHQuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgJHtjb25zdW1lck5hbWV9XFxgIG11c3QgYmUgdXNlZCB3aXRoaW4gXFxgJHtyb290Q29tcG9uZW50TmFtZX1cXGBgKTtcbiAgICB9XG4gICAgUHJvdmlkZXIuZGlzcGxheU5hbWUgPSByb290Q29tcG9uZW50TmFtZSArICdQcm92aWRlcic7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgUHJvdmlkZXIsXG4gICAgICAgIHVzZUNvbnRleHRcbiAgICBdO1xufVxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogY3JlYXRlQ29udGV4dFNjb3BlXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovIGZ1bmN0aW9uICRjNTEyYzI3YWIwMmVmODk1JGV4cG9ydCQ1MGM3YjRlOWQ5ZjE5YzEoc2NvcGVOYW1lLCBjcmVhdGVDb250ZXh0U2NvcGVEZXBzID0gW10pIHtcbiAgICBsZXQgZGVmYXVsdENvbnRleHRzID0gW107XG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogY3JlYXRlQ29udGV4dFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLyBmdW5jdGlvbiAkYzUxMmMyN2FiMDJlZjg5NSRleHBvcnQkZmQ0MmY1MmZkM2FlMTEwOShyb290Q29tcG9uZW50TmFtZSwgZGVmYXVsdENvbnRleHQpIHtcbiAgICAgICAgY29uc3QgQmFzZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovICQzYmtBSyRjcmVhdGVDb250ZXh0KGRlZmF1bHRDb250ZXh0KTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBkZWZhdWx0Q29udGV4dHMubGVuZ3RoO1xuICAgICAgICBkZWZhdWx0Q29udGV4dHMgPSBbXG4gICAgICAgICAgICAuLi5kZWZhdWx0Q29udGV4dHMsXG4gICAgICAgICAgICBkZWZhdWx0Q29udGV4dFxuICAgICAgICBdO1xuICAgICAgICBmdW5jdGlvbiBQcm92aWRlcihwcm9wcykge1xuICAgICAgICAgICAgY29uc3QgeyBzY29wZTogc2NvcGUgLCBjaGlsZHJlbjogY2hpbGRyZW4gLCAuLi5jb250ZXh0IH0gPSBwcm9wcztcbiAgICAgICAgICAgIGNvbnN0IENvbnRleHQgPSAoc2NvcGUgPT09IG51bGwgfHwgc2NvcGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjb3BlW3Njb3BlTmFtZV1baW5kZXhdKSB8fCBCYXNlQ29udGV4dDsgLy8gT25seSByZS1tZW1vaXplIHdoZW4gcHJvcCB2YWx1ZXMgY2hhbmdlXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9ICQzYmtBSyR1c2VNZW1vKCgpPT5jb250ZXh0XG4gICAgICAgICAgICAsIE9iamVjdC52YWx1ZXMoY29udGV4dCkpO1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gJDNia0FLJGNyZWF0ZUVsZW1lbnQoQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSwgY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVzZUNvbnRleHQoY29uc3VtZXJOYW1lLCBzY29wZSkge1xuICAgICAgICAgICAgY29uc3QgQ29udGV4dCA9IChzY29wZSA9PT0gbnVsbCB8fCBzY29wZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NvcGVbc2NvcGVOYW1lXVtpbmRleF0pIHx8IEJhc2VDb250ZXh0O1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9ICQzYmtBSyR1c2VDb250ZXh0KENvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQpIHJldHVybiBjb250ZXh0O1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRDb250ZXh0ICE9PSB1bmRlZmluZWQpIHJldHVybiBkZWZhdWx0Q29udGV4dDsgLy8gaWYgYSBkZWZhdWx0Q29udGV4dCB3YXNuJ3Qgc3BlY2lmaWVkLCBpdCdzIGEgcmVxdWlyZWQgY29udGV4dC5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgJHtjb25zdW1lck5hbWV9XFxgIG11c3QgYmUgdXNlZCB3aXRoaW4gXFxgJHtyb290Q29tcG9uZW50TmFtZX1cXGBgKTtcbiAgICAgICAgfVxuICAgICAgICBQcm92aWRlci5kaXNwbGF5TmFtZSA9IHJvb3RDb21wb25lbnROYW1lICsgJ1Byb3ZpZGVyJztcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFByb3ZpZGVyLFxuICAgICAgICAgICAgdXNlQ29udGV4dFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBjcmVhdGVTY29wZVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLyBjb25zdCBjcmVhdGVTY29wZSA9ICgpPT57XG4gICAgICAgIGNvbnN0IHNjb3BlQ29udGV4dHMgPSBkZWZhdWx0Q29udGV4dHMubWFwKChkZWZhdWx0Q29udGV4dCk9PntcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovICQzYmtBSyRjcmVhdGVDb250ZXh0KGRlZmF1bHRDb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB1c2VTY29wZShzY29wZSkge1xuICAgICAgICAgICAgY29uc3QgY29udGV4dHMgPSAoc2NvcGUgPT09IG51bGwgfHwgc2NvcGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjb3BlW3Njb3BlTmFtZV0pIHx8IHNjb3BlQ29udGV4dHM7XG4gICAgICAgICAgICByZXR1cm4gJDNia0FLJHVzZU1lbW8oKCk9Pih7XG4gICAgICAgICAgICAgICAgICAgIFtgX19zY29wZSR7c2NvcGVOYW1lfWBdOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zY29wZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzY29wZU5hbWVdOiBjb250ZXh0c1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICwgW1xuICAgICAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgICAgIGNvbnRleHRzXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNyZWF0ZVNjb3BlLnNjb3BlTmFtZSA9IHNjb3BlTmFtZTtcbiAgICByZXR1cm4gW1xuICAgICAgICAkYzUxMmMyN2FiMDJlZjg5NSRleHBvcnQkZmQ0MmY1MmZkM2FlMTEwOSxcbiAgICAgICAgJGM1MTJjMjdhYjAyZWY4OTUkdmFyJGNvbXBvc2VDb250ZXh0U2NvcGVzKGNyZWF0ZVNjb3BlLCAuLi5jcmVhdGVDb250ZXh0U2NvcGVEZXBzKVxuICAgIF07XG59XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBjb21wb3NlQ29udGV4dFNjb3Blc1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLyBmdW5jdGlvbiAkYzUxMmMyN2FiMDJlZjg5NSR2YXIkY29tcG9zZUNvbnRleHRTY29wZXMoLi4uc2NvcGVzKSB7XG4gICAgY29uc3QgYmFzZVNjb3BlID0gc2NvcGVzWzBdO1xuICAgIGlmIChzY29wZXMubGVuZ3RoID09PSAxKSByZXR1cm4gYmFzZVNjb3BlO1xuICAgIGNvbnN0IGNyZWF0ZVNjb3BlMSA9ICgpPT57XG4gICAgICAgIGNvbnN0IHNjb3BlSG9va3MgPSBzY29wZXMubWFwKChjcmVhdGVTY29wZSk9Pih7XG4gICAgICAgICAgICAgICAgdXNlU2NvcGU6IGNyZWF0ZVNjb3BlKCksXG4gICAgICAgICAgICAgICAgc2NvcGVOYW1lOiBjcmVhdGVTY29wZS5zY29wZU5hbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB1c2VDb21wb3NlZFNjb3BlcyhvdmVycmlkZVNjb3Blcykge1xuICAgICAgICAgICAgY29uc3QgbmV4dFNjb3BlczEgPSBzY29wZUhvb2tzLnJlZHVjZSgobmV4dFNjb3BlcywgeyB1c2VTY29wZTogdXNlU2NvcGUgLCBzY29wZU5hbWU6IHNjb3BlTmFtZSAgfSk9PntcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgY2FsbGluZyBhIGhvb2sgaW5zaWRlIGEgY2FsbGJhY2sgd2hpY2ggUmVhY3Qgd2FybnMgYWdhaW5zdCB0byBhdm9pZCBpbmNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJzLCBob3dldmVyLCBzY29waW5nIGRvZXNuJ3QgaGF2ZSByZW5kZXIgc2lkZSBlZmZlY3RzIHNvIHdlIGlnbm9yZSB0aGUgcnVsZS5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgICAgICAgICBjb25zdCBzY29wZVByb3BzID0gdXNlU2NvcGUob3ZlcnJpZGVTY29wZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTY29wZSA9IHNjb3BlUHJvcHNbYF9fc2NvcGUke3Njb3BlTmFtZX1gXTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5uZXh0U2NvcGVzLFxuICAgICAgICAgICAgICAgICAgICAuLi5jdXJyZW50U2NvcGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgcmV0dXJuICQzYmtBSyR1c2VNZW1vKCgpPT4oe1xuICAgICAgICAgICAgICAgICAgICBbYF9fc2NvcGUke2Jhc2VTY29wZS5zY29wZU5hbWV9YF06IG5leHRTY29wZXMxXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICwgW1xuICAgICAgICAgICAgICAgIG5leHRTY29wZXMxXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNyZWF0ZVNjb3BlMS5zY29wZU5hbWUgPSBiYXNlU2NvcGUuc2NvcGVOYW1lO1xuICAgIHJldHVybiBjcmVhdGVTY29wZTE7XG59XG5cblxuXG5cbmV4cG9ydCB7JGM1MTJjMjdhYjAyZWY4OTUkZXhwb3J0JGZkNDJmNTJmZDNhZTExMDkgYXMgY3JlYXRlQ29udGV4dCwgJGM1MTJjMjdhYjAyZWY4OTUkZXhwb3J0JDUwYzdiNGU5ZDlmMTljMSBhcyBjcmVhdGVDb250ZXh0U2NvcGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@radix-ui/react-context/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@radix-ui/react-primitive/dist/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@radix-ui/react-primitive/dist/index.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Primitive: function() { return /* binding */ $8927f6f2acc4f386$export$250ffa63cdc0d034; },\n/* harmony export */   Root: function() { return /* binding */ $8927f6f2acc4f386$export$be92b6f5f03c0fe9; },\n/* harmony export */   dispatchDiscreteCustomEvent: function() { return /* binding */ $8927f6f2acc4f386$export$6d1a0317bde7de7f; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @radix-ui/react-slot */ \"(app-pages-browser)/./node_modules/@radix-ui/react-slot/dist/index.mjs\");\n\n\n\n\n\n\n\n\n\nconst $8927f6f2acc4f386$var$NODES = [\n    'a',\n    'button',\n    'div',\n    'form',\n    'h2',\n    'h3',\n    'img',\n    'input',\n    'label',\n    'li',\n    'nav',\n    'ol',\n    'p',\n    'span',\n    'svg',\n    'ul'\n]; // Temporary while we await merge of this fix:\n// https://github.com/DefinitelyTyped/DefinitelyTyped/pull/55396\n// prettier-ignore\n/* -------------------------------------------------------------------------------------------------\n * Primitive\n * -----------------------------------------------------------------------------------------------*/ const $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce((primitive, node)=>{\n    const Node = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, forwardedRef)=>{\n        const { asChild: asChild , ...primitiveProps } = props;\n        const Comp = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_3__.Slot : node;\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n            window[Symbol.for('radix-ui')] = true;\n        }, []);\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(Comp, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, primitiveProps, {\n            ref: forwardedRef\n        }));\n    });\n    Node.displayName = `Primitive.${node}`;\n    return {\n        ...primitive,\n        [node]: Node\n    };\n}, {});\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/ /**\n * Flush custom event dispatch\n * https://github.com/radix-ui/primitives/pull/1378\n *\n * React batches *all* event handlers since version 18, this introduces certain considerations when using custom event types.\n *\n * Internally, React prioritises events in the following order:\n *  - discrete\n *  - continuous\n *  - default\n *\n * https://github.com/facebook/react/blob/a8a4742f1c54493df00da648a3f9d26e3db9c8b5/packages/react-dom/src/events/ReactDOMEventListener.js#L294-L350\n *\n * `discrete` is an  important distinction as updates within these events are applied immediately.\n * React however, is not able to infer the priority of custom event types due to how they are detected internally.\n * Because of this, it's possible for updates from custom events to be unexpectedly batched when\n * dispatched by another `discrete` event.\n *\n * In order to ensure that updates from custom events are applied predictably, we need to manually flush the batch.\n * This utility should be used when dispatching a custom event from within another `discrete` event, this utility\n * is not nessesary when dispatching known event types, or if dispatching a custom type inside a non-discrete event.\n * For example:\n *\n * dispatching a known click 👎\n * target.dispatchEvent(new Event(‘click’))\n *\n * dispatching a custom type within a non-discrete event 👎\n * onScroll={(event) => event.target.dispatchEvent(new CustomEvent(‘customType’))}\n *\n * dispatching a custom type within a `discrete` event 👍\n * onPointerDown={(event) => dispatchDiscreteCustomEvent(event.target, new CustomEvent(‘customType’))}\n *\n * Note: though React classifies `focus`, `focusin` and `focusout` events as `discrete`, it's  not recommended to use\n * this utility with them. This is because it's possible for those handlers to be called implicitly during render\n * e.g. when focus is within a component as it is unmounted, or when managing focus on mount.\n */ function $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event) {\n    if (target) (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync)(()=>target.dispatchEvent(event)\n    );\n}\n/* -----------------------------------------------------------------------------------------------*/ const $8927f6f2acc4f386$export$be92b6f5f03c0fe9 = $8927f6f2acc4f386$export$250ffa63cdc0d034;\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBc0Y7QUFDc0M7QUFDcEU7QUFDQzs7Ozs7O0FBTXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpREFBaUI7QUFDaEQsZ0JBQWdCLHVDQUF1QztBQUN2RCwrQkFBK0Isc0RBQVc7QUFDMUMsUUFBUSxnREFBZ0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1QsNkJBQTZCLG9EQUFvQixPQUFPLDhFQUFvQyxHQUFHO0FBQy9GO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxvQ0FBb0MsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9EQUFnQjtBQUNoQztBQUNBO0FBQ0E7Ozs7O0FBSzZMO0FBQzdMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlL2Rpc3QvaW5kZXgubWpzPzljNmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICQ0cTVGcSRiYWJlbHJ1bnRpbWVoZWxwZXJzZXNtZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IHtmb3J3YXJkUmVmIGFzICQ0cTVGcSRmb3J3YXJkUmVmLCB1c2VFZmZlY3QgYXMgJDRxNUZxJHVzZUVmZmVjdCwgY3JlYXRlRWxlbWVudCBhcyAkNHE1RnEkY3JlYXRlRWxlbWVudH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge2ZsdXNoU3luYyBhcyAkNHE1RnEkZmx1c2hTeW5jfSBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQge1Nsb3QgYXMgJDRxNUZxJFNsb3R9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3Qtc2xvdFwiO1xuXG5cblxuXG5cbmNvbnN0ICQ4OTI3ZjZmMmFjYzRmMzg2JHZhciROT0RFUyA9IFtcbiAgICAnYScsXG4gICAgJ2J1dHRvbicsXG4gICAgJ2RpdicsXG4gICAgJ2Zvcm0nLFxuICAgICdoMicsXG4gICAgJ2gzJyxcbiAgICAnaW1nJyxcbiAgICAnaW5wdXQnLFxuICAgICdsYWJlbCcsXG4gICAgJ2xpJyxcbiAgICAnbmF2JyxcbiAgICAnb2wnLFxuICAgICdwJyxcbiAgICAnc3BhbicsXG4gICAgJ3N2ZycsXG4gICAgJ3VsJ1xuXTsgLy8gVGVtcG9yYXJ5IHdoaWxlIHdlIGF3YWl0IG1lcmdlIG9mIHRoaXMgZml4OlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0RlZmluaXRlbHlUeXBlZC9EZWZpbml0ZWx5VHlwZWQvcHVsbC81NTM5NlxuLy8gcHJldHRpZXItaWdub3JlXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBQcmltaXRpdmVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi8gY29uc3QgJDg5MjdmNmYyYWNjNGYzODYkZXhwb3J0JDI1MGZmYTYzY2RjMGQwMzQgPSAkODkyN2Y2ZjJhY2M0ZjM4NiR2YXIkTk9ERVMucmVkdWNlKChwcmltaXRpdmUsIG5vZGUpPT57XG4gICAgY29uc3QgTm9kZSA9IC8qI19fUFVSRV9fKi8gJDRxNUZxJGZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpPT57XG4gICAgICAgIGNvbnN0IHsgYXNDaGlsZDogYXNDaGlsZCAsIC4uLnByaW1pdGl2ZVByb3BzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgQ29tcCA9IGFzQ2hpbGQgPyAkNHE1RnEkU2xvdCA6IG5vZGU7XG4gICAgICAgICQ0cTVGcSR1c2VFZmZlY3QoKCk9PntcbiAgICAgICAgICAgIHdpbmRvd1tTeW1ib2wuZm9yKCdyYWRpeC11aScpXSA9IHRydWU7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gJDRxNUZxJGNyZWF0ZUVsZW1lbnQoQ29tcCwgJDRxNUZxJGJhYmVscnVudGltZWhlbHBlcnNlc21leHRlbmRzKHt9LCBwcmltaXRpdmVQcm9wcywge1xuICAgICAgICAgICAgcmVmOiBmb3J3YXJkZWRSZWZcbiAgICAgICAgfSkpO1xuICAgIH0pO1xuICAgIE5vZGUuZGlzcGxheU5hbWUgPSBgUHJpbWl0aXZlLiR7bm9kZX1gO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnByaW1pdGl2ZSxcbiAgICAgICAgW25vZGVdOiBOb2RlXG4gICAgfTtcbn0sIHt9KTtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFV0aWxzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovIC8qKlxuICogRmx1c2ggY3VzdG9tIGV2ZW50IGRpc3BhdGNoXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmFkaXgtdWkvcHJpbWl0aXZlcy9wdWxsLzEzNzhcbiAqXG4gKiBSZWFjdCBiYXRjaGVzICphbGwqIGV2ZW50IGhhbmRsZXJzIHNpbmNlIHZlcnNpb24gMTgsIHRoaXMgaW50cm9kdWNlcyBjZXJ0YWluIGNvbnNpZGVyYXRpb25zIHdoZW4gdXNpbmcgY3VzdG9tIGV2ZW50IHR5cGVzLlxuICpcbiAqIEludGVybmFsbHksIFJlYWN0IHByaW9yaXRpc2VzIGV2ZW50cyBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOlxuICogIC0gZGlzY3JldGVcbiAqICAtIGNvbnRpbnVvdXNcbiAqICAtIGRlZmF1bHRcbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9hOGE0NzQyZjFjNTQ0OTNkZjAwZGE2NDhhM2Y5ZDI2ZTNkYjljOGI1L3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL1JlYWN0RE9NRXZlbnRMaXN0ZW5lci5qcyNMMjk0LUwzNTBcbiAqXG4gKiBgZGlzY3JldGVgIGlzIGFuICBpbXBvcnRhbnQgZGlzdGluY3Rpb24gYXMgdXBkYXRlcyB3aXRoaW4gdGhlc2UgZXZlbnRzIGFyZSBhcHBsaWVkIGltbWVkaWF0ZWx5LlxuICogUmVhY3QgaG93ZXZlciwgaXMgbm90IGFibGUgdG8gaW5mZXIgdGhlIHByaW9yaXR5IG9mIGN1c3RvbSBldmVudCB0eXBlcyBkdWUgdG8gaG93IHRoZXkgYXJlIGRldGVjdGVkIGludGVybmFsbHkuXG4gKiBCZWNhdXNlIG9mIHRoaXMsIGl0J3MgcG9zc2libGUgZm9yIHVwZGF0ZXMgZnJvbSBjdXN0b20gZXZlbnRzIHRvIGJlIHVuZXhwZWN0ZWRseSBiYXRjaGVkIHdoZW5cbiAqIGRpc3BhdGNoZWQgYnkgYW5vdGhlciBgZGlzY3JldGVgIGV2ZW50LlxuICpcbiAqIEluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IHVwZGF0ZXMgZnJvbSBjdXN0b20gZXZlbnRzIGFyZSBhcHBsaWVkIHByZWRpY3RhYmx5LCB3ZSBuZWVkIHRvIG1hbnVhbGx5IGZsdXNoIHRoZSBiYXRjaC5cbiAqIFRoaXMgdXRpbGl0eSBzaG91bGQgYmUgdXNlZCB3aGVuIGRpc3BhdGNoaW5nIGEgY3VzdG9tIGV2ZW50IGZyb20gd2l0aGluIGFub3RoZXIgYGRpc2NyZXRlYCBldmVudCwgdGhpcyB1dGlsaXR5XG4gKiBpcyBub3QgbmVzc2VzYXJ5IHdoZW4gZGlzcGF0Y2hpbmcga25vd24gZXZlbnQgdHlwZXMsIG9yIGlmIGRpc3BhdGNoaW5nIGEgY3VzdG9tIHR5cGUgaW5zaWRlIGEgbm9uLWRpc2NyZXRlIGV2ZW50LlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogZGlzcGF0Y2hpbmcgYSBrbm93biBjbGljayDwn5GOXG4gKiB0YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQo4oCYY2xpY2vigJkpKVxuICpcbiAqIGRpc3BhdGNoaW5nIGEgY3VzdG9tIHR5cGUgd2l0aGluIGEgbm9uLWRpc2NyZXRlIGV2ZW50IPCfkY5cbiAqIG9uU2Nyb2xsPXsoZXZlbnQpID0+IGV2ZW50LnRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCjigJhjdXN0b21UeXBl4oCZKSl9XG4gKlxuICogZGlzcGF0Y2hpbmcgYSBjdXN0b20gdHlwZSB3aXRoaW4gYSBgZGlzY3JldGVgIGV2ZW50IPCfkY1cbiAqIG9uUG9pbnRlckRvd249eyhldmVudCkgPT4gZGlzcGF0Y2hEaXNjcmV0ZUN1c3RvbUV2ZW50KGV2ZW50LnRhcmdldCwgbmV3IEN1c3RvbUV2ZW50KOKAmGN1c3RvbVR5cGXigJkpKX1cbiAqXG4gKiBOb3RlOiB0aG91Z2ggUmVhY3QgY2xhc3NpZmllcyBgZm9jdXNgLCBgZm9jdXNpbmAgYW5kIGBmb2N1c291dGAgZXZlbnRzIGFzIGBkaXNjcmV0ZWAsIGl0J3MgIG5vdCByZWNvbW1lbmRlZCB0byB1c2VcbiAqIHRoaXMgdXRpbGl0eSB3aXRoIHRoZW0uIFRoaXMgaXMgYmVjYXVzZSBpdCdzIHBvc3NpYmxlIGZvciB0aG9zZSBoYW5kbGVycyB0byBiZSBjYWxsZWQgaW1wbGljaXRseSBkdXJpbmcgcmVuZGVyXG4gKiBlLmcuIHdoZW4gZm9jdXMgaXMgd2l0aGluIGEgY29tcG9uZW50IGFzIGl0IGlzIHVubW91bnRlZCwgb3Igd2hlbiBtYW5hZ2luZyBmb2N1cyBvbiBtb3VudC5cbiAqLyBmdW5jdGlvbiAkODkyN2Y2ZjJhY2M0ZjM4NiRleHBvcnQkNmQxYTAzMTdiZGU3ZGU3Zih0YXJnZXQsIGV2ZW50KSB7XG4gICAgaWYgKHRhcmdldCkgJDRxNUZxJGZsdXNoU3luYygoKT0+dGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gICAgKTtcbn1cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi8gY29uc3QgJDg5MjdmNmYyYWNjNGYzODYkZXhwb3J0JGJlOTJiNmY1ZjAzYzBmZTkgPSAkODkyN2Y2ZjJhY2M0ZjM4NiRleHBvcnQkMjUwZmZhNjNjZGMwZDAzNDtcblxuXG5cblxuZXhwb3J0IHskODkyN2Y2ZjJhY2M0ZjM4NiRleHBvcnQkMjUwZmZhNjNjZGMwZDAzNCBhcyBQcmltaXRpdmUsICQ4OTI3ZjZmMmFjYzRmMzg2JGV4cG9ydCRiZTkyYjZmNWYwM2MwZmU5IGFzIFJvb3QsICQ4OTI3ZjZmMmFjYzRmMzg2JGV4cG9ydCQ2ZDFhMDMxN2JkZTdkZTdmIGFzIGRpc3BhdGNoRGlzY3JldGVDdXN0b21FdmVudH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@radix-ui/react-primitive/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@radix-ui/react-progress/dist/index.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@radix-ui/react-progress/dist/index.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Indicator: function() { return /* binding */ $67824d98245208a0$export$adb584737d712b70; },\n/* harmony export */   Progress: function() { return /* binding */ $67824d98245208a0$export$b25a304ec7d746bb; },\n/* harmony export */   ProgressIndicator: function() { return /* binding */ $67824d98245208a0$export$2b776f7e7ee60dbd; },\n/* harmony export */   Root: function() { return /* binding */ $67824d98245208a0$export$be92b6f5f03c0fe9; },\n/* harmony export */   createProgressScope: function() { return /* binding */ $67824d98245208a0$export$388eb2d8f6d3261f; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _radix_ui_react_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @radix-ui/react-context */ \"(app-pages-browser)/./node_modules/@radix-ui/react-context/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_primitive__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @radix-ui/react-primitive */ \"(app-pages-browser)/./node_modules/@radix-ui/react-primitive/dist/index.mjs\");\n\n\n\n\n\n\n\n\n\n/* -------------------------------------------------------------------------------------------------\n * Progress\n * -----------------------------------------------------------------------------------------------*/ const $67824d98245208a0$var$PROGRESS_NAME = 'Progress';\nconst $67824d98245208a0$var$DEFAULT_MAX = 100;\nconst [$67824d98245208a0$var$createProgressContext, $67824d98245208a0$export$388eb2d8f6d3261f] = (0,_radix_ui_react_context__WEBPACK_IMPORTED_MODULE_2__.createContextScope)($67824d98245208a0$var$PROGRESS_NAME);\nconst [$67824d98245208a0$var$ProgressProvider, $67824d98245208a0$var$useProgressContext] = $67824d98245208a0$var$createProgressContext($67824d98245208a0$var$PROGRESS_NAME);\nconst $67824d98245208a0$export$b25a304ec7d746bb = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, forwardedRef)=>{\n    const { __scopeProgress: __scopeProgress , value: valueProp , max: maxProp , getValueLabel: getValueLabel = $67824d98245208a0$var$defaultGetValueLabel , ...progressProps } = props;\n    const max = $67824d98245208a0$var$isValidMaxNumber(maxProp) ? maxProp : $67824d98245208a0$var$DEFAULT_MAX;\n    const value = $67824d98245208a0$var$isValidValueNumber(valueProp, max) ? valueProp : null;\n    const valueLabel = $67824d98245208a0$var$isNumber(value) ? getValueLabel(value, max) : undefined;\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)($67824d98245208a0$var$ProgressProvider, {\n        scope: __scopeProgress,\n        value: value,\n        max: max\n    }, /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(_radix_ui_react_primitive__WEBPACK_IMPORTED_MODULE_3__.Primitive.div, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        \"aria-valuemax\": max,\n        \"aria-valuemin\": 0,\n        \"aria-valuenow\": $67824d98245208a0$var$isNumber(value) ? value : undefined,\n        \"aria-valuetext\": valueLabel,\n        role: \"progressbar\",\n        \"data-state\": $67824d98245208a0$var$getProgressState(value, max),\n        \"data-value\": value !== null && value !== void 0 ? value : undefined,\n        \"data-max\": max\n    }, progressProps, {\n        ref: forwardedRef\n    })));\n});\n/*#__PURE__*/ Object.assign($67824d98245208a0$export$b25a304ec7d746bb, {\n    displayName: $67824d98245208a0$var$PROGRESS_NAME\n});\n$67824d98245208a0$export$b25a304ec7d746bb.propTypes = {\n    max (props, propName, componentName) {\n        const propValue = props[propName];\n        const strVal = String(propValue);\n        if (propValue && !$67824d98245208a0$var$isValidMaxNumber(propValue)) return new Error($67824d98245208a0$var$getInvalidMaxError(strVal, componentName));\n        return null;\n    },\n    value (props, propName, componentName) {\n        const valueProp = props[propName];\n        const strVal = String(valueProp);\n        const max = $67824d98245208a0$var$isValidMaxNumber(props.max) ? props.max : $67824d98245208a0$var$DEFAULT_MAX;\n        if (valueProp != null && !$67824d98245208a0$var$isValidValueNumber(valueProp, max)) return new Error($67824d98245208a0$var$getInvalidValueError(strVal, componentName));\n        return null;\n    }\n};\n/* -------------------------------------------------------------------------------------------------\n * ProgressIndicator\n * -----------------------------------------------------------------------------------------------*/ const $67824d98245208a0$var$INDICATOR_NAME = 'ProgressIndicator';\nconst $67824d98245208a0$export$2b776f7e7ee60dbd = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, forwardedRef)=>{\n    var _context$value;\n    const { __scopeProgress: __scopeProgress , ...indicatorProps } = props;\n    const context = $67824d98245208a0$var$useProgressContext($67824d98245208a0$var$INDICATOR_NAME, __scopeProgress);\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(_radix_ui_react_primitive__WEBPACK_IMPORTED_MODULE_3__.Primitive.div, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        \"data-state\": $67824d98245208a0$var$getProgressState(context.value, context.max),\n        \"data-value\": (_context$value = context.value) !== null && _context$value !== void 0 ? _context$value : undefined,\n        \"data-max\": context.max\n    }, indicatorProps, {\n        ref: forwardedRef\n    }));\n});\n/*#__PURE__*/ Object.assign($67824d98245208a0$export$2b776f7e7ee60dbd, {\n    displayName: $67824d98245208a0$var$INDICATOR_NAME\n});\n/* ---------------------------------------------------------------------------------------------- */ function $67824d98245208a0$var$defaultGetValueLabel(value, max) {\n    return `${Math.round(value / max * 100)}%`;\n}\nfunction $67824d98245208a0$var$getProgressState(value, maxValue) {\n    return value == null ? 'indeterminate' : value === maxValue ? 'complete' : 'loading';\n}\nfunction $67824d98245208a0$var$isNumber(value) {\n    return typeof value === 'number';\n}\nfunction $67824d98245208a0$var$isValidMaxNumber(max) {\n    // prettier-ignore\n    return $67824d98245208a0$var$isNumber(max) && !isNaN(max) && max > 0;\n}\nfunction $67824d98245208a0$var$isValidValueNumber(value, max) {\n    // prettier-ignore\n    return $67824d98245208a0$var$isNumber(value) && !isNaN(value) && value <= max && value >= 0;\n} // Split this out for clearer readability of the error message.\nfunction $67824d98245208a0$var$getInvalidMaxError(propValue, componentName) {\n    return `Invalid prop \\`max\\` of value \\`${propValue}\\` supplied to \\`${componentName}\\`. Only numbers greater than 0 are valid max values. Defaulting to \\`${$67824d98245208a0$var$DEFAULT_MAX}\\`.`;\n}\nfunction $67824d98245208a0$var$getInvalidValueError(propValue, componentName) {\n    return `Invalid prop \\`value\\` of value \\`${propValue}\\` supplied to \\`${componentName}\\`. The \\`value\\` prop must be:\n  - a positive number\n  - less than the value passed to \\`max\\` (or ${$67824d98245208a0$var$DEFAULT_MAX} if no \\`max\\` prop is set)\n  - \\`null\\` if the progress is indeterminate.\n\nDefaulting to \\`null\\`.`;\n}\nconst $67824d98245208a0$export$be92b6f5f03c0fe9 = $67824d98245208a0$export$b25a304ec7d746bb;\nconst $67824d98245208a0$export$adb584737d712b70 = $67824d98245208a0$export$2b776f7e7ee60dbd;\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtcHJvZ3Jlc3MvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXNGO0FBQ087QUFDTDtBQUNoQjs7Ozs7O0FBTXhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLDJFQUF5QjtBQUMxSDtBQUNBLGdFQUFnRSxpREFBaUI7QUFDakYsWUFBWSxvS0FBb0s7QUFDaEw7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxLQUFLLGdCQUFnQixvREFBb0IsQ0FBQyxnRUFBZ0IsTUFBTSw4RUFBb0M7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxpREFBaUI7QUFDakY7QUFDQSxZQUFZLHVEQUF1RDtBQUNuRTtBQUNBLHlCQUF5QixvREFBb0IsQ0FBQyxnRUFBZ0IsTUFBTSw4RUFBb0M7QUFDeEc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLDhDQUE4QyxVQUFVLG1CQUFtQixjQUFjLHdFQUF3RSxrQ0FBa0M7QUFDbk07QUFDQTtBQUNBLGdEQUFnRCxVQUFVLG1CQUFtQixjQUFjO0FBQzNGO0FBQ0EsZ0RBQWdELG1DQUFtQztBQUNuRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLNFM7QUFDNVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1wcm9ncmVzcy9kaXN0L2luZGV4Lm1qcz84MDk2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAkazAzd0kkYmFiZWxydW50aW1laGVscGVyc2VzbWV4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCB7Zm9yd2FyZFJlZiBhcyAkazAzd0kkZm9yd2FyZFJlZiwgY3JlYXRlRWxlbWVudCBhcyAkazAzd0kkY3JlYXRlRWxlbWVudH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHRTY29wZSBhcyAkazAzd0kkY3JlYXRlQ29udGV4dFNjb3BlfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LWNvbnRleHRcIjtcbmltcG9ydCB7UHJpbWl0aXZlIGFzICRrMDN3SSRQcmltaXRpdmV9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlXCI7XG5cblxuXG5cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogUHJvZ3Jlc3NcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi8gY29uc3QgJDY3ODI0ZDk4MjQ1MjA4YTAkdmFyJFBST0dSRVNTX05BTUUgPSAnUHJvZ3Jlc3MnO1xuY29uc3QgJDY3ODI0ZDk4MjQ1MjA4YTAkdmFyJERFRkFVTFRfTUFYID0gMTAwO1xuY29uc3QgWyQ2NzgyNGQ5ODI0NTIwOGEwJHZhciRjcmVhdGVQcm9ncmVzc0NvbnRleHQsICQ2NzgyNGQ5ODI0NTIwOGEwJGV4cG9ydCQzODhlYjJkOGY2ZDMyNjFmXSA9ICRrMDN3SSRjcmVhdGVDb250ZXh0U2NvcGUoJDY3ODI0ZDk4MjQ1MjA4YTAkdmFyJFBST0dSRVNTX05BTUUpO1xuY29uc3QgWyQ2NzgyNGQ5ODI0NTIwOGEwJHZhciRQcm9ncmVzc1Byb3ZpZGVyLCAkNjc4MjRkOTgyNDUyMDhhMCR2YXIkdXNlUHJvZ3Jlc3NDb250ZXh0XSA9ICQ2NzgyNGQ5ODI0NTIwOGEwJHZhciRjcmVhdGVQcm9ncmVzc0NvbnRleHQoJDY3ODI0ZDk4MjQ1MjA4YTAkdmFyJFBST0dSRVNTX05BTUUpO1xuY29uc3QgJDY3ODI0ZDk4MjQ1MjA4YTAkZXhwb3J0JGIyNWEzMDRlYzdkNzQ2YmIgPSAvKiNfX1BVUkVfXyovICRrMDN3SSRmb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKT0+e1xuICAgIGNvbnN0IHsgX19zY29wZVByb2dyZXNzOiBfX3Njb3BlUHJvZ3Jlc3MgLCB2YWx1ZTogdmFsdWVQcm9wICwgbWF4OiBtYXhQcm9wICwgZ2V0VmFsdWVMYWJlbDogZ2V0VmFsdWVMYWJlbCA9ICQ2NzgyNGQ5ODI0NTIwOGEwJHZhciRkZWZhdWx0R2V0VmFsdWVMYWJlbCAsIC4uLnByb2dyZXNzUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IG1heCA9ICQ2NzgyNGQ5ODI0NTIwOGEwJHZhciRpc1ZhbGlkTWF4TnVtYmVyKG1heFByb3ApID8gbWF4UHJvcCA6ICQ2NzgyNGQ5ODI0NTIwOGEwJHZhciRERUZBVUxUX01BWDtcbiAgICBjb25zdCB2YWx1ZSA9ICQ2NzgyNGQ5ODI0NTIwOGEwJHZhciRpc1ZhbGlkVmFsdWVOdW1iZXIodmFsdWVQcm9wLCBtYXgpID8gdmFsdWVQcm9wIDogbnVsbDtcbiAgICBjb25zdCB2YWx1ZUxhYmVsID0gJDY3ODI0ZDk4MjQ1MjA4YTAkdmFyJGlzTnVtYmVyKHZhbHVlKSA/IGdldFZhbHVlTGFiZWwodmFsdWUsIG1heCkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gJGswM3dJJGNyZWF0ZUVsZW1lbnQoJDY3ODI0ZDk4MjQ1MjA4YTAkdmFyJFByb2dyZXNzUHJvdmlkZXIsIHtcbiAgICAgICAgc2NvcGU6IF9fc2NvcGVQcm9ncmVzcyxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBtYXg6IG1heFxuICAgIH0sIC8qI19fUFVSRV9fKi8gJGswM3dJJGNyZWF0ZUVsZW1lbnQoJGswM3dJJFByaW1pdGl2ZS5kaXYsICRrMDN3SSRiYWJlbHJ1bnRpbWVoZWxwZXJzZXNtZXh0ZW5kcyh7XG4gICAgICAgIFwiYXJpYS12YWx1ZW1heFwiOiBtYXgsXG4gICAgICAgIFwiYXJpYS12YWx1ZW1pblwiOiAwLFxuICAgICAgICBcImFyaWEtdmFsdWVub3dcIjogJDY3ODI0ZDk4MjQ1MjA4YTAkdmFyJGlzTnVtYmVyKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkLFxuICAgICAgICBcImFyaWEtdmFsdWV0ZXh0XCI6IHZhbHVlTGFiZWwsXG4gICAgICAgIHJvbGU6IFwicHJvZ3Jlc3NiYXJcIixcbiAgICAgICAgXCJkYXRhLXN0YXRlXCI6ICQ2NzgyNGQ5ODI0NTIwOGEwJHZhciRnZXRQcm9ncmVzc1N0YXRlKHZhbHVlLCBtYXgpLFxuICAgICAgICBcImRhdGEtdmFsdWVcIjogdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogdW5kZWZpbmVkLFxuICAgICAgICBcImRhdGEtbWF4XCI6IG1heFxuICAgIH0sIHByb2dyZXNzUHJvcHMsIHtcbiAgICAgICAgcmVmOiBmb3J3YXJkZWRSZWZcbiAgICB9KSkpO1xufSk7XG4vKiNfX1BVUkVfXyovIE9iamVjdC5hc3NpZ24oJDY3ODI0ZDk4MjQ1MjA4YTAkZXhwb3J0JGIyNWEzMDRlYzdkNzQ2YmIsIHtcbiAgICBkaXNwbGF5TmFtZTogJDY3ODI0ZDk4MjQ1MjA4YTAkdmFyJFBST0dSRVNTX05BTUVcbn0pO1xuJDY3ODI0ZDk4MjQ1MjA4YTAkZXhwb3J0JGIyNWEzMDRlYzdkNzQ2YmIucHJvcFR5cGVzID0ge1xuICAgIG1heCAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIGNvbnN0IHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgY29uc3Qgc3RyVmFsID0gU3RyaW5nKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChwcm9wVmFsdWUgJiYgISQ2NzgyNGQ5ODI0NTIwOGEwJHZhciRpc1ZhbGlkTWF4TnVtYmVyKHByb3BWYWx1ZSkpIHJldHVybiBuZXcgRXJyb3IoJDY3ODI0ZDk4MjQ1MjA4YTAkdmFyJGdldEludmFsaWRNYXhFcnJvcihzdHJWYWwsIGNvbXBvbmVudE5hbWUpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICB2YWx1ZSAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlUHJvcCA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgY29uc3Qgc3RyVmFsID0gU3RyaW5nKHZhbHVlUHJvcCk7XG4gICAgICAgIGNvbnN0IG1heCA9ICQ2NzgyNGQ5ODI0NTIwOGEwJHZhciRpc1ZhbGlkTWF4TnVtYmVyKHByb3BzLm1heCkgPyBwcm9wcy5tYXggOiAkNjc4MjRkOTgyNDUyMDhhMCR2YXIkREVGQVVMVF9NQVg7XG4gICAgICAgIGlmICh2YWx1ZVByb3AgIT0gbnVsbCAmJiAhJDY3ODI0ZDk4MjQ1MjA4YTAkdmFyJGlzVmFsaWRWYWx1ZU51bWJlcih2YWx1ZVByb3AsIG1heCkpIHJldHVybiBuZXcgRXJyb3IoJDY3ODI0ZDk4MjQ1MjA4YTAkdmFyJGdldEludmFsaWRWYWx1ZUVycm9yKHN0clZhbCwgY29tcG9uZW50TmFtZSkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogUHJvZ3Jlc3NJbmRpY2F0b3JcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi8gY29uc3QgJDY3ODI0ZDk4MjQ1MjA4YTAkdmFyJElORElDQVRPUl9OQU1FID0gJ1Byb2dyZXNzSW5kaWNhdG9yJztcbmNvbnN0ICQ2NzgyNGQ5ODI0NTIwOGEwJGV4cG9ydCQyYjc3NmY3ZTdlZTYwZGJkID0gLyojX19QVVJFX18qLyAkazAzd0kkZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZik9PntcbiAgICB2YXIgX2NvbnRleHQkdmFsdWU7XG4gICAgY29uc3QgeyBfX3Njb3BlUHJvZ3Jlc3M6IF9fc2NvcGVQcm9ncmVzcyAsIC4uLmluZGljYXRvclByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBjb250ZXh0ID0gJDY3ODI0ZDk4MjQ1MjA4YTAkdmFyJHVzZVByb2dyZXNzQ29udGV4dCgkNjc4MjRkOTgyNDUyMDhhMCR2YXIkSU5ESUNBVE9SX05BTUUsIF9fc2NvcGVQcm9ncmVzcyk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gJGswM3dJJGNyZWF0ZUVsZW1lbnQoJGswM3dJJFByaW1pdGl2ZS5kaXYsICRrMDN3SSRiYWJlbHJ1bnRpbWVoZWxwZXJzZXNtZXh0ZW5kcyh7XG4gICAgICAgIFwiZGF0YS1zdGF0ZVwiOiAkNjc4MjRkOTgyNDUyMDhhMCR2YXIkZ2V0UHJvZ3Jlc3NTdGF0ZShjb250ZXh0LnZhbHVlLCBjb250ZXh0Lm1heCksXG4gICAgICAgIFwiZGF0YS12YWx1ZVwiOiAoX2NvbnRleHQkdmFsdWUgPSBjb250ZXh0LnZhbHVlKSAhPT0gbnVsbCAmJiBfY29udGV4dCR2YWx1ZSAhPT0gdm9pZCAwID8gX2NvbnRleHQkdmFsdWUgOiB1bmRlZmluZWQsXG4gICAgICAgIFwiZGF0YS1tYXhcIjogY29udGV4dC5tYXhcbiAgICB9LCBpbmRpY2F0b3JQcm9wcywge1xuICAgICAgICByZWY6IGZvcndhcmRlZFJlZlxuICAgIH0pKTtcbn0pO1xuLyojX19QVVJFX18qLyBPYmplY3QuYXNzaWduKCQ2NzgyNGQ5ODI0NTIwOGEwJGV4cG9ydCQyYjc3NmY3ZTdlZTYwZGJkLCB7XG4gICAgZGlzcGxheU5hbWU6ICQ2NzgyNGQ5ODI0NTIwOGEwJHZhciRJTkRJQ0FUT1JfTkFNRVxufSk7XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovIGZ1bmN0aW9uICQ2NzgyNGQ5ODI0NTIwOGEwJHZhciRkZWZhdWx0R2V0VmFsdWVMYWJlbCh2YWx1ZSwgbWF4KSB7XG4gICAgcmV0dXJuIGAke01hdGgucm91bmQodmFsdWUgLyBtYXggKiAxMDApfSVgO1xufVxuZnVuY3Rpb24gJDY3ODI0ZDk4MjQ1MjA4YTAkdmFyJGdldFByb2dyZXNzU3RhdGUodmFsdWUsIG1heFZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnaW5kZXRlcm1pbmF0ZScgOiB2YWx1ZSA9PT0gbWF4VmFsdWUgPyAnY29tcGxldGUnIDogJ2xvYWRpbmcnO1xufVxuZnVuY3Rpb24gJDY3ODI0ZDk4MjQ1MjA4YTAkdmFyJGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG59XG5mdW5jdGlvbiAkNjc4MjRkOTgyNDUyMDhhMCR2YXIkaXNWYWxpZE1heE51bWJlcihtYXgpIHtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICByZXR1cm4gJDY3ODI0ZDk4MjQ1MjA4YTAkdmFyJGlzTnVtYmVyKG1heCkgJiYgIWlzTmFOKG1heCkgJiYgbWF4ID4gMDtcbn1cbmZ1bmN0aW9uICQ2NzgyNGQ5ODI0NTIwOGEwJHZhciRpc1ZhbGlkVmFsdWVOdW1iZXIodmFsdWUsIG1heCkge1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHJldHVybiAkNjc4MjRkOTgyNDUyMDhhMCR2YXIkaXNOdW1iZXIodmFsdWUpICYmICFpc05hTih2YWx1ZSkgJiYgdmFsdWUgPD0gbWF4ICYmIHZhbHVlID49IDA7XG59IC8vIFNwbGl0IHRoaXMgb3V0IGZvciBjbGVhcmVyIHJlYWRhYmlsaXR5IG9mIHRoZSBlcnJvciBtZXNzYWdlLlxuZnVuY3Rpb24gJDY3ODI0ZDk4MjQ1MjA4YTAkdmFyJGdldEludmFsaWRNYXhFcnJvcihwcm9wVmFsdWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICByZXR1cm4gYEludmFsaWQgcHJvcCBcXGBtYXhcXGAgb2YgdmFsdWUgXFxgJHtwcm9wVmFsdWV9XFxgIHN1cHBsaWVkIHRvIFxcYCR7Y29tcG9uZW50TmFtZX1cXGAuIE9ubHkgbnVtYmVycyBncmVhdGVyIHRoYW4gMCBhcmUgdmFsaWQgbWF4IHZhbHVlcy4gRGVmYXVsdGluZyB0byBcXGAkeyQ2NzgyNGQ5ODI0NTIwOGEwJHZhciRERUZBVUxUX01BWH1cXGAuYDtcbn1cbmZ1bmN0aW9uICQ2NzgyNGQ5ODI0NTIwOGEwJHZhciRnZXRJbnZhbGlkVmFsdWVFcnJvcihwcm9wVmFsdWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICByZXR1cm4gYEludmFsaWQgcHJvcCBcXGB2YWx1ZVxcYCBvZiB2YWx1ZSBcXGAke3Byb3BWYWx1ZX1cXGAgc3VwcGxpZWQgdG8gXFxgJHtjb21wb25lbnROYW1lfVxcYC4gVGhlIFxcYHZhbHVlXFxgIHByb3AgbXVzdCBiZTpcbiAgLSBhIHBvc2l0aXZlIG51bWJlclxuICAtIGxlc3MgdGhhbiB0aGUgdmFsdWUgcGFzc2VkIHRvIFxcYG1heFxcYCAob3IgJHskNjc4MjRkOTgyNDUyMDhhMCR2YXIkREVGQVVMVF9NQVh9IGlmIG5vIFxcYG1heFxcYCBwcm9wIGlzIHNldClcbiAgLSBcXGBudWxsXFxgIGlmIHRoZSBwcm9ncmVzcyBpcyBpbmRldGVybWluYXRlLlxuXG5EZWZhdWx0aW5nIHRvIFxcYG51bGxcXGAuYDtcbn1cbmNvbnN0ICQ2NzgyNGQ5ODI0NTIwOGEwJGV4cG9ydCRiZTkyYjZmNWYwM2MwZmU5ID0gJDY3ODI0ZDk4MjQ1MjA4YTAkZXhwb3J0JGIyNWEzMDRlYzdkNzQ2YmI7XG5jb25zdCAkNjc4MjRkOTgyNDUyMDhhMCRleHBvcnQkYWRiNTg0NzM3ZDcxMmI3MCA9ICQ2NzgyNGQ5ODI0NTIwOGEwJGV4cG9ydCQyYjc3NmY3ZTdlZTYwZGJkO1xuXG5cblxuXG5leHBvcnQgeyQ2NzgyNGQ5ODI0NTIwOGEwJGV4cG9ydCQzODhlYjJkOGY2ZDMyNjFmIGFzIGNyZWF0ZVByb2dyZXNzU2NvcGUsICQ2NzgyNGQ5ODI0NTIwOGEwJGV4cG9ydCRiMjVhMzA0ZWM3ZDc0NmJiIGFzIFByb2dyZXNzLCAkNjc4MjRkOTgyNDUyMDhhMCRleHBvcnQkMmI3NzZmN2U3ZWU2MGRiZCBhcyBQcm9ncmVzc0luZGljYXRvciwgJDY3ODI0ZDk4MjQ1MjA4YTAkZXhwb3J0JGJlOTJiNmY1ZjAzYzBmZTkgYXMgUm9vdCwgJDY3ODI0ZDk4MjQ1MjA4YTAkZXhwb3J0JGFkYjU4NDczN2Q3MTJiNzAgYXMgSW5kaWNhdG9yfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@radix-ui/react-progress/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@radix-ui/react-slot/dist/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@radix-ui/react-slot/dist/index.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Root: function() { return /* binding */ $5e63c961fc1ce211$export$be92b6f5f03c0fe9; },\n/* harmony export */   Slot: function() { return /* binding */ $5e63c961fc1ce211$export$8c6ed5c666ac1360; },\n/* harmony export */   Slottable: function() { return /* binding */ $5e63c961fc1ce211$export$d9f1ccf0bdb05d45; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _radix_ui_react_compose_refs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @radix-ui/react-compose-refs */ \"(app-pages-browser)/./node_modules/@radix-ui/react-compose-refs/dist/index.mjs\");\n\n\n\n\n\n\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/ const $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, forwardedRef)=>{\n    const { children: children , ...slotProps } = props;\n    const childrenArray = react__WEBPACK_IMPORTED_MODULE_1__.Children.toArray(children);\n    const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);\n    if (slottable) {\n        // the new element to render is the one passed as a child of `Slottable`\n        const newElement = slottable.props.children;\n        const newChildren = childrenArray.map((child)=>{\n            if (child === slottable) {\n                // because the new element will be the one rendered, we are only interested\n                // in grabbing its children (`newElement.props.children`)\n                if (react__WEBPACK_IMPORTED_MODULE_1__.Children.count(newElement) > 1) return react__WEBPACK_IMPORTED_MODULE_1__.Children.only(null);\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(newElement) ? newElement.props.children : null;\n            } else return child;\n        });\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)($5e63c961fc1ce211$var$SlotClone, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, slotProps, {\n            ref: forwardedRef\n        }), /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(newElement) ? /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(newElement, undefined, newChildren) : null);\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)($5e63c961fc1ce211$var$SlotClone, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, slotProps, {\n        ref: forwardedRef\n    }), children);\n});\n$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = 'Slot';\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/ const $5e63c961fc1ce211$var$SlotClone = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, forwardedRef)=>{\n    const { children: children , ...slotProps } = props;\n    if (/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(children)) return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(children, {\n        ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),\n        ref: forwardedRef ? (0,_radix_ui_react_compose_refs__WEBPACK_IMPORTED_MODULE_2__.composeRefs)(forwardedRef, children.ref) : children.ref\n    });\n    return react__WEBPACK_IMPORTED_MODULE_1__.Children.count(children) > 1 ? react__WEBPACK_IMPORTED_MODULE_1__.Children.only(null) : null;\n});\n$5e63c961fc1ce211$var$SlotClone.displayName = 'SlotClone';\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/ const $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children: children  })=>{\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, children);\n};\n/* ---------------------------------------------------------------------------------------------- */ function $5e63c961fc1ce211$var$isSlottable(child) {\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;\n}\nfunction $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {\n    // all child props should override\n    const overrideProps = {\n        ...childProps\n    };\n    for(const propName in childProps){\n        const slotPropValue = slotProps[propName];\n        const childPropValue = childProps[propName];\n        const isHandler = /^on[A-Z]/.test(propName);\n        if (isHandler) {\n            // if the handler exists on both, we compose them\n            if (slotPropValue && childPropValue) overrideProps[propName] = (...args)=>{\n                childPropValue(...args);\n                slotPropValue(...args);\n            };\n            else if (slotPropValue) overrideProps[propName] = slotPropValue;\n        } else if (propName === 'style') overrideProps[propName] = {\n            ...slotPropValue,\n            ...childPropValue\n        };\n        else if (propName === 'className') overrideProps[propName] = [\n            slotPropValue,\n            childPropValue\n        ].filter(Boolean).join(' ');\n    }\n    return {\n        ...slotProps,\n        ...overrideProps\n    };\n}\nconst $5e63c961fc1ce211$export$be92b6f5f03c0fe9 = $5e63c961fc1ce211$export$8c6ed5c666ac1360;\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3Qtc2xvdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBc0Y7QUFDK0k7QUFDdEo7Ozs7O0FBSy9FO0FBQ0E7QUFDQSxxS0FBcUssaURBQWlCO0FBQ3RMLFlBQVksb0NBQW9DO0FBQ2hELDBCQUEwQiwyQ0FBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJDQUFlLCtCQUErQiwyQ0FBZTtBQUNqRixxQ0FBcUMscURBQXFCO0FBQzFELGNBQWM7QUFDZCxTQUFTO0FBQ1QsNkJBQTZCLG9EQUFvQixrQ0FBa0MsOEVBQW9DLEdBQUc7QUFDMUg7QUFDQSxTQUFTLGlCQUFpQixxREFBcUIsNkJBQTZCLG1EQUFtQjtBQUMvRjtBQUNBLHlCQUF5QixvREFBb0Isa0NBQWtDLDhFQUFvQyxHQUFHO0FBQ3RIO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSwySkFBMkosaURBQWlCO0FBQzVLLFlBQVksb0NBQW9DO0FBQ2hELHNCQUFzQixxREFBcUIsaUNBQWlDLG1EQUFtQjtBQUMvRjtBQUNBLDRCQUE0Qix5RUFBa0I7QUFDOUMsS0FBSztBQUNMLFdBQVcsMkNBQWUsdUJBQXVCLDJDQUFlO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSwwSkFBMEoscUJBQXFCO0FBQy9LLHlCQUF5QixvREFBb0IsQ0FBQywyQ0FBZTtBQUM3RDtBQUNBO0FBQ0EseUJBQXlCLHFEQUFxQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS3NLO0FBQ3RLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3Qtc2xvdC9kaXN0L2luZGV4Lm1qcz9iMTRkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAkOUlyalgkYmFiZWxydW50aW1laGVscGVyc2VzbWV4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCB7Zm9yd2FyZFJlZiBhcyAkOUlyalgkZm9yd2FyZFJlZiwgQ2hpbGRyZW4gYXMgJDlJcmpYJENoaWxkcmVuLCBpc1ZhbGlkRWxlbWVudCBhcyAkOUlyalgkaXNWYWxpZEVsZW1lbnQsIGNyZWF0ZUVsZW1lbnQgYXMgJDlJcmpYJGNyZWF0ZUVsZW1lbnQsIGNsb25lRWxlbWVudCBhcyAkOUlyalgkY2xvbmVFbGVtZW50LCBGcmFnbWVudCBhcyAkOUlyalgkRnJhZ21lbnR9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtjb21wb3NlUmVmcyBhcyAkOUlyalgkY29tcG9zZVJlZnN9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29tcG9zZS1yZWZzXCI7XG5cblxuXG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFNsb3RcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi8gY29uc3QgJDVlNjNjOTYxZmMxY2UyMTEkZXhwb3J0JDhjNmVkNWM2NjZhYzEzNjAgPSAvKiNfX1BVUkVfXyovICQ5SXJqWCRmb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKT0+e1xuICAgIGNvbnN0IHsgY2hpbGRyZW46IGNoaWxkcmVuICwgLi4uc2xvdFByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBjaGlsZHJlbkFycmF5ID0gJDlJcmpYJENoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xuICAgIGNvbnN0IHNsb3R0YWJsZSA9IGNoaWxkcmVuQXJyYXkuZmluZCgkNWU2M2M5NjFmYzFjZTIxMSR2YXIkaXNTbG90dGFibGUpO1xuICAgIGlmIChzbG90dGFibGUpIHtcbiAgICAgICAgLy8gdGhlIG5ldyBlbGVtZW50IHRvIHJlbmRlciBpcyB0aGUgb25lIHBhc3NlZCBhcyBhIGNoaWxkIG9mIGBTbG90dGFibGVgXG4gICAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBzbG90dGFibGUucHJvcHMuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IG5ld0NoaWxkcmVuID0gY2hpbGRyZW5BcnJheS5tYXAoKGNoaWxkKT0+e1xuICAgICAgICAgICAgaWYgKGNoaWxkID09PSBzbG90dGFibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBuZXcgZWxlbWVudCB3aWxsIGJlIHRoZSBvbmUgcmVuZGVyZWQsIHdlIGFyZSBvbmx5IGludGVyZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyBpbiBncmFiYmluZyBpdHMgY2hpbGRyZW4gKGBuZXdFbGVtZW50LnByb3BzLmNoaWxkcmVuYClcbiAgICAgICAgICAgICAgICBpZiAoJDlJcmpYJENoaWxkcmVuLmNvdW50KG5ld0VsZW1lbnQpID4gMSkgcmV0dXJuICQ5SXJqWCRDaGlsZHJlbi5vbmx5KG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovICQ5SXJqWCRpc1ZhbGlkRWxlbWVudChuZXdFbGVtZW50KSA/IG5ld0VsZW1lbnQucHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHJldHVybiBjaGlsZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovICQ5SXJqWCRjcmVhdGVFbGVtZW50KCQ1ZTYzYzk2MWZjMWNlMjExJHZhciRTbG90Q2xvbmUsICQ5SXJqWCRiYWJlbHJ1bnRpbWVoZWxwZXJzZXNtZXh0ZW5kcyh7fSwgc2xvdFByb3BzLCB7XG4gICAgICAgICAgICByZWY6IGZvcndhcmRlZFJlZlxuICAgICAgICB9KSwgLyojX19QVVJFX18qLyAkOUlyalgkaXNWYWxpZEVsZW1lbnQobmV3RWxlbWVudCkgPyAvKiNfX1BVUkVfXyovICQ5SXJqWCRjbG9uZUVsZW1lbnQobmV3RWxlbWVudCwgdW5kZWZpbmVkLCBuZXdDaGlsZHJlbikgOiBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gJDlJcmpYJGNyZWF0ZUVsZW1lbnQoJDVlNjNjOTYxZmMxY2UyMTEkdmFyJFNsb3RDbG9uZSwgJDlJcmpYJGJhYmVscnVudGltZWhlbHBlcnNlc21leHRlbmRzKHt9LCBzbG90UHJvcHMsIHtcbiAgICAgICAgcmVmOiBmb3J3YXJkZWRSZWZcbiAgICB9KSwgY2hpbGRyZW4pO1xufSk7XG4kNWU2M2M5NjFmYzFjZTIxMSRleHBvcnQkOGM2ZWQ1YzY2NmFjMTM2MC5kaXNwbGF5TmFtZSA9ICdTbG90Jztcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFNsb3RDbG9uZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLyBjb25zdCAkNWU2M2M5NjFmYzFjZTIxMSR2YXIkU2xvdENsb25lID0gLyojX19QVVJFX18qLyAkOUlyalgkZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZik9PntcbiAgICBjb25zdCB7IGNoaWxkcmVuOiBjaGlsZHJlbiAsIC4uLnNsb3RQcm9wcyB9ID0gcHJvcHM7XG4gICAgaWYgKC8qI19fUFVSRV9fKi8gJDlJcmpYJGlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkgcmV0dXJuIC8qI19fUFVSRV9fKi8gJDlJcmpYJGNsb25lRWxlbWVudChjaGlsZHJlbiwge1xuICAgICAgICAuLi4kNWU2M2M5NjFmYzFjZTIxMSR2YXIkbWVyZ2VQcm9wcyhzbG90UHJvcHMsIGNoaWxkcmVuLnByb3BzKSxcbiAgICAgICAgcmVmOiBmb3J3YXJkZWRSZWYgPyAkOUlyalgkY29tcG9zZVJlZnMoZm9yd2FyZGVkUmVmLCBjaGlsZHJlbi5yZWYpIDogY2hpbGRyZW4ucmVmXG4gICAgfSk7XG4gICAgcmV0dXJuICQ5SXJqWCRDaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPiAxID8gJDlJcmpYJENoaWxkcmVuLm9ubHkobnVsbCkgOiBudWxsO1xufSk7XG4kNWU2M2M5NjFmYzFjZTIxMSR2YXIkU2xvdENsb25lLmRpc3BsYXlOYW1lID0gJ1Nsb3RDbG9uZSc7XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBTbG90dGFibGVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi8gY29uc3QgJDVlNjNjOTYxZmMxY2UyMTEkZXhwb3J0JGQ5ZjFjY2YwYmRiMDVkNDUgPSAoeyBjaGlsZHJlbjogY2hpbGRyZW4gIH0pPT57XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gJDlJcmpYJGNyZWF0ZUVsZW1lbnQoJDlJcmpYJEZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59O1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqLyBmdW5jdGlvbiAkNWU2M2M5NjFmYzFjZTIxMSR2YXIkaXNTbG90dGFibGUoY2hpbGQpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAkOUlyalgkaXNWYWxpZEVsZW1lbnQoY2hpbGQpICYmIGNoaWxkLnR5cGUgPT09ICQ1ZTYzYzk2MWZjMWNlMjExJGV4cG9ydCRkOWYxY2NmMGJkYjA1ZDQ1O1xufVxuZnVuY3Rpb24gJDVlNjNjOTYxZmMxY2UyMTEkdmFyJG1lcmdlUHJvcHMoc2xvdFByb3BzLCBjaGlsZFByb3BzKSB7XG4gICAgLy8gYWxsIGNoaWxkIHByb3BzIHNob3VsZCBvdmVycmlkZVxuICAgIGNvbnN0IG92ZXJyaWRlUHJvcHMgPSB7XG4gICAgICAgIC4uLmNoaWxkUHJvcHNcbiAgICB9O1xuICAgIGZvcihjb25zdCBwcm9wTmFtZSBpbiBjaGlsZFByb3BzKXtcbiAgICAgICAgY29uc3Qgc2xvdFByb3BWYWx1ZSA9IHNsb3RQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIGNvbnN0IGNoaWxkUHJvcFZhbHVlID0gY2hpbGRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIGNvbnN0IGlzSGFuZGxlciA9IC9eb25bQS1aXS8udGVzdChwcm9wTmFtZSk7XG4gICAgICAgIGlmIChpc0hhbmRsZXIpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBoYW5kbGVyIGV4aXN0cyBvbiBib3RoLCB3ZSBjb21wb3NlIHRoZW1cbiAgICAgICAgICAgIGlmIChzbG90UHJvcFZhbHVlICYmIGNoaWxkUHJvcFZhbHVlKSBvdmVycmlkZVByb3BzW3Byb3BOYW1lXSA9ICguLi5hcmdzKT0+e1xuICAgICAgICAgICAgICAgIGNoaWxkUHJvcFZhbHVlKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIHNsb3RQcm9wVmFsdWUoLi4uYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWxzZSBpZiAoc2xvdFByb3BWYWx1ZSkgb3ZlcnJpZGVQcm9wc1twcm9wTmFtZV0gPSBzbG90UHJvcFZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09PSAnc3R5bGUnKSBvdmVycmlkZVByb3BzW3Byb3BOYW1lXSA9IHtcbiAgICAgICAgICAgIC4uLnNsb3RQcm9wVmFsdWUsXG4gICAgICAgICAgICAuLi5jaGlsZFByb3BWYWx1ZVxuICAgICAgICB9O1xuICAgICAgICBlbHNlIGlmIChwcm9wTmFtZSA9PT0gJ2NsYXNzTmFtZScpIG92ZXJyaWRlUHJvcHNbcHJvcE5hbWVdID0gW1xuICAgICAgICAgICAgc2xvdFByb3BWYWx1ZSxcbiAgICAgICAgICAgIGNoaWxkUHJvcFZhbHVlXG4gICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc2xvdFByb3BzLFxuICAgICAgICAuLi5vdmVycmlkZVByb3BzXG4gICAgfTtcbn1cbmNvbnN0ICQ1ZTYzYzk2MWZjMWNlMjExJGV4cG9ydCRiZTkyYjZmNWYwM2MwZmU5ID0gJDVlNjNjOTYxZmMxY2UyMTEkZXhwb3J0JDhjNmVkNWM2NjZhYzEzNjA7XG5cblxuXG5cbmV4cG9ydCB7JDVlNjNjOTYxZmMxY2UyMTEkZXhwb3J0JDhjNmVkNWM2NjZhYzEzNjAgYXMgU2xvdCwgJDVlNjNjOTYxZmMxY2UyMTEkZXhwb3J0JGQ5ZjFjY2YwYmRiMDVkNDUgYXMgU2xvdHRhYmxlLCAkNWU2M2M5NjFmYzFjZTIxMSRleHBvcnQkYmU5MmI2ZjVmMDNjMGZlOSBhcyBSb290fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@radix-ui/react-slot/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/class-variance-authority/dist/index.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/class-variance-authority/dist/index.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cva: function() { return /* binding */ cva; },\n/* harmony export */   cx: function() { return /* binding */ cx; }\n/* harmony export */ });\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/class-variance-authority/node_modules/clsx/dist/clsx.mjs\");\n\nconst falsyToString = (value)=>typeof value === \"boolean\" ? \"\".concat(value) : value === 0 ? \"0\" : value;\nconst cx = clsx__WEBPACK_IMPORTED_MODULE_0__.clsx;\nconst cva = (base, config)=>{\n    return (props)=>{\n        var ref;\n        if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);\n        const { variants , defaultVariants  } = config;\n        const getVariantClassNames = Object.keys(variants).map((variant)=>{\n            const variantProp = props === null || props === void 0 ? void 0 : props[variant];\n            const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];\n            if (variantProp === null) return null;\n            const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);\n            return variants[variant][variantKey];\n        });\n        const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param)=>{\n            let [key, value] = param;\n            if (value === undefined) {\n                return acc;\n            }\n            acc[key] = value;\n            return acc;\n        }, {});\n        const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (ref = config.compoundVariants) === null || ref === void 0 ? void 0 : ref.reduce((acc, param1)=>{\n            let { class: cvClass , className: cvClassName , ...compoundVariantOptions } = param1;\n            return Object.entries(compoundVariantOptions).every((param)=>{\n                let [key, value] = param;\n                return Array.isArray(value) ? value.includes({\n                    ...defaultVariants,\n                    ...propsWithoutUndefined\n                }[key]) : ({\n                    ...defaultVariants,\n                    ...propsWithoutUndefined\n                })[key] === value;\n            }) ? [\n                ...acc,\n                cvClass,\n                cvClassName\n            ] : acc;\n        }, []);\n        return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);\n    };\n};\n\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbGFzcy12YXJpYW5jZS1hdXRob3JpdHkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRCO0FBQzVCO0FBQ08sV0FBVyxzQ0FBSTtBQUNmO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBLGtCQUFrQixzRUFBc0U7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7OztBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jbGFzcy12YXJpYW5jZS1hdXRob3JpdHkvZGlzdC9pbmRleC5tanM/YTVmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcbmNvbnN0IGZhbHN5VG9TdHJpbmcgPSAodmFsdWUpPT50eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiID8gXCJcIi5jb25jYXQodmFsdWUpIDogdmFsdWUgPT09IDAgPyBcIjBcIiA6IHZhbHVlO1xuZXhwb3J0IGNvbnN0IGN4ID0gY2xzeDtcbmV4cG9ydCBjb25zdCBjdmEgPSAoYmFzZSwgY29uZmlnKT0+e1xuICAgIHJldHVybiAocHJvcHMpPT57XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGlmICgoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnZhcmlhbnRzKSA9PSBudWxsKSByZXR1cm4gY3goYmFzZSwgcHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzLmNsYXNzLCBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMuY2xhc3NOYW1lKTtcbiAgICAgICAgY29uc3QgeyB2YXJpYW50cyAsIGRlZmF1bHRWYXJpYW50cyAgfSA9IGNvbmZpZztcbiAgICAgICAgY29uc3QgZ2V0VmFyaWFudENsYXNzTmFtZXMgPSBPYmplY3Qua2V5cyh2YXJpYW50cykubWFwKCh2YXJpYW50KT0+e1xuICAgICAgICAgICAgY29uc3QgdmFyaWFudFByb3AgPSBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHNbdmFyaWFudF07XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0VmFyaWFudFByb3AgPSBkZWZhdWx0VmFyaWFudHMgPT09IG51bGwgfHwgZGVmYXVsdFZhcmlhbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWZhdWx0VmFyaWFudHNbdmFyaWFudF07XG4gICAgICAgICAgICBpZiAodmFyaWFudFByb3AgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3QgdmFyaWFudEtleSA9IGZhbHN5VG9TdHJpbmcodmFyaWFudFByb3ApIHx8IGZhbHN5VG9TdHJpbmcoZGVmYXVsdFZhcmlhbnRQcm9wKTtcbiAgICAgICAgICAgIHJldHVybiB2YXJpYW50c1t2YXJpYW50XVt2YXJpYW50S2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByb3BzV2l0aG91dFVuZGVmaW5lZCA9IHByb3BzICYmIE9iamVjdC5lbnRyaWVzKHByb3BzKS5yZWR1Y2UoKGFjYywgcGFyYW0pPT57XG4gICAgICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gcGFyYW07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICBjb25zdCBnZXRDb21wb3VuZFZhcmlhbnRDbGFzc05hbWVzID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKHJlZiA9IGNvbmZpZy5jb21wb3VuZFZhcmlhbnRzKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5yZWR1Y2UoKGFjYywgcGFyYW0xKT0+e1xuICAgICAgICAgICAgbGV0IHsgY2xhc3M6IGN2Q2xhc3MgLCBjbGFzc05hbWU6IGN2Q2xhc3NOYW1lICwgLi4uY29tcG91bmRWYXJpYW50T3B0aW9ucyB9ID0gcGFyYW0xO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGNvbXBvdW5kVmFyaWFudE9wdGlvbnMpLmV2ZXJ5KChwYXJhbSk9PntcbiAgICAgICAgICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gcGFyYW07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuaW5jbHVkZXMoe1xuICAgICAgICAgICAgICAgICAgICAuLi5kZWZhdWx0VmFyaWFudHMsXG4gICAgICAgICAgICAgICAgICAgIC4uLnByb3BzV2l0aG91dFVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH1ba2V5XSkgOiAoe1xuICAgICAgICAgICAgICAgICAgICAuLi5kZWZhdWx0VmFyaWFudHMsXG4gICAgICAgICAgICAgICAgICAgIC4uLnByb3BzV2l0aG91dFVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0pW2tleV0gPT09IHZhbHVlO1xuICAgICAgICAgICAgfSkgPyBbXG4gICAgICAgICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgICAgICAgIGN2Q2xhc3MsXG4gICAgICAgICAgICAgICAgY3ZDbGFzc05hbWVcbiAgICAgICAgICAgIF0gOiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuIGN4KGJhc2UsIGdldFZhcmlhbnRDbGFzc05hbWVzLCBnZXRDb21wb3VuZFZhcmlhbnRDbGFzc05hbWVzLCBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMuY2xhc3MsIHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wcy5jbGFzc05hbWUpO1xuICAgIH07XG59O1xuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/class-variance-authority/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/class-variance-authority/node_modules/clsx/dist/clsx.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/class-variance-authority/node_modules/clsx/dist/clsx.mjs ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: function() { return /* binding */ clsx; }\n/* harmony export */ });\nfunction r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f);else for(t in e)e[t]&&(n&&(n+=\" \"),n+=t);return n}function clsx(){for(var e,t,f=0,n=\"\";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}/* harmony default export */ __webpack_exports__[\"default\"] = (clsx);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbGFzcy12YXJpYW5jZS1hdXRob3JpdHkvbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsY0FBYyxhQUFhLCtDQUErQyx1REFBdUQsV0FBVywwQ0FBMEMseUNBQXlDLFNBQWdCLGdCQUFnQixxQkFBcUIsbUJBQW1CLGtEQUFrRCxTQUFTLCtEQUFlLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NsYXNzLXZhcmlhbmNlLWF1dGhvcml0eS9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubWpzPzhmMGMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpZm9yKHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zik7ZWxzZSBmb3IodCBpbiBlKWVbdF0mJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIjtmPGFyZ3VtZW50cy5sZW5ndGg7KShlPWFyZ3VtZW50c1tmKytdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/class-variance-authority/node_modules/clsx/dist/clsx.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs":
/*!*****************************************!*\
  !*** ./node_modules/clsx/dist/clsx.mjs ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: function() { return /* binding */ clsx; }\n/* harmony export */ });\nfunction r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}/* harmony default export */ __webpack_exports__[\"default\"] = (clsx);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGNBQWMsYUFBYSwrQ0FBK0MsZ0RBQWdELGVBQWUsUUFBUSxJQUFJLDBDQUEwQyx5Q0FBeUMsU0FBZ0IsZ0JBQWdCLHdDQUF3QyxJQUFJLG1EQUFtRCxTQUFTLCtEQUFlLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm1qcz80YmQwIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgbz1lLmxlbmd0aDtmb3IodD0wO3Q8bzt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpfWVsc2UgZm9yKGYgaW4gZSllW2ZdJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCIsbz1hcmd1bWVudHMubGVuZ3RoO2Y8bztmKyspKGU9YXJndW1lbnRzW2ZdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-web/dist/esm/ort.min.js":
/*!**********************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/esm/ort.min.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: function() { return /* binding */ Dd; },\n/* harmony export */   TRACE: function() { return /* binding */ cs; },\n/* harmony export */   TRACE_FUNC_BEGIN: function() { return /* binding */ sr; },\n/* harmony export */   TRACE_FUNC_END: function() { return /* binding */ ur; },\n/* harmony export */   Tensor: function() { return /* binding */ Re; },\n/* harmony export */   TrainingSession: function() { return /* binding */ Fd; },\n/* harmony export */   \"default\": function() { return /* binding */ XO; },\n/* harmony export */   env: function() { return /* binding */ Z; },\n/* harmony export */   registerBackend: function() { return /* binding */ Dr; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n/*!\n * ONNX Runtime Web v1.17.3\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nvar Od=Object.create;var Dn=Object.defineProperty;var Id=Object.getOwnPropertyDescriptor;var Sd=Object.getOwnPropertyNames;var Ad=Object.getPrototypeOf,Pd=Object.prototype.hasOwnProperty;var E=(a,t)=>()=>(a&&(t=a(a=0)),t);var me=(a,t)=>()=>(t||a((t={exports:{}}).exports,t),t.exports),Pr=(a,t)=>{for(var o in t)Dn(a,o,{get:t[o],enumerable:!0})},Ha=(a,t,o,e)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let r of Sd(t))!Pd.call(a,r)&&r!==o&&Dn(a,r,{get:()=>t[r],enumerable:!(e=Id(t,r))||e.enumerable});return a};var Er=(a,t,o)=>(o=a!=null?Od(Ad(a)):{},Ha(t||!a||!a.__esModule?Dn(o,\"default\",{value:a,enumerable:!0}):o,a)),or=a=>Ha(Dn({},\"__esModule\",{value:!0}),a);var Ln,ir,Dr,Ed,Fn,Cn=E(()=>{\"use strict\";Ln=new Map,ir=[],Dr=(a,t,o)=>{if(t&&typeof t.init==\"function\"&&typeof t.createInferenceSessionHandler==\"function\"){let e=Ln.get(a);if(e===void 0)Ln.set(a,{backend:t,priority:o});else{if(e.priority>o)return;if(e.priority===o&&e.backend!==t)throw new Error(`cannot register backend \"${a}\" using priority ${o}`)}if(o>=0){let r=ir.indexOf(a);r!==-1&&ir.splice(r,1);for(let n=0;n<ir.length;n++)if(Ln.get(ir[n]).priority<=o){ir.splice(n,0,a);return}ir.push(a)}return}throw new TypeError(\"not a valid backend\")},Ed=async a=>{let t=Ln.get(a);if(!t)return\"backend not found.\";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let o=!!t.initPromise;try{return o||(t.initPromise=t.backend.init(a)),await t.initPromise,t.initialized=!0,t.backend}catch(e){return o||(t.error=`${e}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},Fn=async a=>{let t=a.executionProviders||[],o=t.map(u=>typeof u==\"string\"?u:u.name),e=o.length===0?ir:o,r,n=[],s=new Set;for(let u of e){let l=await Ed(u);typeof l==\"string\"?n.push({name:u,err:l}):(r||(r=l),r===l&&s.add(u))}if(!r)throw new Error(`no available backend found. ERR: ${n.map(u=>`[${u.name}] ${u.err}`).join(\", \")}`);for(let{name:u,err:l}of n)o.includes(u)&&console.warn(`removing requested execution provider \"${u}\" from session options because it is not available: ${l}`);let i=t.filter(u=>s.has(typeof u==\"string\"?u:u.name));return[r,new Proxy(a,{get:(u,l)=>l===\"executionProviders\"?i:Reflect.get(u,l)})]}});var qa=E(()=>{\"use strict\";Cn()});var ja,Ya=E(()=>{\"use strict\";ja=\"1.17.3\"});var Xa,it,Ho=E(()=>{\"use strict\";Ya();Xa=\"warning\",it={wasm:{},webgl:{},webgpu:{},versions:{common:ja},set logLevel(a){if(a!==void 0){if(typeof a!=\"string\"||[\"verbose\",\"info\",\"warning\",\"error\",\"fatal\"].indexOf(a)===-1)throw new Error(`Unsupported logging level: ${a}`);Xa=a}},get logLevel(){return Xa}};Object.defineProperty(it,\"logLevel\",{enumerable:!0})});var Z,Ka=E(()=>{\"use strict\";Ho();Z=it});var Ja,Za,Qa=E(()=>{\"use strict\";Ja=(a,t)=>{let o=typeof document<\"u\"?document.createElement(\"canvas\"):new OffscreenCanvas(1,1);o.width=a.dims[3],o.height=a.dims[2];let e=o.getContext(\"2d\");if(e!=null){let r,n;t?.tensorLayout!==void 0&&t.tensorLayout===\"NHWC\"?(r=a.dims[2],n=a.dims[3]):(r=a.dims[3],n=a.dims[2]);let s=t?.format!==void 0?t.format:\"RGB\",i=t?.norm,u,l;i===void 0||i.mean===void 0?u=[255,255,255,255]:typeof i.mean==\"number\"?u=[i.mean,i.mean,i.mean,i.mean]:(u=[i.mean[0],i.mean[1],i.mean[2],0],i.mean[3]!==void 0&&(u[3]=i.mean[3])),i===void 0||i.bias===void 0?l=[0,0,0,0]:typeof i.bias==\"number\"?l=[i.bias,i.bias,i.bias,i.bias]:(l=[i.bias[0],i.bias[1],i.bias[2],0],i.bias[3]!==void 0&&(l[3]=i.bias[3]));let f=n*r,p=0,d=f,T=f*2,v=-1;s===\"RGBA\"?(p=0,d=f,T=f*2,v=f*3):s===\"RGB\"?(p=0,d=f,T=f*2):s===\"RBG\"&&(p=0,T=f,d=f*2);for(let w=0;w<n;w++)for(let I=0;I<r;I++){let L=(a.data[p++]-l[0])*u[0],F=(a.data[d++]-l[1])*u[1],C=(a.data[T++]-l[2])*u[2],Y=v===-1?255:(a.data[v++]-l[3])*u[3];e.fillStyle=\"rgba(\"+L+\",\"+F+\",\"+C+\",\"+Y+\")\",e.fillRect(I,w,1,1)}if(\"toDataURL\"in o)return o.toDataURL();throw new Error(\"toDataURL is not supported\")}else throw new Error(\"Can not access image data\")},Za=(a,t)=>{let o=typeof document<\"u\"?document.createElement(\"canvas\").getContext(\"2d\"):new OffscreenCanvas(1,1).getContext(\"2d\"),e;if(o!=null){let r,n,s;t?.tensorLayout!==void 0&&t.tensorLayout===\"NHWC\"?(r=a.dims[2],n=a.dims[1],s=a.dims[3]):(r=a.dims[3],n=a.dims[2],s=a.dims[1]);let i=t!==void 0&&t.format!==void 0?t.format:\"RGB\",u=t?.norm,l,f;u===void 0||u.mean===void 0?l=[255,255,255,255]:typeof u.mean==\"number\"?l=[u.mean,u.mean,u.mean,u.mean]:(l=[u.mean[0],u.mean[1],u.mean[2],255],u.mean[3]!==void 0&&(l[3]=u.mean[3])),u===void 0||u.bias===void 0?f=[0,0,0,0]:typeof u.bias==\"number\"?f=[u.bias,u.bias,u.bias,u.bias]:(f=[u.bias[0],u.bias[1],u.bias[2],0],u.bias[3]!==void 0&&(f[3]=u.bias[3]));let p=n*r;if(t!==void 0&&(t.format!==void 0&&s===4&&t.format!==\"RGBA\"||s===3&&t.format!==\"RGB\"&&t.format!==\"BGR\"))throw new Error(\"Tensor format doesn't match input tensor dims\");let d=4,T=0,v=1,w=2,I=3,L=0,F=p,C=p*2,Y=-1;i===\"RGBA\"?(L=0,F=p,C=p*2,Y=p*3):i===\"RGB\"?(L=0,F=p,C=p*2):i===\"RBG\"&&(L=0,C=p,F=p*2),e=o.createImageData(r,n);for(let j=0;j<n*r;T+=d,v+=d,w+=d,I+=d,j++)e.data[T]=(a.data[L++]-f[0])*l[0],e.data[v]=(a.data[F++]-f[1])*l[1],e.data[w]=(a.data[C++]-f[2])*l[2],e.data[I]=Y===-1?255:(a.data[Y++]-f[3])*l[3]}else throw new Error(\"Can not access image data\");return e}});var qo,es,ts,rs,ns,os=E(()=>{\"use strict\";$n();qo=(a,t)=>{if(a===void 0)throw new Error(\"Image buffer must be defined\");if(t.height===void 0||t.width===void 0)throw new Error(\"Image height and width must be defined\");if(t.tensorLayout===\"NHWC\")throw new Error(\"NHWC Tensor layout is not supported yet\");let{height:o,width:e}=t,r=t.norm??{mean:255,bias:0},n,s;typeof r.mean==\"number\"?n=[r.mean,r.mean,r.mean,r.mean]:n=[r.mean[0],r.mean[1],r.mean[2],r.mean[3]??255],typeof r.bias==\"number\"?s=[r.bias,r.bias,r.bias,r.bias]:s=[r.bias[0],r.bias[1],r.bias[2],r.bias[3]??0];let i=t.format!==void 0?t.format:\"RGBA\",u=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:\"RGB\",l=o*e,f=u===\"RGBA\"?new Float32Array(l*4):new Float32Array(l*3),p=4,d=0,T=1,v=2,w=3,I=0,L=l,F=l*2,C=-1;i===\"RGB\"&&(p=3,d=0,T=1,v=2,w=-1),u===\"RGBA\"?C=l*3:u===\"RBG\"?(I=0,F=l,L=l*2):u===\"BGR\"&&(F=0,L=l,I=l*2);for(let j=0;j<l;j++,d+=p,v+=p,T+=p,w+=p)f[I++]=(a[d]+s[0])/n[0],f[L++]=(a[T]+s[1])/n[1],f[F++]=(a[v]+s[2])/n[2],C!==-1&&w!==-1&&(f[C++]=(a[w]+s[3])/n[3]);return u===\"RGBA\"?new Xe(\"float32\",f,[1,4,o,e]):new Xe(\"float32\",f,[1,3,o,e])},es=async(a,t)=>{let o=typeof HTMLImageElement<\"u\"&&a instanceof HTMLImageElement,e=typeof ImageData<\"u\"&&a instanceof ImageData,r=typeof ImageBitmap<\"u\"&&a instanceof ImageBitmap,n=typeof a==\"string\",s,i=t??{},u=()=>{if(typeof document<\"u\")return document.createElement(\"canvas\");if(typeof OffscreenCanvas<\"u\")return new OffscreenCanvas(1,1);throw new Error(\"Canvas is not supported\")},l=f=>f instanceof HTMLCanvasElement||f instanceof OffscreenCanvas?f.getContext(\"2d\"):null;if(o){let f=u();f.width=a.width,f.height=a.height;let p=l(f);if(p!=null){let d=a.height,T=a.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(d=t.resizedHeight,T=t.resizedWidth),t!==void 0){if(i=t,t.tensorFormat!==void 0)throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");i.tensorFormat=\"RGBA\",i.height=d,i.width=T}else i.tensorFormat=\"RGBA\",i.height=d,i.width=T;p.drawImage(a,0,0),s=p.getImageData(0,0,T,d).data}else throw new Error(\"Can not access image data\")}else if(e){let f,p;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(f=t.resizedHeight,p=t.resizedWidth):(f=a.height,p=a.width),t!==void 0&&(i=t),i.format=\"RGBA\",i.height=f,i.width=p,t!==void 0){let d=u();d.width=p,d.height=f;let T=l(d);if(T!=null)T.putImageData(a,0,0),s=T.getImageData(0,0,p,f).data;else throw new Error(\"Can not access image data\")}else s=a.data}else if(r){if(t===void 0)throw new Error(\"Please provide image config with format for Imagebitmap\");let f=u();f.width=a.width,f.height=a.height;let p=l(f);if(p!=null){let d=a.height,T=a.width;return p.drawImage(a,0,0,T,d),s=p.getImageData(0,0,T,d).data,i.height=d,i.width=T,qo(s,i)}else throw new Error(\"Can not access image data\")}else{if(n)return new Promise((f,p)=>{let d=u(),T=l(d);if(!a||!T)return p();let v=new Image;v.crossOrigin=\"Anonymous\",v.src=a,v.onload=()=>{d.width=v.width,d.height=v.height,T.drawImage(v,0,0,d.width,d.height);let w=T.getImageData(0,0,d.width,d.height);i.height=d.height,i.width=d.width,f(qo(w.data,i))}});throw new Error(\"Input data provided is not supported - aborted tensor creation\")}if(s!==void 0)return qo(s,i);throw new Error(\"Input data provided is not supported - aborted tensor creation\")},ts=(a,t)=>{let{width:o,height:e,download:r,dispose:n}=t,s=[1,e,o,4];return new Xe({location:\"texture\",type:\"float32\",texture:a,dims:s,download:r,dispose:n})},rs=(a,t)=>{let{dataType:o,dims:e,download:r,dispose:n}=t;return new Xe({location:\"gpu-buffer\",type:o??\"float32\",gpuBuffer:a,dims:e,download:r,dispose:n})},ns=(a,t,o)=>new Xe({location:\"cpu-pinned\",type:a,data:t,dims:o??[t.length]})});var ar,tn,is,as,ss=E(()=>{\"use strict\";ar=new Map([[\"float32\",Float32Array],[\"uint8\",Uint8Array],[\"int8\",Int8Array],[\"uint16\",Uint16Array],[\"int16\",Int16Array],[\"int32\",Int32Array],[\"bool\",Uint8Array],[\"float64\",Float64Array],[\"uint32\",Uint32Array]]),tn=new Map([[Float32Array,\"float32\"],[Uint8Array,\"uint8\"],[Int8Array,\"int8\"],[Uint16Array,\"uint16\"],[Int16Array,\"int16\"],[Int32Array,\"int32\"],[Float64Array,\"float64\"],[Uint32Array,\"uint32\"]]),is=!1,as=()=>{if(!is){is=!0;let a=typeof BigInt64Array<\"u\"&&BigInt64Array.from,t=typeof BigUint64Array<\"u\"&&BigUint64Array.from,o=typeof Float16Array<\"u\"&&Float16Array.from;a&&(ar.set(\"int64\",BigInt64Array),tn.set(BigInt64Array,\"int64\")),t&&(ar.set(\"uint64\",BigUint64Array),tn.set(BigUint64Array,\"uint64\")),o?(ar.set(\"float16\",Float16Array),tn.set(Float16Array,\"float16\")):ar.set(\"float16\",Uint16Array)}}});var us,ls,fs=E(()=>{\"use strict\";$n();us=a=>{let t=1;for(let o=0;o<a.length;o++){let e=a[o];if(typeof e!=\"number\"||!Number.isSafeInteger(e))throw new TypeError(`dims[${o}] must be an integer, got: ${e}`);if(e<0)throw new RangeError(`dims[${o}] must be a non-negative integer, got: ${e}`);t*=e}return t},ls=(a,t)=>{switch(a.location){case\"cpu\":return new Xe(a.type,a.data,t);case\"cpu-pinned\":return new Xe({location:\"cpu-pinned\",data:a.data,type:a.type,dims:t});case\"texture\":return new Xe({location:\"texture\",texture:a.texture,type:a.type,dims:t});case\"gpu-buffer\":return new Xe({location:\"gpu-buffer\",gpuBuffer:a.gpuBuffer,type:a.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${a.location} is not supported`)}}});var Xe,$n=E(()=>{\"use strict\";Qa();os();ss();fs();Xe=class{constructor(t,o,e){as();let r,n;if(typeof t==\"object\"&&\"location\"in t)switch(this.dataLocation=t.location,r=t.type,n=t.dims,t.location){case\"cpu-pinned\":{let i=ar.get(r);if(!i)throw new TypeError(`unsupported type \"${r}\" to create tensor from pinned buffer`);if(!(t.data instanceof i))throw new TypeError(`buffer should be of type ${i.name}`);this.cpuData=t.data;break}case\"texture\":{if(r!==\"float32\")throw new TypeError(`unsupported type \"${r}\" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case\"gpu-buffer\":{if(r!==\"float32\"&&r!==\"float16\"&&r!==\"int32\"&&r!==\"int64\"&&r!==\"uint32\"&&r!==\"uint8\"&&r!==\"bool\")throw new TypeError(`unsupported type \"${r}\" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let i,u;if(typeof t==\"string\")if(r=t,u=e,t===\"string\"){if(!Array.isArray(o))throw new TypeError(\"A string tensor's data must be a string array.\");i=o}else{let l=ar.get(t);if(l===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(o)){if(t===\"float16\"&&l===Uint16Array)throw new TypeError(\"Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.\");t===\"uint64\"||t===\"int64\"?i=l.from(o,BigInt):i=l.from(o)}else if(o instanceof l)i=o;else throw new TypeError(`A ${r} tensor's data must be type of ${l}`)}else if(u=o,Array.isArray(t)){if(t.length===0)throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");let l=typeof t[0];if(l===\"string\")r=\"string\",i=t;else if(l===\"boolean\")r=\"bool\",i=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${l}.`)}else{let l=tn.get(t.constructor);if(l===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);r=l,i=t}if(u===void 0)u=[i.length];else if(!Array.isArray(u))throw new TypeError(\"A tensor's dims must be a number array\");n=u,this.cpuData=i,this.dataLocation=\"cpu\"}let s=us(n);if(this.cpuData&&s!==this.cpuData.length)throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=n,this.size=s}static async fromImage(t,o){return es(t,o)}static fromTexture(t,o){return ts(t,o)}static fromGpuBuffer(t,o){return rs(t,o)}static fromPinnedBuffer(t,o,e){return ns(t,o,e)}toDataURL(t){return Ja(this,t)}toImageData(t){return Za(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error(\"The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.\");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error(\"The data is not stored as a WebGL texture.\");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error(\"The data is not stored as a WebGPU buffer.\");return this.gpuBufferData}async getData(t){switch(this.ensureValid(),this.dataLocation){case\"cpu\":case\"cpu-pinned\":return this.data;case\"texture\":case\"gpu-buffer\":{if(!this.downloader)throw new Error(\"The current tensor is not created with a specified data downloader.\");if(this.isDownloading)throw new Error(\"The current tensor is being downloaded.\");try{this.isDownloading=!0;let o=await this.downloader();return this.downloader=void 0,this.dataLocation=\"cpu\",this.cpuData=o,t&&this.disposer&&(this.disposer(),this.disposer=void 0),o}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error(\"The current tensor is being downloaded.\");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation=\"none\"}ensureValid(){if(this.dataLocation===\"none\")throw new Error(\"The tensor is disposed.\")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error(\"Cannot reshape a tensor that owns GPU resource.\");return ls(this,t)}}});var Re,kn=E(()=>{\"use strict\";$n();Re=Xe});var cs,ps,sr,ur,jo=E(()=>{\"use strict\";Ho();cs=(a,t)=>{(typeof it.trace>\"u\"?!it.wasm.trace:!it.trace)||console.timeStamp(`${a}::ORT::${t}`)},ps=(a,t)=>{let o=new Error().stack?.split(/\\r\\n|\\r|\\n/g)||[],e=!1;for(let r=0;r<o.length;r++){if(e&&!o[r].includes(\"TRACE_FUNC\")){let n=`FUNC_${a}::${o[r].trim().split(\" \")[1]}`;t&&(n+=`::${t}`),cs(\"CPU\",n);return}o[r].includes(\"TRACE_FUNC\")&&(e=!0)}},sr=a=>{(typeof it.trace>\"u\"?!it.wasm.trace:!it.trace)||ps(\"BEGIN\",a)},ur=a=>{(typeof it.trace>\"u\"?!it.wasm.trace:!it.trace)||ps(\"END\",a)}});var Bn,ds=E(()=>{\"use strict\";Cn();kn();jo();Bn=class a{constructor(t){this.handler=t}async run(t,o,e){sr();let r={},n={};if(typeof t!=\"object\"||t===null||t instanceof Re||Array.isArray(t))throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");let s=!0;if(typeof o==\"object\"){if(o===null)throw new TypeError(\"Unexpected argument[1]: cannot be null.\");if(o instanceof Re)throw new TypeError(\"'fetches' cannot be a Tensor\");if(Array.isArray(o)){if(o.length===0)throw new TypeError(\"'fetches' cannot be an empty array.\");s=!1;for(let l of o){if(typeof l!=\"string\")throw new TypeError(\"'fetches' must be a string array or an object.\");if(this.outputNames.indexOf(l)===-1)throw new RangeError(`'fetches' contains invalid output name: ${l}.`);r[l]=null}if(typeof e==\"object\"&&e!==null)n=e;else if(typeof e<\"u\")throw new TypeError(\"'options' must be an object.\")}else{let l=!1,f=Object.getOwnPropertyNames(o);for(let p of this.outputNames)if(f.indexOf(p)!==-1){let d=o[p];(d===null||d instanceof Re)&&(l=!0,s=!1,r[p]=d)}if(l){if(typeof e==\"object\"&&e!==null)n=e;else if(typeof e<\"u\")throw new TypeError(\"'options' must be an object.\")}else n=o}}else if(typeof o<\"u\")throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");for(let l of this.inputNames)if(typeof t[l]>\"u\")throw new Error(`input '${l}' is missing in 'feeds'.`);if(s)for(let l of this.outputNames)r[l]=null;let i=await this.handler.run(t,r,n),u={};for(let l in i)if(Object.hasOwnProperty.call(i,l)){let f=i[l];f instanceof Re?u[l]=f:u[l]=new Re(f.type,f.data,f.dims)}return ur(),u}async release(){return this.handler.dispose()}static async create(t,o,e,r){sr();let n,s={};if(typeof t==\"string\"){if(n=t,typeof o==\"object\"&&o!==null)s=o;else if(typeof o<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(t instanceof Uint8Array){if(n=t,typeof o==\"object\"&&o!==null)s=o;else if(typeof o<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<\"u\"&&t instanceof SharedArrayBuffer){let f=t,p=0,d=t.byteLength;if(typeof o==\"object\"&&o!==null)s=o;else if(typeof o==\"number\"){if(p=o,!Number.isSafeInteger(p))throw new RangeError(\"'byteOffset' must be an integer.\");if(p<0||p>=f.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${f.byteLength}).`);if(d=t.byteLength-p,typeof e==\"number\"){if(d=e,!Number.isSafeInteger(d))throw new RangeError(\"'byteLength' must be an integer.\");if(d<=0||p+d>f.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${f.byteLength-p}].`);if(typeof r==\"object\"&&r!==null)s=r;else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(typeof e<\"u\")throw new TypeError(\"'byteLength' must be a number.\")}else if(typeof o<\"u\")throw new TypeError(\"'options' must be an object.\");n=new Uint8Array(f,p,d)}else throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");let[i,u]=await Fn(s),l=await i.createInferenceSessionHandler(n,u);return ur(),new a(l)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var Dd,hs=E(()=>{\"use strict\";ds();Dd=Bn});var ms=E(()=>{\"use strict\"});var bs=E(()=>{\"use strict\"});var gs=E(()=>{\"use strict\"});var ys=E(()=>{\"use strict\"});var Ld,Nn,Ts=E(()=>{\"use strict\";Cn();kn();Ld=\"Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.\",Nn=class a{constructor(t,o,e){this.handler=t,this.hasOptimizerModel=o,this.hasEvalModel=e}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error(\"This training session has no evalModel loaded.\")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error(\"This training session has no evalModel loaded.\")}static async create(t,o){let e=t.evalModel||\"\",r=t.optimizerModel||\"\",n=o||{},[s,i]=await Fn(n);if(s.createTrainingSessionHandler){let u=await s.createTrainingSessionHandler(t.checkpointState,t.trainModel,e,r,i);return new a(u,!!t.optimizerModel,!!t.evalModel)}else throw new Error(Ld)}typeNarrowingForRunStep(t,o,e,r,n){let s={},i={};if(typeof e!=\"object\"||e===null||e instanceof Re||Array.isArray(e))throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");let u=!0;if(typeof r==\"object\"){if(r===null)throw new TypeError(\"Unexpected argument[1]: cannot be null.\");if(r instanceof Re)throw new TypeError(\"'fetches' cannot be a Tensor\");if(Array.isArray(r)){if(r.length===0)throw new TypeError(\"'fetches' cannot be an empty array.\");u=!1;for(let l of r){if(typeof l!=\"string\")throw new TypeError(\"'fetches' must be a string array or an object.\");if(o.indexOf(l)===-1)throw new RangeError(`'fetches' contains invalid output name: ${l}.`);s[l]=null}if(typeof n==\"object\"&&n!==null)i=n;else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\")}else{let l=!1,f=Object.getOwnPropertyNames(r);for(let p of o)if(f.indexOf(p)!==-1){let d=r[p];(d===null||d instanceof Re)&&(l=!0,u=!1,s[p]=d)}if(l){if(typeof n==\"object\"&&n!==null)i=n;else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\")}else i=r}}else if(typeof r<\"u\")throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");for(let l of t)if(typeof e[l]>\"u\")throw new Error(`input '${l}' is missing in 'feeds'.`);if(u)for(let l of o)s[l]=null;return[s,i]}convertHandlerReturnTypeToMapOfTensors(t){let o={};for(let e in t)if(Object.hasOwnProperty.call(t,e)){let r=t[e];r instanceof Re?o[e]=r:o[e]=new Re(r.type,r.data,r.dims)}return o}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(t,o,e){let[r,n]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,t,o,e),s=await this.handler.runTrainStep(t,r,n);return this.convertHandlerReturnTypeToMapOfTensors(s)}async runOptimizerStep(t){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(t||{});else throw new Error(\"This TrainingSession has no OptimizerModel loaded.\")}async runEvalStep(t,o,e){if(this.hasEvalModel){let[r,n]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,t,o,e),s=await this.handler.runEvalStep(t,r,n);return this.convertHandlerReturnTypeToMapOfTensors(s)}else throw new Error(\"This TrainingSession has no EvalModel loaded.\")}async getParametersSize(t=!0){return this.handler.getParametersSize(t)}async loadParametersBuffer(t,o=!0){let e=await this.getParametersSize(o);if(t.length!==4*e)throw new Error(\"Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.\");return this.handler.loadParametersBuffer(t,o)}async getContiguousParameters(t=!0){return this.handler.getContiguousParameters(t)}async release(){return this.handler.dispose()}}});var Fd,xs=E(()=>{\"use strict\";Ts();Fd=Nn});var Yo={};Pr(Yo,{InferenceSession:()=>Dd,TRACE:()=>cs,TRACE_FUNC_BEGIN:()=>sr,TRACE_FUNC_END:()=>ur,Tensor:()=>Re,TrainingSession:()=>Fd,env:()=>Z,registerBackend:()=>Dr});var Tt=E(()=>{\"use strict\";qa();Ka();hs();kn();ms();bs();jo();gs();ys();xs()});function jt(a,t,o,e){if(t===void 0)return $d(a);if(o===void 0)Rn(a,t,1);else if(typeof o==\"number\"&&e===void 0)Rn(a,t,o);else if(typeof o==\"string\"&&e===void 0)Rn(a,o,1,t);else if(typeof o==\"string\"&&typeof e==\"number\")Rn(a,o,e,t);else throw new TypeError(\"input is valid\")}function $d(a){return{verbose:jt.verbose.bind(null,a),info:jt.info.bind(null,a),warning:jt.warning.bind(null,a),error:jt.error.bind(null,a),fatal:jt.fatal.bind(null,a)}}function Rn(a,t,o,e){let r=rn[e||\"\"]||rn[\"\"];vs[a]<vs[r.minimalSeverity]||(r.logDateTime&&(t=`${new Date().toISOString()}|${t}`),r.logSourceLocation,Cd[r.provider].log(a,t,e))}var Xo,Ko,vs,Cd,_s,rn,ce,Gn,Un,zn,Mn,at=E(()=>{\"use strict\";Xo=class{log(t,o,e){}},Ko=class{log(t,o,e){console.log(`${this.color(t)} ${e?\"\\x1B[35m\"+e+\"\\x1B[0m \":\"\"}${o}`)}color(t){switch(t){case\"verbose\":return\"\\x1B[34;40mv\\x1B[0m\";case\"info\":return\"\\x1B[32mi\\x1B[0m\";case\"warning\":return\"\\x1B[30;43mw\\x1B[0m\";case\"error\":return\"\\x1B[31;40me\\x1B[0m\";case\"fatal\":return\"\\x1B[101mf\\x1B[0m\";default:throw new Error(`unsupported severity: ${t}`)}}},vs={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},Cd={none:new Xo,console:new Ko},_s={provider:\"console\",minimalSeverity:\"warning\",logDateTime:!0,logSourceLocation:!1},rn={\"\":_s};(u=>{function a(l,f){u(\"verbose\",l,f)}u.verbose=a;function t(l,f){u(\"info\",l,f)}u.info=t;function o(l,f){u(\"warning\",l,f)}u.warning=o;function e(l,f){u(\"error\",l,f)}u.error=e;function r(l,f){u(\"fatal\",l,f)}u.fatal=r;function n(l){rn={},s(\"\",l||{})}u.reset=n;function s(l,f){if(l===\"*\")n(f);else{let p=rn[l]||_s;rn[l]={provider:f.provider||p.provider,minimalSeverity:f.minimalSeverity||p.minimalSeverity,logDateTime:f.logDateTime===void 0?p.logDateTime:f.logDateTime,logSourceLocation:f.logSourceLocation===void 0?p.logSourceLocation:f.logSourceLocation}}}u.set=s;function i(l){let f={};l.logLevel&&(f.minimalSeverity=l.logLevel),s(\"\",f)}u.setWithEnv=i})(jt||={});ce=jt,Gn=class{constructor(t,o,e,r,n,s){this.category=t;this.name=o;this.startTime=e;this.endCallback=r;this.timer=n;this.ctx=s}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error(\"No webgl timer found\");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}},Un=class{constructor(t,o,e,r){this.category=t;this.name=o;this.startTime=e;this.endTime=r}},zn=class{constructor(t,o,e){this._started=!1;this._flushPointer=0;this._started=!1,this._maxNumberEvents=t===void 0?1e4:t,this._flushBatchSize=o===void 0?10:o,this._flushIntervalInMilliseconds=e===void 0?5e3:e}static create(t){return t===void 0?new this:new this(t.maxNumberEvents,t.flushBatchSize,t.flushIntervalInMilliseconds)}start(){this._started=!0,this._timingEvents=[],this._flushTime=Mn(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(t,o,e,r){let n=this._started?this.begin(t,o,r):void 0,s=!1,i=e();if(i&&typeof i.then==\"function\")return s=!0,new Promise((u,l)=>{i.then(async f=>{n&&await n.end(),u(f)},async f=>{n&&await n.end(),l(f)})});if(!s&&n){let u=n.end();if(u&&typeof u.then==\"function\")return new Promise((l,f)=>{u.then(()=>{l(i)},p=>{f(p)})})}return i}begin(t,o,e){if(!this._started)throw new Error(\"profiler is not started yet\");if(e===void 0){let r=Mn();return this.flush(r),new Gn(t,o,r,n=>this.endSync(n))}else{let r=e.beginTimer();return new Gn(t,o,0,async n=>this.end(n),r,e)}}async end(t){let o=await t.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new Un(t.category,t.name,t.startTime,o)),this.flush(o))}endSync(t){let o=Mn();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new Un(t.category,t.name,t.startTime,o)),this.flush(o))}logOneEvent(t){ce.verbose(`Profiler.${t.category}`,`${(t.endTime-t.startTime).toFixed(2)}ms on event '${t.name}' at ${t.endTime.toFixed(2)}`)}flush(t){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||t-this._flushTime>=this._flushIntervalInMilliseconds){for(let o=this._flushPointer;this._flushPointer<o+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=Mn()}}get started(){return this._started}},Mn=typeof performance<\"u\"&&performance.now?()=>performance.now():Date.now});function Os(a,t,o){for(let e of o){let r=e[0],n=e[1],s=e[2],i=e[3],u=e[4];if(a.opType===r){for(let l of t)if((l.domain===n||l.domain===\"ai.onnx\"&&n===\"\")&&kd(l.version,s))return{opImpl:i,opInit:u}}}throw new TypeError(`cannot resolve operator '${a.opType}' with opsets: ${t.map(e=>`${e.domain||\"ai.onnx\"} v${e.version}`).join(\", \")}`)}function kd(a,t){if(t.endsWith(\"+\")){let o=Number.parseInt(t.substring(0,t.length-1),10);return!isNaN(o)&&o<=a}else if(t.split(\"-\").length===2){let o=t.split(\"-\"),e=Number.parseInt(o[0],10),r=Number.parseInt(o[1],10);return!isNaN(e)&&!isNaN(r)&&e<=a&&a<=r}else return Number.parseInt(t,10)===a}var Is=E(()=>{\"use strict\"});var Ss=me(Jo=>{\"use strict\";Jo.__esModule=!0;var Bd=function(){function a(t){if(!t)throw new TypeError(\"Invalid argument; `value` has no value.\");this.value=a.EMPTY,t&&a.isGuid(t)&&(this.value=t)}return a.isGuid=function(t){var o=t.toString();return t&&(t instanceof a||a.validator.test(o))},a.create=function(){return new a([a.gen(2),a.gen(1),a.gen(1),a.gen(1),a.gen(3)].join(\"-\"))},a.createEmpty=function(){return new a(\"emptyguid\")},a.parse=function(t){return new a(t)},a.raw=function(){return[a.gen(2),a.gen(1),a.gen(1),a.gen(1),a.gen(3)].join(\"-\")},a.gen=function(t){for(var o=\"\",e=0;e<t;e++)o+=((1+Math.random())*65536|0).toString(16).substring(1);return o},a.prototype.equals=function(t){return a.isGuid(t)&&this.value===t.toString()},a.prototype.isEmpty=function(){return this.value===a.EMPTY},a.prototype.toString=function(){return this.value},a.prototype.toJSON=function(){return{value:this.value}},a.validator=new RegExp(\"^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$\",\"i\"),a.EMPTY=\"00000000-0000-0000-0000-000000000000\",a}();Jo.Guid=Bd});function be(a,t,o){this.low=a|0,this.high=t|0,this.unsigned=!!o}function je(a){return(a&&a.__isLong__)===!0}function As(a){var t=Math.clz32(a&-a);return a?31-t:t}function lr(a,t){var o,e,r;return t?(a>>>=0,(r=0<=a&&a<256)&&(e=Es[a],e)?e:(o=le(a,0,!0),r&&(Es[a]=o),o)):(a|=0,(r=-128<=a&&a<128)&&(e=Ps[a],e)?e:(o=le(a,a<0?-1:0,!1),r&&(Ps[a]=o),o))}function ut(a,t){if(isNaN(a))return t?Vt:xt;if(t){if(a<0)return Vt;if(a>=Cs)return Bs}else{if(a<=-Ls)return tt;if(a+1>=Ls)return ks}return a<0?ut(-a,t).neg():le(a%Fr|0,a/Fr|0,t)}function le(a,t,o){return new be(a,t,o)}function Qo(a,t,o){if(a.length===0)throw Error(\"empty string\");if(typeof t==\"number\"?(o=t,t=!1):t=!!t,a===\"NaN\"||a===\"Infinity\"||a===\"+Infinity\"||a===\"-Infinity\")return t?Vt:xt;if(o=o||10,o<2||36<o)throw RangeError(\"radix\");var e;if((e=a.indexOf(\"-\"))>0)throw Error(\"interior hyphen\");if(e===0)return Qo(a.substring(1),t,o).neg();for(var r=ut(Vn(o,8)),n=xt,s=0;s<a.length;s+=8){var i=Math.min(8,a.length-s),u=parseInt(a.substring(s,s+i),o);if(i<8){var l=ut(Vn(o,i));n=n.mul(l).add(ut(u))}else n=n.mul(r),n=n.add(ut(u))}return n.unsigned=t,n}function wt(a,t){return typeof a==\"number\"?ut(a,t):typeof a==\"string\"?Qo(a,t):le(a.low,a.high,typeof t==\"boolean\"?t:a.unsigned)}var st,Ps,Es,Vn,Ds,Nd,Fr,Cs,Ls,Fs,xt,Vt,Lr,$s,Zo,ks,Bs,tt,$,Wt,ei=E(()=>{st=null;try{st=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}be.prototype.__isLong__;Object.defineProperty(be.prototype,\"__isLong__\",{value:!0});be.isLong=je;Ps={},Es={};be.fromInt=lr;be.fromNumber=ut;be.fromBits=le;Vn=Math.pow;be.fromString=Qo;be.fromValue=wt;Ds=65536,Nd=1<<24,Fr=Ds*Ds,Cs=Fr*Fr,Ls=Cs/2,Fs=lr(Nd),xt=lr(0);be.ZERO=xt;Vt=lr(0,!0);be.UZERO=Vt;Lr=lr(1);be.ONE=Lr;$s=lr(1,!0);be.UONE=$s;Zo=lr(-1);be.NEG_ONE=Zo;ks=le(-1,2147483647,!1);be.MAX_VALUE=ks;Bs=le(-1,-1,!0);be.MAX_UNSIGNED_VALUE=Bs;tt=le(0,-2147483648,!1);be.MIN_VALUE=tt;$=be.prototype;$.toInt=function(){return this.unsigned?this.low>>>0:this.low};$.toNumber=function(){return this.unsigned?(this.high>>>0)*Fr+(this.low>>>0):this.high*Fr+(this.low>>>0)};$.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError(\"radix\");if(this.isZero())return\"0\";if(this.isNegative())if(this.eq(tt)){var o=ut(t),e=this.div(o),r=e.mul(o).sub(this);return e.toString(t)+r.toInt().toString(t)}else return\"-\"+this.neg().toString(t);for(var n=ut(Vn(t,6),this.unsigned),s=this,i=\"\";;){var u=s.div(n),l=s.sub(u.mul(n)).toInt()>>>0,f=l.toString(t);if(s=u,s.isZero())return f+i;for(;f.length<6;)f=\"0\"+f;i=\"\"+f+i}};$.getHighBits=function(){return this.high};$.getHighBitsUnsigned=function(){return this.high>>>0};$.getLowBits=function(){return this.low};$.getLowBitsUnsigned=function(){return this.low>>>0};$.getNumBitsAbs=function(){if(this.isNegative())return this.eq(tt)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,o=31;o>0&&!(t&1<<o);o--);return this.high!=0?o+33:o+1};$.isZero=function(){return this.high===0&&this.low===0};$.eqz=$.isZero;$.isNegative=function(){return!this.unsigned&&this.high<0};$.isPositive=function(){return this.unsigned||this.high>=0};$.isOdd=function(){return(this.low&1)===1};$.isEven=function(){return(this.low&1)===0};$.equals=function(t){return je(t)||(t=wt(t)),this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1?!1:this.high===t.high&&this.low===t.low};$.eq=$.equals;$.notEquals=function(t){return!this.eq(t)};$.neq=$.notEquals;$.ne=$.notEquals;$.lessThan=function(t){return this.comp(t)<0};$.lt=$.lessThan;$.lessThanOrEqual=function(t){return this.comp(t)<=0};$.lte=$.lessThanOrEqual;$.le=$.lessThanOrEqual;$.greaterThan=function(t){return this.comp(t)>0};$.gt=$.greaterThan;$.greaterThanOrEqual=function(t){return this.comp(t)>=0};$.gte=$.greaterThanOrEqual;$.ge=$.greaterThanOrEqual;$.compare=function(t){if(je(t)||(t=wt(t)),this.eq(t))return 0;var o=this.isNegative(),e=t.isNegative();return o&&!e?-1:!o&&e?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1};$.comp=$.compare;$.negate=function(){return!this.unsigned&&this.eq(tt)?tt:this.not().add(Lr)};$.neg=$.negate;$.add=function(t){je(t)||(t=wt(t));var o=this.high>>>16,e=this.high&65535,r=this.low>>>16,n=this.low&65535,s=t.high>>>16,i=t.high&65535,u=t.low>>>16,l=t.low&65535,f=0,p=0,d=0,T=0;return T+=n+l,d+=T>>>16,T&=65535,d+=r+u,p+=d>>>16,d&=65535,p+=e+i,f+=p>>>16,p&=65535,f+=o+s,f&=65535,le(d<<16|T,f<<16|p,this.unsigned)};$.subtract=function(t){return je(t)||(t=wt(t)),this.add(t.neg())};$.sub=$.subtract;$.multiply=function(t){if(this.isZero())return this;if(je(t)||(t=wt(t)),st){var o=st.mul(this.low,this.high,t.low,t.high);return le(o,st.get_high(),this.unsigned)}if(t.isZero())return this.unsigned?Vt:xt;if(this.eq(tt))return t.isOdd()?tt:xt;if(t.eq(tt))return this.isOdd()?tt:xt;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(Fs)&&t.lt(Fs))return ut(this.toNumber()*t.toNumber(),this.unsigned);var e=this.high>>>16,r=this.high&65535,n=this.low>>>16,s=this.low&65535,i=t.high>>>16,u=t.high&65535,l=t.low>>>16,f=t.low&65535,p=0,d=0,T=0,v=0;return v+=s*f,T+=v>>>16,v&=65535,T+=n*f,d+=T>>>16,T&=65535,T+=s*l,d+=T>>>16,T&=65535,d+=r*f,p+=d>>>16,d&=65535,d+=n*l,p+=d>>>16,d&=65535,d+=s*u,p+=d>>>16,d&=65535,p+=e*f+r*l+n*u+s*i,p&=65535,le(T<<16|v,p<<16|d,this.unsigned)};$.mul=$.multiply;$.divide=function(t){if(je(t)||(t=wt(t)),t.isZero())throw Error(\"division by zero\");if(st){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var o=(this.unsigned?st.div_u:st.div_s)(this.low,this.high,t.low,t.high);return le(o,st.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Vt:xt;var e,r,n;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return Vt;if(t.gt(this.shru(1)))return $s;n=Vt}else{if(this.eq(tt)){if(t.eq(Lr)||t.eq(Zo))return tt;if(t.eq(tt))return Lr;var s=this.shr(1);return e=s.div(t).shl(1),e.eq(xt)?t.isNegative()?Lr:Zo:(r=this.sub(t.mul(e)),n=e.add(r.div(t)),n)}else if(t.eq(tt))return this.unsigned?Vt:xt;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();n=xt}for(r=this;r.gte(t);){e=Math.max(1,Math.floor(r.toNumber()/t.toNumber()));for(var i=Math.ceil(Math.log(e)/Math.LN2),u=i<=48?1:Vn(2,i-48),l=ut(e),f=l.mul(t);f.isNegative()||f.gt(r);)e-=u,l=ut(e,this.unsigned),f=l.mul(t);l.isZero()&&(l=Lr),n=n.add(l),r=r.sub(f)}return n};$.div=$.divide;$.modulo=function(t){if(je(t)||(t=wt(t)),st){var o=(this.unsigned?st.rem_u:st.rem_s)(this.low,this.high,t.low,t.high);return le(o,st.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};$.mod=$.modulo;$.rem=$.modulo;$.not=function(){return le(~this.low,~this.high,this.unsigned)};$.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32};$.clz=$.countLeadingZeros;$.countTrailingZeros=function(){return this.low?As(this.low):As(this.high)+32};$.ctz=$.countTrailingZeros;$.and=function(t){return je(t)||(t=wt(t)),le(this.low&t.low,this.high&t.high,this.unsigned)};$.or=function(t){return je(t)||(t=wt(t)),le(this.low|t.low,this.high|t.high,this.unsigned)};$.xor=function(t){return je(t)||(t=wt(t)),le(this.low^t.low,this.high^t.high,this.unsigned)};$.shiftLeft=function(t){return je(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?le(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):le(0,this.low<<t-32,this.unsigned)};$.shl=$.shiftLeft;$.shiftRight=function(t){return je(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?le(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):le(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};$.shr=$.shiftRight;$.shiftRightUnsigned=function(t){return je(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?le(this.low>>>t|this.high<<32-t,this.high>>>t,this.unsigned):t===32?le(this.high,0,this.unsigned):le(this.high>>>t-32,0,this.unsigned)};$.shru=$.shiftRightUnsigned;$.shr_u=$.shiftRightUnsigned;$.rotateLeft=function(t){var o;return je(t)&&(t=t.toInt()),(t&=63)===0?this:t===32?le(this.high,this.low,this.unsigned):t<32?(o=32-t,le(this.low<<t|this.high>>>o,this.high<<t|this.low>>>o,this.unsigned)):(t-=32,o=32-t,le(this.high<<t|this.low>>>o,this.low<<t|this.high>>>o,this.unsigned))};$.rotl=$.rotateLeft;$.rotateRight=function(t){var o;return je(t)&&(t=t.toInt()),(t&=63)===0?this:t===32?le(this.high,this.low,this.unsigned):t<32?(o=32-t,le(this.high<<o|this.low>>>t,this.low<<o|this.high>>>t,this.unsigned)):(t-=32,o=32-t,le(this.low<<o|this.high>>>t,this.high<<o|this.low>>>t,this.unsigned))};$.rotr=$.rotateRight;$.toSigned=function(){return this.unsigned?le(this.low,this.high,!1):this};$.toUnsigned=function(){return this.unsigned?this:le(this.low,this.high,!0)};$.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()};$.toBytesLE=function(){var t=this.high,o=this.low;return[o&255,o>>>8&255,o>>>16&255,o>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};$.toBytesBE=function(){var t=this.high,o=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,o>>>24,o>>>16&255,o>>>8&255,o&255]};be.fromBytes=function(t,o,e){return e?be.fromBytesLE(t,o):be.fromBytesBE(t,o)};be.fromBytesLE=function(t,o){return new be(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,o)};be.fromBytesBE=function(t,o){return new be(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],o)};Wt=be});var O,Wn=E(()=>{O={};O.Offset;O.Table;O.SIZEOF_SHORT=2;O.SIZEOF_INT=4;O.FILE_IDENTIFIER_LENGTH=4;O.SIZE_PREFIX_LENGTH=4;O.Encoding={UTF8_BYTES:1,UTF16_STRING:2};O.int32=new Int32Array(2);O.float32=new Float32Array(O.int32.buffer);O.float64=new Float64Array(O.int32.buffer);O.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1;O.Long=function(a,t){this.low=a|0,this.high=t|0};O.Long.create=function(a,t){return a==0&&t==0?O.Long.ZERO:new O.Long(a,t)};O.Long.prototype.toFloat64=function(){return(this.low>>>0)+this.high*4294967296};O.Long.prototype.equals=function(a){return this.low==a.low&&this.high==a.high};O.Long.ZERO=new O.Long(0,0);O.Builder=function(a){if(a)var t=a;else var t=1024;this.bb=O.ByteBuffer.allocate(t),this.space=t,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1};O.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1};O.Builder.prototype.forceDefaults=function(a){this.force_defaults=a};O.Builder.prototype.dataBuffer=function(){return this.bb};O.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())};O.Builder.prototype.prep=function(a,t){a>this.minalign&&(this.minalign=a);for(var o=~(this.bb.capacity()-this.space+t)+1&a-1;this.space<o+a+t;){var e=this.bb.capacity();this.bb=O.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-e}this.pad(o)};O.Builder.prototype.pad=function(a){for(var t=0;t<a;t++)this.bb.writeInt8(--this.space,0)};O.Builder.prototype.writeInt8=function(a){this.bb.writeInt8(this.space-=1,a)};O.Builder.prototype.writeInt16=function(a){this.bb.writeInt16(this.space-=2,a)};O.Builder.prototype.writeInt32=function(a){this.bb.writeInt32(this.space-=4,a)};O.Builder.prototype.writeInt64=function(a){this.bb.writeInt64(this.space-=8,a)};O.Builder.prototype.writeFloat32=function(a){this.bb.writeFloat32(this.space-=4,a)};O.Builder.prototype.writeFloat64=function(a){this.bb.writeFloat64(this.space-=8,a)};O.Builder.prototype.addInt8=function(a){this.prep(1,0),this.writeInt8(a)};O.Builder.prototype.addInt16=function(a){this.prep(2,0),this.writeInt16(a)};O.Builder.prototype.addInt32=function(a){this.prep(4,0),this.writeInt32(a)};O.Builder.prototype.addInt64=function(a){this.prep(8,0),this.writeInt64(a)};O.Builder.prototype.addFloat32=function(a){this.prep(4,0),this.writeFloat32(a)};O.Builder.prototype.addFloat64=function(a){this.prep(8,0),this.writeFloat64(a)};O.Builder.prototype.addFieldInt8=function(a,t,o){(this.force_defaults||t!=o)&&(this.addInt8(t),this.slot(a))};O.Builder.prototype.addFieldInt16=function(a,t,o){(this.force_defaults||t!=o)&&(this.addInt16(t),this.slot(a))};O.Builder.prototype.addFieldInt32=function(a,t,o){(this.force_defaults||t!=o)&&(this.addInt32(t),this.slot(a))};O.Builder.prototype.addFieldInt64=function(a,t,o){(this.force_defaults||!t.equals(o))&&(this.addInt64(t),this.slot(a))};O.Builder.prototype.addFieldFloat32=function(a,t,o){(this.force_defaults||t!=o)&&(this.addFloat32(t),this.slot(a))};O.Builder.prototype.addFieldFloat64=function(a,t,o){(this.force_defaults||t!=o)&&(this.addFloat64(t),this.slot(a))};O.Builder.prototype.addFieldOffset=function(a,t,o){(this.force_defaults||t!=o)&&(this.addOffset(t),this.slot(a))};O.Builder.prototype.addFieldStruct=function(a,t,o){t!=o&&(this.nested(t),this.slot(a))};O.Builder.prototype.nested=function(a){if(a!=this.offset())throw new Error(\"FlatBuffers: struct must be serialized inline.\")};O.Builder.prototype.notNested=function(){if(this.isNested)throw new Error(\"FlatBuffers: object serialization must not be nested.\")};O.Builder.prototype.slot=function(a){this.vtable[a]=this.offset()};O.Builder.prototype.offset=function(){return this.bb.capacity()-this.space};O.Builder.growByteBuffer=function(a){var t=a.capacity();if(t&3221225472)throw new Error(\"FlatBuffers: cannot grow buffer beyond 2 gigabytes.\");var o=t<<1,e=O.ByteBuffer.allocate(o);return e.setPosition(o-t),e.bytes().set(a.bytes(),o-t),e};O.Builder.prototype.addOffset=function(a){this.prep(O.SIZEOF_INT,0),this.writeInt32(this.offset()-a+O.SIZEOF_INT)};O.Builder.prototype.startObject=function(a){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=a;for(var t=0;t<a;t++)this.vtable[t]=0;this.isNested=!0,this.object_start=this.offset()};O.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error(\"FlatBuffers: endObject called without startObject\");this.addInt32(0);for(var a=this.offset(),t=this.vtable_in_use-1;t>=0&&this.vtable[t]==0;t--);for(var o=t+1;t>=0;t--)this.addInt16(this.vtable[t]!=0?a-this.vtable[t]:0);var e=2;this.addInt16(a-this.object_start);var r=(o+e)*O.SIZEOF_SHORT;this.addInt16(r);var n=0,s=this.space;e:for(t=0;t<this.vtables.length;t++){var i=this.bb.capacity()-this.vtables[t];if(r==this.bb.readInt16(i)){for(var u=O.SIZEOF_SHORT;u<r;u+=O.SIZEOF_SHORT)if(this.bb.readInt16(s+u)!=this.bb.readInt16(i+u))continue e;n=this.vtables[t];break}}return n?(this.space=this.bb.capacity()-a,this.bb.writeInt32(this.space,n-a)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-a,this.offset()-a)),this.isNested=!1,a};O.Builder.prototype.finish=function(a,t,o){var e=o?O.SIZE_PREFIX_LENGTH:0;if(t){var r=t;if(this.prep(this.minalign,O.SIZEOF_INT+O.FILE_IDENTIFIER_LENGTH+e),r.length!=O.FILE_IDENTIFIER_LENGTH)throw new Error(\"FlatBuffers: file identifier must be length \"+O.FILE_IDENTIFIER_LENGTH);for(var n=O.FILE_IDENTIFIER_LENGTH-1;n>=0;n--)this.writeInt8(r.charCodeAt(n))}this.prep(this.minalign,O.SIZEOF_INT+e),this.addOffset(a),e&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)};O.Builder.prototype.finishSizePrefixed=function(a,t){this.finish(a,t,!0)};O.Builder.prototype.requiredField=function(a,t){var o=this.bb.capacity()-a,e=o-this.bb.readInt32(o),r=this.bb.readInt16(e+t)!=0;if(!r)throw new Error(\"FlatBuffers: field \"+t+\" must be set\")};O.Builder.prototype.startVector=function(a,t,o){this.notNested(),this.vector_num_elems=t,this.prep(O.SIZEOF_INT,a*t),this.prep(o,a*t)};O.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()};O.Builder.prototype.createString=function(a){if(a instanceof Uint8Array)var t=a;else for(var t=[],o=0;o<a.length;){var e,r=a.charCodeAt(o++);if(r<55296||r>=56320)e=r;else{var n=a.charCodeAt(o++);e=(r<<10)+n+(65536-56623104-56320)}e<128?t.push(e):(e<2048?t.push(e>>6&31|192):(e<65536?t.push(e>>12&15|224):t.push(e>>18&7|240,e>>12&63|128),t.push(e>>6&63|128)),t.push(e&63|128))}this.addInt8(0),this.startVector(1,t.length,1),this.bb.setPosition(this.space-=t.length);for(var o=0,s=this.space,i=this.bb.bytes();o<t.length;o++)i[s++]=t[o];return this.endVector()};O.Builder.prototype.createLong=function(a,t){return O.Long.create(a,t)};O.ByteBuffer=function(a){this.bytes_=a,this.position_=0};O.ByteBuffer.allocate=function(a){return new O.ByteBuffer(new Uint8Array(a))};O.ByteBuffer.prototype.clear=function(){this.position_=0};O.ByteBuffer.prototype.bytes=function(){return this.bytes_};O.ByteBuffer.prototype.position=function(){return this.position_};O.ByteBuffer.prototype.setPosition=function(a){this.position_=a};O.ByteBuffer.prototype.capacity=function(){return this.bytes_.length};O.ByteBuffer.prototype.readInt8=function(a){return this.readUint8(a)<<24>>24};O.ByteBuffer.prototype.readUint8=function(a){return this.bytes_[a]};O.ByteBuffer.prototype.readInt16=function(a){return this.readUint16(a)<<16>>16};O.ByteBuffer.prototype.readUint16=function(a){return this.bytes_[a]|this.bytes_[a+1]<<8};O.ByteBuffer.prototype.readInt32=function(a){return this.bytes_[a]|this.bytes_[a+1]<<8|this.bytes_[a+2]<<16|this.bytes_[a+3]<<24};O.ByteBuffer.prototype.readUint32=function(a){return this.readInt32(a)>>>0};O.ByteBuffer.prototype.readInt64=function(a){return new O.Long(this.readInt32(a),this.readInt32(a+4))};O.ByteBuffer.prototype.readUint64=function(a){return new O.Long(this.readUint32(a),this.readUint32(a+4))};O.ByteBuffer.prototype.readFloat32=function(a){return O.int32[0]=this.readInt32(a),O.float32[0]};O.ByteBuffer.prototype.readFloat64=function(a){return O.int32[O.isLittleEndian?0:1]=this.readInt32(a),O.int32[O.isLittleEndian?1:0]=this.readInt32(a+4),O.float64[0]};O.ByteBuffer.prototype.writeInt8=function(a,t){this.bytes_[a]=t};O.ByteBuffer.prototype.writeUint8=function(a,t){this.bytes_[a]=t};O.ByteBuffer.prototype.writeInt16=function(a,t){this.bytes_[a]=t,this.bytes_[a+1]=t>>8};O.ByteBuffer.prototype.writeUint16=function(a,t){this.bytes_[a]=t,this.bytes_[a+1]=t>>8};O.ByteBuffer.prototype.writeInt32=function(a,t){this.bytes_[a]=t,this.bytes_[a+1]=t>>8,this.bytes_[a+2]=t>>16,this.bytes_[a+3]=t>>24};O.ByteBuffer.prototype.writeUint32=function(a,t){this.bytes_[a]=t,this.bytes_[a+1]=t>>8,this.bytes_[a+2]=t>>16,this.bytes_[a+3]=t>>24};O.ByteBuffer.prototype.writeInt64=function(a,t){this.writeInt32(a,t.low),this.writeInt32(a+4,t.high)};O.ByteBuffer.prototype.writeUint64=function(a,t){this.writeUint32(a,t.low),this.writeUint32(a+4,t.high)};O.ByteBuffer.prototype.writeFloat32=function(a,t){O.float32[0]=t,this.writeInt32(a,O.int32[0])};O.ByteBuffer.prototype.writeFloat64=function(a,t){O.float64[0]=t,this.writeInt32(a,O.int32[O.isLittleEndian?0:1]),this.writeInt32(a+4,O.int32[O.isLittleEndian?1:0])};O.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+O.SIZEOF_INT+O.FILE_IDENTIFIER_LENGTH)throw new Error(\"FlatBuffers: ByteBuffer is too short to contain an identifier.\");for(var a=\"\",t=0;t<O.FILE_IDENTIFIER_LENGTH;t++)a+=String.fromCharCode(this.readInt8(this.position_+O.SIZEOF_INT+t));return a};O.ByteBuffer.prototype.__offset=function(a,t){var o=a-this.readInt32(a);return t<this.readInt16(o)?this.readInt16(o+t):0};O.ByteBuffer.prototype.__union=function(a,t){return a.bb_pos=t+this.readInt32(t),a.bb=this,a};O.ByteBuffer.prototype.__string=function(a,t){a+=this.readInt32(a);var o=this.readInt32(a),e=\"\",r=0;if(a+=O.SIZEOF_INT,t===O.Encoding.UTF8_BYTES)return this.bytes_.subarray(a,a+o);for(;r<o;){var n,s=this.readUint8(a+r++);if(s<192)n=s;else{var i=this.readUint8(a+r++);if(s<224)n=(s&31)<<6|i&63;else{var u=this.readUint8(a+r++);if(s<240)n=(s&15)<<12|(i&63)<<6|u&63;else{var l=this.readUint8(a+r++);n=(s&7)<<18|(i&63)<<12|(u&63)<<6|l&63}}}n<65536?e+=String.fromCharCode(n):(n-=65536,e+=String.fromCharCode((n>>10)+55296,(n&1024-1)+56320))}return e};O.ByteBuffer.prototype.__indirect=function(a){return a+this.readInt32(a)};O.ByteBuffer.prototype.__vector=function(a){return a+this.readInt32(a)+O.SIZEOF_INT};O.ByteBuffer.prototype.__vector_len=function(a){return this.readInt32(a+this.readInt32(a))};O.ByteBuffer.prototype.__has_identifier=function(a){if(a.length!=O.FILE_IDENTIFIER_LENGTH)throw new Error(\"FlatBuffers: file identifier must be length \"+O.FILE_IDENTIFIER_LENGTH);for(var t=0;t<O.FILE_IDENTIFIER_LENGTH;t++)if(a.charCodeAt(t)!=this.readInt8(this.position_+O.SIZEOF_INT+t))return!1;return!0};O.ByteBuffer.prototype.createLong=function(a,t){return O.Long.create(a,t)}});var W,nn=E(()=>{\"use strict\";Wn();(t=>{let a;(e=>{let o;(n=>{let r;(C=>(C[C.UNDEFINED=0]=\"UNDEFINED\",C[C.FLOAT=1]=\"FLOAT\",C[C.INT=2]=\"INT\",C[C.STRING=3]=\"STRING\",C[C.TENSOR=4]=\"TENSOR\",C[C.GRAPH=5]=\"GRAPH\",C[C.FLOATS=6]=\"FLOATS\",C[C.INTS=7]=\"INTS\",C[C.STRINGS=8]=\"STRINGS\",C[C.TENSORS=9]=\"TENSORS\",C[C.GRAPHS=10]=\"GRAPHS\",C[C.SPARSE_TENSOR=11]=\"SPARSE_TENSOR\",C[C.SPARSE_TENSORS=12]=\"SPARSE_TENSORS\"))(r=n.AttributeType||={})})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{let r;(l=>(l[l.UNKNOWN=0]=\"UNKNOWN\",l[l.VALUE=1]=\"VALUE\",l[l.PARAM=2]=\"PARAM\"))(r=n.DimensionValueType||={})})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{let r;(V=>(V[V.UNDEFINED=0]=\"UNDEFINED\",V[V.FLOAT=1]=\"FLOAT\",V[V.UINT8=2]=\"UINT8\",V[V.INT8=3]=\"INT8\",V[V.UINT16=4]=\"UINT16\",V[V.INT16=5]=\"INT16\",V[V.INT32=6]=\"INT32\",V[V.INT64=7]=\"INT64\",V[V.STRING=8]=\"STRING\",V[V.BOOL=9]=\"BOOL\",V[V.FLOAT16=10]=\"FLOAT16\",V[V.DOUBLE=11]=\"DOUBLE\",V[V.UINT32=12]=\"UINT32\",V[V.UINT64=13]=\"UINT64\",V[V.COMPLEX64=14]=\"COMPLEX64\",V[V.COMPLEX128=15]=\"COMPLEX128\",V[V.BFLOAT16=16]=\"BFLOAT16\",V[V.FLOAT8E4M3FN=17]=\"FLOAT8E4M3FN\",V[V.FLOAT8E4M3FNUZ=18]=\"FLOAT8E4M3FNUZ\",V[V.FLOAT8E5M2=19]=\"FLOAT8E5M2\",V[V.FLOAT8E5M2FNUZ=20]=\"FLOAT8E5M2FNUZ\"))(r=n.TensorDataType||={})})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{let r;(u=>(u[u.Primitive=0]=\"Primitive\",u[u.Fused=1]=\"Fused\"))(r=n.NodeType||={})})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{let r;(f=>(f[f.NONE=0]=\"NONE\",f[f.tensor_type=1]=\"tensor_type\",f[f.sequence_type=2]=\"sequence_type\",f[f.map_type=3]=\"map_type\"))(r=n.TypeInfoValue||={})})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsShape(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsShape(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}dim(i,u){let l=this.bb.__offset(this.bb_pos,4);return l?(u||new t.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}dimLength(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.__vector_len(this.bb_pos+i):0}static startShape(i){i.startObject(1)}static addDim(i,u){i.addFieldOffset(0,u,0)}static createDimVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startDimVector(i,u){i.startVector(4,u,4)}static endShape(i){return i.endObject()}static createShape(i,u){return r.startShape(i),r.addDim(i,u),r.endShape(i)}}n.Shape=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsDimension(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsDimension(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}value(i){let u=this.bb.__offset(this.bb_pos,4);return u?(i||new t.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}denotation(i){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,i):null}static startDimension(i){i.startObject(2)}static addValue(i,u){i.addFieldOffset(0,u,0)}static addDenotation(i,u){i.addFieldOffset(1,u,0)}static endDimension(i){return i.endObject()}static createDimension(i,u,l){return r.startDimension(i),r.addValue(i,u),r.addDenotation(i,l),r.endDimension(i)}}n.Dimension=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsDimensionValue(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsDimensionValue(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}dimType(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.readInt8(this.bb_pos+i):0}dimValue(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.readInt64(this.bb_pos+i):this.bb.createLong(0,0)}dimParam(i){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__string(this.bb_pos+u,i):null}static startDimensionValue(i){i.startObject(3)}static addDimType(i,u){i.addFieldInt8(0,u,0)}static addDimValue(i,u){i.addFieldInt64(1,u,i.createLong(0,0))}static addDimParam(i,u){i.addFieldOffset(2,u,0)}static endDimensionValue(i){return i.endObject()}static createDimensionValue(i,u,l,f){return r.startDimensionValue(i),r.addDimType(i,u),r.addDimValue(i,l),r.addDimParam(i,f),r.endDimensionValue(i)}}n.DimensionValue=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsTensorTypeAndShape(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsTensorTypeAndShape(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}elemType(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.readInt32(this.bb_pos+i):0}shape(i){let u=this.bb.__offset(this.bb_pos,6);return u?(i||new t.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startTensorTypeAndShape(i){i.startObject(2)}static addElemType(i,u){i.addFieldInt32(0,u,0)}static addShape(i,u){i.addFieldOffset(1,u,0)}static endTensorTypeAndShape(i){return i.endObject()}static createTensorTypeAndShape(i,u,l){return r.startTensorTypeAndShape(i),r.addElemType(i,u),r.addShape(i,l),r.endTensorTypeAndShape(i)}}n.TensorTypeAndShape=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsMapType(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsMapType(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}keyType(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.readInt32(this.bb_pos+i):0}valueType(i){let u=this.bb.__offset(this.bb_pos,6);return u?(i||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startMapType(i){i.startObject(2)}static addKeyType(i,u){i.addFieldInt32(0,u,0)}static addValueType(i,u){i.addFieldOffset(1,u,0)}static endMapType(i){return i.endObject()}static createMapType(i,u,l){return r.startMapType(i),r.addKeyType(i,u),r.addValueType(i,l),r.endMapType(i)}}n.MapType=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsSequenceType(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsSequenceType(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}elemType(i){let u=this.bb.__offset(this.bb_pos,4);return u?(i||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startSequenceType(i){i.startObject(1)}static addElemType(i,u){i.addFieldOffset(0,u,0)}static endSequenceType(i){return i.endObject()}static createSequenceType(i,u){return r.startSequenceType(i),r.addElemType(i,u),r.endSequenceType(i)}}n.SequenceType=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(i,u,l,f){return i.prep(4,12),i.writeInt32(f),i.writeInt32(l),i.writeInt32(u),i.offset()}}n.EdgeEnd=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsNodeEdge(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsNodeEdge(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}nodeIndex(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.readUint32(this.bb_pos+i):0}inputEdges(i,u){let l=this.bb.__offset(this.bb_pos,6);return l?(u||new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+l)+i*12,this.bb):null}inputEdgesLength(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.__vector_len(this.bb_pos+i):0}outputEdges(i,u){let l=this.bb.__offset(this.bb_pos,8);return l?(u||new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+l)+i*12,this.bb):null}outputEdgesLength(){let i=this.bb.__offset(this.bb_pos,8);return i?this.bb.__vector_len(this.bb_pos+i):0}static startNodeEdge(i){i.startObject(3)}static addNodeIndex(i,u){i.addFieldInt32(0,u,0)}static addInputEdges(i,u){i.addFieldOffset(1,u,0)}static startInputEdgesVector(i,u){i.startVector(12,u,4)}static addOutputEdges(i,u){i.addFieldOffset(2,u,0)}static startOutputEdgesVector(i,u){i.startVector(12,u,4)}static endNodeEdge(i){return i.endObject()}static createNodeEdge(i,u,l,f){return r.startNodeEdge(i),r.addNodeIndex(i,u),r.addInputEdges(i,l),r.addOutputEdges(i,f),r.endNodeEdge(i)}}n.NodeEdge=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsNode(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsNode(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}name(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,i):null}docString(i){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,i):null}domain(i){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__string(this.bb_pos+u,i):null}sinceVersion(){let i=this.bb.__offset(this.bb_pos,10);return i?this.bb.readInt32(this.bb_pos+i):0}index(){let i=this.bb.__offset(this.bb_pos,12);return i?this.bb.readUint32(this.bb_pos+i):0}opType(i){let u=this.bb.__offset(this.bb_pos,14);return u?this.bb.__string(this.bb_pos+u,i):null}type(){let i=this.bb.__offset(this.bb_pos,16);return i?this.bb.readInt32(this.bb_pos+i):0}executionProviderType(i){let u=this.bb.__offset(this.bb_pos,18);return u?this.bb.__string(this.bb_pos+u,i):null}inputs(i,u){let l=this.bb.__offset(this.bb_pos,20);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+i*4,u):null}inputsLength(){let i=this.bb.__offset(this.bb_pos,20);return i?this.bb.__vector_len(this.bb_pos+i):0}outputs(i,u){let l=this.bb.__offset(this.bb_pos,22);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+i*4,u):null}outputsLength(){let i=this.bb.__offset(this.bb_pos,22);return i?this.bb.__vector_len(this.bb_pos+i):0}attributes(i,u){let l=this.bb.__offset(this.bb_pos,24);return l?(u||new t.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}attributesLength(){let i=this.bb.__offset(this.bb_pos,24);return i?this.bb.__vector_len(this.bb_pos+i):0}inputArgCounts(i){let u=this.bb.__offset(this.bb_pos,26);return u?this.bb.readInt32(this.bb.__vector(this.bb_pos+u)+i*4):0}inputArgCountsLength(){let i=this.bb.__offset(this.bb_pos,26);return i?this.bb.__vector_len(this.bb_pos+i):0}inputArgCountsArray(){let i=this.bb.__offset(this.bb_pos,26);return i?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+i),this.bb.__vector_len(this.bb_pos+i)):null}implicitInputs(i,u){let l=this.bb.__offset(this.bb_pos,28);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+i*4,u):null}implicitInputsLength(){let i=this.bb.__offset(this.bb_pos,28);return i?this.bb.__vector_len(this.bb_pos+i):0}static startNode(i){i.startObject(13)}static addName(i,u){i.addFieldOffset(0,u,0)}static addDocString(i,u){i.addFieldOffset(1,u,0)}static addDomain(i,u){i.addFieldOffset(2,u,0)}static addSinceVersion(i,u){i.addFieldInt32(3,u,0)}static addIndex(i,u){i.addFieldInt32(4,u,0)}static addOpType(i,u){i.addFieldOffset(5,u,0)}static addType(i,u){i.addFieldInt32(6,u,0)}static addExecutionProviderType(i,u){i.addFieldOffset(7,u,0)}static addInputs(i,u){i.addFieldOffset(8,u,0)}static createInputsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startInputsVector(i,u){i.startVector(4,u,4)}static addOutputs(i,u){i.addFieldOffset(9,u,0)}static createOutputsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startOutputsVector(i,u){i.startVector(4,u,4)}static addAttributes(i,u){i.addFieldOffset(10,u,0)}static createAttributesVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startAttributesVector(i,u){i.startVector(4,u,4)}static addInputArgCounts(i,u){i.addFieldOffset(11,u,0)}static createInputArgCountsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addInt32(u[l]);return i.endVector()}static startInputArgCountsVector(i,u){i.startVector(4,u,4)}static addImplicitInputs(i,u){i.addFieldOffset(12,u,0)}static createImplicitInputsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startImplicitInputsVector(i,u){i.startVector(4,u,4)}static endNode(i){return i.endObject()}static createNode(i,u,l,f,p,d,T,v,w,I,L,F,C,Y){return r.startNode(i),r.addName(i,u),r.addDocString(i,l),r.addDomain(i,f),r.addSinceVersion(i,p),r.addIndex(i,d),r.addOpType(i,T),r.addType(i,v),r.addExecutionProviderType(i,w),r.addInputs(i,I),r.addOutputs(i,L),r.addAttributes(i,F),r.addInputArgCounts(i,C),r.addImplicitInputs(i,Y),r.endNode(i)}}n.Node=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsValueInfo(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsValueInfo(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}name(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,i):null}docString(i){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,i):null}type(i){let u=this.bb.__offset(this.bb_pos,8);return u?(i||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startValueInfo(i){i.startObject(3)}static addName(i,u){i.addFieldOffset(0,u,0)}static addDocString(i,u){i.addFieldOffset(1,u,0)}static addType(i,u){i.addFieldOffset(2,u,0)}static endValueInfo(i){return i.endObject()}static createValueInfo(i,u,l,f){return r.startValueInfo(i),r.addName(i,u),r.addDocString(i,l),r.addType(i,f),r.endValueInfo(i)}}n.ValueInfo=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsTypeInfo(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsTypeInfo(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}denotation(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,i):null}valueType(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.readUint8(this.bb_pos+i):0}value(i){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__union(i,this.bb_pos+u):null}static startTypeInfo(i){i.startObject(3)}static addDenotation(i,u){i.addFieldOffset(0,u,0)}static addValueType(i,u){i.addFieldInt8(1,u,0)}static addValue(i,u){i.addFieldOffset(2,u,0)}static endTypeInfo(i){return i.endObject()}static createTypeInfo(i,u,l,f){return r.startTypeInfo(i),r.addDenotation(i,u),r.addValueType(i,l),r.addValue(i,f),r.endTypeInfo(i)}}n.TypeInfo=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsOperatorSetId(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsOperatorSetId(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}domain(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,i):null}version(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.readInt64(this.bb_pos+i):this.bb.createLong(0,0)}static startOperatorSetId(i){i.startObject(2)}static addDomain(i,u){i.addFieldOffset(0,u,0)}static addVersion(i,u){i.addFieldInt64(1,u,i.createLong(0,0))}static endOperatorSetId(i){return i.endObject()}static createOperatorSetId(i,u,l){return r.startOperatorSetId(i),r.addDomain(i,u),r.addVersion(i,l),r.endOperatorSetId(i)}}n.OperatorSetId=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsTensor(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsTensor(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}name(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,i):null}docString(i){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,i):null}dims(i){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.readInt64(this.bb.__vector(this.bb_pos+u)+i*8):this.bb.createLong(0,0)}dimsLength(){let i=this.bb.__offset(this.bb_pos,8);return i?this.bb.__vector_len(this.bb_pos+i):0}dataType(){let i=this.bb.__offset(this.bb_pos,10);return i?this.bb.readInt32(this.bb_pos+i):0}rawData(i){let u=this.bb.__offset(this.bb_pos,12);return u?this.bb.readUint8(this.bb.__vector(this.bb_pos+u)+i):0}rawDataLength(){let i=this.bb.__offset(this.bb_pos,12);return i?this.bb.__vector_len(this.bb_pos+i):0}rawDataArray(){let i=this.bb.__offset(this.bb_pos,12);return i?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+i),this.bb.__vector_len(this.bb_pos+i)):null}stringData(i,u){let l=this.bb.__offset(this.bb_pos,14);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+i*4,u):null}stringDataLength(){let i=this.bb.__offset(this.bb_pos,14);return i?this.bb.__vector_len(this.bb_pos+i):0}static startTensor(i){i.startObject(6)}static addName(i,u){i.addFieldOffset(0,u,0)}static addDocString(i,u){i.addFieldOffset(1,u,0)}static addDims(i,u){i.addFieldOffset(2,u,0)}static createDimsVector(i,u){i.startVector(8,u.length,8);for(let l=u.length-1;l>=0;l--)i.addInt64(u[l]);return i.endVector()}static startDimsVector(i,u){i.startVector(8,u,8)}static addDataType(i,u){i.addFieldInt32(3,u,0)}static addRawData(i,u){i.addFieldOffset(4,u,0)}static createRawDataVector(i,u){i.startVector(1,u.length,1);for(let l=u.length-1;l>=0;l--)i.addInt8(u[l]);return i.endVector()}static startRawDataVector(i,u){i.startVector(1,u,1)}static addStringData(i,u){i.addFieldOffset(5,u,0)}static createStringDataVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startStringDataVector(i,u){i.startVector(4,u,4)}static endTensor(i){return i.endObject()}static createTensor(i,u,l,f,p,d,T){return r.startTensor(i),r.addName(i,u),r.addDocString(i,l),r.addDims(i,f),r.addDataType(i,p),r.addRawData(i,d),r.addStringData(i,T),r.endTensor(i)}}n.Tensor=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsSparseTensor(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsSparseTensor(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}values(i){let u=this.bb.__offset(this.bb_pos,4);return u?(i||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}indices(i){let u=this.bb.__offset(this.bb_pos,6);return u?(i||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}dims(i){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.readInt64(this.bb.__vector(this.bb_pos+u)+i*8):this.bb.createLong(0,0)}dimsLength(){let i=this.bb.__offset(this.bb_pos,8);return i?this.bb.__vector_len(this.bb_pos+i):0}static startSparseTensor(i){i.startObject(3)}static addValues(i,u){i.addFieldOffset(0,u,0)}static addIndices(i,u){i.addFieldOffset(1,u,0)}static addDims(i,u){i.addFieldOffset(2,u,0)}static createDimsVector(i,u){i.startVector(8,u.length,8);for(let l=u.length-1;l>=0;l--)i.addInt64(u[l]);return i.endVector()}static startDimsVector(i,u){i.startVector(8,u,8)}static endSparseTensor(i){return i.endObject()}static createSparseTensor(i,u,l,f){return r.startSparseTensor(i),r.addValues(i,u),r.addIndices(i,l),r.addDims(i,f),r.endSparseTensor(i)}}n.SparseTensor=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsAttribute(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsAttribute(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}name(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,i):null}docString(i){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,i):null}type(){let i=this.bb.__offset(this.bb_pos,8);return i?this.bb.readInt32(this.bb_pos+i):0}f(){let i=this.bb.__offset(this.bb_pos,10);return i?this.bb.readFloat32(this.bb_pos+i):0}i(){let i=this.bb.__offset(this.bb_pos,12);return i?this.bb.readInt64(this.bb_pos+i):this.bb.createLong(0,0)}s(i){let u=this.bb.__offset(this.bb_pos,14);return u?this.bb.__string(this.bb_pos+u,i):null}t(i){let u=this.bb.__offset(this.bb_pos,16);return u?(i||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}g(i){let u=this.bb.__offset(this.bb_pos,18);return u?(i||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}floats(i){let u=this.bb.__offset(this.bb_pos,20);return u?this.bb.readFloat32(this.bb.__vector(this.bb_pos+u)+i*4):0}floatsLength(){let i=this.bb.__offset(this.bb_pos,20);return i?this.bb.__vector_len(this.bb_pos+i):0}floatsArray(){let i=this.bb.__offset(this.bb_pos,20);return i?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+i),this.bb.__vector_len(this.bb_pos+i)):null}ints(i){let u=this.bb.__offset(this.bb_pos,22);return u?this.bb.readInt64(this.bb.__vector(this.bb_pos+u)+i*8):this.bb.createLong(0,0)}intsLength(){let i=this.bb.__offset(this.bb_pos,22);return i?this.bb.__vector_len(this.bb_pos+i):0}strings(i,u){let l=this.bb.__offset(this.bb_pos,24);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+i*4,u):null}stringsLength(){let i=this.bb.__offset(this.bb_pos,24);return i?this.bb.__vector_len(this.bb_pos+i):0}tensors(i,u){let l=this.bb.__offset(this.bb_pos,26);return l?(u||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}tensorsLength(){let i=this.bb.__offset(this.bb_pos,26);return i?this.bb.__vector_len(this.bb_pos+i):0}graphs(i,u){let l=this.bb.__offset(this.bb_pos,28);return l?(u||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}graphsLength(){let i=this.bb.__offset(this.bb_pos,28);return i?this.bb.__vector_len(this.bb_pos+i):0}static startAttribute(i){i.startObject(13)}static addName(i,u){i.addFieldOffset(0,u,0)}static addDocString(i,u){i.addFieldOffset(1,u,0)}static addType(i,u){i.addFieldInt32(2,u,0)}static addF(i,u){i.addFieldFloat32(3,u,0)}static addI(i,u){i.addFieldInt64(4,u,i.createLong(0,0))}static addS(i,u){i.addFieldOffset(5,u,0)}static addT(i,u){i.addFieldOffset(6,u,0)}static addG(i,u){i.addFieldOffset(7,u,0)}static addFloats(i,u){i.addFieldOffset(8,u,0)}static createFloatsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addFloat32(u[l]);return i.endVector()}static startFloatsVector(i,u){i.startVector(4,u,4)}static addInts(i,u){i.addFieldOffset(9,u,0)}static createIntsVector(i,u){i.startVector(8,u.length,8);for(let l=u.length-1;l>=0;l--)i.addInt64(u[l]);return i.endVector()}static startIntsVector(i,u){i.startVector(8,u,8)}static addStrings(i,u){i.addFieldOffset(10,u,0)}static createStringsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startStringsVector(i,u){i.startVector(4,u,4)}static addTensors(i,u){i.addFieldOffset(11,u,0)}static createTensorsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startTensorsVector(i,u){i.startVector(4,u,4)}static addGraphs(i,u){i.addFieldOffset(12,u,0)}static createGraphsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startGraphsVector(i,u){i.startVector(4,u,4)}static endAttribute(i){return i.endObject()}static createAttribute(i,u,l,f,p,d,T,v,w,I,L,F,C,Y){return r.startAttribute(i),r.addName(i,u),r.addDocString(i,l),r.addType(i,f),r.addF(i,p),r.addI(i,d),r.addS(i,T),r.addT(i,v),r.addG(i,w),r.addFloats(i,I),r.addInts(i,L),r.addStrings(i,F),r.addTensors(i,C),r.addGraphs(i,Y),r.endAttribute(i)}}n.Attribute=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsGraph(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsGraph(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}initializers(i,u){let l=this.bb.__offset(this.bb_pos,4);return l?(u||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}initializersLength(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.__vector_len(this.bb_pos+i):0}nodeArgs(i,u){let l=this.bb.__offset(this.bb_pos,6);return l?(u||new t.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}nodeArgsLength(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.__vector_len(this.bb_pos+i):0}nodes(i,u){let l=this.bb.__offset(this.bb_pos,8);return l?(u||new t.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}nodesLength(){let i=this.bb.__offset(this.bb_pos,8);return i?this.bb.__vector_len(this.bb_pos+i):0}maxNodeIndex(){let i=this.bb.__offset(this.bb_pos,10);return i?this.bb.readUint32(this.bb_pos+i):0}nodeEdges(i,u){let l=this.bb.__offset(this.bb_pos,12);return l?(u||new t.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}nodeEdgesLength(){let i=this.bb.__offset(this.bb_pos,12);return i?this.bb.__vector_len(this.bb_pos+i):0}inputs(i,u){let l=this.bb.__offset(this.bb_pos,14);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+i*4,u):null}inputsLength(){let i=this.bb.__offset(this.bb_pos,14);return i?this.bb.__vector_len(this.bb_pos+i):0}outputs(i,u){let l=this.bb.__offset(this.bb_pos,16);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+i*4,u):null}outputsLength(){let i=this.bb.__offset(this.bb_pos,16);return i?this.bb.__vector_len(this.bb_pos+i):0}sparseInitializers(i,u){let l=this.bb.__offset(this.bb_pos,18);return l?(u||new t.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}sparseInitializersLength(){let i=this.bb.__offset(this.bb_pos,18);return i?this.bb.__vector_len(this.bb_pos+i):0}static startGraph(i){i.startObject(8)}static addInitializers(i,u){i.addFieldOffset(0,u,0)}static createInitializersVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startInitializersVector(i,u){i.startVector(4,u,4)}static addNodeArgs(i,u){i.addFieldOffset(1,u,0)}static createNodeArgsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startNodeArgsVector(i,u){i.startVector(4,u,4)}static addNodes(i,u){i.addFieldOffset(2,u,0)}static createNodesVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startNodesVector(i,u){i.startVector(4,u,4)}static addMaxNodeIndex(i,u){i.addFieldInt32(3,u,0)}static addNodeEdges(i,u){i.addFieldOffset(4,u,0)}static createNodeEdgesVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startNodeEdgesVector(i,u){i.startVector(4,u,4)}static addInputs(i,u){i.addFieldOffset(5,u,0)}static createInputsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startInputsVector(i,u){i.startVector(4,u,4)}static addOutputs(i,u){i.addFieldOffset(6,u,0)}static createOutputsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startOutputsVector(i,u){i.startVector(4,u,4)}static addSparseInitializers(i,u){i.addFieldOffset(7,u,0)}static createSparseInitializersVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startSparseInitializersVector(i,u){i.startVector(4,u,4)}static endGraph(i){return i.endObject()}static createGraph(i,u,l,f,p,d,T,v,w){return r.startGraph(i),r.addInitializers(i,u),r.addNodeArgs(i,l),r.addNodes(i,f),r.addMaxNodeIndex(i,p),r.addNodeEdges(i,d),r.addInputs(i,T),r.addOutputs(i,v),r.addSparseInitializers(i,w),r.endGraph(i)}}n.Graph=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsModel(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsModel(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}irVersion(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.readInt64(this.bb_pos+i):this.bb.createLong(0,0)}opsetImport(i,u){let l=this.bb.__offset(this.bb_pos,6);return l?(u||new t.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}opsetImportLength(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.__vector_len(this.bb_pos+i):0}producerName(i){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__string(this.bb_pos+u,i):null}producerVersion(i){let u=this.bb.__offset(this.bb_pos,10);return u?this.bb.__string(this.bb_pos+u,i):null}domain(i){let u=this.bb.__offset(this.bb_pos,12);return u?this.bb.__string(this.bb_pos+u,i):null}modelVersion(){let i=this.bb.__offset(this.bb_pos,14);return i?this.bb.readInt64(this.bb_pos+i):this.bb.createLong(0,0)}docString(i){let u=this.bb.__offset(this.bb_pos,16);return u?this.bb.__string(this.bb_pos+u,i):null}graph(i){let u=this.bb.__offset(this.bb_pos,18);return u?(i||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}graphDocString(i){let u=this.bb.__offset(this.bb_pos,20);return u?this.bb.__string(this.bb_pos+u,i):null}static startModel(i){i.startObject(9)}static addIrVersion(i,u){i.addFieldInt64(0,u,i.createLong(0,0))}static addOpsetImport(i,u){i.addFieldOffset(1,u,0)}static createOpsetImportVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startOpsetImportVector(i,u){i.startVector(4,u,4)}static addProducerName(i,u){i.addFieldOffset(2,u,0)}static addProducerVersion(i,u){i.addFieldOffset(3,u,0)}static addDomain(i,u){i.addFieldOffset(4,u,0)}static addModelVersion(i,u){i.addFieldInt64(5,u,i.createLong(0,0))}static addDocString(i,u){i.addFieldOffset(6,u,0)}static addGraph(i,u){i.addFieldOffset(7,u,0)}static addGraphDocString(i,u){i.addFieldOffset(8,u,0)}static endModel(i){return i.endObject()}static createModel(i,u,l,f,p,d,T,v,w,I){return r.startModel(i),r.addIrVersion(i,u),r.addOpsetImport(i,l),r.addProducerName(i,f),r.addProducerVersion(i,p),r.addDomain(i,d),r.addModelVersion(i,T),r.addDocString(i,v),r.addGraph(i,w),r.addGraphDocString(i,I),r.endModel(i)}}n.Model=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsKernelCreateInfos(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsKernelCreateInfos(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}nodeIndices(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.readUint32(this.bb.__vector(this.bb_pos+u)+i*4):0}nodeIndicesLength(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.__vector_len(this.bb_pos+i):0}nodeIndicesArray(){let i=this.bb.__offset(this.bb_pos,4);return i?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+i),this.bb.__vector_len(this.bb_pos+i)):null}kernelDefHashes(i){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.readUint64(this.bb.__vector(this.bb_pos+u)+i*8):this.bb.createLong(0,0)}kernelDefHashesLength(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.__vector_len(this.bb_pos+i):0}static startKernelCreateInfos(i){i.startObject(2)}static addNodeIndices(i,u){i.addFieldOffset(0,u,0)}static createNodeIndicesVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addInt32(u[l]);return i.endVector()}static startNodeIndicesVector(i,u){i.startVector(4,u,4)}static addKernelDefHashes(i,u){i.addFieldOffset(1,u,0)}static createKernelDefHashesVector(i,u){i.startVector(8,u.length,8);for(let l=u.length-1;l>=0;l--)i.addInt64(u[l]);return i.endVector()}static startKernelDefHashesVector(i,u){i.startVector(8,u,8)}static endKernelCreateInfos(i){return i.endObject()}static createKernelCreateInfos(i,u,l){return r.startKernelCreateInfos(i),r.addNodeIndices(i,u),r.addKernelDefHashes(i,l),r.endKernelCreateInfos(i)}}n.KernelCreateInfos=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsSubGraphSessionState(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsSubGraphSessionState(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}graphId(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,i):null}sessionState(i){let u=this.bb.__offset(this.bb_pos,6);return u?(i||new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startSubGraphSessionState(i){i.startObject(2)}static addGraphId(i,u){i.addFieldOffset(0,u,0)}static addSessionState(i,u){i.addFieldOffset(1,u,0)}static endSubGraphSessionState(i){let u=i.endObject();return i.requiredField(u,4),u}static createSubGraphSessionState(i,u,l){return r.startSubGraphSessionState(i),r.addGraphId(i,u),r.addSessionState(i,l),r.endSubGraphSessionState(i)}}n.SubGraphSessionState=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsSessionState(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsSessionState(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}kernels(i){let u=this.bb.__offset(this.bb_pos,4);return u?(i||new t.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}subGraphSessionStates(i,u){let l=this.bb.__offset(this.bb_pos,6);return l?(u||new t.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}subGraphSessionStatesLength(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.__vector_len(this.bb_pos+i):0}static startSessionState(i){i.startObject(2)}static addKernels(i,u){i.addFieldOffset(0,u,0)}static addSubGraphSessionStates(i,u){i.addFieldOffset(1,u,0)}static createSubGraphSessionStatesVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startSubGraphSessionStatesVector(i,u){i.startVector(4,u,4)}static endSessionState(i){return i.endObject()}static createSessionState(i,u,l){return r.startSessionState(i),r.addKernels(i,u),r.addSubGraphSessionStates(i,l),r.endSessionState(i)}}n.SessionState=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={});(t=>{let a;(e=>{let o;(n=>{class r{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsInferenceSession(i,u){return(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsInferenceSession(i,u){return i.setPosition(i.position()+O.SIZE_PREFIX_LENGTH),(u||new r).__init(i.readInt32(i.position())+i.position(),i)}static bufferHasIdentifier(i){return i.__has_identifier(\"ORTM\")}ortVersion(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,i):null}model(i){let u=this.bb.__offset(this.bb_pos,6);return u?(i||new t.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}sessionState(i){let u=this.bb.__offset(this.bb_pos,8);return u?(i||new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startInferenceSession(i){i.startObject(3)}static addOrtVersion(i,u){i.addFieldOffset(0,u,0)}static addModel(i,u){i.addFieldOffset(1,u,0)}static addSessionState(i,u){i.addFieldOffset(2,u,0)}static endInferenceSession(i){return i.endObject()}static finishInferenceSessionBuffer(i,u){i.finish(u,\"ORTM\")}static finishSizePrefixedInferenceSessionBuffer(i,u){i.finish(u,\"ORTM\",!0)}static createInferenceSession(i,u,l,f){return r.startInferenceSession(i),r.addOrtVersion(i,u),r.addModel(i,l),r.addSessionState(i,f),r.endInferenceSession(i)}}n.InferenceSession=r})(o=e.fbs||={})})(a=t.experimental||={})})(W||={})});var Rs=me((Oy,Ns)=>{\"use strict\";Ns.exports=Rd;function Rd(a,t){for(var o=new Array(arguments.length-1),e=0,r=2,n=!0;r<arguments.length;)o[e++]=arguments[r++];return new Promise(function(i,u){o[e]=function(f){if(n)if(n=!1,f)u(f);else{for(var p=new Array(arguments.length-1),d=0;d<p.length;)p[d++]=arguments[d];i.apply(null,p)}};try{a.apply(t||null,o)}catch(l){n&&(n=!1,u(l))}})}});var zs=me(Us=>{\"use strict\";var Hn=Us;Hn.length=function(t){var o=t.length;if(!o)return 0;for(var e=0;--o%4>1&&t.charAt(o)===\"=\";)++e;return Math.ceil(t.length*3)/4-e};var Cr=new Array(64),Gs=new Array(123);for(vt=0;vt<64;)Gs[Cr[vt]=vt<26?vt+65:vt<52?vt+71:vt<62?vt-4:vt-59|43]=vt++;var vt;Hn.encode=function(t,o,e){for(var r=null,n=[],s=0,i=0,u;o<e;){var l=t[o++];switch(i){case 0:n[s++]=Cr[l>>2],u=(l&3)<<4,i=1;break;case 1:n[s++]=Cr[u|l>>4],u=(l&15)<<2,i=2;break;case 2:n[s++]=Cr[u|l>>6],n[s++]=Cr[l&63],i=0;break}s>8191&&((r||(r=[])).push(String.fromCharCode.apply(String,n)),s=0)}return i&&(n[s++]=Cr[u],n[s++]=61,i===1&&(n[s++]=61)),r?(s&&r.push(String.fromCharCode.apply(String,n.slice(0,s))),r.join(\"\")):String.fromCharCode.apply(String,n.slice(0,s))};var Ms=\"invalid encoding\";Hn.decode=function(t,o,e){for(var r=e,n=0,s,i=0;i<t.length;){var u=t.charCodeAt(i++);if(u===61&&n>1)break;if((u=Gs[u])===void 0)throw Error(Ms);switch(n){case 0:s=u,n=1;break;case 1:o[e++]=s<<2|(u&48)>>4,s=u,n=2;break;case 2:o[e++]=(s&15)<<4|(u&60)>>2,s=u,n=3;break;case 3:o[e++]=(s&3)<<6|u,n=0;break}}if(n===1)throw Error(Ms);return e-r};Hn.test=function(t){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t)}});var Ws=me((Sy,Vs)=>{\"use strict\";Vs.exports=qn;function qn(){this._listeners={}}qn.prototype.on=function(t,o,e){return(this._listeners[t]||(this._listeners[t]=[])).push({fn:o,ctx:e||this}),this};qn.prototype.off=function(t,o){if(t===void 0)this._listeners={};else if(o===void 0)this._listeners[t]=[];else for(var e=this._listeners[t],r=0;r<e.length;)e[r].fn===o?e.splice(r,1):++r;return this};qn.prototype.emit=function(t){var o=this._listeners[t];if(o){for(var e=[],r=1;r<arguments.length;)e.push(arguments[r++]);for(r=0;r<o.length;)o[r].fn.apply(o[r++].ctx,e)}return this}});var Js=me((Ay,Ks)=>{\"use strict\";Ks.exports=Hs(Hs);function Hs(a){return typeof Float32Array<\"u\"?function(){var t=new Float32Array([-0]),o=new Uint8Array(t.buffer),e=o[3]===128;function r(u,l,f){t[0]=u,l[f]=o[0],l[f+1]=o[1],l[f+2]=o[2],l[f+3]=o[3]}function n(u,l,f){t[0]=u,l[f]=o[3],l[f+1]=o[2],l[f+2]=o[1],l[f+3]=o[0]}a.writeFloatLE=e?r:n,a.writeFloatBE=e?n:r;function s(u,l){return o[0]=u[l],o[1]=u[l+1],o[2]=u[l+2],o[3]=u[l+3],t[0]}function i(u,l){return o[3]=u[l],o[2]=u[l+1],o[1]=u[l+2],o[0]=u[l+3],t[0]}a.readFloatLE=e?s:i,a.readFloatBE=e?i:s}():function(){function t(e,r,n,s){var i=r<0?1:0;if(i&&(r=-r),r===0)e(1/r>0?0:2147483648,n,s);else if(isNaN(r))e(2143289344,n,s);else if(r>34028234663852886e22)e((i<<31|2139095040)>>>0,n,s);else if(r<11754943508222875e-54)e((i<<31|Math.round(r/1401298464324817e-60))>>>0,n,s);else{var u=Math.floor(Math.log(r)/Math.LN2),l=Math.round(r*Math.pow(2,-u)*8388608)&8388607;e((i<<31|u+127<<23|l)>>>0,n,s)}}a.writeFloatLE=t.bind(null,qs),a.writeFloatBE=t.bind(null,js);function o(e,r,n){var s=e(r,n),i=(s>>31)*2+1,u=s>>>23&255,l=s&8388607;return u===255?l?NaN:i*(1/0):u===0?i*1401298464324817e-60*l:i*Math.pow(2,u-150)*(l+8388608)}a.readFloatLE=o.bind(null,Ys),a.readFloatBE=o.bind(null,Xs)}(),typeof Float64Array<\"u\"?function(){var t=new Float64Array([-0]),o=new Uint8Array(t.buffer),e=o[7]===128;function r(u,l,f){t[0]=u,l[f]=o[0],l[f+1]=o[1],l[f+2]=o[2],l[f+3]=o[3],l[f+4]=o[4],l[f+5]=o[5],l[f+6]=o[6],l[f+7]=o[7]}function n(u,l,f){t[0]=u,l[f]=o[7],l[f+1]=o[6],l[f+2]=o[5],l[f+3]=o[4],l[f+4]=o[3],l[f+5]=o[2],l[f+6]=o[1],l[f+7]=o[0]}a.writeDoubleLE=e?r:n,a.writeDoubleBE=e?n:r;function s(u,l){return o[0]=u[l],o[1]=u[l+1],o[2]=u[l+2],o[3]=u[l+3],o[4]=u[l+4],o[5]=u[l+5],o[6]=u[l+6],o[7]=u[l+7],t[0]}function i(u,l){return o[7]=u[l],o[6]=u[l+1],o[5]=u[l+2],o[4]=u[l+3],o[3]=u[l+4],o[2]=u[l+5],o[1]=u[l+6],o[0]=u[l+7],t[0]}a.readDoubleLE=e?s:i,a.readDoubleBE=e?i:s}():function(){function t(e,r,n,s,i,u){var l=s<0?1:0;if(l&&(s=-s),s===0)e(0,i,u+r),e(1/s>0?0:2147483648,i,u+n);else if(isNaN(s))e(0,i,u+r),e(2146959360,i,u+n);else if(s>17976931348623157e292)e(0,i,u+r),e((l<<31|2146435072)>>>0,i,u+n);else{var f;if(s<22250738585072014e-324)f=s/5e-324,e(f>>>0,i,u+r),e((l<<31|f/4294967296)>>>0,i,u+n);else{var p=Math.floor(Math.log(s)/Math.LN2);p===1024&&(p=1023),f=s*Math.pow(2,-p),e(f*4503599627370496>>>0,i,u+r),e((l<<31|p+1023<<20|f*1048576&1048575)>>>0,i,u+n)}}}a.writeDoubleLE=t.bind(null,qs,0,4),a.writeDoubleBE=t.bind(null,js,4,0);function o(e,r,n,s,i){var u=e(s,i+r),l=e(s,i+n),f=(l>>31)*2+1,p=l>>>20&2047,d=4294967296*(l&1048575)+u;return p===2047?d?NaN:f*(1/0):p===0?f*5e-324*d:f*Math.pow(2,p-1075)*(d+4503599627370496)}a.readDoubleLE=o.bind(null,Ys,0,4),a.readDoubleBE=o.bind(null,Xs,4,0)}(),a}function qs(a,t,o){t[o]=a&255,t[o+1]=a>>>8&255,t[o+2]=a>>>16&255,t[o+3]=a>>>24}function js(a,t,o){t[o]=a>>>24,t[o+1]=a>>>16&255,t[o+2]=a>>>8&255,t[o+3]=a&255}function Ys(a,t){return(a[t]|a[t+1]<<8|a[t+2]<<16|a[t+3]<<24)>>>0}function Xs(a,t){return(a[t]<<24|a[t+1]<<16|a[t+2]<<8|a[t+3])>>>0}});var Zs=me((exports,module)=>{\"use strict\";module.exports=inquire;function inquire(moduleName){try{var mod=eval(\"quire\".replace(/^/,\"re\"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(a){}return null}});var eu=me(Qs=>{\"use strict\";var ti=Qs;ti.length=function(t){for(var o=0,e=0,r=0;r<t.length;++r)e=t.charCodeAt(r),e<128?o+=1:e<2048?o+=2:(e&64512)===55296&&(t.charCodeAt(r+1)&64512)===56320?(++r,o+=4):o+=3;return o};ti.read=function(t,o,e){var r=e-o;if(r<1)return\"\";for(var n=null,s=[],i=0,u;o<e;)u=t[o++],u<128?s[i++]=u:u>191&&u<224?s[i++]=(u&31)<<6|t[o++]&63:u>239&&u<365?(u=((u&7)<<18|(t[o++]&63)<<12|(t[o++]&63)<<6|t[o++]&63)-65536,s[i++]=55296+(u>>10),s[i++]=56320+(u&1023)):s[i++]=(u&15)<<12|(t[o++]&63)<<6|t[o++]&63,i>8191&&((n||(n=[])).push(String.fromCharCode.apply(String,s)),i=0);return n?(i&&n.push(String.fromCharCode.apply(String,s.slice(0,i))),n.join(\"\")):String.fromCharCode.apply(String,s.slice(0,i))};ti.write=function(t,o,e){for(var r=e,n,s,i=0;i<t.length;++i)n=t.charCodeAt(i),n<128?o[e++]=n:n<2048?(o[e++]=n>>6|192,o[e++]=n&63|128):(n&64512)===55296&&((s=t.charCodeAt(i+1))&64512)===56320?(n=65536+((n&1023)<<10)+(s&1023),++i,o[e++]=n>>18|240,o[e++]=n>>12&63|128,o[e++]=n>>6&63|128,o[e++]=n&63|128):(o[e++]=n>>12|224,o[e++]=n>>6&63|128,o[e++]=n&63|128);return e-r}});var ru=me((Ey,tu)=>{\"use strict\";tu.exports=Md;function Md(a,t,o){var e=o||8192,r=e>>>1,n=null,s=e;return function(u){if(u<1||u>r)return a(u);s+u>e&&(n=a(e),s=0);var l=t.call(n,s,s+=u);return s&7&&(s=(s|7)+1),l}}});var ou=me((Dy,nu)=>{\"use strict\";nu.exports=Me;var on=Xt();function Me(a,t){this.lo=a>>>0,this.hi=t>>>0}var fr=Me.zero=new Me(0,0);fr.toNumber=function(){return 0};fr.zzEncode=fr.zzDecode=function(){return this};fr.length=function(){return 1};var Gd=Me.zeroHash=\"\\0\\0\\0\\0\\0\\0\\0\\0\";Me.fromNumber=function(t){if(t===0)return fr;var o=t<0;o&&(t=-t);var e=t>>>0,r=(t-e)/4294967296>>>0;return o&&(r=~r>>>0,e=~e>>>0,++e>4294967295&&(e=0,++r>4294967295&&(r=0))),new Me(e,r)};Me.from=function(t){if(typeof t==\"number\")return Me.fromNumber(t);if(on.isString(t))if(on.Long)t=on.Long.fromString(t);else return Me.fromNumber(parseInt(t,10));return t.low||t.high?new Me(t.low>>>0,t.high>>>0):fr};Me.prototype.toNumber=function(t){if(!t&&this.hi>>>31){var o=~this.lo+1>>>0,e=~this.hi>>>0;return o||(e=e+1>>>0),-(o+e*4294967296)}return this.lo+this.hi*4294967296};Me.prototype.toLong=function(t){return on.Long?new on.Long(this.lo|0,this.hi|0,!!t):{low:this.lo|0,high:this.hi|0,unsigned:!!t}};var Yt=String.prototype.charCodeAt;Me.fromHash=function(t){return t===Gd?fr:new Me((Yt.call(t,0)|Yt.call(t,1)<<8|Yt.call(t,2)<<16|Yt.call(t,3)<<24)>>>0,(Yt.call(t,4)|Yt.call(t,5)<<8|Yt.call(t,6)<<16|Yt.call(t,7)<<24)>>>0)};Me.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)};Me.prototype.zzEncode=function(){var t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this};Me.prototype.zzDecode=function(){var t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this};Me.prototype.length=function(){var t=this.lo,o=(this.lo>>>28|this.hi<<4)>>>0,e=this.hi>>>24;return e===0?o===0?t<16384?t<128?1:2:t<2097152?3:4:o<16384?o<128?5:6:o<2097152?7:8:e<128?9:10}});var Xt=me(ri=>{\"use strict\";var H=ri;H.asPromise=Rs();H.base64=zs();H.EventEmitter=Ws();H.float=Js();H.inquire=Zs();H.utf8=eu();H.pool=ru();H.LongBits=ou();H.isNode=!!(typeof global<\"u\"&&global&&global.process&&global.process.versions&&global.process.versions.node);H.global=H.isNode&&global||typeof window<\"u\"&&window||typeof self<\"u\"&&self||ri;H.emptyArray=Object.freeze?Object.freeze([]):[];H.emptyObject=Object.freeze?Object.freeze({}):{};H.isInteger=Number.isInteger||function(t){return typeof t==\"number\"&&isFinite(t)&&Math.floor(t)===t};H.isString=function(t){return typeof t==\"string\"||t instanceof String};H.isObject=function(t){return t&&typeof t==\"object\"};H.isset=H.isSet=function(t,o){var e=t[o];return e!=null&&t.hasOwnProperty(o)?typeof e!=\"object\"||(Array.isArray(e)?e.length:Object.keys(e).length)>0:!1};H.Buffer=function(){try{var a=H.inquire(\"buffer\").Buffer;return a.prototype.utf8Write?a:null}catch{return null}}();H._Buffer_from=null;H._Buffer_allocUnsafe=null;H.newBuffer=function(t){return typeof t==\"number\"?H.Buffer?H._Buffer_allocUnsafe(t):new H.Array(t):H.Buffer?H._Buffer_from(t):typeof Uint8Array>\"u\"?t:new Uint8Array(t)};H.Array=typeof Uint8Array<\"u\"?Uint8Array:Array;H.Long=H.global.dcodeIO&&H.global.dcodeIO.Long||H.global.Long||H.inquire(\"long\");H.key2Re=/^true|false|0|1$/;H.key32Re=/^-?(?:0|[1-9][0-9]*)$/;H.key64Re=/^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;H.longToHash=function(t){return t?H.LongBits.from(t).toHash():H.LongBits.zeroHash};H.longFromHash=function(t,o){var e=H.LongBits.fromHash(t);return H.Long?H.Long.fromBits(e.lo,e.hi,o):e.toNumber(!!o)};function iu(a,t,o){for(var e=Object.keys(t),r=0;r<e.length;++r)(a[e[r]]===void 0||!o)&&(a[e[r]]=t[e[r]]);return a}H.merge=iu;H.lcFirst=function(t){return t.charAt(0).toLowerCase()+t.substring(1)};function au(a){function t(o,e){if(!(this instanceof t))return new t(o,e);Object.defineProperty(this,\"message\",{get:function(){return o}}),Error.captureStackTrace?Error.captureStackTrace(this,t):Object.defineProperty(this,\"stack\",{value:new Error().stack||\"\"}),e&&iu(this,e)}return t.prototype=Object.create(Error.prototype,{constructor:{value:t,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return a},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+\": \"+this.message},writable:!0,enumerable:!1,configurable:!0}}),t}H.newError=au;H.ProtocolError=au(\"ProtocolError\");H.oneOfGetter=function(t){for(var o={},e=0;e<t.length;++e)o[t[e]]=1;return function(){for(var r=Object.keys(this),n=r.length-1;n>-1;--n)if(o[r[n]]===1&&this[r[n]]!==void 0&&this[r[n]]!==null)return r[n]}};H.oneOfSetter=function(t){return function(o){for(var e=0;e<t.length;++e)t[e]!==o&&delete this[t[e]]}};H.toJSONOptions={longs:String,enums:String,bytes:String,json:!0};H._configure=function(){var a=H.Buffer;if(!a){H._Buffer_from=H._Buffer_allocUnsafe=null;return}H._Buffer_from=a.from!==Uint8Array.from&&a.from||function(o,e){return new a(o,e)},H._Buffer_allocUnsafe=a.allocUnsafe||function(o){return new a(o)}}});var li=me((Fy,fu)=>{\"use strict\";fu.exports=se;var lt=Xt(),ni,jn=lt.LongBits,su=lt.base64,uu=lt.utf8;function an(a,t,o){this.fn=a,this.len=t,this.next=void 0,this.val=o}function ii(){}function Ud(a){this.head=a.head,this.tail=a.tail,this.len=a.len,this.next=a.states}function se(){this.len=0,this.head=new an(ii,0,0),this.tail=this.head,this.states=null}var lu=function(){return lt.Buffer?function(){return(se.create=function(){return new ni})()}:function(){return new se}};se.create=lu();se.alloc=function(t){return new lt.Array(t)};lt.Array!==Array&&(se.alloc=lt.pool(se.alloc,lt.Array.prototype.subarray));se.prototype._push=function(t,o,e){return this.tail=this.tail.next=new an(t,o,e),this.len+=o,this};function ai(a,t,o){t[o]=a&255}function zd(a,t,o){for(;a>127;)t[o++]=a&127|128,a>>>=7;t[o]=a}function si(a,t){this.len=a,this.next=void 0,this.val=t}si.prototype=Object.create(an.prototype);si.prototype.fn=zd;se.prototype.uint32=function(t){return this.len+=(this.tail=this.tail.next=new si((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this};se.prototype.int32=function(t){return t<0?this._push(ui,10,jn.fromNumber(t)):this.uint32(t)};se.prototype.sint32=function(t){return this.uint32((t<<1^t>>31)>>>0)};function ui(a,t,o){for(;a.hi;)t[o++]=a.lo&127|128,a.lo=(a.lo>>>7|a.hi<<25)>>>0,a.hi>>>=7;for(;a.lo>127;)t[o++]=a.lo&127|128,a.lo=a.lo>>>7;t[o++]=a.lo}se.prototype.uint64=function(t){var o=jn.from(t);return this._push(ui,o.length(),o)};se.prototype.int64=se.prototype.uint64;se.prototype.sint64=function(t){var o=jn.from(t).zzEncode();return this._push(ui,o.length(),o)};se.prototype.bool=function(t){return this._push(ai,1,t?1:0)};function oi(a,t,o){t[o]=a&255,t[o+1]=a>>>8&255,t[o+2]=a>>>16&255,t[o+3]=a>>>24}se.prototype.fixed32=function(t){return this._push(oi,4,t>>>0)};se.prototype.sfixed32=se.prototype.fixed32;se.prototype.fixed64=function(t){var o=jn.from(t);return this._push(oi,4,o.lo)._push(oi,4,o.hi)};se.prototype.sfixed64=se.prototype.fixed64;se.prototype.float=function(t){return this._push(lt.float.writeFloatLE,4,t)};se.prototype.double=function(t){return this._push(lt.float.writeDoubleLE,8,t)};var Vd=lt.Array.prototype.set?function(t,o,e){o.set(t,e)}:function(t,o,e){for(var r=0;r<t.length;++r)o[e+r]=t[r]};se.prototype.bytes=function(t){var o=t.length>>>0;if(!o)return this._push(ai,1,0);if(lt.isString(t)){var e=se.alloc(o=su.length(t));su.decode(t,e,0),t=e}return this.uint32(o)._push(Vd,o,t)};se.prototype.string=function(t){var o=uu.length(t);return o?this.uint32(o)._push(uu.write,o,t):this._push(ai,1,0)};se.prototype.fork=function(){return this.states=new Ud(this),this.head=this.tail=new an(ii,0,0),this.len=0,this};se.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new an(ii,0,0),this.len=0),this};se.prototype.ldelim=function(){var t=this.head,o=this.tail,e=this.len;return this.reset().uint32(e),e&&(this.tail.next=t.next,this.tail=o,this.len+=e),this};se.prototype.finish=function(){for(var t=this.head.next,o=this.constructor.alloc(this.len),e=0;t;)t.fn(t.val,o,e),e+=t.len,t=t.next;return o};se._configure=function(a){ni=a,se.create=lu(),ni._configure()}});var du=me((Cy,pu)=>{\"use strict\";pu.exports=Ct;var cu=li();(Ct.prototype=Object.create(cu.prototype)).constructor=Ct;var Kt=Xt();function Ct(){cu.call(this)}Ct._configure=function(){Ct.alloc=Kt._Buffer_allocUnsafe,Ct.writeBytesBuffer=Kt.Buffer&&Kt.Buffer.prototype instanceof Uint8Array&&Kt.Buffer.prototype.set.name===\"set\"?function(t,o,e){o.set(t,e)}:function(t,o,e){if(t.copy)t.copy(o,e,0,t.length);else for(var r=0;r<t.length;)o[e++]=t[r++]}};Ct.prototype.bytes=function(t){Kt.isString(t)&&(t=Kt._Buffer_from(t,\"base64\"));var o=t.length>>>0;return this.uint32(o),o&&this._push(Ct.writeBytesBuffer,o,t),this};function Wd(a,t,o){a.length<40?Kt.utf8.write(a,t,o):t.utf8Write?t.utf8Write(a,o):t.write(a,o)}Ct.prototype.string=function(t){var o=Kt.Buffer.byteLength(t);return this.uint32(o),o&&this._push(Wd,o,t),this};Ct._configure()});var pi=me(($y,yu)=>{\"use strict\";yu.exports=Pe;var $t=Xt(),ci,bu=$t.LongBits,Hd=$t.utf8;function _t(a,t){return RangeError(\"index out of range: \"+a.pos+\" + \"+(t||1)+\" > \"+a.len)}function Pe(a){this.buf=a,this.pos=0,this.len=a.length}var hu=typeof Uint8Array<\"u\"?function(t){if(t instanceof Uint8Array||Array.isArray(t))return new Pe(t);throw Error(\"illegal buffer\")}:function(t){if(Array.isArray(t))return new Pe(t);throw Error(\"illegal buffer\")},gu=function(){return $t.Buffer?function(o){return(Pe.create=function(r){return $t.Buffer.isBuffer(r)?new ci(r):hu(r)})(o)}:hu};Pe.create=gu();Pe.prototype._slice=$t.Array.prototype.subarray||$t.Array.prototype.slice;Pe.prototype.uint32=function(){var t=4294967295;return function(){if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,_t(this,10);return t}}();Pe.prototype.int32=function(){return this.uint32()|0};Pe.prototype.sint32=function(){var t=this.uint32();return t>>>1^-(t&1)|0};function fi(){var a=new bu(0,0),t=0;if(this.len-this.pos>4){for(;t<4;++t)if(a.lo=(a.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return a;if(a.lo=(a.lo|(this.buf[this.pos]&127)<<28)>>>0,a.hi=(a.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return a;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw _t(this);if(a.lo=(a.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return a}return a.lo=(a.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,a}if(this.len-this.pos>4){for(;t<5;++t)if(a.hi=(a.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return a}else for(;t<5;++t){if(this.pos>=this.len)throw _t(this);if(a.hi=(a.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return a}throw Error(\"invalid varint encoding\")}Pe.prototype.bool=function(){return this.uint32()!==0};function Yn(a,t){return(a[t-4]|a[t-3]<<8|a[t-2]<<16|a[t-1]<<24)>>>0}Pe.prototype.fixed32=function(){if(this.pos+4>this.len)throw _t(this,4);return Yn(this.buf,this.pos+=4)};Pe.prototype.sfixed32=function(){if(this.pos+4>this.len)throw _t(this,4);return Yn(this.buf,this.pos+=4)|0};function mu(){if(this.pos+8>this.len)throw _t(this,8);return new bu(Yn(this.buf,this.pos+=4),Yn(this.buf,this.pos+=4))}Pe.prototype.float=function(){if(this.pos+4>this.len)throw _t(this,4);var t=$t.float.readFloatLE(this.buf,this.pos);return this.pos+=4,t};Pe.prototype.double=function(){if(this.pos+8>this.len)throw _t(this,4);var t=$t.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,t};Pe.prototype.bytes=function(){var t=this.uint32(),o=this.pos,e=this.pos+t;if(e>this.len)throw _t(this,t);return this.pos+=t,Array.isArray(this.buf)?this.buf.slice(o,e):o===e?new this.buf.constructor(0):this._slice.call(this.buf,o,e)};Pe.prototype.string=function(){var t=this.bytes();return Hd.read(t,0,t.length)};Pe.prototype.skip=function(t){if(typeof t==\"number\"){if(this.pos+t>this.len)throw _t(this,t);this.pos+=t}else do if(this.pos>=this.len)throw _t(this);while(this.buf[this.pos++]&128);return this};Pe.prototype.skipType=function(a){switch(a){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(a=this.uint32()&7)!==4;)this.skipType(a);break;case 5:this.skip(4);break;default:throw Error(\"invalid wire type \"+a+\" at offset \"+this.pos)}return this};Pe._configure=function(a){ci=a,Pe.create=gu(),ci._configure();var t=$t.Long?\"toLong\":\"toNumber\";$t.merge(Pe.prototype,{int64:function(){return fi.call(this)[t](!1)},uint64:function(){return fi.call(this)[t](!0)},sint64:function(){return fi.call(this).zzDecode()[t](!1)},fixed64:function(){return mu.call(this)[t](!0)},sfixed64:function(){return mu.call(this)[t](!1)}})}});var vu=me((ky,wu)=>{\"use strict\";wu.exports=cr;var xu=pi();(cr.prototype=Object.create(xu.prototype)).constructor=cr;var Tu=Xt();function cr(a){xu.call(this,a)}cr._configure=function(){Tu.Buffer&&(cr.prototype._slice=Tu.Buffer.prototype.slice)};cr.prototype.string=function(){var t=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+t,this.len)):this.buf.toString(\"utf-8\",this.pos,this.pos=Math.min(this.pos+t,this.len))};cr._configure()});var Ou=me((By,_u)=>{\"use strict\";_u.exports=sn;var di=Xt();(sn.prototype=Object.create(di.EventEmitter.prototype)).constructor=sn;function sn(a,t,o){if(typeof a!=\"function\")throw TypeError(\"rpcImpl must be a function\");di.EventEmitter.call(this),this.rpcImpl=a,this.requestDelimited=!!t,this.responseDelimited=!!o}sn.prototype.rpcCall=function a(t,o,e,r,n){if(!r)throw TypeError(\"request must be specified\");var s=this;if(!n)return di.asPromise(a,s,t,o,e,r);if(!s.rpcImpl){setTimeout(function(){n(Error(\"already ended\"))},0);return}try{return s.rpcImpl(t,o[s.requestDelimited?\"encodeDelimited\":\"encode\"](r).finish(),function(u,l){if(u)return s.emit(\"error\",u,t),n(u);if(l===null){s.end(!0);return}if(!(l instanceof e))try{l=e[s.responseDelimited?\"decodeDelimited\":\"decode\"](l)}catch(f){return s.emit(\"error\",f,t),n(f)}return s.emit(\"data\",l,t),n(null,l)})}catch(i){s.emit(\"error\",i,t),setTimeout(function(){n(i)},0);return}};sn.prototype.end=function(t){return this.rpcImpl&&(t||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit(\"end\").off()),this}});var Su=me(Iu=>{\"use strict\";var qd=Iu;qd.Service=Ou()});var Pu=me((Ry,Au)=>{\"use strict\";Au.exports={}});var Lu=me(Du=>{\"use strict\";var rt=Du;rt.build=\"minimal\";rt.Writer=li();rt.BufferWriter=du();rt.Reader=pi();rt.BufferReader=vu();rt.util=Xt();rt.rpc=Su();rt.roots=Pu();rt.configure=Eu;function Eu(){rt.util._configure(),rt.Writer._configure(rt.BufferWriter),rt.Reader._configure(rt.BufferReader)}Eu()});var Cu=me((Gy,Fu)=>{\"use strict\";Fu.exports=Lu()});var $r=me((Uy,$u)=>{\"use strict\";var ge=Cu(),N=ge.Reader,Ee=ge.Writer,y=ge.util,m=ge.roots.default||(ge.roots.default={});m.onnx=function(){var a={};return a.Version=function(){var t={},o=Object.create(t);return o[t[0]=\"_START_VERSION\"]=0,o[t[1]=\"IR_VERSION_2017_10_10\"]=1,o[t[2]=\"IR_VERSION_2017_10_30\"]=2,o[t[3]=\"IR_VERSION_2017_11_3\"]=3,o[t[4]=\"IR_VERSION_2019_1_22\"]=4,o[t[5]=\"IR_VERSION_2019_3_18\"]=5,o[t[6]=\"IR_VERSION_2019_9_19\"]=6,o[t[7]=\"IR_VERSION_2020_5_8\"]=7,o[t[8]=\"IR_VERSION_2021_7_30\"]=8,o[t[9]=\"IR_VERSION\"]=9,o}(),a.AttributeProto=function(){function t(o){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],o)for(var e=Object.keys(o),r=0;r<e.length;++r)o[e[r]]!=null&&(this[e[r]]=o[e[r]])}return t.prototype.name=\"\",t.prototype.refAttrName=\"\",t.prototype.docString=\"\",t.prototype.type=0,t.prototype.f=0,t.prototype.i=y.Long?y.Long.fromBits(0,0,!1):0,t.prototype.s=y.newBuffer([]),t.prototype.t=null,t.prototype.g=null,t.prototype.sparseTensor=null,t.prototype.tp=null,t.prototype.floats=y.emptyArray,t.prototype.ints=y.emptyArray,t.prototype.strings=y.emptyArray,t.prototype.tensors=y.emptyArray,t.prototype.graphs=y.emptyArray,t.prototype.sparseTensors=y.emptyArray,t.prototype.typeProtos=y.emptyArray,t.create=function(e){return new t(e)},t.encode=function(e,r){if(r||(r=Ee.create()),e.name!=null&&Object.hasOwnProperty.call(e,\"name\")&&r.uint32(10).string(e.name),e.f!=null&&Object.hasOwnProperty.call(e,\"f\")&&r.uint32(21).float(e.f),e.i!=null&&Object.hasOwnProperty.call(e,\"i\")&&r.uint32(24).int64(e.i),e.s!=null&&Object.hasOwnProperty.call(e,\"s\")&&r.uint32(34).bytes(e.s),e.t!=null&&Object.hasOwnProperty.call(e,\"t\")&&m.onnx.TensorProto.encode(e.t,r.uint32(42).fork()).ldelim(),e.g!=null&&Object.hasOwnProperty.call(e,\"g\")&&m.onnx.GraphProto.encode(e.g,r.uint32(50).fork()).ldelim(),e.floats!=null&&e.floats.length){r.uint32(58).fork();for(var n=0;n<e.floats.length;++n)r.float(e.floats[n]);r.ldelim()}if(e.ints!=null&&e.ints.length){r.uint32(66).fork();for(var n=0;n<e.ints.length;++n)r.int64(e.ints[n]);r.ldelim()}if(e.strings!=null&&e.strings.length)for(var n=0;n<e.strings.length;++n)r.uint32(74).bytes(e.strings[n]);if(e.tensors!=null&&e.tensors.length)for(var n=0;n<e.tensors.length;++n)m.onnx.TensorProto.encode(e.tensors[n],r.uint32(82).fork()).ldelim();if(e.graphs!=null&&e.graphs.length)for(var n=0;n<e.graphs.length;++n)m.onnx.GraphProto.encode(e.graphs[n],r.uint32(90).fork()).ldelim();if(e.docString!=null&&Object.hasOwnProperty.call(e,\"docString\")&&r.uint32(106).string(e.docString),e.tp!=null&&Object.hasOwnProperty.call(e,\"tp\")&&m.onnx.TypeProto.encode(e.tp,r.uint32(114).fork()).ldelim(),e.typeProtos!=null&&e.typeProtos.length)for(var n=0;n<e.typeProtos.length;++n)m.onnx.TypeProto.encode(e.typeProtos[n],r.uint32(122).fork()).ldelim();if(e.type!=null&&Object.hasOwnProperty.call(e,\"type\")&&r.uint32(160).int32(e.type),e.refAttrName!=null&&Object.hasOwnProperty.call(e,\"refAttrName\")&&r.uint32(170).string(e.refAttrName),e.sparseTensor!=null&&Object.hasOwnProperty.call(e,\"sparseTensor\")&&m.onnx.SparseTensorProto.encode(e.sparseTensor,r.uint32(178).fork()).ldelim(),e.sparseTensors!=null&&e.sparseTensors.length)for(var n=0;n<e.sparseTensors.length;++n)m.onnx.SparseTensorProto.encode(e.sparseTensors[n],r.uint32(186).fork()).ldelim();return r},t.encodeDelimited=function(e,r){return this.encode(e,r).ldelim()},t.decode=function(e,r){e instanceof N||(e=N.create(e));for(var n=r===void 0?e.len:e.pos+r,s=new m.onnx.AttributeProto;e.pos<n;){var i=e.uint32();switch(i>>>3){case 1:{s.name=e.string();break}case 21:{s.refAttrName=e.string();break}case 13:{s.docString=e.string();break}case 20:{s.type=e.int32();break}case 2:{s.f=e.float();break}case 3:{s.i=e.int64();break}case 4:{s.s=e.bytes();break}case 5:{s.t=m.onnx.TensorProto.decode(e,e.uint32());break}case 6:{s.g=m.onnx.GraphProto.decode(e,e.uint32());break}case 22:{s.sparseTensor=m.onnx.SparseTensorProto.decode(e,e.uint32());break}case 14:{s.tp=m.onnx.TypeProto.decode(e,e.uint32());break}case 7:{if(s.floats&&s.floats.length||(s.floats=[]),(i&7)===2)for(var u=e.uint32()+e.pos;e.pos<u;)s.floats.push(e.float());else s.floats.push(e.float());break}case 8:{if(s.ints&&s.ints.length||(s.ints=[]),(i&7)===2)for(var u=e.uint32()+e.pos;e.pos<u;)s.ints.push(e.int64());else s.ints.push(e.int64());break}case 9:{s.strings&&s.strings.length||(s.strings=[]),s.strings.push(e.bytes());break}case 10:{s.tensors&&s.tensors.length||(s.tensors=[]),s.tensors.push(m.onnx.TensorProto.decode(e,e.uint32()));break}case 11:{s.graphs&&s.graphs.length||(s.graphs=[]),s.graphs.push(m.onnx.GraphProto.decode(e,e.uint32()));break}case 23:{s.sparseTensors&&s.sparseTensors.length||(s.sparseTensors=[]),s.sparseTensors.push(m.onnx.SparseTensorProto.decode(e,e.uint32()));break}case 15:{s.typeProtos&&s.typeProtos.length||(s.typeProtos=[]),s.typeProtos.push(m.onnx.TypeProto.decode(e,e.uint32()));break}default:e.skipType(i&7);break}}return s},t.decodeDelimited=function(e){return e instanceof N||(e=new N(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!=\"object\"||e===null)return\"object expected\";if(e.name!=null&&e.hasOwnProperty(\"name\")&&!y.isString(e.name))return\"name: string expected\";if(e.refAttrName!=null&&e.hasOwnProperty(\"refAttrName\")&&!y.isString(e.refAttrName))return\"refAttrName: string expected\";if(e.docString!=null&&e.hasOwnProperty(\"docString\")&&!y.isString(e.docString))return\"docString: string expected\";if(e.type!=null&&e.hasOwnProperty(\"type\"))switch(e.type){default:return\"type: enum value expected\";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:break}if(e.f!=null&&e.hasOwnProperty(\"f\")&&typeof e.f!=\"number\")return\"f: number expected\";if(e.i!=null&&e.hasOwnProperty(\"i\")&&!y.isInteger(e.i)&&!(e.i&&y.isInteger(e.i.low)&&y.isInteger(e.i.high)))return\"i: integer|Long expected\";if(e.s!=null&&e.hasOwnProperty(\"s\")&&!(e.s&&typeof e.s.length==\"number\"||y.isString(e.s)))return\"s: buffer expected\";if(e.t!=null&&e.hasOwnProperty(\"t\")){var r=m.onnx.TensorProto.verify(e.t);if(r)return\"t.\"+r}if(e.g!=null&&e.hasOwnProperty(\"g\")){var r=m.onnx.GraphProto.verify(e.g);if(r)return\"g.\"+r}if(e.sparseTensor!=null&&e.hasOwnProperty(\"sparseTensor\")){var r=m.onnx.SparseTensorProto.verify(e.sparseTensor);if(r)return\"sparseTensor.\"+r}if(e.tp!=null&&e.hasOwnProperty(\"tp\")){var r=m.onnx.TypeProto.verify(e.tp);if(r)return\"tp.\"+r}if(e.floats!=null&&e.hasOwnProperty(\"floats\")){if(!Array.isArray(e.floats))return\"floats: array expected\";for(var n=0;n<e.floats.length;++n)if(typeof e.floats[n]!=\"number\")return\"floats: number[] expected\"}if(e.ints!=null&&e.hasOwnProperty(\"ints\")){if(!Array.isArray(e.ints))return\"ints: array expected\";for(var n=0;n<e.ints.length;++n)if(!y.isInteger(e.ints[n])&&!(e.ints[n]&&y.isInteger(e.ints[n].low)&&y.isInteger(e.ints[n].high)))return\"ints: integer|Long[] expected\"}if(e.strings!=null&&e.hasOwnProperty(\"strings\")){if(!Array.isArray(e.strings))return\"strings: array expected\";for(var n=0;n<e.strings.length;++n)if(!(e.strings[n]&&typeof e.strings[n].length==\"number\"||y.isString(e.strings[n])))return\"strings: buffer[] expected\"}if(e.tensors!=null&&e.hasOwnProperty(\"tensors\")){if(!Array.isArray(e.tensors))return\"tensors: array expected\";for(var n=0;n<e.tensors.length;++n){var r=m.onnx.TensorProto.verify(e.tensors[n]);if(r)return\"tensors.\"+r}}if(e.graphs!=null&&e.hasOwnProperty(\"graphs\")){if(!Array.isArray(e.graphs))return\"graphs: array expected\";for(var n=0;n<e.graphs.length;++n){var r=m.onnx.GraphProto.verify(e.graphs[n]);if(r)return\"graphs.\"+r}}if(e.sparseTensors!=null&&e.hasOwnProperty(\"sparseTensors\")){if(!Array.isArray(e.sparseTensors))return\"sparseTensors: array expected\";for(var n=0;n<e.sparseTensors.length;++n){var r=m.onnx.SparseTensorProto.verify(e.sparseTensors[n]);if(r)return\"sparseTensors.\"+r}}if(e.typeProtos!=null&&e.hasOwnProperty(\"typeProtos\")){if(!Array.isArray(e.typeProtos))return\"typeProtos: array expected\";for(var n=0;n<e.typeProtos.length;++n){var r=m.onnx.TypeProto.verify(e.typeProtos[n]);if(r)return\"typeProtos.\"+r}}return null},t.fromObject=function(e){if(e instanceof m.onnx.AttributeProto)return e;var r=new m.onnx.AttributeProto;switch(e.name!=null&&(r.name=String(e.name)),e.refAttrName!=null&&(r.refAttrName=String(e.refAttrName)),e.docString!=null&&(r.docString=String(e.docString)),e.type){default:if(typeof e.type==\"number\"){r.type=e.type;break}break;case\"UNDEFINED\":case 0:r.type=0;break;case\"FLOAT\":case 1:r.type=1;break;case\"INT\":case 2:r.type=2;break;case\"STRING\":case 3:r.type=3;break;case\"TENSOR\":case 4:r.type=4;break;case\"GRAPH\":case 5:r.type=5;break;case\"SPARSE_TENSOR\":case 11:r.type=11;break;case\"TYPE_PROTO\":case 13:r.type=13;break;case\"FLOATS\":case 6:r.type=6;break;case\"INTS\":case 7:r.type=7;break;case\"STRINGS\":case 8:r.type=8;break;case\"TENSORS\":case 9:r.type=9;break;case\"GRAPHS\":case 10:r.type=10;break;case\"SPARSE_TENSORS\":case 12:r.type=12;break;case\"TYPE_PROTOS\":case 14:r.type=14;break}if(e.f!=null&&(r.f=Number(e.f)),e.i!=null&&(y.Long?(r.i=y.Long.fromValue(e.i)).unsigned=!1:typeof e.i==\"string\"?r.i=parseInt(e.i,10):typeof e.i==\"number\"?r.i=e.i:typeof e.i==\"object\"&&(r.i=new y.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber())),e.s!=null&&(typeof e.s==\"string\"?y.base64.decode(e.s,r.s=y.newBuffer(y.base64.length(e.s)),0):e.s.length>=0&&(r.s=e.s)),e.t!=null){if(typeof e.t!=\"object\")throw TypeError(\".onnx.AttributeProto.t: object expected\");r.t=m.onnx.TensorProto.fromObject(e.t)}if(e.g!=null){if(typeof e.g!=\"object\")throw TypeError(\".onnx.AttributeProto.g: object expected\");r.g=m.onnx.GraphProto.fromObject(e.g)}if(e.sparseTensor!=null){if(typeof e.sparseTensor!=\"object\")throw TypeError(\".onnx.AttributeProto.sparseTensor: object expected\");r.sparseTensor=m.onnx.SparseTensorProto.fromObject(e.sparseTensor)}if(e.tp!=null){if(typeof e.tp!=\"object\")throw TypeError(\".onnx.AttributeProto.tp: object expected\");r.tp=m.onnx.TypeProto.fromObject(e.tp)}if(e.floats){if(!Array.isArray(e.floats))throw TypeError(\".onnx.AttributeProto.floats: array expected\");r.floats=[];for(var n=0;n<e.floats.length;++n)r.floats[n]=Number(e.floats[n])}if(e.ints){if(!Array.isArray(e.ints))throw TypeError(\".onnx.AttributeProto.ints: array expected\");r.ints=[];for(var n=0;n<e.ints.length;++n)y.Long?(r.ints[n]=y.Long.fromValue(e.ints[n])).unsigned=!1:typeof e.ints[n]==\"string\"?r.ints[n]=parseInt(e.ints[n],10):typeof e.ints[n]==\"number\"?r.ints[n]=e.ints[n]:typeof e.ints[n]==\"object\"&&(r.ints[n]=new y.LongBits(e.ints[n].low>>>0,e.ints[n].high>>>0).toNumber())}if(e.strings){if(!Array.isArray(e.strings))throw TypeError(\".onnx.AttributeProto.strings: array expected\");r.strings=[];for(var n=0;n<e.strings.length;++n)typeof e.strings[n]==\"string\"?y.base64.decode(e.strings[n],r.strings[n]=y.newBuffer(y.base64.length(e.strings[n])),0):e.strings[n].length>=0&&(r.strings[n]=e.strings[n])}if(e.tensors){if(!Array.isArray(e.tensors))throw TypeError(\".onnx.AttributeProto.tensors: array expected\");r.tensors=[];for(var n=0;n<e.tensors.length;++n){if(typeof e.tensors[n]!=\"object\")throw TypeError(\".onnx.AttributeProto.tensors: object expected\");r.tensors[n]=m.onnx.TensorProto.fromObject(e.tensors[n])}}if(e.graphs){if(!Array.isArray(e.graphs))throw TypeError(\".onnx.AttributeProto.graphs: array expected\");r.graphs=[];for(var n=0;n<e.graphs.length;++n){if(typeof e.graphs[n]!=\"object\")throw TypeError(\".onnx.AttributeProto.graphs: object expected\");r.graphs[n]=m.onnx.GraphProto.fromObject(e.graphs[n])}}if(e.sparseTensors){if(!Array.isArray(e.sparseTensors))throw TypeError(\".onnx.AttributeProto.sparseTensors: array expected\");r.sparseTensors=[];for(var n=0;n<e.sparseTensors.length;++n){if(typeof e.sparseTensors[n]!=\"object\")throw TypeError(\".onnx.AttributeProto.sparseTensors: object expected\");r.sparseTensors[n]=m.onnx.SparseTensorProto.fromObject(e.sparseTensors[n])}}if(e.typeProtos){if(!Array.isArray(e.typeProtos))throw TypeError(\".onnx.AttributeProto.typeProtos: array expected\");r.typeProtos=[];for(var n=0;n<e.typeProtos.length;++n){if(typeof e.typeProtos[n]!=\"object\")throw TypeError(\".onnx.AttributeProto.typeProtos: object expected\");r.typeProtos[n]=m.onnx.TypeProto.fromObject(e.typeProtos[n])}}return r},t.toObject=function(e,r){r||(r={});var n={};if((r.arrays||r.defaults)&&(n.floats=[],n.ints=[],n.strings=[],n.tensors=[],n.graphs=[],n.typeProtos=[],n.sparseTensors=[]),r.defaults){if(n.name=\"\",n.f=0,y.Long){var s=new y.Long(0,0,!1);n.i=r.longs===String?s.toString():r.longs===Number?s.toNumber():s}else n.i=r.longs===String?\"0\":0;r.bytes===String?n.s=\"\":(n.s=[],r.bytes!==Array&&(n.s=y.newBuffer(n.s))),n.t=null,n.g=null,n.docString=\"\",n.tp=null,n.type=r.enums===String?\"UNDEFINED\":0,n.refAttrName=\"\",n.sparseTensor=null}if(e.name!=null&&e.hasOwnProperty(\"name\")&&(n.name=e.name),e.f!=null&&e.hasOwnProperty(\"f\")&&(n.f=r.json&&!isFinite(e.f)?String(e.f):e.f),e.i!=null&&e.hasOwnProperty(\"i\")&&(typeof e.i==\"number\"?n.i=r.longs===String?String(e.i):e.i:n.i=r.longs===String?y.Long.prototype.toString.call(e.i):r.longs===Number?new y.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber():e.i),e.s!=null&&e.hasOwnProperty(\"s\")&&(n.s=r.bytes===String?y.base64.encode(e.s,0,e.s.length):r.bytes===Array?Array.prototype.slice.call(e.s):e.s),e.t!=null&&e.hasOwnProperty(\"t\")&&(n.t=m.onnx.TensorProto.toObject(e.t,r)),e.g!=null&&e.hasOwnProperty(\"g\")&&(n.g=m.onnx.GraphProto.toObject(e.g,r)),e.floats&&e.floats.length){n.floats=[];for(var i=0;i<e.floats.length;++i)n.floats[i]=r.json&&!isFinite(e.floats[i])?String(e.floats[i]):e.floats[i]}if(e.ints&&e.ints.length){n.ints=[];for(var i=0;i<e.ints.length;++i)typeof e.ints[i]==\"number\"?n.ints[i]=r.longs===String?String(e.ints[i]):e.ints[i]:n.ints[i]=r.longs===String?y.Long.prototype.toString.call(e.ints[i]):r.longs===Number?new y.LongBits(e.ints[i].low>>>0,e.ints[i].high>>>0).toNumber():e.ints[i]}if(e.strings&&e.strings.length){n.strings=[];for(var i=0;i<e.strings.length;++i)n.strings[i]=r.bytes===String?y.base64.encode(e.strings[i],0,e.strings[i].length):r.bytes===Array?Array.prototype.slice.call(e.strings[i]):e.strings[i]}if(e.tensors&&e.tensors.length){n.tensors=[];for(var i=0;i<e.tensors.length;++i)n.tensors[i]=m.onnx.TensorProto.toObject(e.tensors[i],r)}if(e.graphs&&e.graphs.length){n.graphs=[];for(var i=0;i<e.graphs.length;++i)n.graphs[i]=m.onnx.GraphProto.toObject(e.graphs[i],r)}if(e.docString!=null&&e.hasOwnProperty(\"docString\")&&(n.docString=e.docString),e.tp!=null&&e.hasOwnProperty(\"tp\")&&(n.tp=m.onnx.TypeProto.toObject(e.tp,r)),e.typeProtos&&e.typeProtos.length){n.typeProtos=[];for(var i=0;i<e.typeProtos.length;++i)n.typeProtos[i]=m.onnx.TypeProto.toObject(e.typeProtos[i],r)}if(e.type!=null&&e.hasOwnProperty(\"type\")&&(n.type=r.enums===String?m.onnx.AttributeProto.AttributeType[e.type]===void 0?e.type:m.onnx.AttributeProto.AttributeType[e.type]:e.type),e.refAttrName!=null&&e.hasOwnProperty(\"refAttrName\")&&(n.refAttrName=e.refAttrName),e.sparseTensor!=null&&e.hasOwnProperty(\"sparseTensor\")&&(n.sparseTensor=m.onnx.SparseTensorProto.toObject(e.sparseTensor,r)),e.sparseTensors&&e.sparseTensors.length){n.sparseTensors=[];for(var i=0;i<e.sparseTensors.length;++i)n.sparseTensors[i]=m.onnx.SparseTensorProto.toObject(e.sparseTensors[i],r)}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},t.getTypeUrl=function(e){return e===void 0&&(e=\"type.googleapis.com\"),e+\"/onnx.AttributeProto\"},t.AttributeType=function(){var o={},e=Object.create(o);return e[o[0]=\"UNDEFINED\"]=0,e[o[1]=\"FLOAT\"]=1,e[o[2]=\"INT\"]=2,e[o[3]=\"STRING\"]=3,e[o[4]=\"TENSOR\"]=4,e[o[5]=\"GRAPH\"]=5,e[o[11]=\"SPARSE_TENSOR\"]=11,e[o[13]=\"TYPE_PROTO\"]=13,e[o[6]=\"FLOATS\"]=6,e[o[7]=\"INTS\"]=7,e[o[8]=\"STRINGS\"]=8,e[o[9]=\"TENSORS\"]=9,e[o[10]=\"GRAPHS\"]=10,e[o[12]=\"SPARSE_TENSORS\"]=12,e[o[14]=\"TYPE_PROTOS\"]=14,e}(),t}(),a.ValueInfoProto=function(){function t(o){if(o)for(var e=Object.keys(o),r=0;r<e.length;++r)o[e[r]]!=null&&(this[e[r]]=o[e[r]])}return t.prototype.name=\"\",t.prototype.type=null,t.prototype.docString=\"\",t.create=function(e){return new t(e)},t.encode=function(e,r){return r||(r=Ee.create()),e.name!=null&&Object.hasOwnProperty.call(e,\"name\")&&r.uint32(10).string(e.name),e.type!=null&&Object.hasOwnProperty.call(e,\"type\")&&m.onnx.TypeProto.encode(e.type,r.uint32(18).fork()).ldelim(),e.docString!=null&&Object.hasOwnProperty.call(e,\"docString\")&&r.uint32(26).string(e.docString),r},t.encodeDelimited=function(e,r){return this.encode(e,r).ldelim()},t.decode=function(e,r){e instanceof N||(e=N.create(e));for(var n=r===void 0?e.len:e.pos+r,s=new m.onnx.ValueInfoProto;e.pos<n;){var i=e.uint32();switch(i>>>3){case 1:{s.name=e.string();break}case 2:{s.type=m.onnx.TypeProto.decode(e,e.uint32());break}case 3:{s.docString=e.string();break}default:e.skipType(i&7);break}}return s},t.decodeDelimited=function(e){return e instanceof N||(e=new N(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!=\"object\"||e===null)return\"object expected\";if(e.name!=null&&e.hasOwnProperty(\"name\")&&!y.isString(e.name))return\"name: string expected\";if(e.type!=null&&e.hasOwnProperty(\"type\")){var r=m.onnx.TypeProto.verify(e.type);if(r)return\"type.\"+r}return e.docString!=null&&e.hasOwnProperty(\"docString\")&&!y.isString(e.docString)?\"docString: string expected\":null},t.fromObject=function(e){if(e instanceof m.onnx.ValueInfoProto)return e;var r=new m.onnx.ValueInfoProto;if(e.name!=null&&(r.name=String(e.name)),e.type!=null){if(typeof e.type!=\"object\")throw TypeError(\".onnx.ValueInfoProto.type: object expected\");r.type=m.onnx.TypeProto.fromObject(e.type)}return e.docString!=null&&(r.docString=String(e.docString)),r},t.toObject=function(e,r){r||(r={});var n={};return r.defaults&&(n.name=\"\",n.type=null,n.docString=\"\"),e.name!=null&&e.hasOwnProperty(\"name\")&&(n.name=e.name),e.type!=null&&e.hasOwnProperty(\"type\")&&(n.type=m.onnx.TypeProto.toObject(e.type,r)),e.docString!=null&&e.hasOwnProperty(\"docString\")&&(n.docString=e.docString),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},t.getTypeUrl=function(e){return e===void 0&&(e=\"type.googleapis.com\"),e+\"/onnx.ValueInfoProto\"},t}(),a.NodeProto=function(){function t(o){if(this.input=[],this.output=[],this.attribute=[],o)for(var e=Object.keys(o),r=0;r<e.length;++r)o[e[r]]!=null&&(this[e[r]]=o[e[r]])}return t.prototype.input=y.emptyArray,t.prototype.output=y.emptyArray,t.prototype.name=\"\",t.prototype.opType=\"\",t.prototype.domain=\"\",t.prototype.attribute=y.emptyArray,t.prototype.docString=\"\",t.create=function(e){return new t(e)},t.encode=function(e,r){if(r||(r=Ee.create()),e.input!=null&&e.input.length)for(var n=0;n<e.input.length;++n)r.uint32(10).string(e.input[n]);if(e.output!=null&&e.output.length)for(var n=0;n<e.output.length;++n)r.uint32(18).string(e.output[n]);if(e.name!=null&&Object.hasOwnProperty.call(e,\"name\")&&r.uint32(26).string(e.name),e.opType!=null&&Object.hasOwnProperty.call(e,\"opType\")&&r.uint32(34).string(e.opType),e.attribute!=null&&e.attribute.length)for(var n=0;n<e.attribute.length;++n)m.onnx.AttributeProto.encode(e.attribute[n],r.uint32(42).fork()).ldelim();return e.docString!=null&&Object.hasOwnProperty.call(e,\"docString\")&&r.uint32(50).string(e.docString),e.domain!=null&&Object.hasOwnProperty.call(e,\"domain\")&&r.uint32(58).string(e.domain),r},t.encodeDelimited=function(e,r){return this.encode(e,r).ldelim()},t.decode=function(e,r){e instanceof N||(e=N.create(e));for(var n=r===void 0?e.len:e.pos+r,s=new m.onnx.NodeProto;e.pos<n;){var i=e.uint32();switch(i>>>3){case 1:{s.input&&s.input.length||(s.input=[]),s.input.push(e.string());break}case 2:{s.output&&s.output.length||(s.output=[]),s.output.push(e.string());break}case 3:{s.name=e.string();break}case 4:{s.opType=e.string();break}case 7:{s.domain=e.string();break}case 5:{s.attribute&&s.attribute.length||(s.attribute=[]),s.attribute.push(m.onnx.AttributeProto.decode(e,e.uint32()));break}case 6:{s.docString=e.string();break}default:e.skipType(i&7);break}}return s},t.decodeDelimited=function(e){return e instanceof N||(e=new N(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!=\"object\"||e===null)return\"object expected\";if(e.input!=null&&e.hasOwnProperty(\"input\")){if(!Array.isArray(e.input))return\"input: array expected\";for(var r=0;r<e.input.length;++r)if(!y.isString(e.input[r]))return\"input: string[] expected\"}if(e.output!=null&&e.hasOwnProperty(\"output\")){if(!Array.isArray(e.output))return\"output: array expected\";for(var r=0;r<e.output.length;++r)if(!y.isString(e.output[r]))return\"output: string[] expected\"}if(e.name!=null&&e.hasOwnProperty(\"name\")&&!y.isString(e.name))return\"name: string expected\";if(e.opType!=null&&e.hasOwnProperty(\"opType\")&&!y.isString(e.opType))return\"opType: string expected\";if(e.domain!=null&&e.hasOwnProperty(\"domain\")&&!y.isString(e.domain))return\"domain: string expected\";if(e.attribute!=null&&e.hasOwnProperty(\"attribute\")){if(!Array.isArray(e.attribute))return\"attribute: array expected\";for(var r=0;r<e.attribute.length;++r){var n=m.onnx.AttributeProto.verify(e.attribute[r]);if(n)return\"attribute.\"+n}}return e.docString!=null&&e.hasOwnProperty(\"docString\")&&!y.isString(e.docString)?\"docString: string expected\":null},t.fromObject=function(e){if(e instanceof m.onnx.NodeProto)return e;var r=new m.onnx.NodeProto;if(e.input){if(!Array.isArray(e.input))throw TypeError(\".onnx.NodeProto.input: array expected\");r.input=[];for(var n=0;n<e.input.length;++n)r.input[n]=String(e.input[n])}if(e.output){if(!Array.isArray(e.output))throw TypeError(\".onnx.NodeProto.output: array expected\");r.output=[];for(var n=0;n<e.output.length;++n)r.output[n]=String(e.output[n])}if(e.name!=null&&(r.name=String(e.name)),e.opType!=null&&(r.opType=String(e.opType)),e.domain!=null&&(r.domain=String(e.domain)),e.attribute){if(!Array.isArray(e.attribute))throw TypeError(\".onnx.NodeProto.attribute: array expected\");r.attribute=[];for(var n=0;n<e.attribute.length;++n){if(typeof e.attribute[n]!=\"object\")throw TypeError(\".onnx.NodeProto.attribute: object expected\");r.attribute[n]=m.onnx.AttributeProto.fromObject(e.attribute[n])}}return e.docString!=null&&(r.docString=String(e.docString)),r},t.toObject=function(e,r){r||(r={});var n={};if((r.arrays||r.defaults)&&(n.input=[],n.output=[],n.attribute=[]),r.defaults&&(n.name=\"\",n.opType=\"\",n.docString=\"\",n.domain=\"\"),e.input&&e.input.length){n.input=[];for(var s=0;s<e.input.length;++s)n.input[s]=e.input[s]}if(e.output&&e.output.length){n.output=[];for(var s=0;s<e.output.length;++s)n.output[s]=e.output[s]}if(e.name!=null&&e.hasOwnProperty(\"name\")&&(n.name=e.name),e.opType!=null&&e.hasOwnProperty(\"opType\")&&(n.opType=e.opType),e.attribute&&e.attribute.length){n.attribute=[];for(var s=0;s<e.attribute.length;++s)n.attribute[s]=m.onnx.AttributeProto.toObject(e.attribute[s],r)}return e.docString!=null&&e.hasOwnProperty(\"docString\")&&(n.docString=e.docString),e.domain!=null&&e.hasOwnProperty(\"domain\")&&(n.domain=e.domain),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},t.getTypeUrl=function(e){return e===void 0&&(e=\"type.googleapis.com\"),e+\"/onnx.NodeProto\"},t}(),a.TrainingInfoProto=function(){function t(o){if(this.initializationBinding=[],this.updateBinding=[],o)for(var e=Object.keys(o),r=0;r<e.length;++r)o[e[r]]!=null&&(this[e[r]]=o[e[r]])}return t.prototype.initialization=null,t.prototype.algorithm=null,t.prototype.initializationBinding=y.emptyArray,t.prototype.updateBinding=y.emptyArray,t.create=function(e){return new t(e)},t.encode=function(e,r){if(r||(r=Ee.create()),e.initialization!=null&&Object.hasOwnProperty.call(e,\"initialization\")&&m.onnx.GraphProto.encode(e.initialization,r.uint32(10).fork()).ldelim(),e.algorithm!=null&&Object.hasOwnProperty.call(e,\"algorithm\")&&m.onnx.GraphProto.encode(e.algorithm,r.uint32(18).fork()).ldelim(),e.initializationBinding!=null&&e.initializationBinding.length)for(var n=0;n<e.initializationBinding.length;++n)m.onnx.StringStringEntryProto.encode(e.initializationBinding[n],r.uint32(26).fork()).ldelim();if(e.updateBinding!=null&&e.updateBinding.length)for(var n=0;n<e.updateBinding.length;++n)m.onnx.StringStringEntryProto.encode(e.updateBinding[n],r.uint32(34).fork()).ldelim();return r},t.encodeDelimited=function(e,r){return this.encode(e,r).ldelim()},t.decode=function(e,r){e instanceof N||(e=N.create(e));for(var n=r===void 0?e.len:e.pos+r,s=new m.onnx.TrainingInfoProto;e.pos<n;){var i=e.uint32();switch(i>>>3){case 1:{s.initialization=m.onnx.GraphProto.decode(e,e.uint32());break}case 2:{s.algorithm=m.onnx.GraphProto.decode(e,e.uint32());break}case 3:{s.initializationBinding&&s.initializationBinding.length||(s.initializationBinding=[]),s.initializationBinding.push(m.onnx.StringStringEntryProto.decode(e,e.uint32()));break}case 4:{s.updateBinding&&s.updateBinding.length||(s.updateBinding=[]),s.updateBinding.push(m.onnx.StringStringEntryProto.decode(e,e.uint32()));break}default:e.skipType(i&7);break}}return s},t.decodeDelimited=function(e){return e instanceof N||(e=new N(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!=\"object\"||e===null)return\"object expected\";if(e.initialization!=null&&e.hasOwnProperty(\"initialization\")){var r=m.onnx.GraphProto.verify(e.initialization);if(r)return\"initialization.\"+r}if(e.algorithm!=null&&e.hasOwnProperty(\"algorithm\")){var r=m.onnx.GraphProto.verify(e.algorithm);if(r)return\"algorithm.\"+r}if(e.initializationBinding!=null&&e.hasOwnProperty(\"initializationBinding\")){if(!Array.isArray(e.initializationBinding))return\"initializationBinding: array expected\";for(var n=0;n<e.initializationBinding.length;++n){var r=m.onnx.StringStringEntryProto.verify(e.initializationBinding[n]);if(r)return\"initializationBinding.\"+r}}if(e.updateBinding!=null&&e.hasOwnProperty(\"updateBinding\")){if(!Array.isArray(e.updateBinding))return\"updateBinding: array expected\";for(var n=0;n<e.updateBinding.length;++n){var r=m.onnx.StringStringEntryProto.verify(e.updateBinding[n]);if(r)return\"updateBinding.\"+r}}return null},t.fromObject=function(e){if(e instanceof m.onnx.TrainingInfoProto)return e;var r=new m.onnx.TrainingInfoProto;if(e.initialization!=null){if(typeof e.initialization!=\"object\")throw TypeError(\".onnx.TrainingInfoProto.initialization: object expected\");r.initialization=m.onnx.GraphProto.fromObject(e.initialization)}if(e.algorithm!=null){if(typeof e.algorithm!=\"object\")throw TypeError(\".onnx.TrainingInfoProto.algorithm: object expected\");r.algorithm=m.onnx.GraphProto.fromObject(e.algorithm)}if(e.initializationBinding){if(!Array.isArray(e.initializationBinding))throw TypeError(\".onnx.TrainingInfoProto.initializationBinding: array expected\");r.initializationBinding=[];for(var n=0;n<e.initializationBinding.length;++n){if(typeof e.initializationBinding[n]!=\"object\")throw TypeError(\".onnx.TrainingInfoProto.initializationBinding: object expected\");r.initializationBinding[n]=m.onnx.StringStringEntryProto.fromObject(e.initializationBinding[n])}}if(e.updateBinding){if(!Array.isArray(e.updateBinding))throw TypeError(\".onnx.TrainingInfoProto.updateBinding: array expected\");r.updateBinding=[];for(var n=0;n<e.updateBinding.length;++n){if(typeof e.updateBinding[n]!=\"object\")throw TypeError(\".onnx.TrainingInfoProto.updateBinding: object expected\");r.updateBinding[n]=m.onnx.StringStringEntryProto.fromObject(e.updateBinding[n])}}return r},t.toObject=function(e,r){r||(r={});var n={};if((r.arrays||r.defaults)&&(n.initializationBinding=[],n.updateBinding=[]),r.defaults&&(n.initialization=null,n.algorithm=null),e.initialization!=null&&e.hasOwnProperty(\"initialization\")&&(n.initialization=m.onnx.GraphProto.toObject(e.initialization,r)),e.algorithm!=null&&e.hasOwnProperty(\"algorithm\")&&(n.algorithm=m.onnx.GraphProto.toObject(e.algorithm,r)),e.initializationBinding&&e.initializationBinding.length){n.initializationBinding=[];for(var s=0;s<e.initializationBinding.length;++s)n.initializationBinding[s]=m.onnx.StringStringEntryProto.toObject(e.initializationBinding[s],r)}if(e.updateBinding&&e.updateBinding.length){n.updateBinding=[];for(var s=0;s<e.updateBinding.length;++s)n.updateBinding[s]=m.onnx.StringStringEntryProto.toObject(e.updateBinding[s],r)}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},t.getTypeUrl=function(e){return e===void 0&&(e=\"type.googleapis.com\"),e+\"/onnx.TrainingInfoProto\"},t}(),a.ModelProto=function(){function t(o){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],o)for(var e=Object.keys(o),r=0;r<e.length;++r)o[e[r]]!=null&&(this[e[r]]=o[e[r]])}return t.prototype.irVersion=y.Long?y.Long.fromBits(0,0,!1):0,t.prototype.opsetImport=y.emptyArray,t.prototype.producerName=\"\",t.prototype.producerVersion=\"\",t.prototype.domain=\"\",t.prototype.modelVersion=y.Long?y.Long.fromBits(0,0,!1):0,t.prototype.docString=\"\",t.prototype.graph=null,t.prototype.metadataProps=y.emptyArray,t.prototype.trainingInfo=y.emptyArray,t.prototype.functions=y.emptyArray,t.create=function(e){return new t(e)},t.encode=function(e,r){if(r||(r=Ee.create()),e.irVersion!=null&&Object.hasOwnProperty.call(e,\"irVersion\")&&r.uint32(8).int64(e.irVersion),e.producerName!=null&&Object.hasOwnProperty.call(e,\"producerName\")&&r.uint32(18).string(e.producerName),e.producerVersion!=null&&Object.hasOwnProperty.call(e,\"producerVersion\")&&r.uint32(26).string(e.producerVersion),e.domain!=null&&Object.hasOwnProperty.call(e,\"domain\")&&r.uint32(34).string(e.domain),e.modelVersion!=null&&Object.hasOwnProperty.call(e,\"modelVersion\")&&r.uint32(40).int64(e.modelVersion),e.docString!=null&&Object.hasOwnProperty.call(e,\"docString\")&&r.uint32(50).string(e.docString),e.graph!=null&&Object.hasOwnProperty.call(e,\"graph\")&&m.onnx.GraphProto.encode(e.graph,r.uint32(58).fork()).ldelim(),e.opsetImport!=null&&e.opsetImport.length)for(var n=0;n<e.opsetImport.length;++n)m.onnx.OperatorSetIdProto.encode(e.opsetImport[n],r.uint32(66).fork()).ldelim();if(e.metadataProps!=null&&e.metadataProps.length)for(var n=0;n<e.metadataProps.length;++n)m.onnx.StringStringEntryProto.encode(e.metadataProps[n],r.uint32(114).fork()).ldelim();if(e.trainingInfo!=null&&e.trainingInfo.length)for(var n=0;n<e.trainingInfo.length;++n)m.onnx.TrainingInfoProto.encode(e.trainingInfo[n],r.uint32(162).fork()).ldelim();if(e.functions!=null&&e.functions.length)for(var n=0;n<e.functions.length;++n)m.onnx.FunctionProto.encode(e.functions[n],r.uint32(202).fork()).ldelim();return r},t.encodeDelimited=function(e,r){return this.encode(e,r).ldelim()},t.decode=function(e,r){e instanceof N||(e=N.create(e));for(var n=r===void 0?e.len:e.pos+r,s=new m.onnx.ModelProto;e.pos<n;){var i=e.uint32();switch(i>>>3){case 1:{s.irVersion=e.int64();break}case 8:{s.opsetImport&&s.opsetImport.length||(s.opsetImport=[]),s.opsetImport.push(m.onnx.OperatorSetIdProto.decode(e,e.uint32()));break}case 2:{s.producerName=e.string();break}case 3:{s.producerVersion=e.string();break}case 4:{s.domain=e.string();break}case 5:{s.modelVersion=e.int64();break}case 6:{s.docString=e.string();break}case 7:{s.graph=m.onnx.GraphProto.decode(e,e.uint32());break}case 14:{s.metadataProps&&s.metadataProps.length||(s.metadataProps=[]),s.metadataProps.push(m.onnx.StringStringEntryProto.decode(e,e.uint32()));break}case 20:{s.trainingInfo&&s.trainingInfo.length||(s.trainingInfo=[]),s.trainingInfo.push(m.onnx.TrainingInfoProto.decode(e,e.uint32()));break}case 25:{s.functions&&s.functions.length||(s.functions=[]),s.functions.push(m.onnx.FunctionProto.decode(e,e.uint32()));break}default:e.skipType(i&7);break}}return s},t.decodeDelimited=function(e){return e instanceof N||(e=new N(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!=\"object\"||e===null)return\"object expected\";if(e.irVersion!=null&&e.hasOwnProperty(\"irVersion\")&&!y.isInteger(e.irVersion)&&!(e.irVersion&&y.isInteger(e.irVersion.low)&&y.isInteger(e.irVersion.high)))return\"irVersion: integer|Long expected\";if(e.opsetImport!=null&&e.hasOwnProperty(\"opsetImport\")){if(!Array.isArray(e.opsetImport))return\"opsetImport: array expected\";for(var r=0;r<e.opsetImport.length;++r){var n=m.onnx.OperatorSetIdProto.verify(e.opsetImport[r]);if(n)return\"opsetImport.\"+n}}if(e.producerName!=null&&e.hasOwnProperty(\"producerName\")&&!y.isString(e.producerName))return\"producerName: string expected\";if(e.producerVersion!=null&&e.hasOwnProperty(\"producerVersion\")&&!y.isString(e.producerVersion))return\"producerVersion: string expected\";if(e.domain!=null&&e.hasOwnProperty(\"domain\")&&!y.isString(e.domain))return\"domain: string expected\";if(e.modelVersion!=null&&e.hasOwnProperty(\"modelVersion\")&&!y.isInteger(e.modelVersion)&&!(e.modelVersion&&y.isInteger(e.modelVersion.low)&&y.isInteger(e.modelVersion.high)))return\"modelVersion: integer|Long expected\";if(e.docString!=null&&e.hasOwnProperty(\"docString\")&&!y.isString(e.docString))return\"docString: string expected\";if(e.graph!=null&&e.hasOwnProperty(\"graph\")){var n=m.onnx.GraphProto.verify(e.graph);if(n)return\"graph.\"+n}if(e.metadataProps!=null&&e.hasOwnProperty(\"metadataProps\")){if(!Array.isArray(e.metadataProps))return\"metadataProps: array expected\";for(var r=0;r<e.metadataProps.length;++r){var n=m.onnx.StringStringEntryProto.verify(e.metadataProps[r]);if(n)return\"metadataProps.\"+n}}if(e.trainingInfo!=null&&e.hasOwnProperty(\"trainingInfo\")){if(!Array.isArray(e.trainingInfo))return\"trainingInfo: array expected\";for(var r=0;r<e.trainingInfo.length;++r){var n=m.onnx.TrainingInfoProto.verify(e.trainingInfo[r]);if(n)return\"trainingInfo.\"+n}}if(e.functions!=null&&e.hasOwnProperty(\"functions\")){if(!Array.isArray(e.functions))return\"functions: array expected\";for(var r=0;r<e.functions.length;++r){var n=m.onnx.FunctionProto.verify(e.functions[r]);if(n)return\"functions.\"+n}}return null},t.fromObject=function(e){if(e instanceof m.onnx.ModelProto)return e;var r=new m.onnx.ModelProto;if(e.irVersion!=null&&(y.Long?(r.irVersion=y.Long.fromValue(e.irVersion)).unsigned=!1:typeof e.irVersion==\"string\"?r.irVersion=parseInt(e.irVersion,10):typeof e.irVersion==\"number\"?r.irVersion=e.irVersion:typeof e.irVersion==\"object\"&&(r.irVersion=new y.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber())),e.opsetImport){if(!Array.isArray(e.opsetImport))throw TypeError(\".onnx.ModelProto.opsetImport: array expected\");r.opsetImport=[];for(var n=0;n<e.opsetImport.length;++n){if(typeof e.opsetImport[n]!=\"object\")throw TypeError(\".onnx.ModelProto.opsetImport: object expected\");r.opsetImport[n]=m.onnx.OperatorSetIdProto.fromObject(e.opsetImport[n])}}if(e.producerName!=null&&(r.producerName=String(e.producerName)),e.producerVersion!=null&&(r.producerVersion=String(e.producerVersion)),e.domain!=null&&(r.domain=String(e.domain)),e.modelVersion!=null&&(y.Long?(r.modelVersion=y.Long.fromValue(e.modelVersion)).unsigned=!1:typeof e.modelVersion==\"string\"?r.modelVersion=parseInt(e.modelVersion,10):typeof e.modelVersion==\"number\"?r.modelVersion=e.modelVersion:typeof e.modelVersion==\"object\"&&(r.modelVersion=new y.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber())),e.docString!=null&&(r.docString=String(e.docString)),e.graph!=null){if(typeof e.graph!=\"object\")throw TypeError(\".onnx.ModelProto.graph: object expected\");r.graph=m.onnx.GraphProto.fromObject(e.graph)}if(e.metadataProps){if(!Array.isArray(e.metadataProps))throw TypeError(\".onnx.ModelProto.metadataProps: array expected\");r.metadataProps=[];for(var n=0;n<e.metadataProps.length;++n){if(typeof e.metadataProps[n]!=\"object\")throw TypeError(\".onnx.ModelProto.metadataProps: object expected\");r.metadataProps[n]=m.onnx.StringStringEntryProto.fromObject(e.metadataProps[n])}}if(e.trainingInfo){if(!Array.isArray(e.trainingInfo))throw TypeError(\".onnx.ModelProto.trainingInfo: array expected\");r.trainingInfo=[];for(var n=0;n<e.trainingInfo.length;++n){if(typeof e.trainingInfo[n]!=\"object\")throw TypeError(\".onnx.ModelProto.trainingInfo: object expected\");r.trainingInfo[n]=m.onnx.TrainingInfoProto.fromObject(e.trainingInfo[n])}}if(e.functions){if(!Array.isArray(e.functions))throw TypeError(\".onnx.ModelProto.functions: array expected\");r.functions=[];for(var n=0;n<e.functions.length;++n){if(typeof e.functions[n]!=\"object\")throw TypeError(\".onnx.ModelProto.functions: object expected\");r.functions[n]=m.onnx.FunctionProto.fromObject(e.functions[n])}}return r},t.toObject=function(e,r){r||(r={});var n={};if((r.arrays||r.defaults)&&(n.opsetImport=[],n.metadataProps=[],n.trainingInfo=[],n.functions=[]),r.defaults){if(y.Long){var s=new y.Long(0,0,!1);n.irVersion=r.longs===String?s.toString():r.longs===Number?s.toNumber():s}else n.irVersion=r.longs===String?\"0\":0;if(n.producerName=\"\",n.producerVersion=\"\",n.domain=\"\",y.Long){var s=new y.Long(0,0,!1);n.modelVersion=r.longs===String?s.toString():r.longs===Number?s.toNumber():s}else n.modelVersion=r.longs===String?\"0\":0;n.docString=\"\",n.graph=null}if(e.irVersion!=null&&e.hasOwnProperty(\"irVersion\")&&(typeof e.irVersion==\"number\"?n.irVersion=r.longs===String?String(e.irVersion):e.irVersion:n.irVersion=r.longs===String?y.Long.prototype.toString.call(e.irVersion):r.longs===Number?new y.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber():e.irVersion),e.producerName!=null&&e.hasOwnProperty(\"producerName\")&&(n.producerName=e.producerName),e.producerVersion!=null&&e.hasOwnProperty(\"producerVersion\")&&(n.producerVersion=e.producerVersion),e.domain!=null&&e.hasOwnProperty(\"domain\")&&(n.domain=e.domain),e.modelVersion!=null&&e.hasOwnProperty(\"modelVersion\")&&(typeof e.modelVersion==\"number\"?n.modelVersion=r.longs===String?String(e.modelVersion):e.modelVersion:n.modelVersion=r.longs===String?y.Long.prototype.toString.call(e.modelVersion):r.longs===Number?new y.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber():e.modelVersion),e.docString!=null&&e.hasOwnProperty(\"docString\")&&(n.docString=e.docString),e.graph!=null&&e.hasOwnProperty(\"graph\")&&(n.graph=m.onnx.GraphProto.toObject(e.graph,r)),e.opsetImport&&e.opsetImport.length){n.opsetImport=[];for(var i=0;i<e.opsetImport.length;++i)n.opsetImport[i]=m.onnx.OperatorSetIdProto.toObject(e.opsetImport[i],r)}if(e.metadataProps&&e.metadataProps.length){n.metadataProps=[];for(var i=0;i<e.metadataProps.length;++i)n.metadataProps[i]=m.onnx.StringStringEntryProto.toObject(e.metadataProps[i],r)}if(e.trainingInfo&&e.trainingInfo.length){n.trainingInfo=[];for(var i=0;i<e.trainingInfo.length;++i)n.trainingInfo[i]=m.onnx.TrainingInfoProto.toObject(e.trainingInfo[i],r)}if(e.functions&&e.functions.length){n.functions=[];for(var i=0;i<e.functions.length;++i)n.functions[i]=m.onnx.FunctionProto.toObject(e.functions[i],r)}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},t.getTypeUrl=function(e){return e===void 0&&(e=\"type.googleapis.com\"),e+\"/onnx.ModelProto\"},t}(),a.StringStringEntryProto=function(){function t(o){if(o)for(var e=Object.keys(o),r=0;r<e.length;++r)o[e[r]]!=null&&(this[e[r]]=o[e[r]])}return t.prototype.key=\"\",t.prototype.value=\"\",t.create=function(e){return new t(e)},t.encode=function(e,r){return r||(r=Ee.create()),e.key!=null&&Object.hasOwnProperty.call(e,\"key\")&&r.uint32(10).string(e.key),e.value!=null&&Object.hasOwnProperty.call(e,\"value\")&&r.uint32(18).string(e.value),r},t.encodeDelimited=function(e,r){return this.encode(e,r).ldelim()},t.decode=function(e,r){e instanceof N||(e=N.create(e));for(var n=r===void 0?e.len:e.pos+r,s=new m.onnx.StringStringEntryProto;e.pos<n;){var i=e.uint32();switch(i>>>3){case 1:{s.key=e.string();break}case 2:{s.value=e.string();break}default:e.skipType(i&7);break}}return s},t.decodeDelimited=function(e){return e instanceof N||(e=new N(e)),this.decode(e,e.uint32())},t.verify=function(e){return typeof e!=\"object\"||e===null?\"object expected\":e.key!=null&&e.hasOwnProperty(\"key\")&&!y.isString(e.key)?\"key: string expected\":e.value!=null&&e.hasOwnProperty(\"value\")&&!y.isString(e.value)?\"value: string expected\":null},t.fromObject=function(e){if(e instanceof m.onnx.StringStringEntryProto)return e;var r=new m.onnx.StringStringEntryProto;return e.key!=null&&(r.key=String(e.key)),e.value!=null&&(r.value=String(e.value)),r},t.toObject=function(e,r){r||(r={});var n={};return r.defaults&&(n.key=\"\",n.value=\"\"),e.key!=null&&e.hasOwnProperty(\"key\")&&(n.key=e.key),e.value!=null&&e.hasOwnProperty(\"value\")&&(n.value=e.value),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},t.getTypeUrl=function(e){return e===void 0&&(e=\"type.googleapis.com\"),e+\"/onnx.StringStringEntryProto\"},t}(),a.TensorAnnotation=function(){function t(o){if(this.quantParameterTensorNames=[],o)for(var e=Object.keys(o),r=0;r<e.length;++r)o[e[r]]!=null&&(this[e[r]]=o[e[r]])}return t.prototype.tensorName=\"\",t.prototype.quantParameterTensorNames=y.emptyArray,t.create=function(e){return new t(e)},t.encode=function(e,r){if(r||(r=Ee.create()),e.tensorName!=null&&Object.hasOwnProperty.call(e,\"tensorName\")&&r.uint32(10).string(e.tensorName),e.quantParameterTensorNames!=null&&e.quantParameterTensorNames.length)for(var n=0;n<e.quantParameterTensorNames.length;++n)m.onnx.StringStringEntryProto.encode(e.quantParameterTensorNames[n],r.uint32(18).fork()).ldelim();return r},t.encodeDelimited=function(e,r){return this.encode(e,r).ldelim()},t.decode=function(e,r){e instanceof N||(e=N.create(e));for(var n=r===void 0?e.len:e.pos+r,s=new m.onnx.TensorAnnotation;e.pos<n;){var i=e.uint32();switch(i>>>3){case 1:{s.tensorName=e.string();break}case 2:{s.quantParameterTensorNames&&s.quantParameterTensorNames.length||(s.quantParameterTensorNames=[]),s.quantParameterTensorNames.push(m.onnx.StringStringEntryProto.decode(e,e.uint32()));break}default:e.skipType(i&7);break}}return s},t.decodeDelimited=function(e){return e instanceof N||(e=new N(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!=\"object\"||e===null)return\"object expected\";if(e.tensorName!=null&&e.hasOwnProperty(\"tensorName\")&&!y.isString(e.tensorName))return\"tensorName: string expected\";if(e.quantParameterTensorNames!=null&&e.hasOwnProperty(\"quantParameterTensorNames\")){if(!Array.isArray(e.quantParameterTensorNames))return\"quantParameterTensorNames: array expected\";for(var r=0;r<e.quantParameterTensorNames.length;++r){var n=m.onnx.StringStringEntryProto.verify(e.quantParameterTensorNames[r]);if(n)return\"quantParameterTensorNames.\"+n}}return null},t.fromObject=function(e){if(e instanceof m.onnx.TensorAnnotation)return e;var r=new m.onnx.TensorAnnotation;if(e.tensorName!=null&&(r.tensorName=String(e.tensorName)),e.quantParameterTensorNames){if(!Array.isArray(e.quantParameterTensorNames))throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: array expected\");r.quantParameterTensorNames=[];for(var n=0;n<e.quantParameterTensorNames.length;++n){if(typeof e.quantParameterTensorNames[n]!=\"object\")throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: object expected\");r.quantParameterTensorNames[n]=m.onnx.StringStringEntryProto.fromObject(e.quantParameterTensorNames[n])}}return r},t.toObject=function(e,r){r||(r={});var n={};if((r.arrays||r.defaults)&&(n.quantParameterTensorNames=[]),r.defaults&&(n.tensorName=\"\"),e.tensorName!=null&&e.hasOwnProperty(\"tensorName\")&&(n.tensorName=e.tensorName),e.quantParameterTensorNames&&e.quantParameterTensorNames.length){n.quantParameterTensorNames=[];for(var s=0;s<e.quantParameterTensorNames.length;++s)n.quantParameterTensorNames[s]=m.onnx.StringStringEntryProto.toObject(e.quantParameterTensorNames[s],r)}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},t.getTypeUrl=function(e){return e===void 0&&(e=\"type.googleapis.com\"),e+\"/onnx.TensorAnnotation\"},t}(),a.GraphProto=function(){function t(o){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],o)for(var e=Object.keys(o),r=0;r<e.length;++r)o[e[r]]!=null&&(this[e[r]]=o[e[r]])}return t.prototype.node=y.emptyArray,t.prototype.name=\"\",t.prototype.initializer=y.emptyArray,t.prototype.sparseInitializer=y.emptyArray,t.prototype.docString=\"\",t.prototype.input=y.emptyArray,t.prototype.output=y.emptyArray,t.prototype.valueInfo=y.emptyArray,t.prototype.quantizationAnnotation=y.emptyArray,t.create=function(e){return new t(e)},t.encode=function(e,r){if(r||(r=Ee.create()),e.node!=null&&e.node.length)for(var n=0;n<e.node.length;++n)m.onnx.NodeProto.encode(e.node[n],r.uint32(10).fork()).ldelim();if(e.name!=null&&Object.hasOwnProperty.call(e,\"name\")&&r.uint32(18).string(e.name),e.initializer!=null&&e.initializer.length)for(var n=0;n<e.initializer.length;++n)m.onnx.TensorProto.encode(e.initializer[n],r.uint32(42).fork()).ldelim();if(e.docString!=null&&Object.hasOwnProperty.call(e,\"docString\")&&r.uint32(82).string(e.docString),e.input!=null&&e.input.length)for(var n=0;n<e.input.length;++n)m.onnx.ValueInfoProto.encode(e.input[n],r.uint32(90).fork()).ldelim();if(e.output!=null&&e.output.length)for(var n=0;n<e.output.length;++n)m.onnx.ValueInfoProto.encode(e.output[n],r.uint32(98).fork()).ldelim();if(e.valueInfo!=null&&e.valueInfo.length)for(var n=0;n<e.valueInfo.length;++n)m.onnx.ValueInfoProto.encode(e.valueInfo[n],r.uint32(106).fork()).ldelim();if(e.quantizationAnnotation!=null&&e.quantizationAnnotation.length)for(var n=0;n<e.quantizationAnnotation.length;++n)m.onnx.TensorAnnotation.encode(e.quantizationAnnotation[n],r.uint32(114).fork()).ldelim();if(e.sparseInitializer!=null&&e.sparseInitializer.length)for(var n=0;n<e.sparseInitializer.length;++n)m.onnx.SparseTensorProto.encode(e.sparseInitializer[n],r.uint32(122).fork()).ldelim();return r},t.encodeDelimited=function(e,r){return this.encode(e,r).ldelim()},t.decode=function(e,r){e instanceof N||(e=N.create(e));for(var n=r===void 0?e.len:e.pos+r,s=new m.onnx.GraphProto;e.pos<n;){var i=e.uint32();switch(i>>>3){case 1:{s.node&&s.node.length||(s.node=[]),s.node.push(m.onnx.NodeProto.decode(e,e.uint32()));break}case 2:{s.name=e.string();break}case 5:{s.initializer&&s.initializer.length||(s.initializer=[]),s.initializer.push(m.onnx.TensorProto.decode(e,e.uint32()));break}case 15:{s.sparseInitializer&&s.sparseInitializer.length||(s.sparseInitializer=[]),s.sparseInitializer.push(m.onnx.SparseTensorProto.decode(e,e.uint32()));break}case 10:{s.docString=e.string();break}case 11:{s.input&&s.input.length||(s.input=[]),s.input.push(m.onnx.ValueInfoProto.decode(e,e.uint32()));break}case 12:{s.output&&s.output.length||(s.output=[]),s.output.push(m.onnx.ValueInfoProto.decode(e,e.uint32()));break}case 13:{s.valueInfo&&s.valueInfo.length||(s.valueInfo=[]),s.valueInfo.push(m.onnx.ValueInfoProto.decode(e,e.uint32()));break}case 14:{s.quantizationAnnotation&&s.quantizationAnnotation.length||(s.quantizationAnnotation=[]),s.quantizationAnnotation.push(m.onnx.TensorAnnotation.decode(e,e.uint32()));break}default:e.skipType(i&7);break}}return s},t.decodeDelimited=function(e){return e instanceof N||(e=new N(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!=\"object\"||e===null)return\"object expected\";if(e.node!=null&&e.hasOwnProperty(\"node\")){if(!Array.isArray(e.node))return\"node: array expected\";for(var r=0;r<e.node.length;++r){var n=m.onnx.NodeProto.verify(e.node[r]);if(n)return\"node.\"+n}}if(e.name!=null&&e.hasOwnProperty(\"name\")&&!y.isString(e.name))return\"name: string expected\";if(e.initializer!=null&&e.hasOwnProperty(\"initializer\")){if(!Array.isArray(e.initializer))return\"initializer: array expected\";for(var r=0;r<e.initializer.length;++r){var n=m.onnx.TensorProto.verify(e.initializer[r]);if(n)return\"initializer.\"+n}}if(e.sparseInitializer!=null&&e.hasOwnProperty(\"sparseInitializer\")){if(!Array.isArray(e.sparseInitializer))return\"sparseInitializer: array expected\";for(var r=0;r<e.sparseInitializer.length;++r){var n=m.onnx.SparseTensorProto.verify(e.sparseInitializer[r]);if(n)return\"sparseInitializer.\"+n}}if(e.docString!=null&&e.hasOwnProperty(\"docString\")&&!y.isString(e.docString))return\"docString: string expected\";if(e.input!=null&&e.hasOwnProperty(\"input\")){if(!Array.isArray(e.input))return\"input: array expected\";for(var r=0;r<e.input.length;++r){var n=m.onnx.ValueInfoProto.verify(e.input[r]);if(n)return\"input.\"+n}}if(e.output!=null&&e.hasOwnProperty(\"output\")){if(!Array.isArray(e.output))return\"output: array expected\";for(var r=0;r<e.output.length;++r){var n=m.onnx.ValueInfoProto.verify(e.output[r]);if(n)return\"output.\"+n}}if(e.valueInfo!=null&&e.hasOwnProperty(\"valueInfo\")){if(!Array.isArray(e.valueInfo))return\"valueInfo: array expected\";for(var r=0;r<e.valueInfo.length;++r){var n=m.onnx.ValueInfoProto.verify(e.valueInfo[r]);if(n)return\"valueInfo.\"+n}}if(e.quantizationAnnotation!=null&&e.hasOwnProperty(\"quantizationAnnotation\")){if(!Array.isArray(e.quantizationAnnotation))return\"quantizationAnnotation: array expected\";for(var r=0;r<e.quantizationAnnotation.length;++r){var n=m.onnx.TensorAnnotation.verify(e.quantizationAnnotation[r]);if(n)return\"quantizationAnnotation.\"+n}}return null},t.fromObject=function(e){if(e instanceof m.onnx.GraphProto)return e;var r=new m.onnx.GraphProto;if(e.node){if(!Array.isArray(e.node))throw TypeError(\".onnx.GraphProto.node: array expected\");r.node=[];for(var n=0;n<e.node.length;++n){if(typeof e.node[n]!=\"object\")throw TypeError(\".onnx.GraphProto.node: object expected\");r.node[n]=m.onnx.NodeProto.fromObject(e.node[n])}}if(e.name!=null&&(r.name=String(e.name)),e.initializer){if(!Array.isArray(e.initializer))throw TypeError(\".onnx.GraphProto.initializer: array expected\");r.initializer=[];for(var n=0;n<e.initializer.length;++n){if(typeof e.initializer[n]!=\"object\")throw TypeError(\".onnx.GraphProto.initializer: object expected\");r.initializer[n]=m.onnx.TensorProto.fromObject(e.initializer[n])}}if(e.sparseInitializer){if(!Array.isArray(e.sparseInitializer))throw TypeError(\".onnx.GraphProto.sparseInitializer: array expected\");r.sparseInitializer=[];for(var n=0;n<e.sparseInitializer.length;++n){if(typeof e.sparseInitializer[n]!=\"object\")throw TypeError(\".onnx.GraphProto.sparseInitializer: object expected\");r.sparseInitializer[n]=m.onnx.SparseTensorProto.fromObject(e.sparseInitializer[n])}}if(e.docString!=null&&(r.docString=String(e.docString)),e.input){if(!Array.isArray(e.input))throw TypeError(\".onnx.GraphProto.input: array expected\");r.input=[];for(var n=0;n<e.input.length;++n){if(typeof e.input[n]!=\"object\")throw TypeError(\".onnx.GraphProto.input: object expected\");r.input[n]=m.onnx.ValueInfoProto.fromObject(e.input[n])}}if(e.output){if(!Array.isArray(e.output))throw TypeError(\".onnx.GraphProto.output: array expected\");r.output=[];for(var n=0;n<e.output.length;++n){if(typeof e.output[n]!=\"object\")throw TypeError(\".onnx.GraphProto.output: object expected\");r.output[n]=m.onnx.ValueInfoProto.fromObject(e.output[n])}}if(e.valueInfo){if(!Array.isArray(e.valueInfo))throw TypeError(\".onnx.GraphProto.valueInfo: array expected\");r.valueInfo=[];for(var n=0;n<e.valueInfo.length;++n){if(typeof e.valueInfo[n]!=\"object\")throw TypeError(\".onnx.GraphProto.valueInfo: object expected\");r.valueInfo[n]=m.onnx.ValueInfoProto.fromObject(e.valueInfo[n])}}if(e.quantizationAnnotation){if(!Array.isArray(e.quantizationAnnotation))throw TypeError(\".onnx.GraphProto.quantizationAnnotation: array expected\");r.quantizationAnnotation=[];for(var n=0;n<e.quantizationAnnotation.length;++n){if(typeof e.quantizationAnnotation[n]!=\"object\")throw TypeError(\".onnx.GraphProto.quantizationAnnotation: object expected\");r.quantizationAnnotation[n]=m.onnx.TensorAnnotation.fromObject(e.quantizationAnnotation[n])}}return r},t.toObject=function(e,r){r||(r={});var n={};if((r.arrays||r.defaults)&&(n.node=[],n.initializer=[],n.input=[],n.output=[],n.valueInfo=[],n.quantizationAnnotation=[],n.sparseInitializer=[]),r.defaults&&(n.name=\"\",n.docString=\"\"),e.node&&e.node.length){n.node=[];for(var s=0;s<e.node.length;++s)n.node[s]=m.onnx.NodeProto.toObject(e.node[s],r)}if(e.name!=null&&e.hasOwnProperty(\"name\")&&(n.name=e.name),e.initializer&&e.initializer.length){n.initializer=[];for(var s=0;s<e.initializer.length;++s)n.initializer[s]=m.onnx.TensorProto.toObject(e.initializer[s],r)}if(e.docString!=null&&e.hasOwnProperty(\"docString\")&&(n.docString=e.docString),e.input&&e.input.length){n.input=[];for(var s=0;s<e.input.length;++s)n.input[s]=m.onnx.ValueInfoProto.toObject(e.input[s],r)}if(e.output&&e.output.length){n.output=[];for(var s=0;s<e.output.length;++s)n.output[s]=m.onnx.ValueInfoProto.toObject(e.output[s],r)}if(e.valueInfo&&e.valueInfo.length){n.valueInfo=[];for(var s=0;s<e.valueInfo.length;++s)n.valueInfo[s]=m.onnx.ValueInfoProto.toObject(e.valueInfo[s],r)}if(e.quantizationAnnotation&&e.quantizationAnnotation.length){n.quantizationAnnotation=[];for(var s=0;s<e.quantizationAnnotation.length;++s)n.quantizationAnnotation[s]=m.onnx.TensorAnnotation.toObject(e.quantizationAnnotation[s],r)}if(e.sparseInitializer&&e.sparseInitializer.length){n.sparseInitializer=[];for(var s=0;s<e.sparseInitializer.length;++s)n.sparseInitializer[s]=m.onnx.SparseTensorProto.toObject(e.sparseInitializer[s],r)}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},t.getTypeUrl=function(e){return e===void 0&&(e=\"type.googleapis.com\"),e+\"/onnx.GraphProto\"},t}(),a.TensorProto=function(){function t(o){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],o)for(var e=Object.keys(o),r=0;r<e.length;++r)o[e[r]]!=null&&(this[e[r]]=o[e[r]])}return t.prototype.dims=y.emptyArray,t.prototype.dataType=0,t.prototype.segment=null,t.prototype.floatData=y.emptyArray,t.prototype.int32Data=y.emptyArray,t.prototype.stringData=y.emptyArray,t.prototype.int64Data=y.emptyArray,t.prototype.name=\"\",t.prototype.docString=\"\",t.prototype.rawData=y.newBuffer([]),t.prototype.externalData=y.emptyArray,t.prototype.dataLocation=0,t.prototype.doubleData=y.emptyArray,t.prototype.uint64Data=y.emptyArray,t.create=function(e){return new t(e)},t.encode=function(e,r){if(r||(r=Ee.create()),e.dims!=null&&e.dims.length){r.uint32(10).fork();for(var n=0;n<e.dims.length;++n)r.int64(e.dims[n]);r.ldelim()}if(e.dataType!=null&&Object.hasOwnProperty.call(e,\"dataType\")&&r.uint32(16).int32(e.dataType),e.segment!=null&&Object.hasOwnProperty.call(e,\"segment\")&&m.onnx.TensorProto.Segment.encode(e.segment,r.uint32(26).fork()).ldelim(),e.floatData!=null&&e.floatData.length){r.uint32(34).fork();for(var n=0;n<e.floatData.length;++n)r.float(e.floatData[n]);r.ldelim()}if(e.int32Data!=null&&e.int32Data.length){r.uint32(42).fork();for(var n=0;n<e.int32Data.length;++n)r.int32(e.int32Data[n]);r.ldelim()}if(e.stringData!=null&&e.stringData.length)for(var n=0;n<e.stringData.length;++n)r.uint32(50).bytes(e.stringData[n]);if(e.int64Data!=null&&e.int64Data.length){r.uint32(58).fork();for(var n=0;n<e.int64Data.length;++n)r.int64(e.int64Data[n]);r.ldelim()}if(e.name!=null&&Object.hasOwnProperty.call(e,\"name\")&&r.uint32(66).string(e.name),e.rawData!=null&&Object.hasOwnProperty.call(e,\"rawData\")&&r.uint32(74).bytes(e.rawData),e.doubleData!=null&&e.doubleData.length){r.uint32(82).fork();for(var n=0;n<e.doubleData.length;++n)r.double(e.doubleData[n]);r.ldelim()}if(e.uint64Data!=null&&e.uint64Data.length){r.uint32(90).fork();for(var n=0;n<e.uint64Data.length;++n)r.uint64(e.uint64Data[n]);r.ldelim()}if(e.docString!=null&&Object.hasOwnProperty.call(e,\"docString\")&&r.uint32(98).string(e.docString),e.externalData!=null&&e.externalData.length)for(var n=0;n<e.externalData.length;++n)m.onnx.StringStringEntryProto.encode(e.externalData[n],r.uint32(106).fork()).ldelim();return e.dataLocation!=null&&Object.hasOwnProperty.call(e,\"dataLocation\")&&r.uint32(112).int32(e.dataLocation),r},t.encodeDelimited=function(e,r){return this.encode(e,r).ldelim()},t.decode=function(e,r){e instanceof N||(e=N.create(e));for(var n=r===void 0?e.len:e.pos+r,s=new m.onnx.TensorProto;e.pos<n;){var i=e.uint32();switch(i>>>3){case 1:{if(s.dims&&s.dims.length||(s.dims=[]),(i&7)===2)for(var u=e.uint32()+e.pos;e.pos<u;)s.dims.push(e.int64());else s.dims.push(e.int64());break}case 2:{s.dataType=e.int32();break}case 3:{s.segment=m.onnx.TensorProto.Segment.decode(e,e.uint32());break}case 4:{if(s.floatData&&s.floatData.length||(s.floatData=[]),(i&7)===2)for(var u=e.uint32()+e.pos;e.pos<u;)s.floatData.push(e.float());else s.floatData.push(e.float());break}case 5:{if(s.int32Data&&s.int32Data.length||(s.int32Data=[]),(i&7)===2)for(var u=e.uint32()+e.pos;e.pos<u;)s.int32Data.push(e.int32());else s.int32Data.push(e.int32());break}case 6:{s.stringData&&s.stringData.length||(s.stringData=[]),s.stringData.push(e.bytes());break}case 7:{if(s.int64Data&&s.int64Data.length||(s.int64Data=[]),(i&7)===2)for(var u=e.uint32()+e.pos;e.pos<u;)s.int64Data.push(e.int64());else s.int64Data.push(e.int64());break}case 8:{s.name=e.string();break}case 12:{s.docString=e.string();break}case 9:{s.rawData=e.bytes();break}case 13:{s.externalData&&s.externalData.length||(s.externalData=[]),s.externalData.push(m.onnx.StringStringEntryProto.decode(e,e.uint32()));break}case 14:{s.dataLocation=e.int32();break}case 10:{if(s.doubleData&&s.doubleData.length||(s.doubleData=[]),(i&7)===2)for(var u=e.uint32()+e.pos;e.pos<u;)s.doubleData.push(e.double());else s.doubleData.push(e.double());break}case 11:{if(s.uint64Data&&s.uint64Data.length||(s.uint64Data=[]),(i&7)===2)for(var u=e.uint32()+e.pos;e.pos<u;)s.uint64Data.push(e.uint64());else s.uint64Data.push(e.uint64());break}default:e.skipType(i&7);break}}return s},t.decodeDelimited=function(e){return e instanceof N||(e=new N(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!=\"object\"||e===null)return\"object expected\";if(e.dims!=null&&e.hasOwnProperty(\"dims\")){if(!Array.isArray(e.dims))return\"dims: array expected\";for(var r=0;r<e.dims.length;++r)if(!y.isInteger(e.dims[r])&&!(e.dims[r]&&y.isInteger(e.dims[r].low)&&y.isInteger(e.dims[r].high)))return\"dims: integer|Long[] expected\"}if(e.dataType!=null&&e.hasOwnProperty(\"dataType\")&&!y.isInteger(e.dataType))return\"dataType: integer expected\";if(e.segment!=null&&e.hasOwnProperty(\"segment\")){var n=m.onnx.TensorProto.Segment.verify(e.segment);if(n)return\"segment.\"+n}if(e.floatData!=null&&e.hasOwnProperty(\"floatData\")){if(!Array.isArray(e.floatData))return\"floatData: array expected\";for(var r=0;r<e.floatData.length;++r)if(typeof e.floatData[r]!=\"number\")return\"floatData: number[] expected\"}if(e.int32Data!=null&&e.hasOwnProperty(\"int32Data\")){if(!Array.isArray(e.int32Data))return\"int32Data: array expected\";for(var r=0;r<e.int32Data.length;++r)if(!y.isInteger(e.int32Data[r]))return\"int32Data: integer[] expected\"}if(e.stringData!=null&&e.hasOwnProperty(\"stringData\")){if(!Array.isArray(e.stringData))return\"stringData: array expected\";for(var r=0;r<e.stringData.length;++r)if(!(e.stringData[r]&&typeof e.stringData[r].length==\"number\"||y.isString(e.stringData[r])))return\"stringData: buffer[] expected\"}if(e.int64Data!=null&&e.hasOwnProperty(\"int64Data\")){if(!Array.isArray(e.int64Data))return\"int64Data: array expected\";for(var r=0;r<e.int64Data.length;++r)if(!y.isInteger(e.int64Data[r])&&!(e.int64Data[r]&&y.isInteger(e.int64Data[r].low)&&y.isInteger(e.int64Data[r].high)))return\"int64Data: integer|Long[] expected\"}if(e.name!=null&&e.hasOwnProperty(\"name\")&&!y.isString(e.name))return\"name: string expected\";if(e.docString!=null&&e.hasOwnProperty(\"docString\")&&!y.isString(e.docString))return\"docString: string expected\";if(e.rawData!=null&&e.hasOwnProperty(\"rawData\")&&!(e.rawData&&typeof e.rawData.length==\"number\"||y.isString(e.rawData)))return\"rawData: buffer expected\";if(e.externalData!=null&&e.hasOwnProperty(\"externalData\")){if(!Array.isArray(e.externalData))return\"externalData: array expected\";for(var r=0;r<e.externalData.length;++r){var n=m.onnx.StringStringEntryProto.verify(e.externalData[r]);if(n)return\"externalData.\"+n}}if(e.dataLocation!=null&&e.hasOwnProperty(\"dataLocation\"))switch(e.dataLocation){default:return\"dataLocation: enum value expected\";case 0:case 1:break}if(e.doubleData!=null&&e.hasOwnProperty(\"doubleData\")){if(!Array.isArray(e.doubleData))return\"doubleData: array expected\";for(var r=0;r<e.doubleData.length;++r)if(typeof e.doubleData[r]!=\"number\")return\"doubleData: number[] expected\"}if(e.uint64Data!=null&&e.hasOwnProperty(\"uint64Data\")){if(!Array.isArray(e.uint64Data))return\"uint64Data: array expected\";for(var r=0;r<e.uint64Data.length;++r)if(!y.isInteger(e.uint64Data[r])&&!(e.uint64Data[r]&&y.isInteger(e.uint64Data[r].low)&&y.isInteger(e.uint64Data[r].high)))return\"uint64Data: integer|Long[] expected\"}return null},t.fromObject=function(e){if(e instanceof m.onnx.TensorProto)return e;var r=new m.onnx.TensorProto;if(e.dims){if(!Array.isArray(e.dims))throw TypeError(\".onnx.TensorProto.dims: array expected\");r.dims=[];for(var n=0;n<e.dims.length;++n)y.Long?(r.dims[n]=y.Long.fromValue(e.dims[n])).unsigned=!1:typeof e.dims[n]==\"string\"?r.dims[n]=parseInt(e.dims[n],10):typeof e.dims[n]==\"number\"?r.dims[n]=e.dims[n]:typeof e.dims[n]==\"object\"&&(r.dims[n]=new y.LongBits(e.dims[n].low>>>0,e.dims[n].high>>>0).toNumber())}if(e.dataType!=null&&(r.dataType=e.dataType|0),e.segment!=null){if(typeof e.segment!=\"object\")throw TypeError(\".onnx.TensorProto.segment: object expected\");r.segment=m.onnx.TensorProto.Segment.fromObject(e.segment)}if(e.floatData){if(!Array.isArray(e.floatData))throw TypeError(\".onnx.TensorProto.floatData: array expected\");r.floatData=[];for(var n=0;n<e.floatData.length;++n)r.floatData[n]=Number(e.floatData[n])}if(e.int32Data){if(!Array.isArray(e.int32Data))throw TypeError(\".onnx.TensorProto.int32Data: array expected\");r.int32Data=[];for(var n=0;n<e.int32Data.length;++n)r.int32Data[n]=e.int32Data[n]|0}if(e.stringData){if(!Array.isArray(e.stringData))throw TypeError(\".onnx.TensorProto.stringData: array expected\");r.stringData=[];for(var n=0;n<e.stringData.length;++n)typeof e.stringData[n]==\"string\"?y.base64.decode(e.stringData[n],r.stringData[n]=y.newBuffer(y.base64.length(e.stringData[n])),0):e.stringData[n].length>=0&&(r.stringData[n]=e.stringData[n])}if(e.int64Data){if(!Array.isArray(e.int64Data))throw TypeError(\".onnx.TensorProto.int64Data: array expected\");r.int64Data=[];for(var n=0;n<e.int64Data.length;++n)y.Long?(r.int64Data[n]=y.Long.fromValue(e.int64Data[n])).unsigned=!1:typeof e.int64Data[n]==\"string\"?r.int64Data[n]=parseInt(e.int64Data[n],10):typeof e.int64Data[n]==\"number\"?r.int64Data[n]=e.int64Data[n]:typeof e.int64Data[n]==\"object\"&&(r.int64Data[n]=new y.LongBits(e.int64Data[n].low>>>0,e.int64Data[n].high>>>0).toNumber())}if(e.name!=null&&(r.name=String(e.name)),e.docString!=null&&(r.docString=String(e.docString)),e.rawData!=null&&(typeof e.rawData==\"string\"?y.base64.decode(e.rawData,r.rawData=y.newBuffer(y.base64.length(e.rawData)),0):e.rawData.length>=0&&(r.rawData=e.rawData)),e.externalData){if(!Array.isArray(e.externalData))throw TypeError(\".onnx.TensorProto.externalData: array expected\");r.externalData=[];for(var n=0;n<e.externalData.length;++n){if(typeof e.externalData[n]!=\"object\")throw TypeError(\".onnx.TensorProto.externalData: object expected\");r.externalData[n]=m.onnx.StringStringEntryProto.fromObject(e.externalData[n])}}switch(e.dataLocation){default:if(typeof e.dataLocation==\"number\"){r.dataLocation=e.dataLocation;break}break;case\"DEFAULT\":case 0:r.dataLocation=0;break;case\"EXTERNAL\":case 1:r.dataLocation=1;break}if(e.doubleData){if(!Array.isArray(e.doubleData))throw TypeError(\".onnx.TensorProto.doubleData: array expected\");r.doubleData=[];for(var n=0;n<e.doubleData.length;++n)r.doubleData[n]=Number(e.doubleData[n])}if(e.uint64Data){if(!Array.isArray(e.uint64Data))throw TypeError(\".onnx.TensorProto.uint64Data: array expected\");r.uint64Data=[];for(var n=0;n<e.uint64Data.length;++n)y.Long?(r.uint64Data[n]=y.Long.fromValue(e.uint64Data[n])).unsigned=!0:typeof e.uint64Data[n]==\"string\"?r.uint64Data[n]=parseInt(e.uint64Data[n],10):typeof e.uint64Data[n]==\"number\"?r.uint64Data[n]=e.uint64Data[n]:typeof e.uint64Data[n]==\"object\"&&(r.uint64Data[n]=new y.LongBits(e.uint64Data[n].low>>>0,e.uint64Data[n].high>>>0).toNumber(!0))}return r},t.toObject=function(e,r){r||(r={});var n={};if((r.arrays||r.defaults)&&(n.dims=[],n.floatData=[],n.int32Data=[],n.stringData=[],n.int64Data=[],n.doubleData=[],n.uint64Data=[],n.externalData=[]),r.defaults&&(n.dataType=0,n.segment=null,n.name=\"\",r.bytes===String?n.rawData=\"\":(n.rawData=[],r.bytes!==Array&&(n.rawData=y.newBuffer(n.rawData))),n.docString=\"\",n.dataLocation=r.enums===String?\"DEFAULT\":0),e.dims&&e.dims.length){n.dims=[];for(var s=0;s<e.dims.length;++s)typeof e.dims[s]==\"number\"?n.dims[s]=r.longs===String?String(e.dims[s]):e.dims[s]:n.dims[s]=r.longs===String?y.Long.prototype.toString.call(e.dims[s]):r.longs===Number?new y.LongBits(e.dims[s].low>>>0,e.dims[s].high>>>0).toNumber():e.dims[s]}if(e.dataType!=null&&e.hasOwnProperty(\"dataType\")&&(n.dataType=e.dataType),e.segment!=null&&e.hasOwnProperty(\"segment\")&&(n.segment=m.onnx.TensorProto.Segment.toObject(e.segment,r)),e.floatData&&e.floatData.length){n.floatData=[];for(var s=0;s<e.floatData.length;++s)n.floatData[s]=r.json&&!isFinite(e.floatData[s])?String(e.floatData[s]):e.floatData[s]}if(e.int32Data&&e.int32Data.length){n.int32Data=[];for(var s=0;s<e.int32Data.length;++s)n.int32Data[s]=e.int32Data[s]}if(e.stringData&&e.stringData.length){n.stringData=[];for(var s=0;s<e.stringData.length;++s)n.stringData[s]=r.bytes===String?y.base64.encode(e.stringData[s],0,e.stringData[s].length):r.bytes===Array?Array.prototype.slice.call(e.stringData[s]):e.stringData[s]}if(e.int64Data&&e.int64Data.length){n.int64Data=[];for(var s=0;s<e.int64Data.length;++s)typeof e.int64Data[s]==\"number\"?n.int64Data[s]=r.longs===String?String(e.int64Data[s]):e.int64Data[s]:n.int64Data[s]=r.longs===String?y.Long.prototype.toString.call(e.int64Data[s]):r.longs===Number?new y.LongBits(e.int64Data[s].low>>>0,e.int64Data[s].high>>>0).toNumber():e.int64Data[s]}if(e.name!=null&&e.hasOwnProperty(\"name\")&&(n.name=e.name),e.rawData!=null&&e.hasOwnProperty(\"rawData\")&&(n.rawData=r.bytes===String?y.base64.encode(e.rawData,0,e.rawData.length):r.bytes===Array?Array.prototype.slice.call(e.rawData):e.rawData),e.doubleData&&e.doubleData.length){n.doubleData=[];for(var s=0;s<e.doubleData.length;++s)n.doubleData[s]=r.json&&!isFinite(e.doubleData[s])?String(e.doubleData[s]):e.doubleData[s]}if(e.uint64Data&&e.uint64Data.length){n.uint64Data=[];for(var s=0;s<e.uint64Data.length;++s)typeof e.uint64Data[s]==\"number\"?n.uint64Data[s]=r.longs===String?String(e.uint64Data[s]):e.uint64Data[s]:n.uint64Data[s]=r.longs===String?y.Long.prototype.toString.call(e.uint64Data[s]):r.longs===Number?new y.LongBits(e.uint64Data[s].low>>>0,e.uint64Data[s].high>>>0).toNumber(!0):e.uint64Data[s]}if(e.docString!=null&&e.hasOwnProperty(\"docString\")&&(n.docString=e.docString),e.externalData&&e.externalData.length){n.externalData=[];for(var s=0;s<e.externalData.length;++s)n.externalData[s]=m.onnx.StringStringEntryProto.toObject(e.externalData[s],r)}return e.dataLocation!=null&&e.hasOwnProperty(\"dataLocation\")&&(n.dataLocation=r.enums===String?m.onnx.TensorProto.DataLocation[e.dataLocation]===void 0?e.dataLocation:m.onnx.TensorProto.DataLocation[e.dataLocation]:e.dataLocation),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},t.getTypeUrl=function(e){return e===void 0&&(e=\"type.googleapis.com\"),e+\"/onnx.TensorProto\"},t.DataType=function(){var o={},e=Object.create(o);return e[o[0]=\"UNDEFINED\"]=0,e[o[1]=\"FLOAT\"]=1,e[o[2]=\"UINT8\"]=2,e[o[3]=\"INT8\"]=3,e[o[4]=\"UINT16\"]=4,e[o[5]=\"INT16\"]=5,e[o[6]=\"INT32\"]=6,e[o[7]=\"INT64\"]=7,e[o[8]=\"STRING\"]=8,e[o[9]=\"BOOL\"]=9,e[o[10]=\"FLOAT16\"]=10,e[o[11]=\"DOUBLE\"]=11,e[o[12]=\"UINT32\"]=12,e[o[13]=\"UINT64\"]=13,e[o[14]=\"COMPLEX64\"]=14,e[o[15]=\"COMPLEX128\"]=15,e[o[16]=\"BFLOAT16\"]=16,e[o[17]=\"FLOAT8E4M3FN\"]=17,e[o[18]=\"FLOAT8E4M3FNUZ\"]=18,e[o[19]=\"FLOAT8E5M2\"]=19,e[o[20]=\"FLOAT8E5M2FNUZ\"]=20,e}(),t.Segment=function(){function o(e){if(e)for(var r=Object.keys(e),n=0;n<r.length;++n)e[r[n]]!=null&&(this[r[n]]=e[r[n]])}return o.prototype.begin=y.Long?y.Long.fromBits(0,0,!1):0,o.prototype.end=y.Long?y.Long.fromBits(0,0,!1):0,o.create=function(r){return new o(r)},o.encode=function(r,n){return n||(n=Ee.create()),r.begin!=null&&Object.hasOwnProperty.call(r,\"begin\")&&n.uint32(8).int64(r.begin),r.end!=null&&Object.hasOwnProperty.call(r,\"end\")&&n.uint32(16).int64(r.end),n},o.encodeDelimited=function(r,n){return this.encode(r,n).ldelim()},o.decode=function(r,n){r instanceof N||(r=N.create(r));for(var s=n===void 0?r.len:r.pos+n,i=new m.onnx.TensorProto.Segment;r.pos<s;){var u=r.uint32();switch(u>>>3){case 1:{i.begin=r.int64();break}case 2:{i.end=r.int64();break}default:r.skipType(u&7);break}}return i},o.decodeDelimited=function(r){return r instanceof N||(r=new N(r)),this.decode(r,r.uint32())},o.verify=function(r){return typeof r!=\"object\"||r===null?\"object expected\":r.begin!=null&&r.hasOwnProperty(\"begin\")&&!y.isInteger(r.begin)&&!(r.begin&&y.isInteger(r.begin.low)&&y.isInteger(r.begin.high))?\"begin: integer|Long expected\":r.end!=null&&r.hasOwnProperty(\"end\")&&!y.isInteger(r.end)&&!(r.end&&y.isInteger(r.end.low)&&y.isInteger(r.end.high))?\"end: integer|Long expected\":null},o.fromObject=function(r){if(r instanceof m.onnx.TensorProto.Segment)return r;var n=new m.onnx.TensorProto.Segment;return r.begin!=null&&(y.Long?(n.begin=y.Long.fromValue(r.begin)).unsigned=!1:typeof r.begin==\"string\"?n.begin=parseInt(r.begin,10):typeof r.begin==\"number\"?n.begin=r.begin:typeof r.begin==\"object\"&&(n.begin=new y.LongBits(r.begin.low>>>0,r.begin.high>>>0).toNumber())),r.end!=null&&(y.Long?(n.end=y.Long.fromValue(r.end)).unsigned=!1:typeof r.end==\"string\"?n.end=parseInt(r.end,10):typeof r.end==\"number\"?n.end=r.end:typeof r.end==\"object\"&&(n.end=new y.LongBits(r.end.low>>>0,r.end.high>>>0).toNumber())),n},o.toObject=function(r,n){n||(n={});var s={};if(n.defaults){if(y.Long){var i=new y.Long(0,0,!1);s.begin=n.longs===String?i.toString():n.longs===Number?i.toNumber():i}else s.begin=n.longs===String?\"0\":0;if(y.Long){var i=new y.Long(0,0,!1);s.end=n.longs===String?i.toString():n.longs===Number?i.toNumber():i}else s.end=n.longs===String?\"0\":0}return r.begin!=null&&r.hasOwnProperty(\"begin\")&&(typeof r.begin==\"number\"?s.begin=n.longs===String?String(r.begin):r.begin:s.begin=n.longs===String?y.Long.prototype.toString.call(r.begin):n.longs===Number?new y.LongBits(r.begin.low>>>0,r.begin.high>>>0).toNumber():r.begin),r.end!=null&&r.hasOwnProperty(\"end\")&&(typeof r.end==\"number\"?s.end=n.longs===String?String(r.end):r.end:s.end=n.longs===String?y.Long.prototype.toString.call(r.end):n.longs===Number?new y.LongBits(r.end.low>>>0,r.end.high>>>0).toNumber():r.end),s},o.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},o.getTypeUrl=function(r){return r===void 0&&(r=\"type.googleapis.com\"),r+\"/onnx.TensorProto.Segment\"},o}(),t.DataLocation=function(){var o={},e=Object.create(o);return e[o[0]=\"DEFAULT\"]=0,e[o[1]=\"EXTERNAL\"]=1,e}(),t}(),a.SparseTensorProto=function(){function t(o){if(this.dims=[],o)for(var e=Object.keys(o),r=0;r<e.length;++r)o[e[r]]!=null&&(this[e[r]]=o[e[r]])}return t.prototype.values=null,t.prototype.indices=null,t.prototype.dims=y.emptyArray,t.create=function(e){return new t(e)},t.encode=function(e,r){if(r||(r=Ee.create()),e.values!=null&&Object.hasOwnProperty.call(e,\"values\")&&m.onnx.TensorProto.encode(e.values,r.uint32(10).fork()).ldelim(),e.indices!=null&&Object.hasOwnProperty.call(e,\"indices\")&&m.onnx.TensorProto.encode(e.indices,r.uint32(18).fork()).ldelim(),e.dims!=null&&e.dims.length){r.uint32(26).fork();for(var n=0;n<e.dims.length;++n)r.int64(e.dims[n]);r.ldelim()}return r},t.encodeDelimited=function(e,r){return this.encode(e,r).ldelim()},t.decode=function(e,r){e instanceof N||(e=N.create(e));for(var n=r===void 0?e.len:e.pos+r,s=new m.onnx.SparseTensorProto;e.pos<n;){var i=e.uint32();switch(i>>>3){case 1:{s.values=m.onnx.TensorProto.decode(e,e.uint32());break}case 2:{s.indices=m.onnx.TensorProto.decode(e,e.uint32());break}case 3:{if(s.dims&&s.dims.length||(s.dims=[]),(i&7)===2)for(var u=e.uint32()+e.pos;e.pos<u;)s.dims.push(e.int64());else s.dims.push(e.int64());break}default:e.skipType(i&7);break}}return s},t.decodeDelimited=function(e){return e instanceof N||(e=new N(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!=\"object\"||e===null)return\"object expected\";if(e.values!=null&&e.hasOwnProperty(\"values\")){var r=m.onnx.TensorProto.verify(e.values);if(r)return\"values.\"+r}if(e.indices!=null&&e.hasOwnProperty(\"indices\")){var r=m.onnx.TensorProto.verify(e.indices);if(r)return\"indices.\"+r}if(e.dims!=null&&e.hasOwnProperty(\"dims\")){if(!Array.isArray(e.dims))return\"dims: array expected\";for(var n=0;n<e.dims.length;++n)if(!y.isInteger(e.dims[n])&&!(e.dims[n]&&y.isInteger(e.dims[n].low)&&y.isInteger(e.dims[n].high)))return\"dims: integer|Long[] expected\"}return null},t.fromObject=function(e){if(e instanceof m.onnx.SparseTensorProto)return e;var r=new m.onnx.SparseTensorProto;if(e.values!=null){if(typeof e.values!=\"object\")throw TypeError(\".onnx.SparseTensorProto.values: object expected\");r.values=m.onnx.TensorProto.fromObject(e.values)}if(e.indices!=null){if(typeof e.indices!=\"object\")throw TypeError(\".onnx.SparseTensorProto.indices: object expected\");r.indices=m.onnx.TensorProto.fromObject(e.indices)}if(e.dims){if(!Array.isArray(e.dims))throw TypeError(\".onnx.SparseTensorProto.dims: array expected\");r.dims=[];for(var n=0;n<e.dims.length;++n)y.Long?(r.dims[n]=y.Long.fromValue(e.dims[n])).unsigned=!1:typeof e.dims[n]==\"string\"?r.dims[n]=parseInt(e.dims[n],10):typeof e.dims[n]==\"number\"?r.dims[n]=e.dims[n]:typeof e.dims[n]==\"object\"&&(r.dims[n]=new y.LongBits(e.dims[n].low>>>0,e.dims[n].high>>>0).toNumber())}return r},t.toObject=function(e,r){r||(r={});var n={};if((r.arrays||r.defaults)&&(n.dims=[]),r.defaults&&(n.values=null,n.indices=null),e.values!=null&&e.hasOwnProperty(\"values\")&&(n.values=m.onnx.TensorProto.toObject(e.values,r)),e.indices!=null&&e.hasOwnProperty(\"indices\")&&(n.indices=m.onnx.TensorProto.toObject(e.indices,r)),e.dims&&e.dims.length){n.dims=[];for(var s=0;s<e.dims.length;++s)typeof e.dims[s]==\"number\"?n.dims[s]=r.longs===String?String(e.dims[s]):e.dims[s]:n.dims[s]=r.longs===String?y.Long.prototype.toString.call(e.dims[s]):r.longs===Number?new y.LongBits(e.dims[s].low>>>0,e.dims[s].high>>>0).toNumber():e.dims[s]}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},t.getTypeUrl=function(e){return e===void 0&&(e=\"type.googleapis.com\"),e+\"/onnx.SparseTensorProto\"},t}(),a.TensorShapeProto=function(){function t(o){if(this.dim=[],o)for(var e=Object.keys(o),r=0;r<e.length;++r)o[e[r]]!=null&&(this[e[r]]=o[e[r]])}return t.prototype.dim=y.emptyArray,t.create=function(e){return new t(e)},t.encode=function(e,r){if(r||(r=Ee.create()),e.dim!=null&&e.dim.length)for(var n=0;n<e.dim.length;++n)m.onnx.TensorShapeProto.Dimension.encode(e.dim[n],r.uint32(10).fork()).ldelim();return r},t.encodeDelimited=function(e,r){return this.encode(e,r).ldelim()},t.decode=function(e,r){e instanceof N||(e=N.create(e));for(var n=r===void 0?e.len:e.pos+r,s=new m.onnx.TensorShapeProto;e.pos<n;){var i=e.uint32();switch(i>>>3){case 1:{s.dim&&s.dim.length||(s.dim=[]),s.dim.push(m.onnx.TensorShapeProto.Dimension.decode(e,e.uint32()));break}default:e.skipType(i&7);break}}return s},t.decodeDelimited=function(e){return e instanceof N||(e=new N(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!=\"object\"||e===null)return\"object expected\";if(e.dim!=null&&e.hasOwnProperty(\"dim\")){if(!Array.isArray(e.dim))return\"dim: array expected\";for(var r=0;r<e.dim.length;++r){var n=m.onnx.TensorShapeProto.Dimension.verify(e.dim[r]);if(n)return\"dim.\"+n}}return null},t.fromObject=function(e){if(e instanceof m.onnx.TensorShapeProto)return e;var r=new m.onnx.TensorShapeProto;if(e.dim){if(!Array.isArray(e.dim))throw TypeError(\".onnx.TensorShapeProto.dim: array expected\");r.dim=[];for(var n=0;n<e.dim.length;++n){if(typeof e.dim[n]!=\"object\")throw TypeError(\".onnx.TensorShapeProto.dim: object expected\");r.dim[n]=m.onnx.TensorShapeProto.Dimension.fromObject(e.dim[n])}}return r},t.toObject=function(e,r){r||(r={});var n={};if((r.arrays||r.defaults)&&(n.dim=[]),e.dim&&e.dim.length){n.dim=[];for(var s=0;s<e.dim.length;++s)n.dim[s]=m.onnx.TensorShapeProto.Dimension.toObject(e.dim[s],r)}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},t.getTypeUrl=function(e){return e===void 0&&(e=\"type.googleapis.com\"),e+\"/onnx.TensorShapeProto\"},t.Dimension=function(){function o(r){if(r)for(var n=Object.keys(r),s=0;s<n.length;++s)r[n[s]]!=null&&(this[n[s]]=r[n[s]])}o.prototype.dimValue=null,o.prototype.dimParam=null,o.prototype.denotation=\"\";var e;return Object.defineProperty(o.prototype,\"value\",{get:y.oneOfGetter(e=[\"dimValue\",\"dimParam\"]),set:y.oneOfSetter(e)}),o.create=function(n){return new o(n)},o.encode=function(n,s){return s||(s=Ee.create()),n.dimValue!=null&&Object.hasOwnProperty.call(n,\"dimValue\")&&s.uint32(8).int64(n.dimValue),n.dimParam!=null&&Object.hasOwnProperty.call(n,\"dimParam\")&&s.uint32(18).string(n.dimParam),n.denotation!=null&&Object.hasOwnProperty.call(n,\"denotation\")&&s.uint32(26).string(n.denotation),s},o.encodeDelimited=function(n,s){return this.encode(n,s).ldelim()},o.decode=function(n,s){n instanceof N||(n=N.create(n));for(var i=s===void 0?n.len:n.pos+s,u=new m.onnx.TensorShapeProto.Dimension;n.pos<i;){var l=n.uint32();switch(l>>>3){case 1:{u.dimValue=n.int64();break}case 2:{u.dimParam=n.string();break}case 3:{u.denotation=n.string();break}default:n.skipType(l&7);break}}return u},o.decodeDelimited=function(n){return n instanceof N||(n=new N(n)),this.decode(n,n.uint32())},o.verify=function(n){if(typeof n!=\"object\"||n===null)return\"object expected\";var s={};if(n.dimValue!=null&&n.hasOwnProperty(\"dimValue\")&&(s.value=1,!y.isInteger(n.dimValue)&&!(n.dimValue&&y.isInteger(n.dimValue.low)&&y.isInteger(n.dimValue.high))))return\"dimValue: integer|Long expected\";if(n.dimParam!=null&&n.hasOwnProperty(\"dimParam\")){if(s.value===1)return\"value: multiple values\";if(s.value=1,!y.isString(n.dimParam))return\"dimParam: string expected\"}return n.denotation!=null&&n.hasOwnProperty(\"denotation\")&&!y.isString(n.denotation)?\"denotation: string expected\":null},o.fromObject=function(n){if(n instanceof m.onnx.TensorShapeProto.Dimension)return n;var s=new m.onnx.TensorShapeProto.Dimension;return n.dimValue!=null&&(y.Long?(s.dimValue=y.Long.fromValue(n.dimValue)).unsigned=!1:typeof n.dimValue==\"string\"?s.dimValue=parseInt(n.dimValue,10):typeof n.dimValue==\"number\"?s.dimValue=n.dimValue:typeof n.dimValue==\"object\"&&(s.dimValue=new y.LongBits(n.dimValue.low>>>0,n.dimValue.high>>>0).toNumber())),n.dimParam!=null&&(s.dimParam=String(n.dimParam)),n.denotation!=null&&(s.denotation=String(n.denotation)),s},o.toObject=function(n,s){s||(s={});var i={};return s.defaults&&(i.denotation=\"\"),n.dimValue!=null&&n.hasOwnProperty(\"dimValue\")&&(typeof n.dimValue==\"number\"?i.dimValue=s.longs===String?String(n.dimValue):n.dimValue:i.dimValue=s.longs===String?y.Long.prototype.toString.call(n.dimValue):s.longs===Number?new y.LongBits(n.dimValue.low>>>0,n.dimValue.high>>>0).toNumber():n.dimValue,s.oneofs&&(i.value=\"dimValue\")),n.dimParam!=null&&n.hasOwnProperty(\"dimParam\")&&(i.dimParam=n.dimParam,s.oneofs&&(i.value=\"dimParam\")),n.denotation!=null&&n.hasOwnProperty(\"denotation\")&&(i.denotation=n.denotation),i},o.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},o.getTypeUrl=function(n){return n===void 0&&(n=\"type.googleapis.com\"),n+\"/onnx.TensorShapeProto.Dimension\"},o}(),t}(),a.TypeProto=function(){function t(e){if(e)for(var r=Object.keys(e),n=0;n<r.length;++n)e[r[n]]!=null&&(this[r[n]]=e[r[n]])}t.prototype.tensorType=null,t.prototype.sequenceType=null,t.prototype.mapType=null,t.prototype.optionalType=null,t.prototype.sparseTensorType=null,t.prototype.denotation=\"\";var o;return Object.defineProperty(t.prototype,\"value\",{get:y.oneOfGetter(o=[\"tensorType\",\"sequenceType\",\"mapType\",\"optionalType\",\"sparseTensorType\"]),set:y.oneOfSetter(o)}),t.create=function(r){return new t(r)},t.encode=function(r,n){return n||(n=Ee.create()),r.tensorType!=null&&Object.hasOwnProperty.call(r,\"tensorType\")&&m.onnx.TypeProto.Tensor.encode(r.tensorType,n.uint32(10).fork()).ldelim(),r.sequenceType!=null&&Object.hasOwnProperty.call(r,\"sequenceType\")&&m.onnx.TypeProto.Sequence.encode(r.sequenceType,n.uint32(34).fork()).ldelim(),r.mapType!=null&&Object.hasOwnProperty.call(r,\"mapType\")&&m.onnx.TypeProto.Map.encode(r.mapType,n.uint32(42).fork()).ldelim(),r.denotation!=null&&Object.hasOwnProperty.call(r,\"denotation\")&&n.uint32(50).string(r.denotation),r.sparseTensorType!=null&&Object.hasOwnProperty.call(r,\"sparseTensorType\")&&m.onnx.TypeProto.SparseTensor.encode(r.sparseTensorType,n.uint32(66).fork()).ldelim(),r.optionalType!=null&&Object.hasOwnProperty.call(r,\"optionalType\")&&m.onnx.TypeProto.Optional.encode(r.optionalType,n.uint32(74).fork()).ldelim(),n},t.encodeDelimited=function(r,n){return this.encode(r,n).ldelim()},t.decode=function(r,n){r instanceof N||(r=N.create(r));for(var s=n===void 0?r.len:r.pos+n,i=new m.onnx.TypeProto;r.pos<s;){var u=r.uint32();switch(u>>>3){case 1:{i.tensorType=m.onnx.TypeProto.Tensor.decode(r,r.uint32());break}case 4:{i.sequenceType=m.onnx.TypeProto.Sequence.decode(r,r.uint32());break}case 5:{i.mapType=m.onnx.TypeProto.Map.decode(r,r.uint32());break}case 9:{i.optionalType=m.onnx.TypeProto.Optional.decode(r,r.uint32());break}case 8:{i.sparseTensorType=m.onnx.TypeProto.SparseTensor.decode(r,r.uint32());break}case 6:{i.denotation=r.string();break}default:r.skipType(u&7);break}}return i},t.decodeDelimited=function(r){return r instanceof N||(r=new N(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!=\"object\"||r===null)return\"object expected\";var n={};if(r.tensorType!=null&&r.hasOwnProperty(\"tensorType\")){n.value=1;{var s=m.onnx.TypeProto.Tensor.verify(r.tensorType);if(s)return\"tensorType.\"+s}}if(r.sequenceType!=null&&r.hasOwnProperty(\"sequenceType\")){if(n.value===1)return\"value: multiple values\";n.value=1;{var s=m.onnx.TypeProto.Sequence.verify(r.sequenceType);if(s)return\"sequenceType.\"+s}}if(r.mapType!=null&&r.hasOwnProperty(\"mapType\")){if(n.value===1)return\"value: multiple values\";n.value=1;{var s=m.onnx.TypeProto.Map.verify(r.mapType);if(s)return\"mapType.\"+s}}if(r.optionalType!=null&&r.hasOwnProperty(\"optionalType\")){if(n.value===1)return\"value: multiple values\";n.value=1;{var s=m.onnx.TypeProto.Optional.verify(r.optionalType);if(s)return\"optionalType.\"+s}}if(r.sparseTensorType!=null&&r.hasOwnProperty(\"sparseTensorType\")){if(n.value===1)return\"value: multiple values\";n.value=1;{var s=m.onnx.TypeProto.SparseTensor.verify(r.sparseTensorType);if(s)return\"sparseTensorType.\"+s}}return r.denotation!=null&&r.hasOwnProperty(\"denotation\")&&!y.isString(r.denotation)?\"denotation: string expected\":null},t.fromObject=function(r){if(r instanceof m.onnx.TypeProto)return r;var n=new m.onnx.TypeProto;if(r.tensorType!=null){if(typeof r.tensorType!=\"object\")throw TypeError(\".onnx.TypeProto.tensorType: object expected\");n.tensorType=m.onnx.TypeProto.Tensor.fromObject(r.tensorType)}if(r.sequenceType!=null){if(typeof r.sequenceType!=\"object\")throw TypeError(\".onnx.TypeProto.sequenceType: object expected\");n.sequenceType=m.onnx.TypeProto.Sequence.fromObject(r.sequenceType)}if(r.mapType!=null){if(typeof r.mapType!=\"object\")throw TypeError(\".onnx.TypeProto.mapType: object expected\");n.mapType=m.onnx.TypeProto.Map.fromObject(r.mapType)}if(r.optionalType!=null){if(typeof r.optionalType!=\"object\")throw TypeError(\".onnx.TypeProto.optionalType: object expected\");n.optionalType=m.onnx.TypeProto.Optional.fromObject(r.optionalType)}if(r.sparseTensorType!=null){if(typeof r.sparseTensorType!=\"object\")throw TypeError(\".onnx.TypeProto.sparseTensorType: object expected\");n.sparseTensorType=m.onnx.TypeProto.SparseTensor.fromObject(r.sparseTensorType)}return r.denotation!=null&&(n.denotation=String(r.denotation)),n},t.toObject=function(r,n){n||(n={});var s={};return n.defaults&&(s.denotation=\"\"),r.tensorType!=null&&r.hasOwnProperty(\"tensorType\")&&(s.tensorType=m.onnx.TypeProto.Tensor.toObject(r.tensorType,n),n.oneofs&&(s.value=\"tensorType\")),r.sequenceType!=null&&r.hasOwnProperty(\"sequenceType\")&&(s.sequenceType=m.onnx.TypeProto.Sequence.toObject(r.sequenceType,n),n.oneofs&&(s.value=\"sequenceType\")),r.mapType!=null&&r.hasOwnProperty(\"mapType\")&&(s.mapType=m.onnx.TypeProto.Map.toObject(r.mapType,n),n.oneofs&&(s.value=\"mapType\")),r.denotation!=null&&r.hasOwnProperty(\"denotation\")&&(s.denotation=r.denotation),r.sparseTensorType!=null&&r.hasOwnProperty(\"sparseTensorType\")&&(s.sparseTensorType=m.onnx.TypeProto.SparseTensor.toObject(r.sparseTensorType,n),n.oneofs&&(s.value=\"sparseTensorType\")),r.optionalType!=null&&r.hasOwnProperty(\"optionalType\")&&(s.optionalType=m.onnx.TypeProto.Optional.toObject(r.optionalType,n),n.oneofs&&(s.value=\"optionalType\")),s},t.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},t.getTypeUrl=function(r){return r===void 0&&(r=\"type.googleapis.com\"),r+\"/onnx.TypeProto\"},t.Tensor=function(){function e(r){if(r)for(var n=Object.keys(r),s=0;s<n.length;++s)r[n[s]]!=null&&(this[n[s]]=r[n[s]])}return e.prototype.elemType=0,e.prototype.shape=null,e.create=function(n){return new e(n)},e.encode=function(n,s){return s||(s=Ee.create()),n.elemType!=null&&Object.hasOwnProperty.call(n,\"elemType\")&&s.uint32(8).int32(n.elemType),n.shape!=null&&Object.hasOwnProperty.call(n,\"shape\")&&m.onnx.TensorShapeProto.encode(n.shape,s.uint32(18).fork()).ldelim(),s},e.encodeDelimited=function(n,s){return this.encode(n,s).ldelim()},e.decode=function(n,s){n instanceof N||(n=N.create(n));for(var i=s===void 0?n.len:n.pos+s,u=new m.onnx.TypeProto.Tensor;n.pos<i;){var l=n.uint32();switch(l>>>3){case 1:{u.elemType=n.int32();break}case 2:{u.shape=m.onnx.TensorShapeProto.decode(n,n.uint32());break}default:n.skipType(l&7);break}}return u},e.decodeDelimited=function(n){return n instanceof N||(n=new N(n)),this.decode(n,n.uint32())},e.verify=function(n){if(typeof n!=\"object\"||n===null)return\"object expected\";if(n.elemType!=null&&n.hasOwnProperty(\"elemType\")&&!y.isInteger(n.elemType))return\"elemType: integer expected\";if(n.shape!=null&&n.hasOwnProperty(\"shape\")){var s=m.onnx.TensorShapeProto.verify(n.shape);if(s)return\"shape.\"+s}return null},e.fromObject=function(n){if(n instanceof m.onnx.TypeProto.Tensor)return n;var s=new m.onnx.TypeProto.Tensor;if(n.elemType!=null&&(s.elemType=n.elemType|0),n.shape!=null){if(typeof n.shape!=\"object\")throw TypeError(\".onnx.TypeProto.Tensor.shape: object expected\");s.shape=m.onnx.TensorShapeProto.fromObject(n.shape)}return s},e.toObject=function(n,s){s||(s={});var i={};return s.defaults&&(i.elemType=0,i.shape=null),n.elemType!=null&&n.hasOwnProperty(\"elemType\")&&(i.elemType=n.elemType),n.shape!=null&&n.hasOwnProperty(\"shape\")&&(i.shape=m.onnx.TensorShapeProto.toObject(n.shape,s)),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},e.getTypeUrl=function(n){return n===void 0&&(n=\"type.googleapis.com\"),n+\"/onnx.TypeProto.Tensor\"},e}(),t.Sequence=function(){function e(r){if(r)for(var n=Object.keys(r),s=0;s<n.length;++s)r[n[s]]!=null&&(this[n[s]]=r[n[s]])}return e.prototype.elemType=null,e.create=function(n){return new e(n)},e.encode=function(n,s){return s||(s=Ee.create()),n.elemType!=null&&Object.hasOwnProperty.call(n,\"elemType\")&&m.onnx.TypeProto.encode(n.elemType,s.uint32(10).fork()).ldelim(),s},e.encodeDelimited=function(n,s){return this.encode(n,s).ldelim()},e.decode=function(n,s){n instanceof N||(n=N.create(n));for(var i=s===void 0?n.len:n.pos+s,u=new m.onnx.TypeProto.Sequence;n.pos<i;){var l=n.uint32();switch(l>>>3){case 1:{u.elemType=m.onnx.TypeProto.decode(n,n.uint32());break}default:n.skipType(l&7);break}}return u},e.decodeDelimited=function(n){return n instanceof N||(n=new N(n)),this.decode(n,n.uint32())},e.verify=function(n){if(typeof n!=\"object\"||n===null)return\"object expected\";if(n.elemType!=null&&n.hasOwnProperty(\"elemType\")){var s=m.onnx.TypeProto.verify(n.elemType);if(s)return\"elemType.\"+s}return null},e.fromObject=function(n){if(n instanceof m.onnx.TypeProto.Sequence)return n;var s=new m.onnx.TypeProto.Sequence;if(n.elemType!=null){if(typeof n.elemType!=\"object\")throw TypeError(\".onnx.TypeProto.Sequence.elemType: object expected\");s.elemType=m.onnx.TypeProto.fromObject(n.elemType)}return s},e.toObject=function(n,s){s||(s={});var i={};return s.defaults&&(i.elemType=null),n.elemType!=null&&n.hasOwnProperty(\"elemType\")&&(i.elemType=m.onnx.TypeProto.toObject(n.elemType,s)),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},e.getTypeUrl=function(n){return n===void 0&&(n=\"type.googleapis.com\"),n+\"/onnx.TypeProto.Sequence\"},e}(),t.Map=function(){function e(r){if(r)for(var n=Object.keys(r),s=0;s<n.length;++s)r[n[s]]!=null&&(this[n[s]]=r[n[s]])}return e.prototype.keyType=0,e.prototype.valueType=null,e.create=function(n){return new e(n)},e.encode=function(n,s){return s||(s=Ee.create()),n.keyType!=null&&Object.hasOwnProperty.call(n,\"keyType\")&&s.uint32(8).int32(n.keyType),n.valueType!=null&&Object.hasOwnProperty.call(n,\"valueType\")&&m.onnx.TypeProto.encode(n.valueType,s.uint32(18).fork()).ldelim(),s},e.encodeDelimited=function(n,s){return this.encode(n,s).ldelim()},e.decode=function(n,s){n instanceof N||(n=N.create(n));for(var i=s===void 0?n.len:n.pos+s,u=new m.onnx.TypeProto.Map;n.pos<i;){var l=n.uint32();switch(l>>>3){case 1:{u.keyType=n.int32();break}case 2:{u.valueType=m.onnx.TypeProto.decode(n,n.uint32());break}default:n.skipType(l&7);break}}return u},e.decodeDelimited=function(n){return n instanceof N||(n=new N(n)),this.decode(n,n.uint32())},e.verify=function(n){if(typeof n!=\"object\"||n===null)return\"object expected\";if(n.keyType!=null&&n.hasOwnProperty(\"keyType\")&&!y.isInteger(n.keyType))return\"keyType: integer expected\";if(n.valueType!=null&&n.hasOwnProperty(\"valueType\")){var s=m.onnx.TypeProto.verify(n.valueType);if(s)return\"valueType.\"+s}return null},e.fromObject=function(n){if(n instanceof m.onnx.TypeProto.Map)return n;var s=new m.onnx.TypeProto.Map;if(n.keyType!=null&&(s.keyType=n.keyType|0),n.valueType!=null){if(typeof n.valueType!=\"object\")throw TypeError(\".onnx.TypeProto.Map.valueType: object expected\");s.valueType=m.onnx.TypeProto.fromObject(n.valueType)}return s},e.toObject=function(n,s){s||(s={});var i={};return s.defaults&&(i.keyType=0,i.valueType=null),n.keyType!=null&&n.hasOwnProperty(\"keyType\")&&(i.keyType=n.keyType),n.valueType!=null&&n.hasOwnProperty(\"valueType\")&&(i.valueType=m.onnx.TypeProto.toObject(n.valueType,s)),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},e.getTypeUrl=function(n){return n===void 0&&(n=\"type.googleapis.com\"),n+\"/onnx.TypeProto.Map\"},e}(),t.Optional=function(){function e(r){if(r)for(var n=Object.keys(r),s=0;s<n.length;++s)r[n[s]]!=null&&(this[n[s]]=r[n[s]])}return e.prototype.elemType=null,e.create=function(n){return new e(n)},e.encode=function(n,s){return s||(s=Ee.create()),n.elemType!=null&&Object.hasOwnProperty.call(n,\"elemType\")&&m.onnx.TypeProto.encode(n.elemType,s.uint32(10).fork()).ldelim(),s},e.encodeDelimited=function(n,s){return this.encode(n,s).ldelim()},e.decode=function(n,s){n instanceof N||(n=N.create(n));for(var i=s===void 0?n.len:n.pos+s,u=new m.onnx.TypeProto.Optional;n.pos<i;){var l=n.uint32();switch(l>>>3){case 1:{u.elemType=m.onnx.TypeProto.decode(n,n.uint32());break}default:n.skipType(l&7);break}}return u},e.decodeDelimited=function(n){return n instanceof N||(n=new N(n)),this.decode(n,n.uint32())},e.verify=function(n){if(typeof n!=\"object\"||n===null)return\"object expected\";if(n.elemType!=null&&n.hasOwnProperty(\"elemType\")){var s=m.onnx.TypeProto.verify(n.elemType);if(s)return\"elemType.\"+s}return null},e.fromObject=function(n){if(n instanceof m.onnx.TypeProto.Optional)return n;var s=new m.onnx.TypeProto.Optional;if(n.elemType!=null){if(typeof n.elemType!=\"object\")throw TypeError(\".onnx.TypeProto.Optional.elemType: object expected\");s.elemType=m.onnx.TypeProto.fromObject(n.elemType)}return s},e.toObject=function(n,s){s||(s={});var i={};return s.defaults&&(i.elemType=null),n.elemType!=null&&n.hasOwnProperty(\"elemType\")&&(i.elemType=m.onnx.TypeProto.toObject(n.elemType,s)),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},e.getTypeUrl=function(n){return n===void 0&&(n=\"type.googleapis.com\"),n+\"/onnx.TypeProto.Optional\"},e}(),t.SparseTensor=function(){function e(r){if(r)for(var n=Object.keys(r),s=0;s<n.length;++s)r[n[s]]!=null&&(this[n[s]]=r[n[s]])}return e.prototype.elemType=0,e.prototype.shape=null,e.create=function(n){return new e(n)},e.encode=function(n,s){return s||(s=Ee.create()),n.elemType!=null&&Object.hasOwnProperty.call(n,\"elemType\")&&s.uint32(8).int32(n.elemType),n.shape!=null&&Object.hasOwnProperty.call(n,\"shape\")&&m.onnx.TensorShapeProto.encode(n.shape,s.uint32(18).fork()).ldelim(),s},e.encodeDelimited=function(n,s){return this.encode(n,s).ldelim()},e.decode=function(n,s){n instanceof N||(n=N.create(n));for(var i=s===void 0?n.len:n.pos+s,u=new m.onnx.TypeProto.SparseTensor;n.pos<i;){var l=n.uint32();switch(l>>>3){case 1:{u.elemType=n.int32();break}case 2:{u.shape=m.onnx.TensorShapeProto.decode(n,n.uint32());break}default:n.skipType(l&7);break}}return u},e.decodeDelimited=function(n){return n instanceof N||(n=new N(n)),this.decode(n,n.uint32())},e.verify=function(n){if(typeof n!=\"object\"||n===null)return\"object expected\";if(n.elemType!=null&&n.hasOwnProperty(\"elemType\")&&!y.isInteger(n.elemType))return\"elemType: integer expected\";if(n.shape!=null&&n.hasOwnProperty(\"shape\")){var s=m.onnx.TensorShapeProto.verify(n.shape);if(s)return\"shape.\"+s}return null},e.fromObject=function(n){if(n instanceof m.onnx.TypeProto.SparseTensor)return n;var s=new m.onnx.TypeProto.SparseTensor;if(n.elemType!=null&&(s.elemType=n.elemType|0),n.shape!=null){if(typeof n.shape!=\"object\")throw TypeError(\".onnx.TypeProto.SparseTensor.shape: object expected\");s.shape=m.onnx.TensorShapeProto.fromObject(n.shape)}return s},e.toObject=function(n,s){s||(s={});var i={};return s.defaults&&(i.elemType=0,i.shape=null),n.elemType!=null&&n.hasOwnProperty(\"elemType\")&&(i.elemType=n.elemType),n.shape!=null&&n.hasOwnProperty(\"shape\")&&(i.shape=m.onnx.TensorShapeProto.toObject(n.shape,s)),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},e.getTypeUrl=function(n){return n===void 0&&(n=\"type.googleapis.com\"),n+\"/onnx.TypeProto.SparseTensor\"},e}(),t}(),a.OperatorSetIdProto=function(){function t(o){if(o)for(var e=Object.keys(o),r=0;r<e.length;++r)o[e[r]]!=null&&(this[e[r]]=o[e[r]])}return t.prototype.domain=\"\",t.prototype.version=y.Long?y.Long.fromBits(0,0,!1):0,t.create=function(e){return new t(e)},t.encode=function(e,r){return r||(r=Ee.create()),e.domain!=null&&Object.hasOwnProperty.call(e,\"domain\")&&r.uint32(10).string(e.domain),e.version!=null&&Object.hasOwnProperty.call(e,\"version\")&&r.uint32(16).int64(e.version),r},t.encodeDelimited=function(e,r){return this.encode(e,r).ldelim()},t.decode=function(e,r){e instanceof N||(e=N.create(e));for(var n=r===void 0?e.len:e.pos+r,s=new m.onnx.OperatorSetIdProto;e.pos<n;){var i=e.uint32();switch(i>>>3){case 1:{s.domain=e.string();break}case 2:{s.version=e.int64();break}default:e.skipType(i&7);break}}return s},t.decodeDelimited=function(e){return e instanceof N||(e=new N(e)),this.decode(e,e.uint32())},t.verify=function(e){return typeof e!=\"object\"||e===null?\"object expected\":e.domain!=null&&e.hasOwnProperty(\"domain\")&&!y.isString(e.domain)?\"domain: string expected\":e.version!=null&&e.hasOwnProperty(\"version\")&&!y.isInteger(e.version)&&!(e.version&&y.isInteger(e.version.low)&&y.isInteger(e.version.high))?\"version: integer|Long expected\":null},t.fromObject=function(e){if(e instanceof m.onnx.OperatorSetIdProto)return e;var r=new m.onnx.OperatorSetIdProto;return e.domain!=null&&(r.domain=String(e.domain)),e.version!=null&&(y.Long?(r.version=y.Long.fromValue(e.version)).unsigned=!1:typeof e.version==\"string\"?r.version=parseInt(e.version,10):typeof e.version==\"number\"?r.version=e.version:typeof e.version==\"object\"&&(r.version=new y.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber())),r},t.toObject=function(e,r){r||(r={});var n={};if(r.defaults)if(n.domain=\"\",y.Long){var s=new y.Long(0,0,!1);n.version=r.longs===String?s.toString():r.longs===Number?s.toNumber():s}else n.version=r.longs===String?\"0\":0;return e.domain!=null&&e.hasOwnProperty(\"domain\")&&(n.domain=e.domain),e.version!=null&&e.hasOwnProperty(\"version\")&&(typeof e.version==\"number\"?n.version=r.longs===String?String(e.version):e.version:n.version=r.longs===String?y.Long.prototype.toString.call(e.version):r.longs===Number?new y.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber():e.version),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},t.getTypeUrl=function(e){return e===void 0&&(e=\"type.googleapis.com\"),e+\"/onnx.OperatorSetIdProto\"},t}(),a.OperatorStatus=function(){var t={},o=Object.create(t);return o[t[0]=\"EXPERIMENTAL\"]=0,o[t[1]=\"STABLE\"]=1,o}(),a.FunctionProto=function(){function t(o){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],o)for(var e=Object.keys(o),r=0;r<e.length;++r)o[e[r]]!=null&&(this[e[r]]=o[e[r]])}return t.prototype.name=\"\",t.prototype.input=y.emptyArray,t.prototype.output=y.emptyArray,t.prototype.attribute=y.emptyArray,t.prototype.attributeProto=y.emptyArray,t.prototype.node=y.emptyArray,t.prototype.docString=\"\",t.prototype.opsetImport=y.emptyArray,t.prototype.domain=\"\",t.create=function(e){return new t(e)},t.encode=function(e,r){if(r||(r=Ee.create()),e.name!=null&&Object.hasOwnProperty.call(e,\"name\")&&r.uint32(10).string(e.name),e.input!=null&&e.input.length)for(var n=0;n<e.input.length;++n)r.uint32(34).string(e.input[n]);if(e.output!=null&&e.output.length)for(var n=0;n<e.output.length;++n)r.uint32(42).string(e.output[n]);if(e.attribute!=null&&e.attribute.length)for(var n=0;n<e.attribute.length;++n)r.uint32(50).string(e.attribute[n]);if(e.node!=null&&e.node.length)for(var n=0;n<e.node.length;++n)m.onnx.NodeProto.encode(e.node[n],r.uint32(58).fork()).ldelim();if(e.docString!=null&&Object.hasOwnProperty.call(e,\"docString\")&&r.uint32(66).string(e.docString),e.opsetImport!=null&&e.opsetImport.length)for(var n=0;n<e.opsetImport.length;++n)m.onnx.OperatorSetIdProto.encode(e.opsetImport[n],r.uint32(74).fork()).ldelim();if(e.domain!=null&&Object.hasOwnProperty.call(e,\"domain\")&&r.uint32(82).string(e.domain),e.attributeProto!=null&&e.attributeProto.length)for(var n=0;n<e.attributeProto.length;++n)m.onnx.AttributeProto.encode(e.attributeProto[n],r.uint32(90).fork()).ldelim();return r},t.encodeDelimited=function(e,r){return this.encode(e,r).ldelim()},t.decode=function(e,r){e instanceof N||(e=N.create(e));for(var n=r===void 0?e.len:e.pos+r,s=new m.onnx.FunctionProto;e.pos<n;){var i=e.uint32();switch(i>>>3){case 1:{s.name=e.string();break}case 4:{s.input&&s.input.length||(s.input=[]),s.input.push(e.string());break}case 5:{s.output&&s.output.length||(s.output=[]),s.output.push(e.string());break}case 6:{s.attribute&&s.attribute.length||(s.attribute=[]),s.attribute.push(e.string());break}case 11:{s.attributeProto&&s.attributeProto.length||(s.attributeProto=[]),s.attributeProto.push(m.onnx.AttributeProto.decode(e,e.uint32()));break}case 7:{s.node&&s.node.length||(s.node=[]),s.node.push(m.onnx.NodeProto.decode(e,e.uint32()));break}case 8:{s.docString=e.string();break}case 9:{s.opsetImport&&s.opsetImport.length||(s.opsetImport=[]),s.opsetImport.push(m.onnx.OperatorSetIdProto.decode(e,e.uint32()));break}case 10:{s.domain=e.string();break}default:e.skipType(i&7);break}}return s},t.decodeDelimited=function(e){return e instanceof N||(e=new N(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!=\"object\"||e===null)return\"object expected\";if(e.name!=null&&e.hasOwnProperty(\"name\")&&!y.isString(e.name))return\"name: string expected\";if(e.input!=null&&e.hasOwnProperty(\"input\")){if(!Array.isArray(e.input))return\"input: array expected\";for(var r=0;r<e.input.length;++r)if(!y.isString(e.input[r]))return\"input: string[] expected\"}if(e.output!=null&&e.hasOwnProperty(\"output\")){if(!Array.isArray(e.output))return\"output: array expected\";for(var r=0;r<e.output.length;++r)if(!y.isString(e.output[r]))return\"output: string[] expected\"}if(e.attribute!=null&&e.hasOwnProperty(\"attribute\")){if(!Array.isArray(e.attribute))return\"attribute: array expected\";for(var r=0;r<e.attribute.length;++r)if(!y.isString(e.attribute[r]))return\"attribute: string[] expected\"}if(e.attributeProto!=null&&e.hasOwnProperty(\"attributeProto\")){if(!Array.isArray(e.attributeProto))return\"attributeProto: array expected\";for(var r=0;r<e.attributeProto.length;++r){var n=m.onnx.AttributeProto.verify(e.attributeProto[r]);if(n)return\"attributeProto.\"+n}}if(e.node!=null&&e.hasOwnProperty(\"node\")){if(!Array.isArray(e.node))return\"node: array expected\";for(var r=0;r<e.node.length;++r){var n=m.onnx.NodeProto.verify(e.node[r]);if(n)return\"node.\"+n}}if(e.docString!=null&&e.hasOwnProperty(\"docString\")&&!y.isString(e.docString))return\"docString: string expected\";if(e.opsetImport!=null&&e.hasOwnProperty(\"opsetImport\")){if(!Array.isArray(e.opsetImport))return\"opsetImport: array expected\";for(var r=0;r<e.opsetImport.length;++r){var n=m.onnx.OperatorSetIdProto.verify(e.opsetImport[r]);if(n)return\"opsetImport.\"+n}}return e.domain!=null&&e.hasOwnProperty(\"domain\")&&!y.isString(e.domain)?\"domain: string expected\":null},t.fromObject=function(e){if(e instanceof m.onnx.FunctionProto)return e;var r=new m.onnx.FunctionProto;if(e.name!=null&&(r.name=String(e.name)),e.input){if(!Array.isArray(e.input))throw TypeError(\".onnx.FunctionProto.input: array expected\");r.input=[];for(var n=0;n<e.input.length;++n)r.input[n]=String(e.input[n])}if(e.output){if(!Array.isArray(e.output))throw TypeError(\".onnx.FunctionProto.output: array expected\");r.output=[];for(var n=0;n<e.output.length;++n)r.output[n]=String(e.output[n])}if(e.attribute){if(!Array.isArray(e.attribute))throw TypeError(\".onnx.FunctionProto.attribute: array expected\");r.attribute=[];for(var n=0;n<e.attribute.length;++n)r.attribute[n]=String(e.attribute[n])}if(e.attributeProto){if(!Array.isArray(e.attributeProto))throw TypeError(\".onnx.FunctionProto.attributeProto: array expected\");r.attributeProto=[];for(var n=0;n<e.attributeProto.length;++n){if(typeof e.attributeProto[n]!=\"object\")throw TypeError(\".onnx.FunctionProto.attributeProto: object expected\");r.attributeProto[n]=m.onnx.AttributeProto.fromObject(e.attributeProto[n])}}if(e.node){if(!Array.isArray(e.node))throw TypeError(\".onnx.FunctionProto.node: array expected\");r.node=[];for(var n=0;n<e.node.length;++n){if(typeof e.node[n]!=\"object\")throw TypeError(\".onnx.FunctionProto.node: object expected\");r.node[n]=m.onnx.NodeProto.fromObject(e.node[n])}}if(e.docString!=null&&(r.docString=String(e.docString)),e.opsetImport){if(!Array.isArray(e.opsetImport))throw TypeError(\".onnx.FunctionProto.opsetImport: array expected\");r.opsetImport=[];for(var n=0;n<e.opsetImport.length;++n){if(typeof e.opsetImport[n]!=\"object\")throw TypeError(\".onnx.FunctionProto.opsetImport: object expected\");r.opsetImport[n]=m.onnx.OperatorSetIdProto.fromObject(e.opsetImport[n])}}return e.domain!=null&&(r.domain=String(e.domain)),r},t.toObject=function(e,r){r||(r={});var n={};if((r.arrays||r.defaults)&&(n.input=[],n.output=[],n.attribute=[],n.node=[],n.opsetImport=[],n.attributeProto=[]),r.defaults&&(n.name=\"\",n.docString=\"\",n.domain=\"\"),e.name!=null&&e.hasOwnProperty(\"name\")&&(n.name=e.name),e.input&&e.input.length){n.input=[];for(var s=0;s<e.input.length;++s)n.input[s]=e.input[s]}if(e.output&&e.output.length){n.output=[];for(var s=0;s<e.output.length;++s)n.output[s]=e.output[s]}if(e.attribute&&e.attribute.length){n.attribute=[];for(var s=0;s<e.attribute.length;++s)n.attribute[s]=e.attribute[s]}if(e.node&&e.node.length){n.node=[];for(var s=0;s<e.node.length;++s)n.node[s]=m.onnx.NodeProto.toObject(e.node[s],r)}if(e.docString!=null&&e.hasOwnProperty(\"docString\")&&(n.docString=e.docString),e.opsetImport&&e.opsetImport.length){n.opsetImport=[];for(var s=0;s<e.opsetImport.length;++s)n.opsetImport[s]=m.onnx.OperatorSetIdProto.toObject(e.opsetImport[s],r)}if(e.domain!=null&&e.hasOwnProperty(\"domain\")&&(n.domain=e.domain),e.attributeProto&&e.attributeProto.length){n.attributeProto=[];for(var s=0;s<e.attributeProto.length;++s)n.attributeProto[s]=m.onnx.AttributeProto.toObject(e.attributeProto[s],r)}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,ge.util.toJSONOptions)},t.getTypeUrl=function(e){return e===void 0&&(e=\"type.googleapis.com\"),e+\"/onnx.FunctionProto\"},t}(),a}();$u.exports=m});function kr(a,t){if(!a)throw new Error(typeof t==\"string\"?t:t())}function ln(a){return new TextDecoder().decode(a)}var ye,pr,hi,Ke,Xn,Ve,nt,U,un,dr,hr,mr,fe=E(()=>{\"use strict\";Wn();ei();ye=Er($r());br();pr=class{static arraysEqual(t,o){if(t.length!==o.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==o[e])return!1;return!0}},hi=class{static preprocessInputShapes(t,o){let e=t.length===1?[1,t[0]]:t,r=o.length===1?[o[0],1]:o;return[e,r]}static postprocessOutputShape(t,o,e){o===1&&t.splice(t.length-2,1),e===1&&t.pop()}static calcMatMulShape(t,o){return t[1]!==o[0]?void 0:[t[0],o[1]]}},Ke=class a{static calcShape(t,o,e=!1){let r=t.length,n=o.length;if(r===0)return o;if(n===0)return t;let s=Math.max(t.length,o.length),i=new Array(s);if(e){if(r<2||n<2)return;let u=hi.calcMatMulShape([t[r-2],t[r-1]],[o[n-2],o[n-1]]);if(u===void 0)return;[i[s-2],i[s-1]]=u}for(let u=e?3:1;u<=s;u++){let l=r-u<0?1:t[r-u],f=n-u<0?1:o[n-u];if(l!==f&&l>1&&f>1)return;i[s-u]=Math.max(l,f)}return i}static index(t,o){let e=new Array(o.length);return a.fillIndex(t,o,e),e}static fillIndex(t,o,e){let r=t.length-o.length;for(let n=0;n<o.length;n++)e[n]=t[r+n]%o[n]}static calc(t,o,e,r,n){let s=a.calcShape(t.dims,o.dims);if(s){if(r&&!U.areEqual(s,t.dims))return;let i=U.size(s),u=r?t:new Ce(s,n||t.type);if(s.length===0)u.set([],e(t.get([]),o.get([])));else{let l=new Array(s.length),f=new Array(t.dims.length),p=new Array(o.dims.length),d=0,T=0,v=!1,w=!1;t.dims.length===0&&(d=t.get([]),v=!0),o.dims.length===0&&(T=o.get([]),w=!0);let I;for(let L=0;L<i;L++){I=L;for(let F=s.length-1;F>=0;F--)l[F]=I%s[F],I=Math.floor(I/s[F]);v||(a.fillIndex(l,t.dims,f),d=t.get(f)),w||(a.fillIndex(l,o.dims,p),T=o.get(p)),u.set(l,e(d,T))}}return u}}static isValidBroadcast(t,o){let e=t.length,r=o.length;if(e>r)return!1;for(let n=1;n<=e;n++)if(t[e-n]!==1&&t[e-n]!==o[r-n])return!1;return!0}static getBroadcastDims(t,o){let e=t.length,r=[];for(let n=0;n<e;n++){let s=e-1-n,i=t[s]||1;(o[o.length-1-n]||1)>1&&i===1&&r.unshift(s)}return r}},Xn=class{static getShapeOfGemmResult(t,o,e,r,n){if(t.length!==2||e.length!==2)throw new Error(\"shape need to be of size 2\");let s,i,u;o?(s=t[1],i=t[0]):(s=t[0],i=t[1]);let l=-1;if(r?(u=e[0],l=1):(u=e[1],l=0),e[l]!==i)throw new Error(\"dimension mismatch\");if(s<=0||u<=0||i<=0)throw new Error(\"invalid shape specified\");if(n&&!Ke.isValidBroadcast(n,[s,u]))throw new Error(\"gemm: invalid bias shape for broadcast\");return[s,u,i]}},Ve=class a{static tensorDataTypeFromProto(t){switch(t){case ye.onnx.TensorProto.DataType.INT8:return\"int8\";case ye.onnx.TensorProto.DataType.UINT8:return\"uint8\";case ye.onnx.TensorProto.DataType.BOOL:return\"bool\";case ye.onnx.TensorProto.DataType.INT16:return\"int16\";case ye.onnx.TensorProto.DataType.UINT16:return\"uint16\";case ye.onnx.TensorProto.DataType.INT32:return\"int32\";case ye.onnx.TensorProto.DataType.UINT32:return\"uint32\";case ye.onnx.TensorProto.DataType.FLOAT:return\"float32\";case ye.onnx.TensorProto.DataType.DOUBLE:return\"float64\";case ye.onnx.TensorProto.DataType.STRING:return\"string\";case ye.onnx.TensorProto.DataType.INT64:return\"int32\";case ye.onnx.TensorProto.DataType.UINT64:return\"uint32\";default:throw new Error(`unsupported data type: ${ye.onnx.TensorProto.DataType[t]}`)}}static tensorDataTypeStringToEnum(t){switch(t){case\"int8\":return ye.onnx.TensorProto.DataType.INT8;case\"uint8\":return ye.onnx.TensorProto.DataType.UINT8;case\"bool\":return ye.onnx.TensorProto.DataType.BOOL;case\"int16\":return ye.onnx.TensorProto.DataType.INT16;case\"uint16\":return ye.onnx.TensorProto.DataType.UINT16;case\"int32\":return ye.onnx.TensorProto.DataType.INT32;case\"uint32\":return ye.onnx.TensorProto.DataType.UINT32;case\"float32\":return ye.onnx.TensorProto.DataType.FLOAT;case\"float64\":return ye.onnx.TensorProto.DataType.DOUBLE;case\"string\":return ye.onnx.TensorProto.DataType.STRING;case\"int64\":return ye.onnx.TensorProto.DataType.INT64;case\"uint64\":return ye.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${t}`)}}static tensorDimsFromProto(t){return t.map(o=>Wt.isLong(o)?o.toNumber():o)}static tensorValueTypeFromProto(t){return{tensorType:a.tensorDataTypeFromProto(t.elemType),shape:{dims:a.tensorDimsFromProto(t.shape.dim.map(o=>o.dimValue))}}}static tensorDimsFromORTFormat(t){let o=[];for(let e=0;e<t.dimsLength();e++)o.push(nt.longToNumber(t.dims(e)));return o}static tensorAttributesFromORTFormat(t){let o=[];for(let e=0;e<t.attributesLength();e++)o.push(t.attributes(e));return o}},nt=class{static longToNumber(t,o){return Wt.isLong(t)?t.toNumber():t instanceof O.Long?Wt.fromValue({low:t.low,high:t.high,unsigned:o??!1}).toNumber():t}static isLong(t){return Wt.isLong(t)||t instanceof O.Long}},U=class a{static size(t){return a.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,o){if(o<0||o>t.length)throw new Error(`invalid dimension of ${o} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return a.getSizeFromDimensionRange(t,o,t.length)}static sizeToDimension(t,o){if(o<0||o>t.length)throw new Error(`invalid dimension of ${o} for sizeToDimension as Tensor has ${t.length} dimensions.`);return a.getSizeFromDimensionRange(t,0,o)}static getSizeFromDimensionRange(t,o,e){let r=1;for(let n=o;n<e;n++){if(t[n]<=0)throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.\");r*=t[n]}return r}static computeStrides(t){let o=t.length;if(o===0)return[];if(o===1)return[1];let e=new Array(o);e[o-1]=1,e[o-2]=t[o-1];for(let r=o-3;r>=0;--r)e[r]=e[r+1]*t[r+1];return e}static transpose(t){return t.slice().reverse()}static indicesToOffset(t,o,e){e===void 0&&(e=t.length);let r=0;for(let n=0;n<e;++n)r+=o[n]*t[n];return r}static offsetToIndices(t,o){let e=o.length;if(e===0)return[];if(e===1)return[t*o[0]];let r=new Array(o.length);for(let n=0;n<r.length-1;++n)r[n]=Math.floor(t/o[n]),t-=r[n]*o[n];return r[r.length-1]=t,r}static normalizeAxis(t,o){if(t<-o&&t>=o)throw new Error(\"unsupported axis for this operation.\");return t<0?t+o:t}static normalizeAxes(t,o){return t.map(e=>this.normalizeAxis(e,o))}static incrementIndex(t,o,e){if(o.length===0||t.length===0)throw new Error(\"Index incrementing unsupported for scalar Tensor\");if(e===void 0)e=o.length;else if(e<=0||e>o.length)throw new Error(\"Incorrect axis to increment on\");for(let r=e-1;r>=0&&(t[r]++,!(t[r]<o[r]));--r)t[r]=0}static calculateReshapedDims(t,o){if(o.length===0){if(t.length===0||a.size(t)===1)return[];throw new Error(\"cannot reshape to a scalar Tensor\")}let e=o.length,r=new Array(e),n=-1,s=1;for(let u=0;u<e;u++){if(o[u]<-1)throw new Error(\"a dimension in shape hints cannot be less than -1\");if(o[u]===-1){if(n!==-1)throw new Error(\"at most one dimension in shape hints can be -1\");n=u}else{if(o[u]===0){if(u>=t.length)throw new Error(\"the dimension with value zero exceeds the dimension size of the input tensor\");r[u]=t[u]}else r[u]=o[u];s*=r[u]}}let i=a.size(t);if(n!==-1){if(i%s!==0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${t}] Output shape: [${o}]`);r[n]=i/s}else if(s!==i)throw new Error(\"reshapedDims and originalDims don't have matching sizes\");return r}static sortBasedOnPerm(t,o){return o?o.map(e=>t[e]):t.slice().reverse()}static padShape(t,o){let e=t.length;return t.map((r,n)=>r+o[n]+o[n+e])}static areEqual(t,o){return t.length!==o.length?!1:t.every((e,r)=>e===o[r])}static validateDimsAndCalcSize(t){if(t.length>6)throw new TypeError(\"Only rank 0 to 6 is supported for tensor shape.\");let o=1;for(let e of t){if(!Number.isInteger(e))throw new TypeError(`Invalid shape: ${e} is not an integer`);if(e<0||e>2147483647)throw new TypeError(`Invalid shape: length ${e} is not allowed`);o*=e}return o}static flattenShape(t,o){o<0&&(o+=t.length);let e=t.reduce((s,i)=>s*i,1),r=t.slice(o).reduce((s,i)=>s*i,1);return[e/r,r]}static squeezeShape(t,o){let e=new Array;o=a.normalizeAxes(o,t.length);for(let r=0;r<t.length;r++){let n=o.indexOf(r)>=0;if(n&&t[r]!==1)throw new Error(\"squeeze an axis of size different than 1\");(o.length===0&&t[r]>1||o.length>0&&!n)&&e.push(t[r])}return e}static unsqueezeShape(t,o){let e=new Array(t.length+o.length);e.fill(0);for(let n=0;n<o.length;n++){let s=a.normalizeAxis(o[n],e.length);if(s>=e.length)throw new Error(\"'axes' has an out of range axis\");if(e[s]!==0)throw new Error(\"'axes' has a duplicate axis\");e[s]=1}let r=0;for(let n=0;n<e.length;n++)e[n]===0&&(e[n]=t[r++]);if(r!==t.length)throw new Error(\"the unsqueezed dimension could not be established\");return e}},un=class a{static splitShape(t,o,e,r){if(e.length===0){if(!r)throw new Error(\"need to know number of outputs when the 'split' attribute is not specified\");a.determineSplit(t[o],r,e)}let n=[],s=[0];for(let i=0;i<e.length;++i){i!==0&&s.push(s[i-1]+e[i-1]);let u=t.slice();u[o]=e[i],n.push(u)}return[n,s]}static determineSplit(t,o,e){if(t%o!==0)throw new Error(\"cannot split tensor to equal sized parts\");for(let r=0;r<o;++r)e.push(t/o)}},dr=class a{static adjustPoolAttributes(t,o,e,r,n,s){if(!t&&e.length!==o.length-2)throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");if(t)for(let i=0;i<o.length-2;i++)i>=e.length?e.push(o[i+2]):e[i]=o[i+2];for(let i=0;i<e.length;i++)if(i<r.length){if(r[i]<0)throw new Error(\"strides should be greater than or equal to 1\")}else r.push(1);for(let i=0;i<e.length;i++)if(i<n.length){if(n[i]<0)throw new Error(\"dilations should be greater than or equal to 1\")}else n.push(1);for(let i=0;i<e.length*2;i++)if(i<s.length){if(s[i]<0)throw new Error(\"pad should be greater than or equal to 1\")}else s.push(0);for(let i=0;i<e.length;i++){if(e[i]<=0)throw new Error(\"kernel shapes need to be greater than 0\");if(s[i]>=e[i]||s[i+e.length]>=e[i])throw new Error(\"pads should be smaller than kernel\")}}static adjustPadsBasedOnAutoPad(t,o,e,r,n,s){if(s){if(n.length!==2*(t.length-2))throw new Error(\"length of pads should be twice the length of data dimensions\");if(o.length!==t.length-2)throw new Error(\"length of strides should be the length of data dimensions\");if(r.length!==t.length-2)throw new Error(\"length of kernel shapes should be the length of data dimensions\");for(let i=0;i<t.length-2;i++)a.adjustPadAndReturnShape(t[i+2],o[i],e[i],r[i],n,i,i+t.length-2,s)}}static computePoolOutputShape(t,o,e,r,n,s,i){if(o.length<=0)throw new Error(\"input shape must be of size greater than 0\");let u=[o[0],o[1]];return a.computeShapeHelper(t,o,u,e,r,n,s,i),u}static computeConvOutputShape(t,o,e,r,n,s,i){if(t.length<=0||o.length<=0)throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");let u=[t[0],o[0]];return a.computeShapeHelper(!1,t,u,e,r,n,s,i),u}static computeShapeHelper(t,o,e,r,n,s,i,u){if(t)for(let l=0;l<o.length-2;l++)e.push(1);else for(let l=0;l<o.length-2;l++)e.push(a.adjustPadAndReturnShape(o[l+2],r[l],n[l],s[l],i,l,l+o.length-2,u))}static adjustPadAndReturnShape(t,o,e,r,n,s,i,u){let l=e*(r-1)+1;if(u&&u!==\"NOTSET\")switch(u){case\"VALID\":return n[s]=0,n[i]=0,Math.floor((t-l)/o+1);case\"SAME_LOWER\":case\"SAME_UPPER\":if(e!==1)throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");{let p=((t+o-1)/o-1)*o+r-t;return n[s]=Math.floor(u===\"SAME_LOWER\"?(p+1)/2:p/2),n[i]=p-n[s],Math.floor((t+p-r)/o+1)}default:throw new Error(\"Unsupported AutoPad type\")}else return Math.floor((t+n[s]+n[i]-l)/o+1)}},hr=-34028234663852886e22,mr=34028234663852886e22});function jd(a){switch(a){case\"bool\":case\"int8\":case\"uint8\":return 1;case\"int16\":case\"uint16\":return 2;case\"int32\":case\"uint32\":case\"float32\":return 4;case\"float64\":return 8;default:throw new Error(`cannot calculate sizeof() on type ${a}`)}}function ku(a){switch(a){case re.onnx.TensorProto.DataType.UINT8:case re.onnx.TensorProto.DataType.INT8:case re.onnx.TensorProto.DataType.BOOL:return 1;case re.onnx.TensorProto.DataType.UINT16:case re.onnx.TensorProto.DataType.INT16:return 2;case re.onnx.TensorProto.DataType.FLOAT:case re.onnx.TensorProto.DataType.INT32:case re.onnx.TensorProto.DataType.UINT32:return 4;case re.onnx.TensorProto.DataType.INT64:case re.onnx.TensorProto.DataType.DOUBLE:case re.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${re.onnx.TensorProto.DataType[a]}`)}}function Yd(a,t){return new(Ru(t))(a)}function Ru(a){switch(a){case\"bool\":case\"uint8\":return Uint8Array;case\"int8\":return Int8Array;case\"int16\":return Int16Array;case\"uint16\":return Uint16Array;case\"int32\":return Int32Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"float32\":return Float32Array;case\"float64\":return Float64Array;default:throw new Error(\"unspecified error\")}}function bi(a,t){if(t===re.onnx.TensorProto.DataType.INT64||t===mi.TensorDataType.INT64){if(a.greaterThanOrEqual(2147483648)||a.lessThan(-2147483648))throw new TypeError(\"int64 is not supported\")}else if(t===re.onnx.TensorProto.DataType.UINT32||t===mi.TensorDataType.UINT32||t===re.onnx.TensorProto.DataType.UINT64||t===mi.TensorDataType.UINT64){if(a.greaterThanOrEqual(4294967296)||a.lessThan(0))throw new TypeError(\"uint64 is not supported\")}else throw new TypeError(`not a LONG type: ${re.onnx.TensorProto.DataType[t]}`);return a.toNumber()}function Bu(a,t,o){switch(t){case re.onnx.TensorProto.DataType.BOOL:case re.onnx.TensorProto.DataType.UINT8:return a.getUint8(o);case re.onnx.TensorProto.DataType.INT8:return a.getInt8(o);case re.onnx.TensorProto.DataType.UINT16:return a.getUint16(o,!0);case re.onnx.TensorProto.DataType.INT16:return a.getInt16(o,!0);case re.onnx.TensorProto.DataType.FLOAT:return a.getFloat32(o,!0);case re.onnx.TensorProto.DataType.INT32:return a.getInt32(o,!0);case re.onnx.TensorProto.DataType.UINT32:return a.getUint32(o,!0);case re.onnx.TensorProto.DataType.INT64:return bi(Wt.fromBits(a.getUint32(o,!0),a.getUint32(o+4,!0),!1),t);case re.onnx.TensorProto.DataType.DOUBLE:return a.getFloat64(o,!0);case re.onnx.TensorProto.DataType.UINT64:return bi(Wt.fromBits(a.getUint32(o,!0),a.getUint32(o+4,!0),!0),t);default:throw new Error(`cannot read from DataView for type ${re.onnx.TensorProto.DataType[t]}`)}}var Nu,re,mi,Ce,br=E(()=>{\"use strict\";Nu=Er(Ss());ei();nn();re=Er($r());fe();mi=W.experimental.fbs,Ce=class a{constructor(t,o,e,r,n,s=Nu.Guid.create()){this.dims=t;this.type=o;this.dataProvider=e;this.asyncDataProvider=r;this.cache=n;this.dataId=s;this.size=U.validateDimsAndCalcSize(t);let i=this.size,u=e===void 0&&r===void 0&&n===void 0;if(n!==void 0&&n.length!==i)throw new RangeError(\"Input dims doesn't match data length.\");if(o===\"string\"){if(n!==void 0&&(!Array.isArray(n)||!n.every(l=>typeof l==\"string\")))throw new TypeError(\"cache should be a string array\");u&&(this.cache=new Array(i))}else{if(n!==void 0){let l=Ru(o);if(!(n instanceof l))throw new TypeError(`cache should be type ${l.name}`)}if(u){let l=new ArrayBuffer(i*jd(o));this.cache=Yd(l,o)}}}get data(){if(this.cache===void 0){let t=this.dataProvider(this.dataId);if(t.length!==this.size)throw new Error(\"Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.\");this.cache=t}return this.cache}get stringData(){if(this.type!==\"string\")throw new TypeError(\"data type is not string\");return this.data}get integerData(){switch(this.type){case\"uint8\":case\"int8\":case\"uint16\":case\"int16\":case\"int32\":case\"uint32\":case\"bool\":return this.data;default:throw new TypeError(\"data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)\")}}get floatData(){switch(this.type){case\"float32\":case\"float64\":return this.data;default:throw new TypeError(\"data type is not float (float32, float64)\")}}get numberData(){if(this.type!==\"string\")return this.data;throw new TypeError(\"type cannot be non-number (string)\")}get(t){return this.data[U.indicesToOffset(t,this.strides)]}set(t,o){this.data[U.indicesToOffset(t,this.strides)]=o}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=U.computeStrides(this.dims)),this._strides}static fromProto(t){if(!t)throw new Error(\"cannot construct Value from an empty tensor\");let o=Ve.tensorDataTypeFromProto(t.dataType),e=Ve.tensorDimsFromProto(t.dims),r=new a(e,o);if(o===\"string\")t.stringData.forEach((n,s)=>{r.data[s]=ln(n)});else if(t.rawData&&typeof t.rawData.byteLength==\"number\"&&t.rawData.byteLength>0){let n=r.data,s=new DataView(t.rawData.buffer,t.rawData.byteOffset,t.rawData.byteLength),i=ku(t.dataType),u=t.rawData.byteLength/i;if(t.rawData.byteLength%i!==0)throw new Error(\"invalid buffer length\");if(n.length!==u)throw new Error(\"buffer length mismatch\");for(let l=0;l<u;l++){let f=Bu(s,t.dataType,l*i);n[l]=f}}else{let n;switch(t.dataType){case re.onnx.TensorProto.DataType.FLOAT:n=t.floatData;break;case re.onnx.TensorProto.DataType.INT32:case re.onnx.TensorProto.DataType.INT16:case re.onnx.TensorProto.DataType.UINT16:case re.onnx.TensorProto.DataType.INT8:case re.onnx.TensorProto.DataType.UINT8:case re.onnx.TensorProto.DataType.BOOL:n=t.int32Data;break;case re.onnx.TensorProto.DataType.INT64:n=t.int64Data;break;case re.onnx.TensorProto.DataType.DOUBLE:n=t.doubleData;break;case re.onnx.TensorProto.DataType.UINT32:case re.onnx.TensorProto.DataType.UINT64:n=t.uint64Data;break;default:throw new Error(\"unspecific error\")}if(n==null)throw new Error(\"failed to populate data from a tensorproto value\");let s=r.data;if(s.length!==n.length)throw new Error(\"array length mismatch\");for(let i=0;i<n.length;i++){let u=n[i];Wt.isLong(u)?s[i]=bi(u,t.dataType):s[i]=u}}return r}static fromData(t,o,e){return new a(o,e,void 0,void 0,t)}static fromOrtTensor(t){if(!t)throw new Error(\"cannot construct Value from an empty tensor\");let o=Ve.tensorDimsFromORTFormat(t),e=Ve.tensorDataTypeFromProto(t.dataType()),r=new a(o,e);if(e===\"string\")for(let n=0;n<t.stringDataLength();n++)r.data[n]=t.stringData(n);else if(t.rawDataArray()&&typeof t.rawDataLength()==\"number\"&&t.rawDataLength()>0){let n=r.data,s=new DataView(t.rawDataArray().buffer,t.rawDataArray().byteOffset,t.rawDataLength()),i=ku(t.dataType()),u=t.rawDataLength()/i;if(t.rawDataLength()%i!==0)throw new Error(\"invalid buffer length\");if(n.length!==u)throw new Error(\"buffer length mismatch\");for(let l=0;l<u;l++){let f=Bu(s,t.dataType(),l*i);n[l]=f}}return r}}});function q(a){return a===1?Xd:Kd}function Mu(a){let t=q(a);return`${t.version}\n      precision highp float;\n      ${t.attribute} vec3 position;\n      ${t.attribute} vec2 textureCoord;\n\n      ${t.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`}function Gu(a){let t=q(a);return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFrag} vec2 TexCoords;\n    ${t.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `}function Uu(a,t){let o=q(a);return`\n  void main() {\n    int indices[${t}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${o.output} = result;\n  }\n  `}var Xd,Kd,xe=E(()=>{\"use strict\";Xd={version:\"\",attribute:\"attribute\",varyingVertex:\"varying\",varyingFrag:\"varying\",texture2D:\"texture2D\",output:\"gl_FragColor\",outputDeclaration:\"\"},Kd={version:\"#version 300 es\",attribute:\"in\",varyingVertex:\"out\",varyingFrag:\"in\",texture2D:\"texture\",output:\"outputColor\",outputDeclaration:\"out vec4 outputColor;\"}});var ae=E(()=>{\"use strict\"});async function gi(a,t=e=>0,o){return new Promise((e,r)=>{let n=0,s=()=>{if(a()){e();return}n++;let i=t(n);if(o!=null&&n>=o){r();return}setTimeout(s,i)};s()})}function Kn(a){return kr(typeof a<\"u\"&&a.length!==0,()=>\"empty string found for sampler name\"),\"get\"+a.charAt(0).toUpperCase()+a.slice(1)}function zu(a){return kr(typeof a<\"u\"&&a.length!==0,()=>\"empty string found for sampler name\"),\"get\"+a.charAt(0).toUpperCase()+a.slice(1)+\"AtOutCoords\"}function Br(a,t){let o=JSON.parse(JSON.stringify(a));return o=t,o}function Nr(a,t){return t.map(o=>a[o]).join(\", \")}function Je(a){if(a<=1)return\"int\";if(a===2)return\"ivec2\";if(a===3)return\"ivec3\";if(a===4)return\"ivec4\";if(a===5)return\"ivec5\";if(a===6)return\"ivec6\";throw Error(`GPU for rank ${a} is not yet supported`)}function Ot(a=6){return[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"].slice(0,a)}var kt=E(()=>{\"use strict\";fe()});function Jd(a,t){return Ot(t).map(o=>`${a}.${o}`)}function Rr(a,t){return t===1?[a]:Jd(a,t)}function Bt(){return`\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  `}var gr=E(()=>{\"use strict\";kt()});function Qd(a,t,o){if(a===0)return\"false\";if(a===1)return`rc > ${t[0]}`;let e=\"\";for(let r=a-2;r<a;r++)e+=`${o[r]} >= ${t[r-a+2]}`,r<a-1&&(e+=\"||\");return e}function eh(a,t){let o=a.length;if(o===0)return\"getA(), 0, 0, 0\";if(o===1)return`getA(rc),\n            rc + 1 >= ${a[0]} ? 0. : getA(rc + 1),\n            0, 0`;let e=\"r, c\",r=\"r, cp1\",n=\"rp1, c\",s=\"rp1, cp1\",i=\"\";if(o>2)for(let u=0;u<o-2;++u)i=i+`${t[u]},`;return`getA(${i}${e}),\n          rEdge ? 0. : getA(${i}${n}),\n          cEdge ? 0. : getA(${i}${r}),\n          rEdge || cEdge ? 0. : getA(${i}${s})`}function th(a,t,o,e){return a===0||a===1?\"\":`\n    int r = ${t[a-2]};\n    int c = ${t[a-1]};\n    int rp1 = ${t[a-2]} + 1;\n    int cp1 = ${t[a-1]} + 1;\n    bool rEdge = rp1 >= ${e};\n    bool cEdge = cp1 >= ${o};\n    `}var Vu,Zd,Wu,Hu=E(()=>{\"use strict\";xe();ae();kt();gr();Vu={name:\"pack\",inputNames:[\"A\"],inputTypes:[1]},Zd=(a,t)=>{let o=q(a.session.backend.glContext.version),e=t.dims,r=e.length,n=t.dims.length,s=Je(n),i=Rr(\"rc\",n),u=th(n,i,e[e.length-2],e[e.length-1]),l;r===0?l=[1,1]:r===1?l=[e[0],1]:l=[e[n-1],e[n-2]];let f=Qd(n,l,i),p=eh(e,i),d=`\n        void main() {\n          ${s} rc = getOutputCoords();\n\n          if(${f}) {\n            ${o.output} = vec4(0);\n          } else {\n            ${u}\n\n            ${o.output} = vec4(${p});\n          }\n        }\n      `;return{...Vu,hasMain:!0,output:{dims:t.dims,type:t.type,textureType:2},shaderSource:d}},Wu=(a,t)=>({...Vu,get:()=>Zd(a,t)})});function yi(a){if(a.length===0)return[1,1,1];let t=1;for(let o=0;o<a.length-2;++o)t*=a[o];return[t,a.length>1?a[a.length-2]:1,a[a.length-1]]}function ju(a,t){let o=!1;return a.length===0||t.length===0?o=!0:a.length<2||t.length<2?o=a[a.length-1]===t[t.length-1]:o=a[a.length-1]===t[t.length-1]&&a[a.length-2]===t[t.length-2],o}function oh(a){let t=U.computeStrides(a),o=[\"b\",\"r\",\"c\"],e=\"index\";return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t.map((n,s)=>{let i=`int ${o[s]} = ${e} / ${n}`,u=s===t.length-1?`int ${o[s+1]} = ${e} - ${o[s]} * ${n}`:`index -= ${o[s]} * ${n}`;return`${i}; ${u};`}).join(\"\")}\n      return ivec3(b, r, c);\n    }\n  `}function ih(a){let t=U.computeStrides(a);return`\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${t[0]} + coords.z * ${t[1]} + coords.y;\n  }\n`}var rh,nh,qu,Yu=E(()=>{\"use strict\";fe();xe();ae();gr();rh=a=>({name:\"Reshape (packed)\",inputTypes:[2],inputNames:[\"A\"],cacheHint:`${a}`}),nh=(a,t,o,e)=>{let r=t.dims,n=e,s=\"\";for(let l=0;l<4;l++){let f=\"\";switch(l){case 0:f=\"outputCoords = rc;\";break;case 1:f=\"outputCoords = ivec3(rc.x, rc.y+1, rc.z);\";break;case 2:f=\"outputCoords = ivec3(rc.x, rc.y, rc.z+1);\";break;case 3:f=\"outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);\";break;default:throw new Error}s+=`\n        ${f}\n        ${l>0?\"if(outputCoords.y < rows && outputCoords.z < cols){\":\"\"}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${l}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${l>0?\"}\":\"\"}\n      `}let i=q(a.session.backend.glContext.version),u=`\n      ${oh(r)}\n      ${ih(n)}\n      ${Bt()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${n[2]};\n        int cols = ${n[1]};\n\n        ${s}\n        ${i.output} = result;\n      }\n    `;return{...o,output:{dims:n,type:t.type,textureType:2},shaderSource:u,hasMain:!0}},qu=(a,t,o)=>{let e=rh(o);return{...e,get:()=>nh(a,t,e,o)}}});var Ti,Xu=E(()=>{\"use strict\";xe();ae();Ti=(a,t)=>{let o=t.shape,e=q(a.session.backend.glContext.version),r=`\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${e.texture2D}(X,TexCoords).r;\n      ${e.output} = encodeAsUint8(value);\n    }`,n={name:\"Uint8Encode\",inputTypes:[0],inputNames:[\"X\"],output:{dims:o,type:t.tensor.type,textureType:3},shaderSource:r,hasMain:!0};return a.executeProgram(n,[t.tensor])}});function sh(a,t){if(a===1)return\"rc\";let o=\"\";for(let e=0;e<a;e++)o+=t[e],e<a-1&&(o+=\",\");return o}var Ku,ah,Ju,Zu=E(()=>{\"use strict\";xe();ae();kt();gr();Ku={name:\"unpack\",inputNames:[\"A\"],inputTypes:[2]},ah=(a,t)=>{let o=t.dims.length,e=Rr(\"rc\",o),r=e.slice(-2),n=Je(o),s=Bt(),u=t.dims.length===0?\"\":sh(o,e),l=o<=1?\"rc\":`vec2(${r.join(\",\")})`,f=q(a.session.backend.glContext.version),p=`\n    ${s}\n    void main() {\n      ${n} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${u});\n\n       ${f.output} = vec4(getChannel(packedInput, ${l}), 0, 0, 0);\n     }\n   `;return{...Ku,hasMain:!0,output:{dims:t.dims,type:t.type,textureType:0},shaderSource:p}},Ju=(a,t)=>({...Ku,get:()=>ah(a,t)})});var Jn,fn,Zn,cn=E(()=>{\"use strict\";at();Jn=class{constructor(t,o=1){if(o===1)this.internalFormat=t.R32F,this.format=t.RED,this.textureType=t.FLOAT,this.channelSize=o;else if(o===4)this.internalFormat=t.RGBA32F,this.format=t.RGBA,this.textureType=t.FLOAT,this.channelSize=o;else throw new Error(`Invalid number of channels: ${o}`)}encode(t,o){let e,r;return t.constructor!==Float32Array&&(ce.warning(\"Encoder\",\"data was not of type Float32; creating new Float32Array\"),r=new Float32Array(t)),o*this.channelSize>t.length?(ce.warning(\"Encoder\",\"Source data too small. Allocating larger array\"),r=t,e=this.allocate(o*this.channelSize),r.forEach((n,s)=>e[s]=n)):(r=t,e=r),e}allocate(t){return new Float32Array(t*4)}decode(t,o){return this.channelSize===1?t.filter((r,n)=>n%4===0).subarray(0,o):t.subarray(0,o)}},fn=class{constructor(t,o=1,e){if(o!==1&&o!==4)throw new Error(`Invalid number of channels: ${o}`);this.internalFormat=t.RGBA,this.format=t.RGBA,this.channelSize=o,this.textureType=e||t.FLOAT}encode(t,o){let e=t;return this.channelSize===1&&(ce.verbose(\"Encoder\",\"Exploding into a larger array\"),e=this.allocate(o),t.forEach((r,n)=>e[n*4]=r)),e}allocate(t){return new Float32Array(t*4)}decode(t,o){return this.channelSize===1?t.filter((r,n)=>n%4===0).subarray(0,o):t.subarray(0,o)}},Zn=class{constructor(t,o=1){this.channelSize=4;if(o===1)this.internalFormat=t.ALPHA,this.format=t.ALPHA,this.textureType=t.UNSIGNED_BYTE,this.channelSize=o;else if(o===4)this.internalFormat=t.RGBA,this.format=t.RGBA,this.textureType=t.UNSIGNED_BYTE,this.channelSize=o;else throw new Error(`Invalid number of channels: ${o}`)}encode(t,o){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}allocate(t){return new Uint8Array(t*this.channelSize)}decode(t,o){if(t instanceof Uint8Array)return t.subarray(0,o);throw new Error(`Invalid array type: ${t.constructor}`)}}});var pn,Qu,xi,el=E(()=>{\"use strict\";fe();ae();pn=(a,t,o)=>{let e=o===0||o===1?1:4,r=o===2,n=o===1||o===2,s=o===4?t.length-1:void 0,i=o===4?t.map((u,l)=>l===t.length-1?u*4:u):void 0;return xi(a,t,e,i,{isPacked:r,reverseWH:n,breakAxis:s})},Qu=(a,t,o)=>{let e=pn(a,t,o);return[e.width,e.height]},xi=(a,t,o=1,e,r)=>{let n=!!(r&&r.isPacked),[s,i]=a.computeTextureWH(n&&e||t,r),u=t.length,l=t.slice(0);if(u===0&&(l=[1]),o===1)e=t;else if(n){if(o!==4)throw new Error(\"a packed texture must be 4-channel\");e=t,u>0&&(l[u-1]=Math.ceil(l[u-1]/2)),u>1&&(l[u-2]=Math.ceil(l[u-2]/2))}else if(!e)throw new Error(\"Unpacked shape is needed when using channels > 1\");return{width:s,height:i,channels:o,isPacked:n,shape:l,strides:U.computeStrides(l),unpackedShape:e,reversedWH:r&&r.reverseWH}}});var lh,Qn,rl=E(()=>{\"use strict\";at();br();fe();Hu();Yu();Xu();Zu();cn();el();ae();lh=(a,t)=>{let o=t.map(r=>`${r.unpackedShape.join(\",\")};${r.width}x${r.height}`).join(\"_\"),e=a.name;return a.cacheHint&&(e+=\"[\"+a.cacheHint+\"]\"),e+=\":\"+o,e},Qn=class{constructor(t){this.session=t;this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(t,o){return Qu(this.session.layoutStrategy,t,o)}executeProgram(t,o){if(o.length<t.inputNames.length)throw new Error(`Input size mustn't be less than ${t.inputNames.length}.`);if(t.inputNames.length!==t.inputTypes.length)throw new Error(\"input names size does not match input types\");let e=[];for(let l=0;l<t.inputNames.length;++l)e[l]=this.getOrCreateTextureData(o[l],t.inputTypes[l]);let r=lh(t,e),n=this.session.programManager.getArtifact(r),s=n?n.programInfo:typeof t.get==\"function\"?t.get():t,i=pn(this.session.layoutStrategy,s.output.dims,s.output.textureType),u=this.createTextureData(i,s.output.type);return n||(n=this.session.programManager.build(s,e,u),this.session.programManager.setArtifact(r,n)),this.runProgram(n,e,u),u}run(t,o){return this.executeProgram(t,o).tensor}runProgram(t,o,e){for(let r=0;r<o.length;++r)if(!!o[r].isPacked!=(t.programInfo.inputTypes[r]===2))throw new Error(`input[${r}] property packed inconsistent`);if(!!e.isPacked!=(t.programInfo.output.textureType===2))throw new Error(\"output property packed inconsistent\");this.session.programManager.run(t,o,e)}getOrCreateTextureData(t,o){let e=this.getTextureData(t.dataId,o===2);if(!e&&(e=this.getTextureData(t.dataId,o!==2),e))return o===2?this.pack(e):this.unpack(e);if(!e){let r=pn(this.session.layoutStrategy,t.dims,o);if(o===4){let i=t.dims;if(i.length===4){let u=[i[0],Math.ceil(i[1]*i[2]*i[3]/4)],l=pn(this.session.layoutStrategy,u,o),f=t.numberData;if(i[1]*i[2]*i[3]%4!==0){let p=i[0],d=i[1]*i[2]*i[3],T=Math.ceil(d*1/4)*4,v=p*T;f=new Float32Array(v);for(let w=0;w<p;++w){let I=w*d,L=w*T+w%1*d;f.set(t.numberData.subarray(I,I+d),L)}}return this.createTextureData(l,t.type,f,t,1)}}if(o===2){let n=xi(this.session.layoutStrategy,t.dims,1,[],{reverseWH:!0}),s=this.createTextureData(n,t.type,t.numberData,t,1);e=this.pack(s)}else e=this.createTextureData(r,t.type,t.numberData,t,1)}return e}createTextureDataFromLayoutBindTensor(t,o,e,r){return this.createTextureData(t,o,e,r,1)}createTextureData(t,o,e,r,n){ce.verbose(\"InferenceHandler\",`Creating TextureData: layout:[${JSON.stringify(t)}]`);let s=this.session.textureManager.createTextureFromLayout(o,t,e,n);return this.createTextureDataFromTexture(t,o,s,r)}reshapeUnpacked(t,o){let e=this.getOrCreateTextureData(t,0),r={channels:e.channels,height:e.height,width:e.width,shape:o.length!==0?o:[1],strides:U.computeStrides(o),unpackedShape:o};return this.createTextureDataFromTexture(r,t.type,e.texture).tensor}reshapePacked(t,o){let e=this.getOrCreateTextureData(t,2);if(ju(t.dims,o)){let l={channels:e.channels,height:e.height,width:e.width,shape:o.length!==0?o:[1],strides:U.computeStrides(o),unpackedShape:o,isPacked:!0};return this.createTextureDataFromTexture(l,t.type,e.texture).tensor}let r=yi(t.dims),n=yi(o),s=this.reshapePacked(t,r),i=this.run(qu(this,s,n),[s]);return this.reshapePacked(i,o)}cast(t,o){let e=this.getOrCreateTextureData(t,0);return this.createTextureDataFromTexture(e,o,e.texture).tensor}createTextureDataFromTexture(t,o,e,r,n){let s={...t,tensor:r||new Ce(t.unpackedShape,o,i=>this.readTexture(s),async i=>this.readTextureAsync(s),void 0,n),texture:e};return this.setTextureData(s.tensor.dataId,s,t.isPacked),s}getTextureData(t,o=!1){return this.session.isInitializer(t)?this.session.getTextureData(t,o):o?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,o,e=!1){this.session.isInitializer(t)?this.session.setTextureData(t,o,e):(e?this.packedTextureDataCache:this.unpackedTextureDataCache).set(t,o)}isTextureLayoutCached(t,o=!1){return!!this.getTextureData(t.dataId,o)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(t=>this.session.textureManager.releaseTexture(t)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(t=>this.session.textureManager.releaseTexture(t)),this.unpackedTextureDataCache=new Map}readTexture(t){return t.isPacked?this.readTexture(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat(Ti(this,t))}async readTextureAsync(t){return t.isPacked?this.readTextureAsync(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat(Ti(this,t))}pack(t){return this.executeProgram(Wu(this,t.tensor),[t.tensor])}unpack(t){return this.executeProgram(Ju(this,t.tensor),[t.tensor])}}});var wi,ee,Ge=E(()=>{\"use strict\";wi=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(\";\")),this.key}},ee=a=>new wi(a)});var nl,ol,il,fh,ch,al=E(()=>{\"use strict\";Ge();xe();ae();nl={name:\"BatchNormalization\",inputNames:[\"A\",\"Scale\",\"B\",\"Mean\",\"Variance\"],inputTypes:[0,0,0,0,0]},ol=(a,t,o)=>(ch(t),[a.run({...nl,cacheHint:o.cacheKey,get:()=>fh(a,t,o)},t)]),il=a=>{let t=a.attributes.getFloat(\"epsilon\",1e-5),o=a.attributes.getFloat(\"momentum\",.9),e=a.attributes.getInt(\"spatial\",1);return ee({epsilon:t,momentum:o,spatial:e})},fh=(a,t,o)=>{let e=q(a.session.backend.glContext.version),r=t[0].dims.length,[n,s]=a.calculateTextureWidthAndHeight(t[1].dims,0),i=`\n  float process(int[${r}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${n}, ${s});\n    float scale = getColorAsFloat(${e.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${e.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${e.texture2D}(Variance, position));\n    float b = getColorAsFloat(${e.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${o.epsilon})) ) + b;\n  }`;return{...nl,output:{dims:t[0].dims,type:t[0].type,textureType:0},shaderSource:i}},ch=a=>{if(!a||a.length!==5)throw new Error(\"BatchNormalization requires 5 inputs.\");let t=a[0],o=a[1],e=a[2],r=a[3],n=a[4];if(t.dims.length<3||o.dims.length!==1||e.dims.length!==1||r.dims.length!==1||n.dims.length!==1)throw new Error(\"invalid input shape.\");if(o.dims[0]!==t.dims[1]||e.dims[0]!==t.dims[1]||r.dims[0]!==t.dims[1]||n.dims[0]!==t.dims[1])throw new Error(\"invalid input shape.\");if(t.type!==\"float32\"&&t.type!==\"float64\"||o.type!==\"float32\"&&o.type!==\"float64\"||e.type!==\"float32\"&&e.type!==\"float64\"||r.type!==\"float32\"&&r.type!==\"float64\"||n.type!==\"float32\"&&n.type!==\"float64\")throw new Error(\"invalid input tensor types.\")}});var eo,ft,R,dn,to,Ht=E(()=>{\"use strict\";eo=class{constructor(t,o,e,r){this.glContext=t;this.programInfo=o;this.inputTextureLayouts=e;this.outputTextureLayout=r}},ft=class{constructor(t){this.context=t}},R=class{constructor(t,o){this.routineBody=t;this.dependencies=o}},dn=class{constructor(t,o,e){this.name=t;e?this.dependencies=e:this.dependencies=[],o&&(this.routineBody=o)}addDependency(t){t&&this.dependencies.push(t)}},to=class{static returnOrderedNodes(t){if(!t||t.length===0)return[];if(t.length===1)return t;let o=new Set,e=new Set,r=new Array;return this.createOrderedNodes(t,o,e,r),r}static createOrderedNodes(t,o,e,r){for(let n=0;n<t.length;++n)this.dfsTraverse(t[n],o,e,r)}static dfsTraverse(t,o,e,r){if(!t||e.has(t.name))return;if(o.has(t.name))throw new Error(\"Cyclic dependency detected. Can't topologically sort routines needed for shader.\");o.add(t.name);let n=t.dependencies;if(n&&n.length>0)for(let s=0;s<n.length;++s)this.dfsTraverse(n[s],o,e,r);r.push(t),e.add(t.name),o.delete(t.name)}}});function dh(){let a=\"add_\";return{body:`\n  float ${a}(float a, float b) {\n    return a + b;\n  }\n  vec4 ${a}(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  `,name:a,type:0}}function hh(){let a=\"div_\";return{body:`\n  float ${a}(float a, float b) {\n    return a / b;\n  }\n  vec4 ${a}(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  `,name:a,type:0}}function mh(){let a=\"mul_\";return{body:`\n  float ${a}(float a, float b) {\n    return a * b;\n  }\n  vec4 ${a}(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  `,name:a,type:0}}function bh(){let a=\"sub_\";return{body:`\n  float ${a}(float a, float b) {\n    return a - b;\n  }\n  vec4 ${a}(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  `,name:a,type:0}}function gh(){let a=\"equal_\";return{body:`\n  float ${a}(float a, float b) {\n    return float(a == b);\n  }\n  vec4 ${a}(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  `,name:a,type:0}}function yh(){let a=\"greater_\";return{body:`\n  float ${a}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${a}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `,name:a,type:0}}function Th(){let a=\"less_\";return{body:`\n  float ${a}(float a, float b) {\n    return float(a < b);\n  }\n  vec4 ${a}(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  `,name:a,type:0}}function xh(){let a=\"and_\";return{body:`\n  float ${a}(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 ${a}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  `,name:a,type:0}}function wh(){let a=\"or_\";return{body:`\n  float ${a}(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 ${a}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  `,name:a,type:0}}function vh(){let a=\"xor_\";return{body:`\n  float ${a}(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 ${a}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  `,name:a,type:0}}function _h(){return Ih(\"pow\")}function Oh(){let a=\"prelu_\";return{body:`\n  float ${a}(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 ${a}(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  `,name:a,type:0}}function Ih(a){let t=`${a}_`;return{body:`\n  float ${t}(float a, float b) {\n    return ${a}(a, b);\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return ${a}(v1, v2);\n  }\n  `,name:t,type:0}}var ct,Sh,sl,ul,ll,fl,cl,pl,dl,hl,ml,bl,gl,yl,Tl=E(()=>{\"use strict\";fe();Ht();xe();ae();ct=(a,t,o,e=t[0].type,r)=>{let n=a.session.pack?2:0;return{name:o.name,inputNames:[\"A\",\"B\"],inputTypes:[n,n],cacheHint:r,get:()=>Sh(a,t,o,e)}},Sh=(a,t,o,e=t[0].type)=>{let r=a.session.pack?2:0,n=!U.areEqual(t[0].dims,t[1].dims),s=t[0].dims,i=a.session.pack;if(n){let f=Ke.calcShape(t[0].dims,t[1].dims,!1);if(!f)throw new Error(\"Can't perform binary op on the given tensors\");s=f;let p=s.length,d=t[0].dims.length!==0?t[0].dims.length:1,T=t[1].dims.length!==0?t[1].dims.length:1,v=t[0].dims.length!==0?\"bcastIndices_A(indices, aindices);\":\"aindices[0] = 0;\",w=t[1].dims.length!==0?\"bcastIndices_B(indices, bindices);\":\"bindices[0] = 0;\",I=q(a.session.backend.glContext.version),L=i?`\n      ${o.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${o.name}(a, b);\n        ${I.output} = result;\n      }`:`\n      ${o.body}\n      float process(int indices[${p}]) {\n        int aindices[${d}];\n        int bindices[${T}];\n        ${v}\n        ${w}\n        return ${o.name}(_A(aindices), _B(bindices));\n      }`;return{name:o.name,inputNames:[\"A\",\"B\"],inputTypes:[r,r],output:{dims:s,type:e,textureType:r},shaderSource:L,hasMain:i}}let u=q(a.session.backend.glContext.version),l=`\n    ${o.body}\n    void main() {\n      vec4 v1 = ${u.texture2D}(A, TexCoords);\n      vec4 v2 = ${u.texture2D}(B, TexCoords);\n      vec4 result = ${o.name}(v1, v2);\n      ${u.output} = result;\n    }\n    `;return{name:o.name,inputNames:[\"A\",\"B\"],inputTypes:[r,r],output:{dims:t[0].dims,type:e,textureType:r},shaderSource:l,hasMain:!0}},sl=(a,t)=>[a.run(ct(a,t,dh()),t)],ul=(a,t)=>[a.run(ct(a,t,xh(),\"bool\"),t)],ll=(a,t)=>[a.run(ct(a,t,hh()),t)],fl=(a,t)=>[a.run(ct(a,t,gh(),\"bool\"),t)],cl=(a,t)=>[a.run(ct(a,t,yh(),\"bool\"),t)],pl=(a,t)=>[a.run(ct(a,t,Th(),\"bool\"),t)],dl=(a,t)=>[a.run(ct(a,t,mh()),t)],hl=(a,t)=>[a.run(ct(a,t,wh(),\"bool\"),t)],ml=(a,t)=>[a.run(ct(a,t,_h()),t)],bl=(a,t)=>[a.run(ct(a,t,Oh()),t)],gl=(a,t)=>[a.run(ct(a,t,bh()),t)],yl=(a,t)=>[a.run(ct(a,t,vh(),\"bool\"),t)]});var xl,wl,Ph,vl=E(()=>{\"use strict\";fe();xl=(a,t,o)=>(Ph(t),[a.cast(t[0],o)]),wl=a=>Ve.tensorDataTypeFromProto(a.attributes.getInt(\"to\")),Ph=a=>{if(!a||a.length!==1)throw new Error(\"Cast requires 1 input.\");if(a[0].type===\"string\")throw new Error(\"Invalid input type.\")}});var Eh,Dh,_l,ro,Ol=E(()=>{\"use strict\";xe();ae();kt();gr();Eh=(a,t)=>({name:\"Concat (packed)\",inputNames:Array.from({length:a},(o,e)=>`X${e}`),inputTypes:Array(a).fill(2),cacheHint:t}),Dh=(a,t,o,e)=>{let r=o[0].dims.slice();if(e>=r.length||e<-1*r.length)throw new Error(\"axis specified for concat doesn't match input dimensionality\");e<0&&(e=r.length+e);let n=r.slice(0);for(let j=1;j<o.length;j++){let M=o[j].dims.slice();for(let ie=0;ie<r.length;ie++)if(ie===e)n[e]+=M[ie];else if(r[ie]!==M[ie])throw new Error(\"non concat dimensions must match\")}let s=n.length,i=Rr(\"coords\",s),u=Je(s),l=Bt(),f=o.map(j=>j.dims),p=Ot(s),d=new Array(f.length-1);d[0]=f[0][e];for(let j=1;j<d.length;j++)d[j]=d[j-1]+f[j][e];let T=p[e],v=p.slice(-2),w=p.join(),I=`if (${T} < ${d[0]}) {\n        return getChannel(\n            getX0(${w}), vec2(${v.join()}));\n        }`;for(let j=1;j<d.length;j++){let M=d[j-1];I+=`\n            if (${T} < ${d[j]}  && ${T} >= ${d[j-1]}) {\n              return getChannel(\n                getX${j}(${ro(p,T,M)}),\n                vec2(${ro(v,T,M)}));\n            }`}let L=d.length,F=d[d.length-1];I+=`\n            return getChannel(\n              getX${L}(${ro(p,T,F)}),\n              vec2(${ro(v,T,F)}));`;let C=q(a.session.backend.glContext.version),Y=`\n          ${l}\n          float getValue(${p.map(j=>\"int \"+j)}) {\n            ${I}\n          }\n\n          void main() {\n            ${u} coords = getOutputCoords();\n            int lastDim = coords.${p[s-1]};\n            coords.${p[s-1]} = coords.${p[s-2]};\n            coords.${p[s-2]} = lastDim;\n\n            vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n            ${i[s-1]} = ${i[s-1]} + 1;\n            if (${i[s-1]} < ${n[s-1]}) {\n              result.g = getValue(${i});\n            }\n\n            ${i[s-2]} = ${i[s-2]} + 1;\n            if (${i[s-2]} < ${n[s-2]}) {\n              result.a = getValue(${i});\n            }\n\n            ${i[s-1]} = ${i[s-1]} - 1;\n            if (${i[s-2]} < ${n[s-2]} &&\n                ${i[s-1]} < ${n[s-1]}) {\n              result.b = getValue(${i});\n            }\n            ${C.output} = result;\n          }\n        `;return{...t,output:{dims:n,type:o[0].type,textureType:2},shaderSource:Y,hasMain:!0}},_l=(a,t,o)=>{let e=Eh(t.length,o.cacheKey);return{...e,get:()=>Dh(a,e,t,o.axis)}},ro=(a,t,o)=>{let e=a.indexOf(t);return a.map((n,s)=>s===e?`${n} - ${o}`:n).join()}});var Il,Lh,Fh,Ch,Sl,$h,kh,Bh,Al,Nh,Pl=E(()=>{\"use strict\";Ge();ae();Ol();Il=(a,t,o)=>(Nh(t),a.session.pack&&t[0].dims.length>1?[a.run(_l(a,t,o),t)]:[a.run(Ch(a,t,o),t)]),Lh=(a,t)=>({name:\"Concat\",inputNames:Array.from({length:a},(o,e)=>`X${e}`),inputTypes:Array(a).fill(0),cacheHint:t}),Fh=(a,t,o,e)=>{let r=o[0].dims.slice();if(e>=r.length||e<-1*r.length)throw new Error(\"axis specified for concat doesn't match input dimensionality\");e<0&&(e=r.length+e);let n=r.slice(0);for(let T=1;T<o.length;T++){let v=o[T].dims.slice();for(let w=0;w<r.length;w++)if(w===e)n[e]+=v[w];else if(r[w]!==v[w])throw new Error(\"non concat dimensions must match\")}let s=n.length,i=new Array(o.length),u=0;for(let T=0;T<i.length;++T)u+=o[T].dims[e],i[T]=u;let l=\"\";o.length<5?l=Sl(i):l=$h(i);let f=kh(o.length,s),p=Bh(i),d=`\n        ${f}\n        ${p}\n        ${l}\n        float process(int indices[${s}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${e}]);\n\n          if(textureIndex != 0) {\n            indices[${e}] = indices[${e}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;return{...t,output:{dims:n,type:o[0].type,textureType:0},shaderSource:d}},Ch=(a,t,o)=>{let e=Lh(t.length,o.cacheKey);return{...e,get:()=>Fh(a,e,t,o.axis)}},Sl=a=>`int getTextureWhereDataResides(int index) {\n      ${a.map((o,e)=>`if(index<${o}) {return ${e};}\n`).join(\"\")}\n    }`,$h=a=>Sl(a),kh=(a,t)=>{let o=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${t}]) {`];for(let e=0;e<a;++e)e===0?o.push(`\tif (textureIndex == ${e}) { return _X${e}(indices); }`):e===a-1?o.push(`\telse { return _X${e}(indices); }`):o.push(`\telse if (textureIndex == ${e}) { return _X${e}(indices); }`);return o.push(\"\t}\"),o.join(`\n`)},Bh=a=>{let t=[\"int getSizeInConcatAxisValueFromIndex(int index) {\"];for(let o=0;o<a.length;++o)o===0?t.push(`\tif (index == ${o}) { return ${a[o]}; }`):o===a.length-1?t.push(`\telse { return ${a[o]}; }`):t.push(`\telse if (index == ${o}) { return ${a[o]}; }`);return t.push(\"\t}\"),t.join(`\n`)},Al=a=>ee({axis:a.attributes.getInt(\"axis\")}),Nh=a=>{if(!a||a.length<1)throw new Error(\"too few inputs\");let t=a[0].type,o=a[0].dims.length;if(t===\"string\")throw new Error(\"string tensor is not supported yet\");for(let e of a){if(e.type!==t)throw new Error(\"input tensors should be one type\");if(e.dims.length!==o)throw new Error(\"input tensors should have the same shape\")}}});function Rh(){return pt(\"abs\")}function Mh(){return pt(\"acos\")}function Gh(){return pt(\"asin\")}function Uh(){return pt(\"atan\")}function zh(){return pt(\"ceil\")}function Vh(){return pt(\"cos\")}function Wh(a){let t=\"elu\";return{body:`\n  const float alpha = float(${a});\n\n  float ${t}_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 ${t}_(vec4 v) {\n    return vec4(${t}_(v.x), ${t}_(v.y), ${t}_(v.z), ${t}_(v.w));\n  }\n  `,name:t,type:0}}function Hh(){return pt(\"exp\")}function qh(){return pt(\"floor\")}function vi(a,t){let o=\"clip\";return{body:`\n  const float min = float(${a});\n  const float max = float(${t});\n\n  float ${o}_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 ${o}_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `,name:o,type:0}}function jh(){let a=\"indentity\";return{body:`\n  float ${a}_(float a) {\n    return a;\n  }\n  vec4 ${a}_(vec4 v) {\n    return v;\n  }\n  `,name:a,type:0}}function Yh(a){let t=\"leakyRelu\";return{body:`\n  const float alpha = float(${a});\n\n  float ${t}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${t}_(vec4 v) {\n    return vec4(${t}_(v.x), ${t}_(v.y), ${t}_(v.z), ${t}_(v.w));\n  }\n  `,name:t,type:0}}function Xh(){return pt(\"log\")}function Kh(){let a=\"neg\";return{body:`\n  float ${a}_(float a) {\n    return -a;\n  }\n  vec4 ${a}_(vec4 v) {\n    return -v;\n  }\n  `,name:a,type:0}}function Jh(){let a=\"not\";return{body:`\n  float ${a}_(float a) {\n    return float( ! bool(a) );\n  }\n  bool ${a}_(bool a) {\n    return !a;\n  }\n  vec4 ${a}_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 ${a}_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  `,name:a,type:0}}function Zh(){return pt(\"sin\")}function _i(){let a=\"relu\";return{body:`\n  float ${a}_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 ${a}_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  `,name:a,type:0}}function Oi(){let a=\"sigmoid\";return{body:`\n  float ${a}_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 ${a}_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  `,name:a,type:0}}function Qh(){return pt(\"sqrt\")}function em(){return pt(\"tan\")}function tm(){let a=\"tanh\";return{body:`\n  float ${a}_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 ${a}_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  `,name:a,type:0}}function pt(a){return{body:`\n  float ${a}_(float a) {\n    return ${a}(a);\n  }\n  vec4 ${a}_(vec4 v) {\n    return ${a}(v);\n  }\n  `,name:a,type:0}}var rm,De,El,Dl,Ll,Fl,Ii,Cl,$l,nm,kl,Bl,Nl,Rl,Ml,Gl,Si,Ul,zl,Vl,Wl,Hl,ql,jl,Yl,Xl,Kl,Jl,Ai=E(()=>{\"use strict\";Ge();fe();Ht();xe();ae();rm=(a,t,o,e)=>{let r=a.session.pack?2:0,n=q(a.session.backend.glContext.version);return{...t,output:{dims:o.dims,type:o.type,textureType:r},shaderSource:`\n     ${e.body}\n     void main() {\n       vec4 v = ${n.texture2D}(A, TexCoords);\n       v = ${e.name}_(v);\n       ${n.output} = v;\n     }\n     `,hasMain:!0}},De=(a,t,o,e)=>{let r=a.session.pack?2:0,n={name:o.name,inputTypes:[r],inputNames:[\"A\"],cacheHint:e};return{...n,get:()=>rm(a,n,t,o)}},El=(a,t)=>[a.run(De(a,t[0],Rh()),t)],Dl=(a,t)=>[a.run(De(a,t[0],Mh()),t)],Ll=(a,t)=>[a.run(De(a,t[0],Gh()),t)],Fl=(a,t)=>[a.run(De(a,t[0],Uh()),t)],Ii=(a,t,o)=>[a.run(De(a,t[0],vi(o.min,o.max),o.cacheKey),t)],Cl=a=>ee({min:a.attributes.getFloat(\"min\",hr),max:a.attributes.getFloat(\"max\",mr)}),$l=(a,t)=>{let o=nm(a,t);return Ii(a,[t[0]],o)},nm=(a,t)=>{if(t.length>=3&&(!a.session.isInitializer(t[1].dataId)||!a.session.isInitializer(t[2].dataId)))throw new Error(\"dynamic clip attributes are not allowed\");let o=t.length>=3?t[1].numberData[0]:hr,e=t.length>=3?t[2].numberData[0]:mr;return ee({min:o,max:e})},kl=(a,t)=>[a.run(De(a,t[0],zh()),t)],Bl=(a,t)=>[a.run(De(a,t[0],Vh()),t)],Nl=(a,t,o)=>[a.run(De(a,t[0],Wh(o.alpha),o.cacheKey),t)],Rl=a=>ee({alpha:a.attributes.getFloat(\"alpha\",1)}),Ml=(a,t)=>[a.run(De(a,t[0],Hh()),t)],Gl=(a,t)=>[a.run(De(a,t[0],qh()),t)],Si=(a,t)=>[a.run(De(a,t[0],jh()),t)],Ul=(a,t,o)=>[a.run(De(a,t[0],Yh(o.alpha),o.cacheKey),t)],zl=a=>ee({alpha:a.attributes.getFloat(\"alpha\",.01)}),Vl=(a,t)=>[a.run(De(a,t[0],Xh()),t)],Wl=(a,t)=>[a.run(De(a,t[0],Kh()),t)],Hl=(a,t)=>[a.run(De(a,t[0],Jh()),t)],ql=(a,t)=>[a.run(De(a,t[0],_i()),t)],jl=(a,t)=>[a.run(De(a,t[0],Oi()),t)],Yl=(a,t)=>[a.run(De(a,t[0],Zh()),t)],Xl=(a,t)=>[a.run(De(a,t[0],Qh()),t)],Kl=(a,t)=>[a.run(De(a,t[0],em()),t)],Jl=(a,t)=>[a.run(De(a,t[0],tm()),t)]});function Nt(a){let t;switch(a.activation){case\"Relu\":t=_i();break;case\"Sigmoid\":t=Oi();break;case\"Clip\":t=vi(a.clipMin,a.clipMax);break;default:return{activationFunction:\"\",applyActivation:\"\"}}let o=t.name,e=t.body,r=`value = ${o}_(value);`;return{activationFunction:e,applyActivation:r}}var Mr,yr=E(()=>{\"use strict\";fe();Ai();Mr=a=>{let t=a.getString(\"activation\",\"\");if(t===\"Clip\"){let[o,e]=a.getFloats(\"activation_params\",[hr,mr]);return{activation:t,clipMax:e,clipMin:o,activationCacheKey:`${t}:${o},${e}`}}return{activation:t,activationCacheKey:t}}});var im,am,Zl,Ql=E(()=>{\"use strict\";at();xe();ae();no();yr();im=(a,t)=>({name:\"GroupedConv\",inputNames:a?[\"X\",\"W\",\"Bias\"]:[\"X\",\"W\"],inputTypes:a?[0,0,0]:[0,0],cacheHint:t}),am=(a,t,o,e)=>{let n=t.length>2?\"value += getBias(output_channel);\":\"\",s=t[0].dims.slice(),i=t[1].dims.slice(),u=i[0]/e.group;ce.verbose(\"GroupedConv\",`autpPad:${e.autoPad}, dilations:${e.dilations}, group:${e.group}, kernelShape:${e.kernelShape}, pads:${e.pads}, strides:${e.strides}`);let l=Gr(s,i,e.dilations,e.pads,e.strides),f=q(a.session.backend.glContext.version),{activationFunction:p,applyActivation:d}=Nt(e),T=`\n  const ivec2 strides = ivec2(${e.strides[0]}, ${e.strides[1]});\n  const ivec2 pads = ivec2(${e.pads[0]}, ${e.pads[1]});\n  ${p}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${u};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${i[1]}; wInChannel++) {\n      int input_channel = group_id * ${i[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${i[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${e.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${s[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${i[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${e.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${s[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${n}\n    ${d}\n    ${f.output} = vec4(value, .0, .0, .0);\n  }\n`;return{...o,output:{dims:l,type:t[0].type,textureType:0},shaderSource:T,hasMain:!0}},Zl=(a,t,o)=>{let e=im(t.length>2,o.cacheKey);return{...e,get:()=>am(a,t,e,o)}}});var sm,um,ef,tf=E(()=>{\"use strict\";xe();ae();gr();sm=a=>({name:\"Im2Col (packed)\",inputNames:[\"A\"],inputTypes:[2],cacheHint:a}),um=(a,t,o,e,r,n)=>{let s=o.dims,i=e.dims,u=2,l=3,f=r.length,p=[i[1]*i[2]*i[3],r[2]*r[3]],d=i[2]*i[3],T=Bt(),v=q(a.session.backend.glContext.version),w=\"\";for(let L=0;L<=1;L++)for(let F=0;F<=1;F++)w+=`\n            blockIndex = rc.x + ${F};\n            pos = rc.y + ${L};\n\n            if(blockIndex < ${p[1]} && pos < ${p[0]}) {\n              offsetY = int(blockIndex / (${r[f-1]})) * ${n.strides[0]} -\n                ${n.pads[0]};\n              d0 = offsetY + ${n.dilations[0]} * (imod(pos, ${d}) / ${i[2]});\n\n              if(d0 < ${s[u]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${r[f-1]}) * ${n.strides[1]} -\n                  ${n.pads[1]};\n                d1 = offsetX + ${n.dilations[1]} * imod(imod(pos, ${d}), ${i[2]});\n\n                if(d1 < ${s[l]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${d}.);\n                    innerDims = vec2(d0, d1);\n                    result[${L*2+F}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;let I=`\n      ${T}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${w}\n          ${v.output} = result;\n      }\n            `;return{...t,output:{dims:p,type:o.type,textureType:2},shaderSource:I,hasMain:!0}},ef=(a,t,o,e,r)=>{let n=sm(r.cacheKey);return{...n,get:()=>um(a,n,t,o,e,r)}}});function fm(a,t,o){let e=t[0].dims,r=t[1].dims,n=Ke.calcShape(e,r,!0);if(!n)throw new Error(\"Can't use matmul on the given tensors\");let s=Je(n.length),i=Ot(),{activationFunction:u,applyActivation:l}=Nt(o),f=t.length>2,p=f?\"value += getBiasForMatmul();\":\"\",d=f?`${Ei(s,i,t[2].dims,n,!1)}`:\"\",T=n.length,v=e.length,w=r.length,I=e[e.length-1],L=`\n    ${u}\n    ${d}\n    float process(int indices[${T}]) {\n        int a[${v}];\n        int b[${w}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${I}; ++k) {\n            a[${v-1}] = k;\n            b[${w-2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${p}\n        ${l}\n        return value;\n    }`;return{...a,output:{dims:n,type:t[0].type,textureType:0},shaderSource:L}}function Pi(a,t){let o=lm(a.length>2,t.activationCacheKey);return{...o,get:()=>fm(o,a,t)}}function Ei(a,t,o,e,r){let n=\"\",s=o.length,i=e.length,u=i-s;i<2&&s>0?n=\"coords\":n=o.map((w,I)=>`coords.${t[I+u]}`).join(\", \");let f=Ke.getBroadcastDims(o,e).map(w=>`coords.${t[w+u]} = 0;`).join(`\n`),d=U.size(o)===1,T=\"vec4(outputValue.xx, outputValue.yy)\";return d&&(T=\"vec4(outputValue.x)\"),r?`\nvec4 getBiasForMatmul() {\n  ${a} coords = getOutputCoords();\n  ${f}\n  vec4 outputValue = getBias(${n});\n  return ${T};\n}`:`\nfloat getBiasForMatmul() {\n  ${a} coords = getOutputCoords();\n  ${f}\n  return getBias(coords.x);\n}`}var rf,nf,lm,cm,oo=E(()=>{\"use strict\";fe();ae();kt();yr();Di();rf=(a,t,o)=>(cm(t),a.session.pack?[a.run(io(a,t,o),t)]:[a.run(Pi(t,o),t)]),nf=a=>Mr(a.attributes),lm=(a,t)=>({name:\"MatMul\",inputNames:a?[\"A\",\"B\",\"Bias\"]:[\"A\",\"B\"],inputTypes:a?[0,0,0]:[0,0],cacheHint:t});cm=a=>{if(!a||a.length!==2)throw new Error(\"MatMul requires 2 inputs.\");if(a[0].dims[a[0].dims.length-1]!==a[1].dims[a[1].dims.length-2])throw new Error(\"shared dimension does not match.\");if(a[0].type!==\"float32\"&&a[0].type!==\"float64\"||a[1].type!==\"float32\"&&a[1].type!==\"float64\")throw new Error(\"inputs should be float type\");if(a[0].type!==a[1].type)throw new Error(\"inputs types should match\")}});function hm(a,t,o,e){let r=[],n=[],s=o[0].dims,i=o[1].dims,u=s.length,l=i.length,f=e.length,p=f-u,d=f-l;r=s.map((C,Y)=>`coords.${t[Y+p]}`),r[u-1]=\"i*2\",r.join(\", \"),n=i.map((C,Y)=>`coords.${t[Y+d]}`),n[l-2]=\"i*2\",n.join(\", \");let T=Ke.getBroadcastDims(s,e),v=Ke.getBroadcastDims(i,e),w=T.map(C=>`coords.${t[C+p]} = 0;`).join(`\n`),I=v.map(C=>`coords.${t[C+d]} = 0;`).join(`\n`),L=`int lastDim = coords.${t[f-1]};\n  coords.${t[f-1]} = coords.${t[f-2]};\n  coords.${t[f-2]} = lastDim;`;return`\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${a} coords = getOutputCoords();\n  ${L}\n  ${w}\n  vec4 outputValue = getA(${r});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${a} coords = getOutputCoords();\n  ${L}\n  ${I}\n  vec4 outputValue = getB(${n});\n  return outputValue;\n}`}function mm(a,t){let o=\"\";for(let e=0;e<t-2;e++)o+=`rc.${a[e]}, `;return o+=`rc.${a[t-2]}, i*2`,o}function bm(a,t){let o=\"\";for(let e=0;e<t-2;e++)o+=`rc.${a[e]}, `;return o+=`i*2, rc.${a[t-1]}`,o}var pm,dm,io,Di=E(()=>{\"use strict\";fe();xe();ae();kt();yr();oo();pm=(a,t)=>({name:\"MatMul (packed)\",inputNames:a?[\"A\",\"B\",\"Bias\"]:[\"A\",\"B\"],inputTypes:a?[2,2,2]:[2,2],cacheHint:t}),dm=(a,t,o,e)=>{let r=o.length>2,n=r?\"value += getBiasForMatmul();\":\"\",s=o[0].dims,i=o[1].dims,u=Ke.calcShape(s,i,!0),l=!U.areEqual(o[0].dims,o[1].dims);if(!u)throw new Error(\"Can't use matmul on the given tensors\");let f=s[s.length-1],p=Math.ceil(f/2),d=s.length,T=i.length,v=q(a.session.backend.glContext.version),w=Je(u.length),I=u.length,L=Ot(),{activationFunction:F,applyActivation:C}=Nt(e),Y=r?`${Ei(w,L,o[2].dims,u,!0)}`:\"\",j=l?`${hm(w,L,o,u)}`:\"\",M=l?\"getAAtOutCoordsMatmul(i)\":`getA(${mm(L,d)})`,ie=l?\"getBAtOutCoordsMatmul(i)\":`getB(${bm(L,T)})`,ot=l?\"\":`${w} rc =\n          getOutputCoords(); int lastDim = rc.${L[I-1]}; rc.${L[I-1]} =\n          rc.${L[I-2]}; rc.${L[I-2]} = lastDim;\n      `,We=`\n            ${j}\n            ${Y}\n            ${F}\n            void main() {\n              ${ot}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${p}; i++) {\n                vec4 a = ${M};\n                vec4 b = ${ie};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${n}\n              ${C}\n              ${v.output} = value;\n            }`;return{...t,output:{dims:u,type:o[0].type,textureType:2},shaderSource:We,hasMain:!0}},io=(a,t,o)=>{let e=pm(t.length>2,o.activationCacheKey);return{...e,get:()=>dm(a,e,t,o)}}});var of,af=E(()=>{\"use strict\";no();tf();Di();of=(a,t,o)=>{let e=t[0].dims,r=t[1].dims,n=Gr(e,r,o.dilations,o.pads,o.strides),s=a.run(ef(a,t[0],t[1],n,o),[t[0]]),i=a.reshapePacked(t[1],[r[0],r[1]*r[2]*r[3]]),u=t.length===3?[i,s,t[2]]:[i,s],l=a.run(io(a,u,o),u);return a.reshapePacked(l,n)}});var gm,ym,sf,Li,Fi=E(()=>{\"use strict\";ae();gm=a=>({name:\"Im2Col\",inputNames:[\"X\"],inputTypes:[0],cacheHint:a}),ym=(a,t,o,e,r,n)=>{let s=o.dims,i=e.dims,u=r.length,l=Li(s,i,r,4),f=`\n        const int XC = ${s[1]};\n        const int XH = ${s[2]};\n        const int XW = ${s[3]};\n        const int KH = ${n.kernelShape[0]};\n        const int KW = ${n.kernelShape[1]};\n        const int dilationH = ${n.dilations[0]};\n        const int dilationW = ${n.dilations[1]};\n        const int strideH = ${n.strides[0]};\n        const int strideW = ${n.strides[1]};\n        const int padH = ${n.pads[0]};\n        const int padW = ${n.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${u}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${s.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;return{...t,output:{dims:l,type:o.type,textureType:4},shaderSource:f}},sf=(a,t,o,e,r)=>{let n=gm(r.cacheKey);return{...n,get:()=>ym(a,n,t,o,e,r)}},Li=(a,t,o,e=4)=>[o[0],o[2],o[3],Math.ceil(a[1]*t[2]*t[3]/e)]});var Tm,xm,uf,lf=E(()=>{\"use strict\";fe();xe();ae();yr();Fi();Tm=(a,t)=>({name:\"ConvDotProduct\",inputNames:a?[\"Im2Col\",\"K\",\"B\"]:[\"Im2Col\",\"K\"],inputTypes:a?[0,4,0]:[0,4],cacheKey:t.activationCacheKey}),xm=(a,t,o,e,r)=>{let n=o[0].dims,s=o[1].dims,i=[s[0],Math.ceil(n[1]*s[2]*s[3]/4)],u=Li(n,s,e),[l,f]=a.calculateTextureWidthAndHeight(i,4),p=U.computeStrides(u),[d,T]=a.calculateTextureWidthAndHeight(u,4),v=e.length,w=o.length<3?\"0.0\":\"_B(b)\",I=Math.ceil(n[1]*s[2]*s[3]/4),{activationFunction:L,applyActivation:F}=Nt(r),C=q(a.session.backend.glContext.version),Y=`\n${L}\nfloat process(int indices[${v}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${p[0]} + im2col[1] * ${p[1]} + im2col[2] * ${p[2]};\n  int kernelOffset = indices[1] * ${i[1]};\n  float value = ${w};\n  for (int i = 0; i < ${I}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${d}, ${T});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${l}, ${f});\n    value += dot(${C.texture2D}(Im2Col, im2colCoords), ${C.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${F}\n  return value;\n}`;return{...t,output:{dims:e,type:o[0].type,textureType:0},shaderSource:Y}},uf=(a,t,o,e)=>{let r=Tm(t.length>2,e);return{...r,get:()=>xm(a,r,t,o,e)}}});var Gr,Ci,wm,vm,_m,Om,$i,Im,no=E(()=>{\"use strict\";Ge();fe();Ql();af();lf();yr();Fi();oo();Gr=(a,t,o,e,r)=>{let n=a[0],s=a.slice(2),i=s.length,u=t[0],f=t.slice(2).map((v,w)=>v+(v-1)*(o[w]-1)),d=s.map((v,w)=>v+e[w]+e[w+i]).map((v,w)=>Math.floor((v-f[w]+r[w])/r[w]));return[n,u].concat(...d)},Ci=(a,t,o)=>(Im(t,o),wm(a,t,o)),wm=(a,t,o)=>{let e=Om(o,t),r=a.session.pack,n=e.kernelShape[0]===1&&e.kernelShape[1]===1;return e.group>1?[a.run(Zl(a,t,e),t)]:n&&r?[vm(a,t,e)]:r&&t[0].dims.length===4&&t[0].dims[0]===1&&!n?[of(a,t,e)]:[_m(a,t,e)]},vm=(a,t,o)=>{let e=t[0].dims,r=t[1].dims,n=Gr(e,r,o.dilations,o.pads,o.strides),s=a.reshapeUnpacked(t[0],[e[1],e[2]*e[3]]),i=a.reshapeUnpacked(t[1],[r[0],r[1]]),u=t.length>2?[i,s,t[2]]:[i,s],l=a.run(Pi(u,o),u);return a.reshapeUnpacked(l,n)},_m=(a,t,o)=>{let e=t[0].dims,r=t[1].dims,n=Gr(e,r,o.dilations,o.pads,o.strides),s=a.run(sf(a,t[0],t[1],n,o),[t[0]]),i=t.length===3?[s,t[1],t[2]]:[s,t[1]];return a.run(uf(a,t,n,o),i)},Om=(a,t)=>{let o=a.kernelShape.slice();if(a.kernelShape.length===0)for(let n=2;n<t[1].dims.length;++n)o.push(t[1].dims[n]);let e=a.pads.slice();dr.adjustPadsBasedOnAutoPad(t[0].dims,a.strides,a.dilations,o,e,a.autoPad);let r=Object.assign({},a);return Object.assign(r,{kernelShape:o,pads:e,cacheKey:a.cacheKey}),r},$i=a=>{let t=a.attributes,o=Mr(t),e=t.getString(\"auto_pad\",\"NOTSET\"),r=t.getInts(\"dilations\",[1,1]),n=t.getInt(\"group\",1),s=t.getInts(\"kernel_shape\",[]),i=t.getInts(\"pads\",[0,0,0,0]),u=t.getInts(\"strides\",[1,1]);return ee({autoPad:e,dilations:r,group:n,kernelShape:s,pads:i,strides:u,...o})},Im=(a,t)=>{if(!a||a.length!==2&&a.length!==3)throw new Error(\"Conv requires 2 or 3 inputs\");if(a[0].dims.length!==4||a[1].dims.length!==4)throw new Error(\"currently only support 2-dimensional conv\");let o=a[0].dims[1],e=a[1].dims[1]*t.group;if(o!==e)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");if(a.length===3&&(a[2].dims.length!==1||a[1].dims[0]!==a[2].dims[0]))throw new Error(\"invalid bias\");let r=a[0].dims.length-2;if(t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.length!==r*2)throw new Error(`pads should be ${r*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==a[1].dims.length-2)throw new Error(\"invalid kernel shape\");if(a[0].type!==\"float32\"||a[1].type!==\"float32\")throw new Error(\"Conv input(X,W) should be float tensor\");if(a.length===3&&a[2].type!==\"float32\")throw new Error(\"Conv input(bias) should be float tensor\")}});var Sm,Am,Pm,ff,Em,Dm,Lm,Fm,Cm,$m,cf,km,pf=E(()=>{\"use strict\";Ge();xe();ae();yr();Sm=(a,t,o,e,r,n)=>(a-1)*t+o+(e-1)*r+1-n,Am=(a,t,o,e,r)=>{let n=Math.floor(a/2);t===\"SAME_UPPER\"?(o[e]=n,o[r]=a-n):t===\"SAME_LOWER\"&&(o[e]=a-n,o[r]=n)},Pm=(a,t,o,e,r,n,s,i)=>{let u=a.length-2,l=i.length===0;for(let f=0;f<u;++f){let p=l?a[f+2]*n[f]:i[f],d=Sm(a[f+2],n[f],r[f],t[f],o[f],p);Am(d,e,r,f,f+u),l&&i.push(n[f]*(a[f+2]-1)+s[f]+(t[f]-1)*o[f]+1-r[f]-r[f+u])}},ff=(a,t,o)=>(km(t,o),Em(a,t,o)),Em=(a,t,o)=>{let e=$m(o,t);return[Cm(a,t,e)]},Dm=(a,t)=>({name:\"ConvTranspose\",inputNames:a?[\"X\",\"W\",\"B\"]:[\"X\",\"W\"],inputTypes:a?[0,0,0]:[0,0],cacheHint:t}),Lm=(a,t,o,e)=>{let n=t.length>2?\"getB(output_channel)\":\"0.0\",s=t[0].dims,i=t[1].dims,u=i[1],l=i[0]/e.group,f=[t[0].dims[0],t[1].dims[1]*e.group,...e.outputShape],p=q(a.session.backend.glContext.version),{activationFunction:d,applyActivation:T}=Nt(e),v=`\n  const ivec2 strides = ivec2(${e.strides[0]}, ${e.strides[1]});\n  const ivec2 pads = ivec2(${e.pads[0]}, ${e.pads[1]});\n  ${d}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${u};\n    int wOutChannel = output_channel - group_id * ${u};\n\n    float value = ${n};\n    for (int inChannelOffset = 0; inChannelOffset < ${l}; inChannelOffset++) {\n      int input_channel = group_id * ${l} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${i[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${i[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${e.dilations[0]}, wHOff * ${e.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${s[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${s[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${T}\n    ${p.output} = vec4(value, .0, .0, .0);\n  }\n`;return{...o,output:{dims:f,type:t[0].type,textureType:0},shaderSource:v,hasMain:!0}},Fm=(a,t,o)=>{let e=Dm(t.length>2,o.cacheKey);return{...e,get:()=>Lm(a,t,e,o)}},Cm=(a,t,o)=>a.run(Fm(a,t,o),t),$m=(a,t)=>{let o=a.kernelShape.slice();if(a.kernelShape.length===0)for(let i=2;i<t[1].dims.length;++i)o.push(t[1].dims[i]);let e=a.pads.slice(),r=a.outputShape.slice(),n=t[0].dims;Pm(n,o,a.dilations,a.autoPad,e,a.strides,a.outputPadding,r);let s=Object.assign({},a);return Object.assign(s,{kernelShape:o,pads:e,outputShape:r,cacheKey:a.cacheKey}),s},cf=a=>{let t=a.attributes,o=Mr(t),e=t.getString(\"auto_pad\",\"NOTSET\"),r=t.getInts(\"dilations\",[1,1]),n=t.getInt(\"group\",1),s=t.getInts(\"kernel_shape\",[]),i=t.getInts(\"output_padding\",[0,0]),u=t.getInts(\"output_shape\",[]),l=t.getInts(\"pads\",[0,0,0,0]),f=t.getInts(\"strides\",[1,1]);return ee({autoPad:e,dilations:r,group:n,kernelShape:s,outputPadding:i,outputShape:u,pads:l,strides:f,...o})},km=(a,t)=>{if(!a||a.length!==2&&a.length!==3)throw new Error(\"Conv requires 2 or 3 inputs\");if(a[0].dims.length!==4||a[1].dims.length!==4)throw new Error(\"currently only support 2-dimensional conv\");let o=a[0].dims[1],e=a[1].dims[0];if(o!==e)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");let r=a[1].dims[1]*t.group;if(a.length===3&&(a[2].dims.length!==1||a[2].dims[0]!==r))throw new Error(\"invalid bias\");let n=a[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(t.outputPadding.length!==n)throw new Error(`output_padding should be ${n}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==a[1].dims.length-2)throw new Error(\"invalid kernel shape\");if(t.outputShape.length!==0&&t.outputShape.length!==a[0].dims.length-2)throw new Error(\"invalid output shape\");if(a[0].type!==\"float32\"||a[1].type!==\"float32\")throw new Error(\"ConvTranspose input(X,W) should be float tensor\");if(a.length===3&&a[2].type!==\"float32\")throw new Error(\"ConvTranspose input(bias) should be float tensor\")}});var df,Tr,hf,Bm,mf,Nm,Rm,Mm,ao=E(()=>{\"use strict\";Ge();fe();ae();df={name:\"Transpose\",inputNames:[\"A\"],inputTypes:[0]},Tr=(a,t,o)=>(Mm(t),[a.run({...df,cacheHint:o.cacheKey,get:()=>Bm(a,t[0],o.perm)},t)]),hf=a=>ee({perm:a.attributes.getInts(\"perm\",[])}),Bm=(a,t,o)=>{let e=t.dims;o=mf(e,o);let r=Nm(e,o),n=e.length,s=`\n      ${Rm(\"perm\",o,n)}\n      float process(int indices[${n}]) {\n        int a[${n}];\n        perm(a, indices);\n        return _A(a);\n      }`;return{...df,output:{dims:r,type:t.type,textureType:0},shaderSource:s}},mf=(a,t)=>(t&&t.length!==a.length&&(t=[...a.keys()].reverse()),t),Nm=(a,t)=>(t=mf(a,t),U.sortBasedOnPerm(a,t)),Rm=(a,t,o)=>{let e=[];e.push(`void ${a}(out int a[${o}], int src[${o}]) {`);for(let r=0;r<o;++r)e.push(`\ta[${t[r]}]=src[${r}];`);return e.push(\"\t}\"),e.join(`\n`)},Mm=a=>{if(!a||a.length!==1)throw new Error(\"Transpose requires 1 input.\");if(a[0].type!==\"float32\"&&a[0].type!==\"float64\")throw new Error(\"input should be float tensor\")}});var bf,gf,Gm,yf=E(()=>{\"use strict\";ao();bf=(a,t,o)=>{Gm(t);let e=o.blocksize,r=e*e,n=o.mode===\"DCR\"?[0,3,4,1,5,2]:[0,1,4,2,5,3],s=o.mode===\"DCR\"?[t[0].dims[0],e,e,t[0].dims[1]/r,t[0].dims[2],t[0].dims[3]]:[t[0].dims[0],t[0].dims[1]/r,e,e,t[0].dims[2],t[0].dims[3]],i=a.reshapeUnpacked(t[0],s),u={perm:n,cacheKey:`${n}`},[l]=Tr(a,[i],u),f=[t[0].dims[0],t[0].dims[1]/r,t[0].dims[2]*e,t[0].dims[3]*e];return[a.reshapeUnpacked(l,f)]},gf=a=>{let t=a.attributes.getInt(\"blocksize\");if(t<1)throw new Error(`blocksize must be >= 1, but got : ${t} for DepthToSpace`);let o=a.attributes.getString(\"mode\",\"DCR\");if(o!==\"DCR\"&&o!==\"CRD\")throw new Error(`unrecognized mode: ${o} for DepthToSpace`);return{mode:o,blocksize:t}},Gm=a=>{if(a.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${a.length}`);if(a[0].type===\"string\"||a[0].dims.length!==4)throw new TypeError(\"DepthToSpace input should be a 4-D numeric tensor\")}});var Tf,xf,Um,wf=E(()=>{\"use strict\";fe();Tf=(a,t,o)=>{Um(t,o);let e=U.flattenShape(t[0].dims,o);return[a.reshapeUnpacked(t[0],e)]},xf=a=>a.attributes.getInt(\"axis\",1),Um=(a,t)=>{if(!a||a.length!==1)throw new Error(\"Flatten requires 1 input.\");let o=a[0].dims.length;if(o===0)throw new Error(\"scalar tensor is not supported.\");if(t<-o||t>o)throw new Error(\"Invalid axis\");if(a[0].type===\"string\")throw new Error(\"string tensor is not supported.\")}});var Jt,hn=E(()=>{\"use strict\";Jt=[\"float32\",\"float64\",\"int32\",\"int16\",\"int8\",\"uint16\",\"uint32\",\"uint8\"]});var vf,_f,zm,Vm,Wm,Hm,Of=E(()=>{\"use strict\";Ge();hn();fe();ae();vf=(a,t,o)=>(Hm(t,o.axis),[a.run(Wm(a,t,o),t)]),_f=a=>ee({axis:a.attributes.getInt(\"axis\",0)}),zm={name:\"Gather\",inputNames:[\"A\",\"B\"],inputTypes:[0,0]},Vm=(a,t,o,e)=>{let r=o[0].dims.slice(),n=o[1].dims.slice(),s=new Array(r.length+n.length-1);e=U.normalizeAxis(e,r.length);let i=[];for(let d=0;d<s.length;d++)d<e?(s[d]=r[d],i.push(`inputIdx[${d}] = outputIdx[${d}];`)):d<e+n.length?(s[d]=n[d-e],i.push(`indexDataIdx[${d-e}] = outputIdx[${d}];`)):(s[d]=r[d-n.length+1],i.push(`inputIdx[${d-n.length+1}] = outputIdx[${d}];`));let u=s.length||1,l=r.length,f=n.length||1,p=`\n      float process(int outputIdx[${u}]) {\n        int inputIdx[${l}];\n        int indexDataIdx[${f}];\n        indexDataIdx[0] = 0;\n        ${i.join(`\n        `)}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${e}] = idx < 0 ? idx + ${r[e]} : idx;\n        return _A(inputIdx);\n      }`;return{...t,output:{dims:s,type:o[0].type,textureType:0},shaderSource:p}},Wm=(a,t,o)=>{let e={...zm,cacheHint:o.cacheKey};return{...e,get:()=>Vm(a,e,t,o.axis)}},Hm=(a,t)=>{if(!a||a.length!==2)throw new Error(\"Gather requires 2 inputs.\");let o=a[0].dims.length;if(o<1)throw new Error(\"Invalid input shape.\");if(t<-o||t>o-1)throw new Error(\"Invalid axis.\");if(Jt.indexOf(a[0].type)===-1)throw new Error(\"Invaid input type.\");if(a[1].type!==\"int32\"&&a[1].type!==\"int16\")throw new Error(\"Invaid input type.\")}});var ki,If,Sf,Af,qm,jm,Ym,Pf=E(()=>{\"use strict\";Ge();fe();ae();ki=(a,t,o)=>(Ym(t,o),[a.run(qm(t,o),t)]),If=(a,t)=>{let o=a.attributes.getInt(\"transA\",0)!==0,e=a.attributes.getInt(\"transB\",0)!==0,r=a.attributes.getFloat(\"alpha\",1),n=a.attributes.getFloat(\"beta\",1);return ee({transA:o,transB:e,alpha:r,beta:n,isOptionalC:t})},Sf=a=>If(a,!1),Af=a=>If(a,!0),qm=(a,t)=>{let o={name:\"Gemm\",inputNames:a.length===3?[\"A\",\"B\",\"C\"]:[\"A\",\"B\"],inputTypes:a.length===3?[0,0,0]:[0,0],key:t.cacheKey};return{...o,get:()=>jm(o,a,t)}},jm=(a,t,o)=>{let e=t[0].dims.slice(),r=t[1].dims.slice(),[n,s]=Xn.getShapeOfGemmResult(e,o.transA,r,o.transB,t.length===3?t[2].dims:void 0),i=[n,s];if(!i)throw new Error(\"Can't use gemm on the given tensors\");let u=e[e.length-1],l=\"\";o.transA&&(u=e[0]),o.transA&&o.transB?l=\"value += _A_T(a) * _B_T(b);\":o.transA&&!o.transB?l=\"value += _A_T(a) * _B(b);\":!o.transA&&o.transB?l=\"value += _A(a) * _B_T(b);\":!o.transA&&!o.transB&&(l=\"value += _A(a) * _B(b);\");let f=i.length,p=t.length===3?`int c[${t[2].dims.length}];`:\"\",d=t.length===3?\"bcastIndices_C(indices, c);\":\"\",T=t.length===3?\"value += beta * _C(c);\":\"\",v=`\n      float process(int indices[${f}]) {\n          int a[${f}];\n          int b[${f}];\n          ${p}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${d}\n\n          float value = 0.0;\n          for (int k=0; k<${u}; ++k) {\n              a[${f-1}] = k;\n              b[${f-2}] = k;\n              ${l}\n          }\n\n          value = value * alpha;\n          ${T}\n          return value;\n      }`;return{...a,output:{dims:i,type:t[0].type,textureType:0},variables:[{name:\"alpha\",type:\"float\",data:o.alpha},{name:\"beta\",type:\"float\",data:o.beta}],shaderSource:v}},Ym=(a,t)=>{if(!a)throw new Error(\"Input is missing\");if(t.isOptionalC&&(a.length<2||a.length>3))throw new Error(\"Invaid input shape.\");if(!t.isOptionalC&&a.length!==3)throw new Error(\"Gemm requires 3 inputs\");if(a.length===3&&a[2].dims.length!==1&&a[2].dims.length!==2)throw new Error(\"Invalid input shape of C\");if(a[0].type!==\"float32\"&&a[0].type!==\"float64\"||a[1].type!==\"float32\"&&a[1].type!==\"float64\"||a.length===3&&a[2].type!==\"float32\"&&a[2].type!==\"float64\")throw new Error(\"Invalid input type.\");if(a[0].type!==a[1].type||a.length===3&&a[0].type!==a[2].type)throw new Error(\"Input types are mismatched\")}});var Ef,Df,Xm,Km,Jm,Zm,Qm,Lf=E(()=>{\"use strict\";Ge();ae();Ef=(a,t,o)=>(Qm(t),[a.run(Jm(a,t,o),t)]),Df=a=>{let t=a.attributes.getFloat(\"scale\"),o=a.attributes.getFloats(\"bias\");return ee({scale:t,bias:o})},Xm={name:\"ImageScaler\",inputNames:[\"X\"],inputTypes:[0]},Km=(a,t,o,e)=>{let r=o[0].dims.slice(),n=r.length,i=`\n      ${Zm(e.bias.length)}\n      float process(int indices[${n}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;return{...t,output:{dims:r,type:o[0].type,textureType:0},variables:[{name:\"bias\",type:\"float\",arrayLength:e.bias.length,data:e.bias},{name:\"scale\",type:\"float\",data:e.scale}],shaderSource:i}},Jm=(a,t,o)=>{let e={...Xm,cacheHint:o.cacheKey};return{...e,get:()=>Km(a,e,t,o)}},Zm=a=>{let t=[`float getBias(float bias[${a}], int channel) {`];for(let o=0;o<a;++o)o===0?t.push(`\tif (channel == ${o}) { return bias[${o}]; }`):o===a-1?t.push(`\telse { return bias[${o}]; }`):t.push(`\telse if (channel == ${o}) { return bias[${o}]; }`);return t.push(\"\t}\"),t.join(`\n`)},Qm=a=>{if(!a||a.length!==1)throw new Error(\"ImageScaler requires 1 input.\");if(a[0].dims.length!==4)throw new Error(\"Invalid input shape.\");if(a[0].type!==\"float32\"&&a[0].type!==\"float64\")throw new Error(\"Invalid input type.\")}});var Cf,$f,Ff,eb,tb,rb,nb,ob,ib,kf=E(()=>{\"use strict\";xe();ae();Cf=(a,t,o)=>{ib(t);let e=a.run(tb(t[0]),t);return[a.run(ob(a,t[0],o,e.dims),[t[0],e,t[1],t[2]])]},$f=a=>a.attributes.getFloat(\"epsilon\",1e-5),Ff={name:\"InstanceNormalization_MeanAndVariance\",inputNames:[\"X\"],inputTypes:[0]},eb=(a,t)=>{let o=t.dims.slice(),e=o[1],r=o[2]*o[3],n=[o[0],e],s=`\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${o[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${o[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${r});\n        temp = 0.0;\n        for(int a2=0; a2<${o[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${o[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${r});\n\n        return v;\n      }`;return{...a,output:{dims:n,type:t.type,textureType:4},shaderSource:s}},tb=a=>({...Ff,get:()=>eb(Ff,a)}),rb={name:\"InstanceNormalization_ComputeOutput\",inputNames:[\"X\",\"MeanAndVariance\",\"Scale\",\"B\"],inputTypes:[0,4,0,0]},nb=(a,t,o,e,r)=>{let n=q(a.session.backend.glContext.version),[s,i]=a.calculateTextureWidthAndHeight(r,4),[u,l]=[s/4,i],f=`\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${u}, ${l});\n        return ${n.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;return{...t,output:{dims:o.dims,type:o.type,textureType:0},variables:[{name:\"epsilon\",type:\"float\",data:e}],shaderSource:f}},ob=(a,t,o,e)=>{let r={...rb,cacheHint:`${o}`};return{...r,get:()=>nb(a,r,t,o,e)}},ib=a=>{if(!a||a.length!==3)throw new Error(\"InstanceNormalization requires 3 inputs.\");let t=a[0],o=a[1],e=a[2];if(t.dims.length<3||o.dims.length!==1||e.dims.length!==1)throw new Error(\"Invalid input shape.\");if(o.dims[0]!==t.dims[1]||e.dims[0]!==t.dims[1])throw new Error(\"Input shapes are mismatched.\");if(t.type!==\"float32\"&&t.type!==\"float64\"||o.type!==\"float32\"&&o.type!==\"float64\"||e.type!==\"float32\"&&e.type!==\"float64\")throw new Error(\"Invalid input type.\");if(a[0].dims.length!==4)throw new Error(\"Only support 4-D input shape.\")}});function ab(a,t){let o=a[0].dims[1],e=a[0].dims.length,r=-Math.floor((t.size-1)/2),n=Math.ceil((t.size-1)/2),s=`float(${t.alpha}) / float(${t.size})`,i=`float(${t.bias})`,u=`float(${t.beta})`,l=`\n    float process(int indices[${e}]) {\n        int c = indices[1];\n        float x = _X(indices);\n        float square_sum = 0.0;\n\n        for (int i = ${r}; i <= ${n}; i++) {\n          int idx = c + i;\n          if (c >= 0 && c < ${o}) {\n            indices[1] = idx;\n            float j = _X(indices);\n            square_sum += j * j;\n          }\n        }\n        return x / pow(${i} + ${s} * square_sum, ${u});\n    }`;return{...Rf,cacheHint:t.cacheKey,output:{dims:a[0].dims,type:a[0].type,textureType:0},shaderSource:l}}function sb(a,t){return{...Rf,cacheHint:t.cacheKey,get:()=>ab(a,t)}}var Bf,Nf,Rf,ub,Mf=E(()=>{\"use strict\";Ge();ae();Bf=(a,t,o)=>(ub(t),[a.run(sb(t,o),t)]),Nf=a=>{let t=a.attributes.getFloat(\"alpha\",1e-4),o=a.attributes.getFloat(\"beta\",.75),e=a.attributes.getFloat(\"bias\",1),r=a.attributes.getInt(\"size\");return ee({alpha:t,beta:o,bias:e,size:r})},Rf={name:\"LRN\",inputNames:[\"X\"],inputTypes:[0]};ub=a=>{if(!a||a.length!==1)throw new Error(\"LRN requires 1 input.\");if(a[0].dims.length!==4)throw new Error('currently only support LRN for input with \"NCHW\" format');if(a[0].type!==\"float32\")throw new Error(\"input should be float type\")}});var lb,Bi,Gf,Uf,zf,fb,cb,pb,db,hb,mb,bb,gb,Vf=E(()=>{\"use strict\";Ge();fe();xe();ae();lb={name:\"Pad\",inputNames:[\"A\"],inputTypes:[0]},Bi=(a,t,o)=>(pb(t),[a.run({...lb,cacheHint:o.cacheKey,get:()=>cb(a,t[0],o)},t)]),Gf=a=>{let t=a.attributes.getString(\"mode\",\"constant\"),o=a.attributes.getFloat(\"value\",0),e=a.attributes.getInts(\"pads\");return ee({mode:t,value:o,pads:e})},Uf=(a,t,o)=>{db(t);let e=fb(a,t,o);return Bi(a,[t[0]],e)},zf=a=>a.attributes.getString(\"mode\",\"constant\"),fb=(a,t,o)=>{if(!a.session.isInitializer(t[1].dataId)||t.length>=3&&!a.session.isInitializer(t[2].dataId))throw new Error(\"dynamic pad attributes are not allowed\");let e=Array.from(t[1].integerData),r=t.length>=3?t[2].floatData[0]:0;return ee({mode:o,pads:e,value:r})},cb=(a,t,o)=>{let e=U.padShape(t.dims.slice(),o.pads),r=e.length,s=`\n      ${hb(a,t,o)}\n      float process(int[${r}] indices) {\n          return padA(indices);\n      }`;return{name:\"Pad\",inputNames:[\"A\"],inputTypes:[0],output:{dims:e,type:t.type,textureType:0},shaderSource:s}},pb=a=>{if(!a||a.length!==1)throw new Error(\"Pad requires 1 input\");if(a[0].type!==\"float32\"&&a[0].type!==\"float64\")throw new Error(\"Invalid input type.\")},db=a=>{if(!a||a.length!==2&&a.length!==3)throw new Error(\"Pad requires 2 or 3 inputs\");if(a[1].type!==\"int32\")throw new Error(\"Invalid input type.\");if(a.length>=3&&a[2].type===\"string\")throw new Error(\"Invalid input type.\")},hb=(a,t,o)=>{let e=q(a.session.backend.glContext.version),[r,n]=a.calculateTextureWidthAndHeight(t.dims,0),s=U.computeStrides(t.dims);switch(o.mode){case\"constant\":return mb(e,t.dims,s,r,n,o.pads,o.value);case\"reflect\":return bb(e,t.dims,s,r,n,o.pads);case\"edge\":return gb(e,t.dims,s,r,n,o.pads);default:throw new Error(\"Invalid mode\")}},mb=(a,t,o,e,r,n,s)=>{let i=t.length,u=\"\";for(let l=i-1;l>=0;--l)u+=`\n        k = m[${l}] - ${n[l]};\n        if (k < 0)  return constant;\n        if (k >= ${t[l]}) return constant;\n        offset += k * ${o[l]};\n        `;return`\n      float padA(int m[${i}]) {\n        const float constant = float(${s});\n        int offset = 0;\n        int k = 0;\n        ${u}\n        vec2 coords = offsetToCoords(offset, ${e}, ${r});\n        float value = getColorAsFloat(${a.texture2D}(A, coords));\n        return value;\n      }\n      `},bb=(a,t,o,e,r,n)=>{let s=t.length,i=\"\";for(let u=s-1;u>=0;--u)i+=`\n        k = m[${u}] - ${n[u]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2*(t[u]-1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${t[u]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${o[u]};\n        `;return`\n      float padA(int m[${s}]) {\n        int offset = 0;\n        int k = 0;\n        ${i}\n        vec2 coords = offsetToCoords(offset, ${e}, ${r});\n        float value = getColorAsFloat(${a.texture2D}(A, coords));\n        return value;\n      }\n      `},gb=(a,t,o,e,r,n)=>{let s=t.length,i=\"\";for(let u=s-1;u>=0;--u)i+=`\n        k = m[${u}] - ${n[u]};\n        if (k < 0)  k = 0;\n        if (k >= ${t[u]}) k = ${t[u]-1};\n        offset += k * ${o[u]};\n      `;return`\n      float padA(int m[${s}]) {\n        int offset = 0;\n        int k = 0;\n        ${i}\n        vec2 coords = offsetToCoords(offset, ${e}, ${r});\n        float value = getColorAsFloat(${a.texture2D}(A, coords));\n        return value;\n      }\n      `}});var Hf,qf,jf,Yf,Xf,Kf,Jf,Zf,Qf,yb,Wf,ec,uo,tc,so,Tb,rc=E(()=>{\"use strict\";Ge();fe();ae();Hf=(a,t,o)=>{uo(t);let e={name:\"AveragePool\",inputNames:[\"X\"],inputTypes:[0],cacheHint:o.cacheKey};return[a.run({...e,get:()=>jf(t,e,!1,o)},t)]},qf=a=>{let t=a.attributes.getString(\"auto_pad\",\"NOTSET\"),o=a.attributes.getInt(\"ceil_mode\",0),e=a.attributes.getInt(\"count_include_pad\",0)!==0,r=a.attributes.getInts(\"kernel_shape\"),n=a.attributes.getInts(\"strides\",[]),s=a.attributes.getInts(\"pads\",[]);if(o!==0)throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");return ee({autoPad:t,ceilMode:o,countIncludePad:e,kernelShape:r,strides:n,pads:s})},jf=(a,t,o,e)=>{let[r,n]=Qf(a,e,o),s=U.size(r.kernelShape),i=\"value += _X(x);\",u=\"\";r.countIncludePad?u+=`value /= float(${s});`:u+=`value /= float(${s} - pad);`;let f=`\n        ${tc(a[0].dims,r,i,u,\"0.0\")}\n      `;return{...t,output:{dims:n,type:a[0].type,textureType:0},shaderSource:f}},Yf=(a,t,o)=>{uo(t);let e={name:\"GlobalAveragePool\",inputNames:[\"X\"],inputTypes:[0],cacheHint:`${o.countIncludePad}`};return[a.run({...e,get:()=>jf(t,e,!0,o)},t)]},Xf=a=>{let t=a.attributes.getInt(\"count_include_pad\",0)!==0;return ee({autoPad:\"\",ceilMode:0,countIncludePad:t,kernelShape:[],strides:[],pads:[]})},Kf=(a,t,o)=>{uo(t);let e={name:\"MaxPool\",inputNames:[\"X\"],inputTypes:[0],cacheHint:o.cacheKey};return[a.run({...e,get:()=>Zf(t,e,!1,o)},t)]},Jf=a=>{let t=a.attributes.getString(\"auto_pad\",\"NOTSET\"),o=a.attributes.getInt(\"ceil_mode\",0),e=a.attributes.getInts(\"kernel_shape\"),r=a.attributes.getInts(\"strides\",[]),n=a.attributes.getInts(\"pads\",[]),s=a.attributes.getInt(\"storage_order\",0),i=a.attributes.getInts(\"dilations\",[]);if(s!==0)throw new Error(\"column major storage order is not yet supported for MaxPool\");if(o!==0)throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");return ee({autoPad:t,ceilMode:o,countIncludePad:!1,kernelShape:e,strides:r,pads:n,storageOrder:s,dilations:i})},Zf=(a,t,o,e)=>{let[r,n]=Qf(a,e,o),s=`\n      value = max(_X(x), value);\n    `,i=\"\",l=`\n      ${tc(a[0].dims,r,s,i,\"-1e5\")}\n    `;return{...t,output:{dims:n,type:a[0].type,textureType:0},shaderSource:l}},Qf=(a,t,o)=>{let e=a[0].dims.slice(),r=Object.hasOwnProperty.call(t,\"dilations\"),n=t.kernelShape.slice(),s=t.strides.slice(),i=r?t.dilations.slice():[],u=t.pads.slice();dr.adjustPoolAttributes(o,e,n,s,i,u);let l=dr.computePoolOutputShape(o,e,s,i,n,u,t.autoPad),f=Object.assign({},t);return r?Object.assign(f,{kernelShape:n,strides:s,pads:u,dilations:i,cacheKey:t.cacheKey}):Object.assign(f,{kernelShape:n,strides:s,pads:u,cacheKey:t.cacheKey}),[f,l]},yb={autoPad:\"\",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:\"\"},Wf={name:\"GlobalMaxPool\",inputNames:[\"X\"],inputTypes:[0]},ec=(a,t)=>(uo(t),[a.run({...Wf,get:()=>Zf(t,Wf,!0,yb)},t)]),uo=a=>{if(!a||a.length!==1)throw new Error(\"Pool ops requires 1 input.\");if(a[0].type!==\"float32\"&&a[0].type!==\"float64\")throw new Error(\"Invalid input type.\")},tc=(a,t,o,e,r)=>{let n=a.length;if(t.kernelShape.length<=2){let s=t.kernelShape[t.kernelShape.length-1],i=t.strides[t.strides.length-1],u=t.pads[t.pads.length/2-1],l=t.pads[t.pads.length-1],f=a[n-1],p=\"\",d=\"\",T=\"\";if(u+l!==0?p=`\n          for (int i = 0; i < ${s}; i++) {\n            x[${n} - 1] = indices[${n} - 1] * ${i} - ${u} + i;\n            if (x[${n} - 1] < 0 || x[${n} - 1] >= ${f}) {\n              pad++;\n              continue;\n            }\n            ${o}\n          }`:p=`\n          for (int i = 0; i < ${s}; i++) {\n            x[${n} - 1] = indices[${n} - 1] * ${i} - ${u} + i;\n            ${o}\n          }`,t.kernelShape.length===2){let w=t.kernelShape[t.kernelShape.length-2],I=t.strides[t.strides.length-2],L=t.pads[t.pads.length/2-2],F=t.pads[t.pads.length-2],C=a[n-2];L+F!==0?d=`\n            for (int j = 0; j < ${w}; j++) {\n              x[${n} - 2] = indices[${n} - 2] * ${I} - ${L} + j;\n              if (x[${n} - 2] < 0 || x[${n} - 2] >= ${C}) {\n                pad+= ${s};\n                continue;\n              }\n          `:d=`\n            for (int j = 0; j < ${w}; j++) {\n              x[${n} - 2] = indices[${n} - 2] * ${I} - ${L} + j;\n            `,T=`\n          }\n        `}return`\n        float process(int indices[${n}]) {\n          int x[${n}];\n          copyVec(indices, x);\n\n          float value = ${r};\n          int pad = 0;\n          ${d}\n          ${p}\n          ${T}\n          ${e}\n          return value;\n        }\n      `}else{let s=U.size(t.kernelShape),i=U.computeStrides(t.kernelShape),u=i.length,l=t.pads.length,f=Tb(u),p=so(a,\"inputDims\"),d=so(t.pads,\"pads\"),T=so(i,\"kernelStrides\"),v=so(t.strides,\"strides\"),w=t.pads.reduce((F,C)=>F+C),I=\"\";return w?I=`\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${o}\n          }`:I=`\n          }\n          ${o}\n        `,`\n        ${f}\n        float process(int indices[${n}]) {\n          int x[${n}];\n          copyVec(indices, x);\n          int offset[${u}];\n          int pads[${l}];\n          int inputDims[${n}];\n          int kernelStrides[${u}];\n          int strides[${u}];\n          ${d}\n          ${p}\n          ${v}\n          ${T}\n\n          float value = ${r};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${s}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${n} - ${u}; j < ${n}; j++) {\n              x[j] = indices[j] * strides[j - ${n} + ${u}]\n                + offset[j - ${n} + ${u}] - pads[j - 2];\n              ${I}\n          }\n          ${e}\n\n          return value;\n        }\n      `}},so=(a,t)=>{let o=\"\";for(let e=0;e<a.length;e++)o+=`\n      ${t}[${e}] = ${a[e]};\n    `;return o},Tb=a=>`\n  void offsetToIndices(int offset, int[${a}] strides, out int[${a}] indices) {\n    if (${a} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${a} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${a} - 1] = offset;\n  }`});var xr,Zt,xb,wb,nc,oc,ic,ac,sc,uc,lc,fc=E(()=>{\"use strict\";Ge();hn();fe();ae();xr=(a,t,o,e,r)=>{wb(t);let n={name:e,inputNames:[\"A\"],inputTypes:[0]};return[a.run({...n,cacheHint:o.cacheKey,get:()=>xb(a,t,o,e,r,n)},t)]},Zt=a=>{let t=a.attributes.getInts(\"axes\",[]),o=a.attributes.getInt(\"keepdims\",1)===1;return ee({axes:t,keepDims:o})},xb=(a,t,o,e,r,n)=>{let s=[],i=t[0].dims.length||1,u=[],l=U.normalizeAxes(o.axes,t[0].dims.length),f=r(t,l),p=f[1];for(let v=0;v<t[0].dims.length;v++)l.indexOf(v)>=0||l.length===0?(o.keepDims&&s.push(1),p=`\n          for(int j${v} = 0; j${v} < ${t[0].dims[v]}; j${v}++) {\n            inputIdx[${v}] = j${v};\n            ${p}\n          }`):(u.push(`inputIdx[${v}] = outputIdx[${s.length}];`),s.push(t[0].dims[v]));let T=`\n      float process(int outputIdx[${s.length||1}]) {\n        float value;                 // final result\n        int inputIdx[${i}];      // addressing input data\n        ${u.join(`\n`)}\n        ${f[0]}       // init ops for reduce max/min\n        ${p}\n        ${f[2]}       // final computation for reduce mean\n        return value;\n      }`;return{...n,output:{dims:s,type:t[0].type,textureType:0},shaderSource:T}},wb=a=>{if(!a||a.length!==1)throw new Error(\"Reduce op requires 1 input.\");if(Jt.indexOf(a[0].type)===-1)throw new Error(\"Invalid input type.\")},nc=(a,t,o)=>xr(a,t,o,\"ReduceSum\",()=>[\"value = 0.0;\",\"value += _A(inputIdx);\",\"\"]),oc=(a,t,o)=>xr(a,t,o,\"ReduceMean\",(r,n)=>{let s=1;for(let i=0;i<r[0].dims.length;i++)(n.indexOf(i)>=0||n.length===0)&&(s*=r[0].dims[i]);return[\"value = 0.0;\",\"value += _A(inputIdx);\",`value /= ${s}.;`]}),ic=(a,t,o)=>xr(a,t,o,\"ReduceMax\",(r,n)=>{let s=[];for(let i=0;i<r[0].dims.length;i++)(n.indexOf(i)>=0||n.length===0)&&s.push(`inputIdx[${i}] = 0;`);return[`${s.join(`\n`)}\nvalue = _A(inputIdx);`,\"value = max(value, _A(inputIdx));\",\"\"]}),ac=(a,t,o)=>xr(a,t,o,\"ReduceMin\",(r,n)=>{let s=[];for(let i=0;i<r[0].dims.length;i++)(n.indexOf(i)>=0||n.length===0)&&s.push(`inputIdx[${i}] = 0;`);return[`${s.join(`\n`)}\nvalue = _A(inputIdx);`,\"value = min(value, _A(inputIdx));\",\"\"]}),sc=(a,t,o)=>xr(a,t,o,\"ReduceProd\",()=>[\"value = 1.0;\",\"value *= _A(inputIdx);\",\"\"]),uc=(a,t,o)=>xr(a,t,o,\"ReduceLogSum\",()=>[\"value = 0.0;\",\"value += _A(inputIdx);\",\"value = log(value);\"]),lc=(a,t,o)=>xr(a,t,o,\"ReduceLogSumSquare\",()=>[\"float t; value = 0.0;\",\"t = _A(inputIdx); value += t * t;\",\"\"])});var cc,pc=E(()=>{\"use strict\";fe();cc=(a,t)=>{let o=U.calculateReshapedDims(t[0].dims,t[1].integerData);return a.session.pack?[a.reshapePacked(t[0],o)]:[a.reshapeUnpacked(t[0],o)]}});var dc,Ni,hc,mc,mn,vb,Ri,lo,Mi=E(()=>{\"use strict\";Ge();xe();ae();dc={name:\"Upsample\",inputNames:[\"X\"],inputTypes:[0]},Ni=(a,t,o)=>(Ri(t,o),[a.run({...dc,cacheHint:o.cacheKey,get:()=>vb(a,t,o)},t)]),hc=a=>mn(a,7),mc=a=>mn(a,9),mn=(a,t)=>{let o=t>=10,e=a.attributes.getString(\"mode\",\"nearest\");if(e!==\"nearest\"&&e!==\"linear\"&&(t<11||e!==\"cubic\"))throw new Error(`unrecognized mode: ${e}`);let r=[];t<9&&(r=a.attributes.getFloats(\"scales\"),lo(r,e,o));let n=a.attributes.getFloat(\"extrapolation_value\",0),s=t>10?a.attributes.getString(\"coordinate_transformation_mode\",\"half_pixel\"):\"asymmetric\";if([\"asymmetric\",\"pytorch_half_pixel\",\"tf_half_pixel_for_nn\",\"align_corners\",\"tf_crop_and_resize\",\"half_pixel\"].indexOf(s)===-1)throw new Error(`coordinate_transform_mode '${s}' is not supported`);let i=s===\"tf_crop_and_resize\",u=i,l=e===\"nearest\"&&t>=11?a.attributes.getString(\"nearest_mode\",\"round_prefer_floor\"):\"\";if([\"round_prefer_floor\",\"round_prefer_ceil\",\"floor\",\"ceil\",\"\"].indexOf(l)===-1)throw new Error(`nearest_mode '${l}' is not supported`);let f=a.attributes.getFloat(\"cubic_coeff_a\",-.75),p=a.attributes.getInt(\"exclude_outside\",0)!==0;if(p&&e!==\"cubic\")throw new Error(\"exclude_outside can be set to 1 only when mode is CUBIC.\");let d=t<11?!0:e===\"nearest\"&&s===\"asymmetric\"&&l===\"floor\",T=0,v=0,w=0;return t>10?a.inputs.length>2?(T=1,v=2,w=3):(v=1,w=2):t===9&&(v=1),ee({opset:t,isResize:o,mode:e,scales:r,extrapolationValue:n,coordinateTransformMode:s,useExtrapolation:u,needRoiInput:i,nearestMode:l,cubicCoefficientA:f,excludeOutside:p,useNearest2xOptimization:d,roiInputIdx:T,scalesInputIdx:v,sizesInputIdx:w})},vb=(a,t,o)=>{let e=q(a.session.backend.glContext.version),[r,n]=a.calculateTextureWidthAndHeight(t[0].dims,0),s=t[0].dims.map((w,I)=>Math.floor(w*o.scales[I])),[i,u]=a.calculateTextureWidthAndHeight(s,0),l=s.length,f=new Array(l),p=new Array(l),d=`\n      int output_pitches[${l}];\n      int input_pitches[${l}];\n      `;for(let w=l-1;w>=0;w--)f[w]=w===l-1?1:f[w+1]*s[w+1],p[w]=w===l-1?1:p[w+1]*t[0].dims[w+1],d+=`\n        output_pitches[${w}] = ${f[w]};\n        input_pitches[${w}] = ${p[w]};\n        `;let T=`\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${r}, ${n});\n        float value = getColorAsFloat(${e.texture2D}(X, coords));\n        return value;\n      }\n      `,v=o.mode===\"nearest\"?`\n    ${T}\n    float process(int indices[${l}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${i}, ${u});\n\n      ${d}\n\n      int d, m;\n      for (int dim = 0; dim < ${l}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }`:l===4?`\n    ${T}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${i}, ${u});\n\n      ${d}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${t[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }`:`\n    ${T}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${i}, ${u});\n\n      ${d}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${t[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;return{...dc,output:{dims:s,type:t[0].type,textureType:0},shaderSource:v,variables:[{name:\"scales\",type:\"int\",arrayLength:o.scales.length,data:o.scales.map(w=>Math.ceil(w))}]}},Ri=(a,t)=>{if(!a||t.opset<9&&a.length!==1||t.opset>=9&&t.opset<11&&a.length!==2||t.opset>=11&&a.length<2)throw new Error(\"invalid inputs.\");if(t.scales.length>0&&a[0].dims.length!==t.scales.length)throw new Error(\"Invalid input shape.\");if(a[0].type===\"string\")throw new Error(\"Invalid input tensor types.\")},lo=(a,t,o)=>{if(o){for(let e of a)if(e<=0)throw new Error(\"Scale value should be greater than 0.\")}else for(let e of a)if(e<1)throw new Error(\"Scale value should be greater than or equal to 1.\");if((t===\"linear\"||t===\"cubic\")&&a.length!==2&&(a.length!==4||a[0]!==1||a[1]!==1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${o?\"Resize\":\"Upsample\"} opeartor.`)}});var Gi,Ui,bc,gc,_b,Ob,Ib,Sb,yc=E(()=>{\"use strict\";xe();ae();kt();gr();Mi();Gi={name:\"Resize\",inputNames:[\"A\"],inputTypes:[2]},Ui=(a,t,o)=>(Ri(t,o),[a.run({...Gi,cacheHint:o.cacheKey,get:()=>_b(a,t,o)},t)]),bc=a=>mn(a,10),gc=a=>mn(a,11),_b=(a,t,o)=>{let e=q(a.session.backend.glContext.version),[r,n]=Ob(t,o);if(r.every(C=>C===1)&&o.coordinateTransformMode!==\"tf_crop_and_resize\")return{...Gi,output:{dims:n,type:t[0].type,textureType:2},hasMain:!0,shaderSource:`void main() {\n                    vec4 v = ${e.texture2D}(X, TexCoords);\n                    ${e.output} = v;\n                }`};let i=n.length;if(i<2)throw new Error(`output dimension should be at least 2, but got ${i}`);let u=n[i-2],l=n[i-1],f=t[0].dims;if(i!==f.length)throw new Error(`output dimension should match input ${f.length}, but got ${i}`);let p=f[i-2],d=f[i-1],T=r[i-2],v=r[i-1],w=\"\";if(o.mode!==\"linear\")throw new Error(`resize (packed) does not support mode: '${o.mode}'`);switch(o.coordinateTransformMode){case\"asymmetric\":w=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                `;break;case\"half_pixel\":w=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                `;break;case\"pytorch_half_pixel\":w=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${l}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${u}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${l}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${u}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;break;case\"align_corners\":w=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${l}.0 - 1.0, ${u}.0 - 1.0, ${l}.0 - 1.0,\n                            ${u}.0 - 1.0);\n                        vec4 original = vec4(${d}.0 - 1.0, ${p}.0 - 1.0, ${d}.0 - 1.0,\n                            ${p}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${o.coordinateTransformMode}'`)}let I=Je(i),L=Bt(),F=`\n            const vec2 inputWH = vec2(${p}.0, ${d}.0);\n            const vec4 scaleWHWH = vec4(float(${T}), float(${v}), float(${T}), float(${v}));\n            ${L}\n            ${w}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${I} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${u-1};\n                bool hasNextCol = rc.z < ${l-1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${e.output} = vec4(newValue);\n            }\n        `;return{...Gi,output:{dims:n,type:t[0].type,textureType:2},hasMain:!0,shaderSource:F}},Ob=(a,t)=>{let e=a[0].dims,r=t.scales,n;if(r.length===0){let i=a[t.scalesInputIdx];if(i&&i.size!==0){if(a[t.sizesInputIdx])throw new Error(\"Only one of scales or sizes must be provided as input.\");r=Ib(i,t.mode,t.isResize)}else{let u=a[t.sizesInputIdx];if(!u||u.size===0)throw new Error(\"Either scales or sizes MUST be provided as input.\");n=Array.from(u.integerData),r=Sb(n,e,t.mode,t.isResize)}}else if(a[t.sizesInputIdx])throw new Error(\"Only one of scales or sizes must be provided as input.\");let s=n||e.map((i,u)=>Math.floor(i*r[u]));return[r,s]},Ib=(a,t,o)=>{let e=Array.from(a.floatData);return lo(e,t,o),e},Sb=(a,t,o,e)=>{let r=t.length,n=new Array(r);for(let s=0,i=r;s<i;s++)if(t[s]===0){if(a[s]!==0)throw new Error(\"Input dim is zero but required output dim is non-zero.\");n[s]=1}else n[s]=a[s]/t[s];return lo(n,o,e),n}});var Tc,Ab,xc=E(()=>{\"use strict\";br();Tc=(a,t)=>(Ab(t),[new Ce([t[0].dims.length],\"int32\",void 0,void 0,new Int32Array(t[0].dims))]),Ab=a=>{if(!a||a.length!==1)throw new Error(\"Shape requires 1 input.\")}});var zi,wc,vc,_c,Pb,Oc,Eb,Db,Ic=E(()=>{\"use strict\";Ge();hn();fe();ae();zi={name:\"Slice\",inputNames:[\"A\"],inputTypes:[0]},wc=(a,t,o)=>(Pb(t),[a.run({...zi,cacheHint:o.cacheKey,get:()=>_c(a,t[0],o)},t)]),vc=a=>{let t=a.attributes.getInts(\"starts\"),o=a.attributes.getInts(\"ends\"),e=a.attributes.getInts(\"axes\",[]);return ee({starts:t,ends:o,axes:e})},_c=(a,t,o)=>{let e=o.axes.length===0?t.dims.slice(0).map((p,d)=>d):o.axes,r=U.normalizeAxes(e,t.dims.length),n=o.starts.map((p,d)=>p>t.dims[r[d]]-1?t.dims[r[d]]:U.normalizeAxis(p,t.dims[r[d]])),s=o.ends.map((p,d)=>p>t.dims[r[d]]-1?t.dims[r[d]]:U.normalizeAxis(p,t.dims[r[d]])),i=t.dims.slice(),u=[];for(let p=0;p<r.length;p++)i[r[p]]=s[p]-n[p],n[p]>0&&u.push(`outputIdx[${r[p]}] += ${n[p]};`);let f=`\n      float process(int outputIdx[${i.length}]) {\n        ${u.join(`\n      `)}\n        return _A(outputIdx);\n      }`;return{...zi,output:{dims:i,type:t.type,textureType:0},shaderSource:f}},Pb=a=>{if(!a||a.length!==1)throw new Error(\"Slice requires 1 input.\");if(Jt.indexOf(a[0].type)===-1)throw new Error(\"Invalid input type.\")},Oc=(a,t)=>{Db(t);let o=Eb(a,t);return[a.run({...zi,cacheHint:o.cacheKey,get:()=>_c(a,t[0],o)},[t[0]])]},Eb=(a,t)=>{if(!a.session.isInitializer(t[1].dataId)||!a.session.isInitializer(t[2].dataId)||t.length>=4&&!a.session.isInitializer(t[3].dataId)||t.length>=5&&!a.session.isInitializer(t[4].dataId))throw new Error(\"dynamic slice attributes are not allowed\");if(t.length>=5&&t[4].integerData.some(s=>s!==1))throw new Error(\"currently non-1 steps is not supported for Slice\");let o=Array.from(t[1].integerData),e=Array.from(t[2].integerData),r=t.length>=4?Array.from(t[3].integerData):[],n=`${r};${o};${e}`;return{starts:o,ends:e,axes:r,cacheKey:n}},Db=a=>{if(!a||a.length<3||a.length>5)throw new Error(\"Invalid input number.\");if(a[1].type!==\"int32\"||a[1].dims.length!==1)throw new Error(\"Invalid input type.\");if(a[2].type!==\"int32\"||a[2].dims.length!==1)throw new Error(\"Invalid input type.\");if(a.length>=4&&(a[3].type!==\"int32\"||a[3].dims.length!==1))throw new Error(\"Invalid input type.\");if(a.length>=5&&(a[4].type!==\"int32\"||a[4].dims.length!==1))throw new Error(\"Invalid input type.\")}});var Sc,Ac,Pc,Ec,Dc,Lc,Fc,Cc,Lb,Fb,Cb,$c,kc=E(()=>{\"use strict\";Ge();fe();xe();ae();ao();Sc={name:\"SoftmaxComputeMax\",inputNames:[\"A\"],inputTypes:[0]},Ac={name:\"SoftmaxComputeScale\",inputNames:[\"A\",\"Max\"],inputTypes:[0,0]},Pc={name:\"SoftMax\",inputNames:[\"A\",\"Max\",\"Norm\"],inputTypes:[0,0,0]},Ec=(a,t,o)=>{$c(t);let e=t[0].dims.slice(),r=U.normalizeAxis(o.axis,e.length),n=U.sizeToDimension(e,r),s=U.sizeFromDimension(e,r);return Cc(a,t,o,n,s)},Dc=a=>ee({axis:a.attributes.getInt(\"axis\",1)}),Lc=a=>ee({axis:a.attributes.getInt(\"axis\",-1)}),Fc=(a,t,o)=>{$c(t);let e=t[0].dims.slice(),r=U.normalizeAxis(o.axis,e.length),n=e.length,s=r!==n-1,i=[],u=[],l=[],f;s&&(u=Array.from({length:n}).map((v,w)=>w),u[r]=n-1,u[n-1]=r,u.map(v=>i.push(e[v])),f=ee({perm:u}),l=Tr(a,t,f));let p=s?U.sizeToDimension(i,n-1):U.sizeToDimension(e,n-1),d=s?U.sizeFromDimension(i,n-1):U.sizeFromDimension(e,n-1),T=Cc(a,s?l:t,o,p,d);return s?Tr(a,T,f):T},Cc=(a,t,o,e,r)=>{let n=Lb(a,t[0],e,r,[e]),s=a.run({...Sc,cacheHint:o.cacheKey,get:()=>n},t),i=Fb(a,t[0],e,r,n.output.dims,[e]),u=a.run({...Ac,cacheHint:o.cacheKey,get:()=>i},[t[0],s]),l=Cb(a,t[0],e,r,n.output.dims,i.output.dims);return[a.run({...Pc,cacheHint:o.cacheKey,get:()=>l},[t[0],s,u])]},Lb=(a,t,o,e,r)=>{let[n,s]=a.calculateTextureWidthAndHeight(t.dims,0),i=r.length;if(o<1||e<1)throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");if(r.length!==1)throw new Error(\"Dimensionality of the output should be 1\");if(r[0]!==o)throw new Error(\"Shape of the output should be equal to logical row count\");let u=q(a.session.backend.glContext.version),l=`\n      float process(int[${i}] indices) {\n        int logical_row_start_offset = indices[0] * ${e};\n\n        float max = getColorAsFloat(${u.texture2D}(A, offsetToCoords(logical_row_start_offset, ${n},\n        ${s} )));\n        for(int i=1; i<${e}; ++i)\n        {\n          float current = getColorAsFloat(${u.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${n}, ${s})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;return{...Sc,output:{dims:r,type:t.type,textureType:0},shaderSource:l}},Fb=(a,t,o,e,r,n)=>{let[s,i]=a.calculateTextureWidthAndHeight(t.dims,0),u=n.length;if(o<1||e<1)throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");if(n.length!==1)throw new Error(\"Dimensionality of the output should be 1\");if(n[0]!==o)throw new Error(\"Shape of the output should be equal to logical row count\");if(r.length!==1)throw new Error(\"Dimensionality of the intermediate results should be 1\");if(r[0]!==o)throw new Error(\"Shape of the intermediate results should be equal to logical row count\");let l=q(a.session.backend.glContext.version),f=`\n      float process(int[${u}] indices) {\n        int logical_row_start_offset = indices[0] * ${e};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${e}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${l.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${s}, ${i}))) - max);\n        }\n\n        return norm_factor;\n      }`;return{...Ac,output:{dims:n,type:t.type,textureType:0},shaderSource:f}},Cb=(a,t,o,e,r,n)=>{let[s,i]=a.calculateTextureWidthAndHeight(t.dims,0),u=t.dims.length;if(o<1||e<1)throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");if(r.length!==1||n.length!==1)throw new Error(\"Dimensionality of the intermediate results should be 1\");if(r[0]!==o||n[0]!==o)throw new Error(\"Shape of the intermediate results should be equal to logical row count\");let l=`\n      float process(int[${u}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${s}, ${i});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${e};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;return{...Pc,output:{dims:t.dims,type:t.type,textureType:0},shaderSource:l}},$c=a=>{if(!a||a.length!==1)throw new Error(\"Softmax requires 1 input.\");if(a[0].type!==\"float32\"&&a[0].type!==\"float64\")throw new Error(\"Invalid input type\")}});var Bc,Nc,Rc,$b,kb,Bb,Mc=E(()=>{\"use strict\";Ge();fe();ae();Bc={name:\"Split\",inputNames:[\"A\"],inputTypes:[0]},Nc=(a,t,o)=>{Bb(t);let e=U.normalizeAxis(o.axis,t[0].dims.length),r=$b(a,t,e,o),n=[];for(let s=0;s<r;++s)n.push(a.run({...Bc,cacheHint:`${o.cacheKey};${s}`,get:()=>kb(a,t[0],o,e,s)},t));return n},Rc=a=>{let t=a.attributes.getInt(\"axis\",0),o=a.attributes.getInts(\"split\",[]),e=a.outputs.length;return ee({axis:t,split:o,numOutputs:e})},$b=(a,t,o,e)=>{let[,r]=un.splitShape(t[0].dims,o,e.split,e.numOutputs);return r.length},kb=(a,t,o,e,r)=>{let[n,s]=un.splitShape(t.dims,e,o.split,o.numOutputs),i=s[r],u=n[r],f=`\n      float process(int indices[${u.length}]) {\n        indices[${e}] += ${i};\n        return _A(indices);\n      }\n    `;return{...Bc,cacheHint:`${o.cacheKey}:${r}`,output:{dims:u,type:t.type,textureType:0},shaderSource:f}},Bb=a=>{if(!a||a.length!==1)throw new Error(\"Split requires one input.\");if(a[0].type!==\"int8\"&&a[0].type!==\"uint8\"&&a[0].type!==\"int16\"&&a[0].type!==\"uint16\"&&a[0].type!==\"int32\"&&a[0].type!==\"uint32\"&&a[0].type!==\"float32\"&&a[0].type!==\"float64\"&&a[0].type!==\"bool\")throw new Error(\"Invalid input type.\")}});var Vi,Gc,Uc,Nb,Rb,zc=E(()=>{\"use strict\";fe();Vi=(a,t,o)=>{Nb(t);let e=U.squeezeShape(t[0].dims,o);return[a.reshapeUnpacked(t[0],e)]},Gc=(a,t)=>(Rb(t),Vi(a,[t[0]],Array.from(t[1].integerData))),Uc=a=>a.attributes.getInts(\"axes\"),Nb=a=>{if(!a||a.length!==1)throw new Error(\"Squeeze requires 1 input.\");if(a[0].type===\"string\")throw new Error(\"invalid input tensor types.\")},Rb=a=>{if(!a||a.length!==2)throw new Error(\"Squeeze requires 2 inputs.\");if(a[1].type!==\"int32\")throw new Error(\"Invalid input type.\")}});var Vc,Mb,Gb,Wc=E(()=>{\"use strict\";xe();ae();Vc=(a,t)=>{Gb(t);let o={name:\"Sum\",inputNames:t.map((r,n)=>`X${n}`),inputTypes:new Array(t.length).fill(0)};return[a.run({...o,get:()=>Mb(a,t,o)},t)]},Mb=(a,t,o)=>{let e=q(a.session.backend.glContext.version),r=t[0].dims.slice(),s=`\n      void main() {\n        vec4 result = ${t.map((i,u)=>`${e.texture2D}(X${u},TexCoords)`).join(\" + \")};\n        ${e.output} = result;\n      }\n    `;return{...o,output:{dims:r,type:t[0].type,textureType:0},hasMain:!0,shaderSource:s}},Gb=a=>{if(!a||a.length===0)throw new Error(\"Sum requires inputs.\");let t=a[0].dims.length;for(let o=1;o<a.length;o++){if(t!==a[o].dims.length)throw new Error(\"Input shapes are mismatched.\");for(let e=0;e<t;e++)if(a[0].dims[e]!==a[o].dims[e])throw new Error(\"Input shapes are not matched.\")}if(a[0].type!==\"float32\"&&a[0].type!==\"float64\")throw new Error(\"Invalid input type.\");for(let o=1;o<a.length;o++)if(a[0].type!==a[o].type)throw new Error(\"Input types are not matched.\")}});var Hc,Ub,zb,qc=E(()=>{\"use strict\";hn();ae();Hc=(a,t)=>{zb(t);let o={name:\"Tile\",inputNames:[\"A\"],inputTypes:[0]};return[a.run({...o,get:()=>Ub(a,t,o)},t)]},Ub=(a,t,o)=>{let e=t[0].dims.slice(),r=new Array(e.length),n=[];for(let u=0;u<e.length;u++)r[u]=e[u]*t[1].numberData[u],n.push(`inputIdx[${u}] = int(mod(float(outputIdx[${u}]), ${e[u]}.));`);let s=r.length,i=`\n      float process(int outputIdx[${s}]) {\n        int inputIdx[${s}];\n        ${n.join(`\n`)}\n        return _A(inputIdx);\n      }\n    `;return{...o,output:{dims:r,type:t[0].type,textureType:0},shaderSource:i}},zb=a=>{if(!a||a.length!==2)throw new Error(\"Tile requires 2 input.\");if(a[1].dims.length!==1)throw new Error(\"The second input shape must 1 dimension.\");if(a[1].dims[0]!==a[0].dims.length)throw new Error(\"Invalid input shape.\");if(Jt.indexOf(a[0].type)===-1)throw new Error(\"Invalid input type.\");if(a[1].type!==\"int32\"&&a[1].type!==\"int16\")throw new Error(\"Invalid repeat type.\")}});var Wi,jc,Yc,Vb,Wb,Xc=E(()=>{\"use strict\";fe();Wi=(a,t,o)=>{Vb(t);let e=U.unsqueezeShape(t[0].dims,o);return[a.reshapeUnpacked(t[0],e)]},jc=(a,t)=>(Wb(t),Wi(a,[t[0]],Array.from(t[1].integerData))),Yc=a=>a.attributes.getInts(\"axes\"),Vb=a=>{if(!a||a.length!==1)throw new Error(\"Unsqueeze requires 1 input.\");if(a[0].type===\"string\")throw new Error(\"invalid input tensor types.\")},Wb=a=>{if(!a||a.length!==2)throw new Error(\"Unsqueeze requires 2 inputs.\");if(a[1].type!==\"int32\")throw new Error(\"Invalid input type.\")}});var Kc,Jc=E(()=>{\"use strict\";al();Tl();vl();Pl();no();pf();yf();wf();Of();Pf();Lf();kf();Mf();oo();Vf();rc();fc();pc();yc();xc();Ic();kc();Mc();zc();Wc();qc();ao();Ai();Xc();Mi();Kc=[[\"Abs\",\"\",\"6+\",El],[\"Acos\",\"\",\"7+\",Dl],[\"Add\",\"\",\"7+\",sl],[\"And\",\"\",\"7+\",ul],[\"Asin\",\"\",\"7+\",Ll],[\"Atan\",\"\",\"7+\",Fl],[\"AveragePool\",\"\",\"7+\",Hf,qf],[\"BatchNormalization\",\"\",\"7+\",ol,il],[\"Cast\",\"\",\"6+\",xl,wl],[\"Ceil\",\"\",\"6+\",kl],[\"Clip\",\"\",\"6-10\",Ii,Cl],[\"Clip\",\"\",\"11+\",$l],[\"Concat\",\"\",\"4+\",Il,Al],[\"Conv\",\"\",\"1+\",Ci,$i],[\"ConvTranspose\",\"\",\"1+\",ff,cf],[\"Cos\",\"\",\"7+\",Bl],[\"Div\",\"\",\"7+\",ll],[\"Dropout\",\"\",\"7+\",Si],[\"DepthToSpace\",\"\",\"1+\",bf,gf],[\"Equal\",\"\",\"7+\",fl],[\"Elu\",\"\",\"6+\",Nl,Rl],[\"Exp\",\"\",\"6+\",Ml],[\"Flatten\",\"\",\"1+\",Tf,xf],[\"Floor\",\"\",\"6+\",Gl],[\"FusedConv\",\"com.microsoft\",\"1+\",Ci,$i],[\"Gather\",\"\",\"1+\",vf,_f],[\"Gemm\",\"\",\"7-10\",ki,Sf],[\"Gemm\",\"\",\"11+\",ki,Af],[\"GlobalAveragePool\",\"\",\"1+\",Yf,Xf],[\"GlobalMaxPool\",\"\",\"1+\",ec],[\"Greater\",\"\",\"7+\",cl],[\"Identity\",\"\",\"1+\",Si],[\"ImageScaler\",\"\",\"1+\",Ef,Df],[\"InstanceNormalization\",\"\",\"6+\",Cf,$f],[\"LeakyRelu\",\"\",\"6+\",Ul,zl],[\"Less\",\"\",\"7+\",pl],[\"LRN\",\"\",\"1+\",Bf,Nf],[\"Log\",\"\",\"6+\",Vl],[\"MatMul\",\"\",\"1+\",rf,nf],[\"MaxPool\",\"\",\"1+\",Kf,Jf],[\"Mul\",\"\",\"7+\",dl],[\"Neg\",\"\",\"6+\",Wl],[\"Not\",\"\",\"1+\",Hl],[\"Or\",\"\",\"7+\",hl],[\"Pad\",\"\",\"2-10\",Bi,Gf],[\"Pad\",\"\",\"11+\",Uf,zf],[\"Pow\",\"\",\"7+\",ml],[\"PRelu\",\"\",\"7+\",bl],[\"ReduceLogSum\",\"\",\"1+\",uc,Zt],[\"ReduceMax\",\"\",\"1+\",ic,Zt],[\"ReduceMean\",\"\",\"1+\",oc,Zt],[\"ReduceMin\",\"\",\"1+\",ac,Zt],[\"ReduceProd\",\"\",\"1+\",sc,Zt],[\"ReduceSum\",\"\",\"1-12\",nc,Zt],[\"ReduceSumSquare\",\"\",\"1+\",lc,Zt],[\"Relu\",\"\",\"6+\",ql],[\"Reshape\",\"\",\"5+\",cc],[\"Resize\",\"\",\"10\",Ui,bc],[\"Resize\",\"\",\"11+\",Ui,gc],[\"Shape\",\"\",\"1+\",Tc],[\"Sigmoid\",\"\",\"6+\",jl],[\"Sin\",\"\",\"7+\",Yl],[\"Slice\",\"\",\"10+\",Oc],[\"Slice\",\"\",\"1-9\",wc,vc],[\"Softmax\",\"\",\"1-12\",Ec,Dc],[\"Softmax\",\"\",\"13+\",Fc,Lc],[\"Split\",\"\",\"2-12\",Nc,Rc],[\"Sqrt\",\"\",\"6+\",Xl],[\"Squeeze\",\"\",\"1-12\",Vi,Uc],[\"Squeeze\",\"\",\"13+\",Gc],[\"Sub\",\"\",\"7+\",gl],[\"Sum\",\"\",\"6+\",Vc],[\"Tan\",\"\",\"7+\",Kl],[\"Tanh\",\"\",\"6+\",Jl],[\"Tile\",\"\",\"6+\",Hc],[\"Transpose\",\"\",\"1+\",Tr,hf],[\"Upsample\",\"\",\"7-8\",Ni,hc],[\"Upsample\",\"\",\"9\",Ni,mc],[\"Unsqueeze\",\"\",\"1-12\",Wi,Yc],[\"Unsqueeze\",\"\",\"13+\",jc],[\"Xor\",\"\",\"7+\",yl]]});function Qc(a){let t={},o;for(;(o=Zc.exec(a))!==null;){let e=o[3].split(\",\").map(r=>{let n=r.trim().split(\" \");return n&&n.length===2?{type:n[0],name:n[1]}:null}).filter(r=>r!==null);t[o[2]]={params:e,body:o[4]}}for(let e in t){let r=Hb.replace(\"__FUNC__\",e),n=new RegExp(r,\"gm\");for(;(o=n.exec(a))!==null;){let s=o[1],i=o[2],u=o[3].split(\",\"),l=s?`${s} ${i};`:\"\",f=t[e].body,p=\"\";t[e].params.forEach((T,v)=>{T&&(p+=`${T.type} ${T.name} = ${u[v]};\n`)}),f=`${p}\n ${f}`,f=f.replace(\"return\",`${i} = `);let d=`\n      ${l}\n      {\n        ${f}\n      }\n      `;a=a.replace(o[0],d)}}return a=a.replace(Zc,\"\"),a}var Zc,Hb,ep=E(()=>{\"use strict\";Zc=/@inline[\\s\\n\\r]+(\\w+)[\\s\\n\\r]+([0-9a-zA-Z_]+)\\s*\\(([^)]*)\\)\\s*{(([^}]|[\\n\\r])*)}/gm,Hb=\"(\\\\w+)?\\\\s+([_0-9a-zA-Z]+)\\\\s+=\\\\s+__FUNC__\\\\((.*)\\\\)\\\\s*;\"});function Ur(a,t){let o=[],e=[],r=t!=null&&Array.isArray(t)&&t.length===0,n=t==null||r?null:qb(t,a).sort(),s=0;for(let i=0;i<a.length;++i){if(n!=null){if(n[s]===i&&a[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${a[i]}' is not 1`);(n[s]==null||n[s]>i)&&a[i]===1&&(o.push(a[i]),e.push(i)),n[s]<=i&&s++}a[i]!==1&&(o.push(a[i]),e.push(i))}return{newShape:o,keptDims:e}}function qb(a,t){let o=t.length;return a=a==null?t.map((e,r)=>r):[].concat(a),kr(a.every(e=>e>=-o&&e<o),()=>`All values in axis param must be in range [-${o}, ${o}) but got axis ${a}`),kr(a.every(jb),()=>`All values in axis param must be integers but got axis ${a}`),a.map(e=>e<0?o+e:e)}function jb(a){return a%1===0}function Yb(a){if(a.length===0)return 1;let t=a[0];for(let o=1;o<a.length;o++)t*=a[o];return t}function tp(a){let t=Math.ceil(Math.sqrt(a));return[t,Math.ceil(a/t)]}var fo,Hi=E(()=>{\"use strict\";at();fe();fo=class{constructor(t){this.maxTextureSize=t}computeTextureWH(t,o){let e=this.computeTexture(t,o);return o&&o.isPacked&&(e[0]/=2,e[1]/=2),o&&o.reverseWH?[e[1],e[0]]:e}computeTexture(t,o){let e=o&&o.isPacked;if(t.length===0)return e?[2,2]:[1,1];let r=this.maxTextureSize;if(o&&o.breakAxis!==void 0){let i=o.breakAxis>=t.length?1:t.slice(o.breakAxis).reduce((l,f)=>l*f),u=o.breakAxis<=0?1:t.slice(0,o.breakAxis).reduce((l,f)=>l*f);if(i>r||u>r)ce.verbose(\"TextureLayout\",`Given width/height preferences were unattainable: shape:${t}, breakAxis:${o.breakAxis}`);else return[i,u]}let n=t.slice(0);e&&(r=r*2,n=n.map((i,u)=>u>=n.length-2?n[u]%2===0?n[u]:n[u]+1:n[u]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Ur(n).newShape);let s=Yb(n);return n.length<=1&&s<=r?[1,s]:n.length===2&&n[0]<=r&&n[1]<=r?n:n.length===3&&n[0]*n[1]<=r&&n[2]<=r?[n[0]*n[1],n[2]]:n.length===3&&n[0]<=r&&n[1]*n[2]<=r?[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=r&&n[3]<=r?[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=r&&n[1]*n[2]*n[3]<=r?[n[0],n[1]*n[2]*n[3]]:e?tp(s/4).map(i=>i*2):tp(s)}}});var co,rp=E(()=>{\"use strict\";fe();Ht();xe();Hi();kt();co=class extends ft{constructor(o){super(o)}getFunctions(){return{...this.offsetToCoords(),...this.coordsToOffset(),...this.toVec(),...this.valueFrom(),...this.getCommonUtilFuncs(),...this.getInputsSamplingSnippets(),...this.getOutputSamplingSnippet()}}getCustomTypes(){return{}}offsetToCoords(){let o=\"offsetToCoords\";return{offsetToCoords:new R(`\n      vec2 ${o}(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      `)}}coordsToOffset(){let o=\"coordsToOffset\";return{coordsToOffset:new R(`\n      int ${o}(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      `)}}getOutputSamplingSnippet(){let o=this.context.outputTextureLayout;return o.isPacked?this.getPackedOutputSamplingSnippet(o):this.getUnpackedOutputSamplingSnippet(o)}getPackedOutputSamplingSnippet(o){let e=o.unpackedShape,r=[o.width,o.height],n={},s=\"getOutputCoords\";switch(e.length){case 0:n[s]=this.getOutputScalarCoords();break;case 1:n[s]=this.getOutputPacked1DCoords(e,r);break;case 2:n[s]=this.getOutputPacked2DCoords(e,r);break;case 3:n[s]=this.getOutputPacked3DCoords(e,r);break;default:n[s]=this.getOutputPackedNDCoords(e,r)}let u=`\n      void setOutput(vec4 val) {\n        ${q(this.context.glContext.version).output} = val;\n      }\n    `,l=\"floatTextureSetRGBA\";return n[l]=new R(u),n}getUnpackedOutputSamplingSnippet(o){let e=o.unpackedShape,r=[o.width,o.height],n={},s=\"getOutputCoords\";switch(e.length){case 0:n[s]=this.getOutputScalarCoords();break;case 1:n[s]=this.getOutputUnpacked1DCoords(e,r);break;case 2:n[s]=this.getOutputUnpacked2DCoords(e,r);break;case 3:n[s]=this.getOutputUnpacked3DCoords(e,r);break;case 4:n[s]=this.getOutputUnpacked4DCoords(e,r);break;case 5:n[s]=this.getOutputUnpacked5DCoords(e,r);break;case 6:n[s]=this.getOutputUnpacked6DCoords(e,r);break;default:throw new Error(`Unsupported output dimensionality: ${e.length}`)}let u=`\n        void setOutput(float val) {\n          ${q(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\n        }\n    `,l=\"floatTextureSetR\";return n[l]=new R(u),n}getOutputScalarCoords(){return new R(`\n      int getOutputCoords() {\n        return 0;\n      }\n    `)}getOutputPacked1DCoords(o,e){let r=e,n=\"\";return r[0]===1?(n=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${r[1]}.0);\n          }\n        `,new R(n)):r[1]===1?(n=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${r[0]}.0);\n          }\n        `,new R(n)):(n=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${r[0]}, ${r[1]}));\n          return 2 * (resTexRC.y * ${r[0]} + resTexRC.x);\n        }\n      `,new R(n))}getOutputPacked2DCoords(o,e){let r=\"\";if(pr.arraysEqual(o,e))return r=`\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${e[0]}, ${e[1]}));\n        }\n      `,new R(r);let n=e,s=Math.ceil(o[1]/2);return r=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${n[0]}, ${n[1]}));\n\n          int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${s}) * 2;\n          int c = 2 * (index / ${s});\n\n          return ivec2(r, c);\n        }\n      `,new R(r)}getOutputPacked3DCoords(o,e){let r=[e[0],e[1]],n=Math.ceil(o[2]/2),s=n*Math.ceil(o[1]/2),i=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${r[0]}, ${r[1]}));\n          int index = resTexRC.y * ${r[0]} + resTexRC.x;\n\n          int b = index / ${s};\n          index -= b * ${s};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${n}) * 2;\n          int c = 2 * (index / ${n});\n\n          return ivec3(b, r, c);\n        }\n      `;return new R(i)}getOutputPackedNDCoords(o,e){let r=[e[0],e[1]],n=Math.ceil(o[o.length-1]/2),s=n*Math.ceil(o[o.length-2]/2),i=s,u=\"\",l=\"b, r, c\";for(let p=2;p<o.length-1;p++)i*=o[o.length-p-1],u=`\n      int b${p} = index / ${i};\n      index -= b${p} * ${i};\n    `+u,l=`b${p}, `+l;let f=`\n      ivec${o.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${r[0]}, ${r[1]}));\n        int index = resTexRC.y * ${r[0]} + resTexRC.x;\n\n        ${u}\n\n        int b = index / ${s};\n        index -= b * ${s};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${n}) * 2;\n        int c = 2 * (index / ${n});\n\n        return ivec${o.length}(${l});\n      }\n    `;return new R(f)}getOutputUnpacked1DCoords(o,e){let r=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          return resTexRC.y * ${e[0]} + resTexRC.x;\n        }\n      `;return new R(r)}getOutputUnpacked2DCoords(o,e){let r=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\n          int r = index / ${o[1]};\n          int c = index - r * ${o[1]};\n          return ivec2(r, c);\n        }\n      `;return new R(r)}getOutputUnpacked3DCoords(o,e){let r=\"\",n=o.length,s=null;n<2&&(s=[]),s=new Array(n-1),s[n-2]=o[n-1];for(let l=n-3;l>=0;--l)s[l]=s[l+1]*o[l+1];let i=[\"r\",\"c\",\"d\"],u=s.map((l,f)=>{let p=`int ${i[f]} = index / ${l}`,d=f===s.length-1?`int ${i[f+1]} = index - ${i[f]} * ${l}`:`index -= ${i[f]} * ${l}`;return`${p}; ${d};`}).join(\"\");return r=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\n          ${u}\n          return ivec3(r, c, d);\n        }\n      `,new R(r)}getOutputUnpacked4DCoords(o,e){let r=\"\",n=o.length,s=null;n<2&&(s=[]),s=new Array(n-1),s[n-2]=o[n-1];for(let l=n-3;l>=0;--l)s[l]=s[l+1]*o[l+1];let i=[\"r\",\"c\",\"d\",\"d2\"],u=s.map((l,f)=>{let p=`int ${i[f]} = index / ${l}`,d=f===s.length-1?`int ${i[f+1]} = index - ${i[f]} * ${l}`:`index -= ${i[f]} * ${l}`;return`${p}; ${d};`}).join(\"\");return r=`\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\n          ${u}\n          return ivec4(r, c, d, d2);\n        }\n      `,new R(r)}getOutputUnpacked5DCoords(o,e){let r=\"\",n=o.length,s=null;n<2&&(s=[]),s=new Array(n-1),s[n-2]=o[n-1];for(let l=n-3;l>=0;--l)s[l]=s[l+1]*o[l+1];let i=[\"r\",\"c\",\"d\",\"d2\",\"d3\"],u=s.map((l,f)=>{let p=`int ${i[f]} = index / ${l}`,d=f===s.length-1?`int ${i[f+1]} = index - ${i[f]} * ${l}`:`index -= ${i[f]} * ${l}`;return`${p}; ${d};`}).join(\"\");return r=`\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\n          ${u}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `,new R(r)}getOutputUnpacked6DCoords(o,e){let r=\"\",n=o.length,s=null;n<2&&(s=[]),s=new Array(n-1),s[n-2]=o[n-1];for(let l=n-3;l>=0;--l)s[l]=s[l+1]*o[l+1];let i=[\"r\",\"c\",\"d\",\"d2\",\"d3\",\"d4\"],u=s.map((l,f)=>{let p=`int ${i[f]} = index / ${l}`,d=f===s.length-1?`int ${i[f+1]} = index - ${i[f]} * ${l}`:`index -= ${i[f]} * ${l}`;return`${p}; ${d};`}).join(\"\");return r=`\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${e[0]}, ${e[1]}));\n         int index = resTexRC.y * ${e[0]} + resTexRC.x;\n         ${u}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `,new R(r)}getCommonUtilFuncs(){let o={},e=\"uvFromFlat\";o[e]=new R(`\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    `),e=\"packedUVfrom1D\",o[e]=new R(`\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `),e=\"packedUVfrom2D\",o[e]=new R(`\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `),e=\"packedUVfrom3D\",o[e]=new R(`\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `),e=\"sampleTexture\";let r=q(this.context.glContext.version);return o[e]=new R(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${r.texture2D}(textureSampler, uv).r;\n        }`),o}getInputsSamplingSnippets(){let o={},e=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((r,n)=>{let s=this.context.inputTextureLayouts[n],i=Kn(r);s.isPacked?o[i]=this.getPackedSamplerFromInput(i,r,s):o[i]=this.getUnpackedSamplerFromInput(i,r,s);let u=zu(r);s.unpackedShape.length<=e.unpackedShape.length&&(s.isPacked?o[u]=this.getPackedSamplerAtOutputCoords(u,s,e,r):o[u]=this.getUnpackedSamplerAtOutputCoords(u,s,e,r))}),o}getPackedSamplerAtOutputCoords(o,e,r,n){let s=e.unpackedShape,i=r.unpackedShape,l=Kn(n),f=s.length,p=i.length,d=Ke.getBroadcastDims(s,i),T=Je(p),v=p-f,w,I=Ot();f===0?w=\"\":p<2&&d.length>=1?w=\"coords = 0;\":w=d.map(We=>`coords.${I[We+v]} = 0;`).join(`\n`);let L=\"\";p<2&&f>0?L=\"coords\":L=s.map((We,Fe)=>`coords.${I[Fe+v]}`).join(\", \");let F=\"return outputValue;\",Y=U.size(s)===1,M=U.size(i)===1;if(f===1&&!Y&&!M)F=`\n        return vec4(outputValue.xy, outputValue.xy);\n      `;else if(Y&&!M)p===1?F=`\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        `:F=`\n          return vec4(outputValue.x);\n        `;else if(d.length){let We=f-2,Fe=f-1;d.indexOf(We)>-1&&d.indexOf(Fe)>-1?F=\"return vec4(outputValue.x);\":d.indexOf(We)>-1?F=\"return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);\":d.indexOf(Fe)>-1&&(F=\"return vec4(outputValue.xx, outputValue.zz);\")}let ie=`\n        int lastDim = coords.${I[p-1]};\n        coords.${I[p-1]} = coords.${I[p-2]};\n        coords.${I[p-2]} = lastDim;\n      `,ot=`\n      vec4 ${o}() {\n        ${T} coords = getOutputCoords();\n        ${ie}\n        ${w}\n        vec4 outputValue = ${l}(${L});\n        ${F}\n      }\n    `;return new R(ot,[\"coordinates.getOutputCoords\"])}getUnpackedSamplerAtOutputCoords(o,e,r,n){let s=[r.width,r.height],i=[e.width,e.height],u=e.unpackedShape.length,l=r.unpackedShape.length,f=e.unpackedShape,p=r.unpackedShape,d=Kn(n);if(u===l&&pr.arraysEqual(i,s)){let Y=`\n          float ${o}() {\n            return sampleTexture(${n}, TexCoords);\n          }\n        `;return new R(Y,[\"coordinates.sampleTexture\"])}let T=Je(l),v=Ke.getBroadcastDims(f,p),w=l-u,I,L=Ot();u===0?I=\"\":l<2&&v.length>=1?I=\"coords = 0;\":I=v.map(Y=>`coords.${L[Y+w]} = 0;`).join(`\n`);let F=\"\";l<2&&u>0?F=\"coords\":F=e.unpackedShape.map((Y,j)=>`coords.${L[j+w]}`).join(\", \");let C=`\n        float ${o}() {\n          ${T} coords = getOutputCoords();\n          ${I}\n          return ${d}(${F});\n        }\n      `;return new R(C,[\"coordinates.getOutputCoords\"])}getPackedSamplerFromInput(o,e,r){switch(r.unpackedShape.length){case 0:return this.getPackedSamplerScalar(o,e);case 1:return this.getPackedSampler1D(o,e,r);case 2:return this.getPackedSampler2D(o,e,r);case 3:return this.getPackedSampler3D(o,e,r);default:return this.getPackedSamplerND(o,e,r)}}getUnpackedSamplerFromInput(o,e,r){let n=r.unpackedShape;switch(n.length){case 0:return this.getUnpackedSamplerScalar(o,e,r);case 1:return this.getUnpackedSampler1D(o,e,r);case 2:return this.getUnpackedSampler2D(o,e,r);case 3:return this.getUnpackedSampler3D(o,e,r);case 4:return this.getUnpackedSampler4D(o,e,r);case 5:return this.getUnpackedSampler5D(o,e,r);case 6:return this.getUnpackedSampler6D(o,e,r);default:throw new Error(`Unsupported dimension ${n.length}-D`)}}getPackedSamplerScalar(o,e){let r=q(this.context.glContext.version),n=`\n          vec4 ${o}() {\n            return ${r.texture2D}(${e}, halfCR);\n          }\n        `;return new R(n)}getPackedSampler1D(o,e,r){let n=[r.width,r.height],s=[n[1],n[0]],i=q(this.context.glContext.version),l=`vec4 ${o}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${s[0]}, ${s[1]}, index);\n      return ${i.texture2D}(${e}, uv);\n    }`;return new R(l,[\"coordinates.packedUVfrom1D\"])}getPackedSampler2D(o,e,r){let n=r.unpackedShape,s=[r.width,r.height],i=q(this.context.glContext.version),u=s[0],l=s[1];if(s!=null&&pr.arraysEqual(n,s)){let v=`vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${u}.0);\n        return ${i.texture2D}(${e}, uv);\n      }`;return new R(v)}let f=s,p=Math.ceil(n[1]/2),T=`vec4 ${o}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${f[1]}, ${f[0]}, ${p}, row, col);\n      return ${i.texture2D}(${e}, uv);\n    }`;return new R(T,[\"coordinates.packedUVfrom2D\"])}getPackedSampler3D(o,e,r){let n=r.unpackedShape,s=[r.width,r.height],i=[s[0],s[1]],u=q(this.context.glContext.version);if(n[0]===1){let w=n.slice(1),I=[1,2],L=Br(n,w),F=[\"b\",\"row\",\"col\"],C=JSON.parse(JSON.stringify(r));C.unpackedShape=L;let Y=this.getPackedSamplerFromInput(o,e,C),M=`${Y.routineBody}\n      vec4 ${o}(int b, int row, int col) {\n        return ${o}(${Nr(F,I)});\n      } `;return new R(M,Y.dependencies)}let l=i[0],f=i[1],p=Math.ceil(n[2]/2),d=p*Math.ceil(n[1]/2),v=`vec4 ${o}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${f}, ${l}, ${d}, ${p}, b, row, col);\n      return ${u.texture2D}(${e}, uv);}`;return new R(v,[\"coordinates.packedUVfrom3D\"])}getPackedSamplerND(o,e,r){let n=r.unpackedShape,s=n.length,i=[r.width,r.height],u=q(this.context.glContext.version),l=[i[0],i[1]],f=l[1],p=l[0],d=Math.ceil(n[s-1]/2),T=d*Math.ceil(n[s-2]/2),v=\"int b, int row, int col\",w=`b * ${T} + (row / 2) * ${d} + (col / 2)`;for(let F=2;F<s-1;F++)v=`int b${F}, `+v,T*=n[s-F-1],w=`b${F} * ${T} + `+w;let L=`vec4 ${o}(${v}) {\n      int index = ${w};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${f});\n      return ${u.texture2D}(${e}, uv);\n    }`;return new R(L)}getUnpackedSamplerScalar(o,e,r){let[n,s]=[r.width,r.height];if(n===1&&s===1){let u=`\n          float ${o}() {\n            return sampleTexture(${e}, halfCR);\n          }\n        `;return new R(u,[\"coordinates.sampleTexture\"])}let i=`\n        float ${o}() {\n          int offset_${e} = coordsToOffset(TexCoords, ${n}, ${s});\n          vec2 uv = uvFromFlat(${n}, ${s}, offset_${e});\n          return sampleTexture(${e}, uv);\n        }\n      `;return new R(i,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}getUnpackedSampler1D(o,e,r){let n=r.width,s=r.height;if(s===1&&n===1){let u=`\n        float ${o}(int index) {\n          return sampleTexture(${e}, halfCR);\n        }\n      `;return new R(u,[\"coordinates.sampleTexture\"])}if(s===1){let u=`\n          float ${o}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${n}.0, 0.5);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new R(u,[\"coordinates.sampleTexture\"])}if(n===1){let u=`\n          float ${o}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${s}.0);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new R(u,[\"coordinates.sampleTexture\"])}let i=`\n        float ${o}(int index) {\n          vec2 uv = uvFromFlat(${n}, ${s}, index);\n          return sampleTexture(${e}, uv);\n        }\n      `;return new R(i,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\"])}getUnpackedSampler2D(o,e,r){let n=r.unpackedShape,s=[r.height,r.width];if(s!=null&&pr.arraysEqual(n,s)){let T=s[1],v=s[0],w=`\n          float ${o}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${T}.0, ${v}.0);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new R(w,[\"coordinates.sampleTexture\"])}let{newShape:i,keptDims:u}=Ur(n),l=i;if(l.length<n.length){let T=Br(n,l),v=JSON.parse(JSON.stringify(r));v.unpackedShape=T;let w=[\"col\",\"row\"],I=`\n          ${this.getUnpackedSamplerFromInput(o,e,v).routineBody}\n          float ${o}(int row, int col) {\n            return ${o}(${Nr(w,u)});\n          }\n        `;return new R(I,[\"coordinates.sampleTexture\"])}let f=s[1],p=s[0];if(p===1){let T=`\n          float ${o}(int row, int col) {\n            int offset_${e} = coordsToOffset(TexCoords, ${f}, ${p});\n            float index = dot(vec3(row, col, offset_${e}), vec3(${n[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${f}.0);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new R(T,[\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}if(f===1){let T=`\n          float ${o}(int row, int col) {\n            int offset_${e} = coordsToOffset(TexCoords, ${f}, ${p});\n            float index = dot(vec3(row, col, offset_${e}), vec3(${n[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new R(T,[\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}let d=`\n        float ${o}(int row, int col) {\n          int index = col * ${n[1]} + row;\n          vec2 uv = uvFromFlat(${f}, ${p}, index);\n          return sampleTexture(${e}, uv);\n        }\n      `;return new R(d,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}getUnpackedSampler3D(o,e,r){let n=r.unpackedShape,s=n[1]*n[2],i=n[2],{newShape:u,keptDims:l}=Ur(n),f=u;if(f.length<n.length){let v=Br(n,f),w=[\"batch\",\"col\",\"row\"],I=JSON.parse(JSON.stringify(r));I.unpackedShape=v;let L=this.getUnpackedSamplerFromInput(o,e,I),F=l.reverse(),C=`\n          ${L.routineBody}\n          float ${o}(int batch, int row, int col) {\n            return ${o}(${Nr(w,F)});\n          }\n        `;return new R(C,L.dependencies)}let p=r.width,d=r.height,T=`\n          float ${o}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${s} + col * ${i} + row;\n            vec2 uv = uvFromFlat(${p}, ${d}, index);\n            return sampleTexture(${e}, uv);\n          }\n      `;return new R(T,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}getUnpackedSampler4D(o,e,r){let n=r.unpackedShape,s=n[3],i=n[2]*s,u=n[1]*i,l=r.width,f=r.height,p=`\n        float ${o}(int row, int col, int depth, int depth2) {\n          int index = row * ${u} + col * ${i} +\n              depth2 * ${s} + depth;\n          vec2 uv = uvFromFlat(${l}, ${f}, index);\n          return sampleTexture(${e}, uv);\n        }\n      `;return new R(p,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\"])}getUnpackedSampler5D(o,e,r){let n=r.unpackedShape,s=n[4],i=n[3]*s,u=n[2]*i,l=n[1]*u,{newShape:f,keptDims:p}=Ur(n);if(f.length<n.length){let w=Br(n,f),I=[\"row\",\"col\",\"depth\",\"depth2\",\"depth3\"],L=JSON.parse(JSON.stringify(r));L.unpackedShape=w;let F=`\n          ${this.getUnpackedSamplerFromInput(o,e,L).routineBody}\n          float ${o}(int row, int col, int depth, int depth2, int depth3) {\n            return ${o}(${Nr(I,p)});\n          }\n        `;return new R(F,[\"coordinates.sampleTexture\",\"coordinates.uvFromFlat\"])}let d=r.width,T=r.height,v=`\n        float ${o}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${l} + col * ${u} + depth * ${i} +\n          depth3 * ${s} + depth2;\n          vec2 uv = uvFromFlat(${d}, ${T}, index);\n          return sampleTexture(${e}, uv);\n        }\n      `;return new R(v,[\"coordinates.sampleTexture\",\"coordinates.uvFromFlat\"])}getUnpackedSampler6D(o,e,r){let n=r.unpackedShape,s=n[5],i=n[4]*s,u=n[3]*i,l=n[2]*u,f=n[1]*l,{newShape:p,keptDims:d}=Ur(n);if(p.length<n.length){let I=Br(n,p),L=[\"row\",\"col\",\"depth\",\"depth2\",\"depth3\",\"depth4\"],F=JSON.parse(JSON.stringify(r));F.unpackedShape=I;let C=`\n            ${this.getUnpackedSamplerFromInput(o,e,F).routineBody}\n            float ${o}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${o}(${Nr(L,d)});\n            }\n          `;return new R(C,[\"coordinates.sampleTexture\",\"coordinates.uvFromFlat\"])}let T=r.width,v=r.height,w=`\n          float ${o}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${f} + col * ${l} + depth * ${u} +\n            depth2 * ${i} + depth3 * ${s} + depth4;\n            vec2 uv = uvFromFlat(${T}, ${v}, index);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new R(w,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}toVec(){let o=this.context.outputTextureLayout,e=o.shape.length,r=o.strides,n=o.width,s=o.height,i=[];for(let l=0;l<e-1;++l)i.push(`\n        c[${l}] = offset / ${r[l]};`),i.push(`\n        offset -= c[${l}] * ${r[l]};`);i.push(`\n        c[${e-1}] = offset;`);let u=`\n      void toVec(vec2 texCoords, out int c[${e}]) {\n        int offset = coordsToOffset(texCoords, ${n}, ${s});\n        ${i.join(\"\")}\n      }\n      void toVec(int offset, out int c[${e}]) {\n        ${i.join(\"\")}\n      }\n    `;return{toVec:new R(u,[\"coordinates.coordsToOffset\"])}}valueFrom(){let o={};return this.context.programInfo.inputNames.forEach((e,r)=>{let n=this.context.inputTextureLayouts[r],i=(n.unpackedShape.length>0?n.unpackedShape:n.shape).length,u=`_${e}`;o[u]=new R(this.getValueFromSingle(e,i,n.width,n.height,!1),[`shapeUtils.indicesToOffset${u}`,\"coordinates.offsetToCoords\",\"fragcolor.getColorAsFloat\"]),u=u+\"_T\",o[u]=new R(this.getValueFromSingle(e,i,n.width,n.height,!0),[`shapeUtils.indicesToOffset${u}`,\"coordinates.offsetToCoords\",\"fragcolor.getColorAsFloat\"])}),o}getValueFromSingle(o,e,r,n,s){let i=`_${o}`;s&&(i=i+\"_T\");let u=q(this.context.glContext.version);return`\n        float ${i}(int m[${e}]) {\n          int offset = indicesToOffset${i}(m);\n          vec2 coords = offsetToCoords(offset, ${r}, ${n});\n          float value = getColorAsFloat(${u.texture2D}(${o}, coords));\n          return value;\n        }\n        `}getPackedValueFrom(o,e,r,n,s){let i=`_${o}_Pack`;s&&(i=i+\"_T\");let u=q(this.context.glContext.version);return`\n        vec4 ${i}(int m[${e}]) {\n          int offset = indicesToOffset_${o}(m);\n          vec2 coords = offsetToCoords(offset, ${r}, ${n});\n          return ${u.texture2D}(${o}, coords);\n        }\n        `}}});var po,np=E(()=>{\"use strict\";Ht();po=class a extends ft{constructor(t){super(t)}getFunctions(){return{...this.encodeFloat32(),...this.decodeFloat32()}}getCustomTypes(){return{}}encodeFloat32(){return{encode:new R(`highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        `)}}decodeFloat32(){return{decode:new R(`highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        `)}}encodeUint8(){let t=a.isLittleEndian()?\"rgba.rgba=rgba.abgr;\":\"\";return{encode:new R(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${t}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `)}}decodeUint8(){let t=a.isLittleEndian()?\"rgba.rgba=rgba.abgr;\":\"\";return{decode:new R(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${t}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `)}}static isLittleEndian(){let t=new ArrayBuffer(4),o=new Uint32Array(t),e=new Uint8Array(t);if(o[0]=3735928559,e[0]===239)return!0;if(e[0]===222)return!1;throw new Error(\"unknown endianness\")}}});var ho,op=E(()=>{\"use strict\";Ht();xe();ho=class extends ft{constructor(t){super(t)}getFunctions(){return{...this.setFragColor(),...this.getColorAsFloat()}}getCustomTypes(){return{}}setFragColor(){let t=q(this.context.glContext.version);return{setFragColor:new R(`\n        void setFragColor(float value) {\n            ${t.output} = encode(value);\n        }\n        `,[\"encoding.encode\"])}}getColorAsFloat(){return{getColorAsFloat:new R(`\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        `,[\"encoding.decode\"])}}}});var mo,ip=E(()=>{\"use strict\";Ht();mo=class a extends ft{constructor(t){super(t)}getFunctions(){return{...this.bcastIndex(),...this.bcastMatmulIndex(),...this.offsetToIndices(),...this.indicesToOffset(),...this.incrementIndices()}}getCustomTypes(){return{}}bcastIndex(){let t=this.context.outputTextureLayout.shape.length,o={};return this.context.programInfo.inputNames.forEach((e,r)=>{let n=this.context.inputTextureLayouts[r].unpackedShape;if(n.length<=t){let s=n.length,i=t-s,u=`bcastIndices_${e}`,l=\"\";for(let p=0;p<s;++p)l+=`\n          realIndices[${p}] = int( mod(float(bcastedIndices[${i+p}]), ${n[p]}.0) );\n          `;let f=`\n        void ${u} (int bcastedIndices[${t}], out int realIndices[${s}]) {\n          ${l}\n        }\n        `;o[u]=new R(f)}}),o}bcastMatmulIndex(){let t=this.context.outputTextureLayout.shape.length,o={};return this.context.programInfo.inputNames.forEach((e,r)=>{let n=this.context.inputTextureLayouts[r].shape;if(!(n.length<2||n.length>t)){let s=n.length,i=t-s,u=`bcastMatmulIndices_${e}`,l=\"\";for(let p=0;p<s-2;++p)l+=`\n          realIndices[${p}] = int( mod(float(bcastedIndices[${i+p}]), ${n[p]}.0) );\n          `;let f=`\n        void ${u}(int bcastedIndices[${t}], out int realIndices[${s}]) {\n          ${l}\n          realIndices[${s-1}] = bcastedIndices[${t-1}];\n          realIndices[${s-2}] = bcastedIndices[${t-2}];\n        }\n        `;o[u]=new R(f)}}),o}indicesToOffset(){let t={};return this.context.programInfo.inputNames.forEach((o,e)=>{let r=this.context.inputTextureLayouts[e].shape,n=this.context.inputTextureLayouts[e].strides,s=r.length,i=`indicesToOffset_${o}`;t[i]=new R(a.indexToOffsetSingle(i,s,n)),i=`indicesToOffset_${o}_T`,t[i]=new R(a.indexToOffsetSingle(i,s,n.slice().reverse()))}),t}static indexToOffsetSingle(t,o,e){let r=\"\";for(let n=o-1;n>=0;--n)r+=`\n        offset += indices[${n}] * ${e[n]};\n        `;return`\n      int ${t}(int indices[${o}]) {\n        int offset = 0;\n        ${r}\n        return offset;\n      }\n      `}offsetToIndices(){let t={};return this.context.programInfo.inputNames.forEach((o,e)=>{let r=this.context.inputTextureLayouts[e].shape,n=this.context.inputTextureLayouts[e].strides,s=r.length,i=`offsetToIndices_${o}`;t[i]=new R(a.offsetToIndicesSingle(i,s,n)),i=`offsetToIndices_${o}_T`,t[i]=new R(a.offsetToIndicesSingle(i,s,n.slice().reverse()))}),t}static offsetToIndicesSingle(t,o,e){let r=[];for(let n=0;n<o-1;++n)r.push(`\n      indices[${n}] = offset / ${e[n]};`),r.push(`\n        offset -= indices[${n}] * ${e[n]};`);return r.push(`\n      indices[${o-1}] = offset;`),`\n      void ${t}(int offset, out int indices[${o}]) {\n        ${r.join(\"\")}\n      }\n      `}incrementIndices(){let t={};return this.context.programInfo.inputNames.forEach((o,e)=>{let r=this.context.inputTextureLayouts[e].shape,n=r.length,s=`incrementIndices_${o}`,i=\"\";for(let l=0;l<n;++l)i+=`\n        shape[${l}] = ${r[l]};`;let u=`\n        void ${s}(int axis, out int indices[${n}]) {\n          int shape[${n}];\n          ${i};\n          for(int i = ${n} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `;t[s]=new R(u)}),t}}});var bo,ap=E(()=>{\"use strict\";Ht();bo=class extends ft{constructor(t){super(t)}getCustomTypes(){return{}}getFunctions(){return{...this.binaryVecFunctions(),...this.copyVec(),...this.setVecItem(),...this.getVecItem()}}binaryVecFunctions(){let o=this.context.outputTextureLayout.shape.length,e={add:\"+=\",sub:\"-=\",mul:\"*=\",div:\"/=\"},r={};for(let n in e){let s=`${n}Vec`,i=\"\";for(let l=0;l<o;++l)i+=`\n          dest[${l}] ${e[n]} src[${l}];\n          `;let u=`\n        void ${s}(int src[${o}], out int dest[${o}]) {\n          ${i}\n        }\n        `;r[s]=new R(u)}return r}copyVec(){let o=this.context.outputTextureLayout.shape.length,e=\"\";for(let n=0;n<o;++n)e+=`\n        dest[${n}] = src[${n}];\n        `;let r=`\n      void copyVec(int src[${o}], out int dest[${o}]) {\n        ${e}\n      }\n      `;return{copyVec:new R(r)}}setVecItem(){let o=this.context.outputTextureLayout.shape.length,e=`\n        if(index < 0)\n            index =${o} + index;\n        if (index == 0)\n            m[0] = value;\n        `;for(let n=1;n<o-1;++n)e+=`\n        else if (index == ${n})\n            m[${n}] = value;\n            `;e+=`\n        else\n            m[${o-1}] = value;\n        `;let r=`\n      void setVecItem(out int m[${o}], int index, int value) {\n        ${e}\n      }\n        `;return{setVecItem:new R(r)}}getVecItem(){let o=this.context.outputTextureLayout.shape.length,e=`\n        if(index < 0)\n            index = ${o} + index;\n        if (index == 0)\n            return m[0];\n      `;for(let n=1;n<o-1;++n)e+=`\n        else if (index == ${n})\n            return m[${n}];\n      `;e+=`\n        else\n            return m[${o-1}];\n        `;let r=`\n      int getVecItem(int m[${o}], int index) {\n        ${e}\n      }\n    `;return{getVecItem:new R(r)}}}});var qi,sp=E(()=>{\"use strict\";rp();np();op();ip();ap();qi={encoding:po,fragcolor:ho,vec:bo,shapeUtils:mo,coordinates:co}});var go,up=E(()=>{\"use strict\";Ht();ep();sp();xe();go=class{constructor(t,o,e,r){this.libs={};this.glslLibRoutineDependencyGraph={};this.context=new eo(t,o,e,r),Object.keys(qi).forEach(s=>{let i=new qi[s](this.context);this.libs[s]=i});let n=this.glslLibRoutineDependencyGraph;for(let s in this.libs){let u=this.libs[s].getFunctions();for(let l in u){let f=s+\".\"+l,p;n[f]?(p=n[f],p.routineBody=u[l].routineBody):(p=new dn(f,u[l].routineBody),n[f]=p);let d=u[l].dependencies;if(d)for(let T=0;T<d.length;++T)if(n[d[T]])p.addDependency(n[d[T]]);else{let v=new dn(d[T]);n[d[T]]=v,p.addDependency(v)}}}}preprocess(){let t=this.context.programInfo,o=t.shaderSource;return this.context.programInfo.hasMain||(o=`${o}\n      ${Uu(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),o=Qc(o),`${Gu(this.context.glContext.version)}\n    ${this.getUniforms(t.inputNames,t.variables)}\n    ${this.getImports(o)}\n    ${o}`}getImports(t){let o=this.selectGlslLibRoutinesToBeIncluded(t);if(o.length===0)return\"\";let e=\"\";for(let r=0;r<o.length;++r)if(o[r].routineBody)e+=o[r].routineBody+`\n`;else throw new Error(`Missing body for the Glsl Library routine: ${o[r].name}`);return e}selectGlslLibRoutinesToBeIncluded(t){let o=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(e=>{let r=e.split(\".\")[1];t.indexOf(r)!==-1&&o.push(this.glslLibRoutineDependencyGraph[e])}),to.returnOrderedNodes(o)}getUniforms(t,o){let e=[];if(t)for(let r of t)e.push(`uniform sampler2D ${r};`);if(o)for(let r of o)e.push(`uniform ${r.type} ${r.name}${r.arrayLength?`[${r.arrayLength}]`:\"\"};`);return e.join(`\n`)}}});var yo,lp=E(()=>{\"use strict\";Tt();at();up();xe();yo=class{constructor(t,o,e){this.profiler=t;this.glContext=o;this.textureLayoutStrategy=e;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,o){this.repo.set(t,o)}run(t,o,e){this.profiler.event(\"op\",`ProgramManager.run ${t.programInfo.name??\"unknown kernel\"}`,()=>{let r=this.glContext.gl,n=t.program;r.useProgram(n);try{this.bindOutput(e),this.attributesBound||this.bindAttributes(t.attribLocations),this.bindUniforms(t.uniformLocations,t.programInfo.variables??[],o)}catch(s){throw ce.error(\"ProgramManager\",t.programInfo.shaderSource),s}this.profiler.event(\"backend\",\"GlContext.draw()\",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(t=>this.glContext.deleteProgram(t.program))}build(t,o,e){return this.profiler.event(\"backend\",\"ProgramManager.build\",()=>{let r=new go(this.glContext,t,o,e),n=r.preprocess(),s=this.compile(n);return{programInfo:t,program:s,uniformLocations:this.getUniformLocations(s,r.context.programInfo.inputNames,r.context.programInfo.variables),attribLocations:this.getAttribLocations(s)}})}compile(t){if(!this.vertexShader){ce.verbose(\"ProrgramManager\",\"Compiling and caching Vertex shader for the first time\");let r=Mu(this.glContext.version);this.vertexShader=this.glContext.compileShader(r,this.glContext.gl.VERTEX_SHADER)}Z.debug&&ce.verbose(\"ProrgramManager\",`FragShader:\n${t}\n`);let o=this.glContext.compileShader(t,this.glContext.gl.FRAGMENT_SHADER),e=this.glContext.createProgram(this.vertexShader,o);return this.glContext.deleteShader(o),e}bindOutput(t){let o=t.width,e=t.height;ce.verbose(\"ProrgramManager\",`Binding output texture to Framebuffer: w/h=${o}/${e}, shape=${t.shape}, type=${t.tensor.type}`),this.glContext.attachFramebuffer(t.texture,o,e)}bindAttributes(t){let o=t.position,e=t.textureCoord;this.glContext.setVertexAttributes(o,e),this.attributesBound=!0}bindUniforms(t,o,e){let r=this.glContext.gl,n=0;for(let{name:s,type:i,location:u,arrayLength:l}of t){let f=o.find(p=>p.name===s)?.data;if(i!==\"sampler2D\"&&!f)throw new Error(`variable '${s}' does not have data defined in program info`);switch(i){case\"sampler2D\":this.bindTexture(e[n],u,n),n++;break;case\"float\":l?r.uniform1fv(u,f):r.uniform1f(u,f);break;case\"int\":l?r.uniform1iv(u,f):r.uniform1i(u,f);break;default:throw new Error(`Uniform not implemented: ${i}`)}}}bindTexture(t,o,e){this.glContext.bindTextureToUniform(t.texture,e,o)}getAttribLocations(t){return{position:this.getAttribLocation(t,\"position\"),textureCoord:this.getAttribLocation(t,\"textureCoord\")}}getUniformLocations(t,o,e){let r=[];if(o)for(let n of o)r.push({name:n,type:\"sampler2D\",location:this.getUniformLocation(t,n)});if(e)for(let n of e)r.push({...n,location:this.getUniformLocation(t,n.name)});return r}getUniformLocation(t,o){let r=this.glContext.gl.getUniformLocation(t,o);if(r===null)throw new Error(`Uniform ${o} not found.`);return r}getAttribLocation(t,o){return this.glContext.gl.getAttribLocation(t,o)}}});var To,fp=E(()=>{\"use strict\";at();cn();To=class{constructor(t,o,e,r){this.glContext=t;this.layoutStrategy=o;this.profiler=e;this.config=r;this.pendingRead=new Map;r.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(t,o,e,r){let n=this.toEncoderType(t),s=this.glContext.getEncoder(n,o.channels||1,r);if(o.isPacked&&r===1)throw new Error(\"not implemented\");let i=o.width,u=o.height,l,f;if(this.config.reuseTextures){l=`${i}x${u}_${s.format}_${s.internalFormat}_${s.textureType}`,f=this.inUseTextures.get(l),f||(f=[],this.inUseTextures.set(l,f));let d=this.idleTextures.get(l);if(d&&d.length>0){let T=d.pop();return f.push(T),r===1&&this.glContext.updateTexture(T,i,u,s,this.toTextureData(t,e)),T}}ce.verbose(\"TextureManager\",`Creating new texture of size ${o.width}x${o.height}`);let p=this.glContext.allocateTexture(i,u,s,this.toTextureData(t,e));return this.config.reuseTextures&&(f.push(p),this.textureLookup.set(p,l)),p}readTexture(t,o,e){return e||(e=1),this.profiler.event(\"backend\",\"TextureManager.readTexture\",()=>{let r=t.shape.reduce((s,i)=>s*i)*e,n=this.glContext.readTexture(t.texture,t.width,t.height,r,this.toEncoderType(o),e);return this.toTensorData(o,n)})}async readTextureAsync(t,o,e){let r=t.tensor.dataId;if(e||(e=1),this.pendingRead.has(r)){let n=this.pendingRead.get(r);return new Promise(s=>n?.push(s))}return this.profiler.event(\"backend\",\"TextureManager.readTextureAsync\",async()=>{this.pendingRead.set(r,[]);let n=t.shape.reduce((l,f)=>l*f)*e;await this.glContext.createAndWaitForFence();let s=this.glContext.readTexture(t.texture,t.width,t.height,n,this.toEncoderType(o),e),i=this.toTensorData(o,s),u=this.pendingRead.get(r);return this.pendingRead.delete(r),u?.forEach(l=>l(i)),i})}readUint8TextureAsFloat(t){return this.profiler.event(\"backend\",\"TextureManager.readUint8TextureAsFloat\",()=>{let o=t.shape.reduce((r,n)=>r*n),e=this.glContext.readTexture(t.texture,t.width,t.height,o*4,\"byte\",4);return new Float32Array(e.buffer,e.byteOffset,o)})}releaseTexture(t,o){let e;if(this.config.reuseTextures&&(e=this.textureLookup.get(t.texture),e)){o&&this.textureLookup.delete(e);let r=this.inUseTextures.get(e);if(r){let n=r.indexOf(t.texture);if(n!==-1){r.splice(n,1);let s=this.idleTextures.get(e);s||(s=[],this.idleTextures.set(e,s)),s.push(t.texture)}}}(!e||o)&&(ce.verbose(\"TextureManager\",`Deleting texture of size ${t.width}x${t.height}`),this.glContext.deleteTexture(t.texture))}toTensorData(t,o){switch(t){case\"int16\":return o instanceof Int16Array?o:Int16Array.from(o);case\"int32\":return o instanceof Int32Array?o:Int32Array.from(o);case\"int8\":return o instanceof Int8Array?o:Int8Array.from(o);case\"uint16\":return o instanceof Uint16Array?o:Uint16Array.from(o);case\"uint32\":return o instanceof Uint32Array?o:Uint32Array.from(o);case\"uint8\":case\"bool\":return o instanceof Uint8Array?o:Uint8Array.from(o);case\"float32\":return o instanceof Float32Array?o:Float32Array.from(o);case\"float64\":return o instanceof Float64Array?o:Float64Array.from(o);default:throw new Error(`TensorData type ${t} is not supported`)}}toTextureData(t,o){if(o)return o instanceof Float32Array?o:new Float32Array(o)}toEncoderType(t){return\"float\"}clearActiveTextures(){this.glContext.clearActiveTextures()}}});var xo,cp=E(()=>{\"use strict\";at();Is();rl();Jc();lp();Hi();fp();xo=class{constructor(t,o){this.backend=t;this.context=o;this.layoutStrategy=new fo(t.glContext.maxTextureSize),this.programManager=new yo(this.context.profiler,t.glContext,this.layoutStrategy),this.textureManager=new To(t.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:t.textureCacheMode===\"full\"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=t.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new Qn(this)}onGraphInitialized(t){let o=t.getValues().filter(e=>e.from===-1&&e.tensor).map(e=>e.tensor.dataId);this.initializers=new Set(o)}isInitializer(t){return this.initializers?this.initializers.has(t):!1}addInitializer(t){this.initializers.add(t)}getTextureData(t,o){return o?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,o,e=!1){ce.verbose(\"WebGLSessionHandler\",\"Storing Texture data in cache\"),e?this.packedTextureDataCache.set(t,o):this.unpackedTextureDataCache.set(t,o)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(t=>this.textureManager.releaseTexture(t,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(t=>this.textureManager.releaseTexture(t,!0)),this.unpackedTextureDataCache=new Map}resolve(t,o,e){let r=Os(t,o,Kc);return{impl:r.opImpl,context:r.opInit?r.opInit(t,e):t}}}});function Xb(a){let t=0;for(;t<a.length&&a[t]();++t);return t-1}var bn,pp=E(()=>{\"use strict\";Tt();cn();cn();kt();bn=class{constructor(t,o){this.frameBufferBound=!1;this.itemsToPoll=[];this.gl=t,this.version=o,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(t,o,e,r){let n=this.gl,s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE);let i=r?e.encode(r,t*o):null;return n.texImage2D(n.TEXTURE_2D,0,e.internalFormat,t,o,0,e.format,e.textureType,i),this.checkError(),s}updateTexture(t,o,e,r,n){let s=this.gl;s.bindTexture(s.TEXTURE_2D,t);let i=r.encode(n,o*e);s.texSubImage2D(s.TEXTURE_2D,0,0,0,o,e,r.format,r.textureType,i),this.checkError()}attachFramebuffer(t,o,e){let r=this.gl;r.bindTexture(r.TEXTURE_2D,t),r.bindFramebuffer(r.FRAMEBUFFER,this.framebuffer),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0),this.checkError(),r.viewport(0,0,o,e),r.scissor(0,0,o,e)}readTexture(t,o,e,r,n,s){let i=this.gl;s||(s=1),this.frameBufferBound||this.attachFramebuffer(t,o,e);let u=this.getEncoder(n,s),l=u.allocate(o*e);return i.bindTexture(i.TEXTURE_2D,t),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,t,0),i.readPixels(0,0,o,e,i.RGBA,u.textureType,l),this.checkError(),u.decode(l,r)}isFramebufferReady(){return!0}getActiveTexture(){let t=this.gl;return`TEXTURE${t.getParameter(this.gl.ACTIVE_TEXTURE)-t.TEXTURE0}`}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(t,o){let e=this.gl;e.vertexAttribPointer(t,3,e.FLOAT,!1,20,0),e.enableVertexAttribArray(t),o!==-1&&(e.vertexAttribPointer(o,2,e.FLOAT,!1,20,12),e.enableVertexAttribArray(o)),this.checkError()}createProgram(t,o){let e=this.gl,r=e.createProgram();return e.attachShader(r,t),e.attachShader(r,o),e.linkProgram(r),r}compileShader(t,o){let e=this.gl,r=e.createShader(o);if(!r)throw new Error(`createShader() returned null with type ${o}`);if(e.shaderSource(r,t),e.compileShader(r),e.getShaderParameter(r,e.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${e.getShaderInfoLog(r)}\nShader source:\n${t}`);return r}deleteShader(t){this.gl.deleteShader(t)}bindTextureToUniform(t,o,e){let r=this.gl;r.activeTexture(r.TEXTURE0+o),this.checkError(),r.bindTexture(r.TEXTURE_2D,t),this.checkError(),r.uniform1i(e,o),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(Z.debug){let t=this.gl,o=t.getError(),e=\"\";switch(o){case t.NO_ERROR:return;case t.INVALID_ENUM:e=\"INVALID_ENUM\";break;case t.INVALID_VALUE:e=\"INVALID_VALUE\";break;case t.INVALID_OPERATION:e=\"INVALID_OPERATION\";break;case t.INVALID_FRAMEBUFFER_OPERATION:e=\"INVALID_FRAMEBUFFER_OPERATION\";break;case t.OUT_OF_MEMORY:e=\"OUT_OF_MEMORY\";break;case t.CONTEXT_LOST_WEBGL:e=\"CONTEXT_LOST_WEBGL\";break;default:e=`Unknown WebGL Error: ${o.toString(16)}`}throw new Error(e)}}deleteTexture(t){this.gl.deleteTexture(t)}deleteProgram(t){this.gl.deleteProgram(t)}getEncoder(t,o,e=0){if(this.version===2)return new Jn(this.gl,o);switch(t){case\"float\":return e===1||this.isRenderFloat32Supported?new fn(this.gl,o):new fn(this.gl,o,this.textureHalfFloatExtension.HALF_FLOAT_OES);case\"int\":throw new Error(\"not implemented\");case\"byte\":return new Zn(this.gl,o);default:throw new Error(`Invalid dataType: ${t}`)}}clearActiveTextures(){let t=this.gl;for(let o=0;o<this.maxTextureImageUnits;++o)t.activeTexture(t.TEXTURE0+o),t.bindTexture(t.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(this.framebuffer),t.bindBuffer(t.ARRAY_BUFFER,null),t.deleteBuffer(this.vertexbuffer),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let t=this.gl,o=t.createBuffer();if(!o)throw new Error(\"createBuffer() returned null\");let e=this.createDefaultGeometry();return t.bindBuffer(t.ARRAY_BUFFER,o),t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW),this.checkError(),o}createFramebuffer(){let t=this.gl.createFramebuffer();if(!t)throw new Error(\"createFramebuffer returned null\");return t}queryVitalParameters(){let t=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error(\"both float32 and float16 TextureType are not supported\");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=t.getParameter(t.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension(\"EXT_color_buffer_float\"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension(\"EXT_disjoint_timer_query_webgl2\")):(this.textureFloatExtension=this.gl.getExtension(\"OES_texture_float\"),this.textureHalfFloatExtension=this.gl.getExtension(\"OES_texture_half_float\"))}checkFloatTextureAttachableToFrameBuffer(){let t=this.gl,o=t.createTexture();t.bindTexture(t.TEXTURE_2D,o);let e=this.version===2?t.RGBA32F:t.RGBA;t.texImage2D(t.TEXTURE_2D,0,e,1,1,0,t.RGBA,t.FLOAT,null);let r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,o,0);let n=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(o),t.deleteFramebuffer(r),n}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension(\"WEBGL_color_buffer_float\"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let t=this.gl,o,e,r,n,s;try{o=t.createTexture(),e=t.createFramebuffer(),t.bindTexture(t.TEXTURE_2D,o);let i=this.version===2?t.RGBA32F:t.RGBA;return t.texImage2D(t.TEXTURE_2D,0,i,1,1,0,t.RGBA,t.FLOAT,null),t.bindFramebuffer(t.FRAMEBUFFER,e),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,o,0),t.enable(t.BLEND),r=t.createShader(t.VERTEX_SHADER),!r||(t.shaderSource(r,\"void main(){}\"),t.compileShader(r),n=t.createShader(t.FRAGMENT_SHADER),!n)||(t.shaderSource(n,\"precision highp float;void main(){gl_FragColor=vec4(0.5);}\"),t.compileShader(n),s=t.createProgram(),!s)?!1:(t.attachShader(s,r),t.attachShader(s,n),t.linkProgram(s),t.useProgram(s),t.drawArrays(t.POINTS,0,1),t.getError()===t.NO_ERROR)}finally{t.disable(t.BLEND),s&&t.deleteProgram(s),r&&t.deleteShader(r),n&&t.deleteShader(n),e&&(t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(e)),o&&(t.bindTexture(t.TEXTURE_2D,null),t.deleteTexture(o))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let t=this.gl,o=this.disjointTimerQueryWebgl2Extension,e=t.createQuery();return t.beginQuery(o.TIME_ELAPSED_EXT,e),e}else throw new Error(\"WebGL1 profiling currently not supported.\")}endTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let t=this.gl,o=this.disjointTimerQueryWebgl2Extension;t.endQuery(o.TIME_ELAPSED_EXT);return}else throw new Error(\"WebGL1 profiling currently not supported\")}isTimerResultAvailable(t){let o=!1,e=!1;if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let r=this.gl,n=this.disjointTimerQueryWebgl2Extension;o=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE),e=r.getParameter(n.GPU_DISJOINT_EXT)}else throw new Error(\"WebGL1 profiling currently not supported\");return o&&!e}getTimerResult(t){let o=0;if(this.version===2){let e=this.gl;o=e.getQueryParameter(t,e.QUERY_RESULT),e.deleteQuery(t)}else throw new Error(\"WebGL1 profiling currently not supported\");return o/1e6}async waitForQueryAndGetTime(t){return await gi(()=>this.isTimerResultAvailable(t)),this.getTimerResult(t)}async createAndWaitForFence(){let t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let o,e=t,r=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);return t.flush(),r===null?o=()=>!0:o=()=>{let n=e.clientWaitSync(r,0,0);return n===e.ALREADY_SIGNALED||n===e.CONDITION_SATISFIED},{query:r,isFencePassed:o}}async pollFence(t){return new Promise(o=>{this.addItemToPoll(()=>t.isFencePassed(),()=>o())})}pollItems(){let t=Xb(this.itemsToPoll.map(o=>o.isDoneFn));for(let o=0;o<=t;++o){let{resolveFn:e}=this.itemsToPoll[o];e()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}async addItemToPoll(t,o){this.itemsToPoll.push({isDoneFn:t,resolveFn:o}),!(this.itemsToPoll.length>1)&&await gi(()=>(this.pollItems(),this.itemsToPoll.length===0))}}});function ji(a){let t;if((!a||a===\"webgl2\")&&\"webgl2\"in zr?t=zr.webgl2:(!a||a===\"webgl\")&&\"webgl\"in zr&&(t=zr.webgl),!t)try{let e=Jb();t=dp(e,a)}catch{let r=Kb();t=dp(r,a)}a=a||t.version===1?\"webgl\":\"webgl2\";let o=t.gl;return zr[a]=t,o.isContextLost()?(delete zr[a],ji(a)):(o.disable(o.DEPTH_TEST),o.disable(o.STENCIL_TEST),o.disable(o.BLEND),o.disable(o.DITHER),o.disable(o.POLYGON_OFFSET_FILL),o.disable(o.SAMPLE_COVERAGE),o.enable(o.SCISSOR_TEST),o.enable(o.CULL_FACE),o.cullFace(o.BACK),t)}function dp(a,t){let o={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1},e,r=o;if((!t||t===\"webgl2\")&&(e=a.getContext(\"webgl2\",r),e))try{return new bn(e,2)}catch(n){ce.warning(\"GlContextFactory\",`failed to create WebGLContext using contextId 'webgl2'. Error: ${n}`)}if((!t||t===\"webgl\")&&(e=a.getContext(\"webgl\",r)||a.getContext(\"experimental-webgl\",r),e))try{return new bn(e,1)}catch(n){ce.warning(\"GlContextFactory\",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${n}`)}throw new Error(\"WebGL is not supported\")}function Kb(){if(typeof document>\"u\")throw new TypeError(\"failed to create canvas: document is not supported\");let a=document.createElement(\"canvas\");return a.width=1,a.height=1,a}function Jb(){if(typeof OffscreenCanvas>\"u\")throw new TypeError(\"failed to create offscreen canvas: OffscreenCanvas is not supported\");return new OffscreenCanvas(1,1)}var zr,hp=E(()=>{\"use strict\";at();pp();zr={}});var wo,mp=E(()=>{\"use strict\";Tt();at();cp();hp();wo=class{get contextId(){return Z.webgl.contextId}set contextId(t){Z.webgl.contextId=t}get matmulMaxBatchSize(){return Z.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(t){Z.webgl.matmulMaxBatchSize=t}get textureCacheMode(){return Z.webgl.textureCacheMode}set textureCacheMode(t){Z.webgl.textureCacheMode=t}get pack(){return Z.webgl.pack}set pack(t){Z.webgl.pack=t}get async(){return Z.webgl.async}set async(t){Z.webgl.async=t}initialize(){try{return this.glContext=ji(this.contextId),typeof this.matmulMaxBatchSize!=\"number\"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!=\"string\"&&(this.textureCacheMode=\"full\"),typeof this.pack!=\"boolean\"&&(this.pack=!1),typeof this.async!=\"boolean\"&&(this.async=!1),ce.setWithEnv(Z),Z.webgl.context||Object.defineProperty(Z.webgl,\"context\",{value:this.glContext.gl}),ce.verbose(\"WebGLBackend\",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(t){return ce.warning(\"WebGLBackend\",`Unable to initialize WebGLBackend. ${t}`),!1}}createSessionHandler(t){return new xo(this,t)}dispose(){this.glContext.dispose()}}});async function Yi(a){if(a){let t=typeof a==\"string\"?[a]:a;for(let o of t){let e=bp.get(o);if(e)return e;let r=await Qb(o);if(r)return r}}else return Yi([\"webgl\"]);throw new Error(\"no available backend to use\")}async function Qb(a){let t=Zb;if(typeof t[a]<\"u\"&&eg(t[a])){let o=t[a],e=o.initialize();if(typeof e==\"object\"&&\"then\"in e&&(e=await e),e)return bp.set(a,o),o}}function eg(a){let t=a;return\"initialize\"in t&&typeof t.initialize==\"function\"&&\"createSessionHandler\"in t&&typeof t.createSessionHandler==\"function\"&&\"dispose\"in t&&typeof t.dispose==\"function\"}var bp,Zb,gp=E(()=>{\"use strict\";mp();bp=new Map,Zb={webgl:new wo}});var Xi,vo,yp=E(()=>{\"use strict\";at();Xi=class{constructor(t,o){this.op=t;this.node=o}},vo=class{constructor(t,o,e){this.graph=t;this.profiler=e;this.initialize(o)}initialize(t){this.profiler.event(\"session\",\"ExecutionPlan.initialize\",()=>{let o=this.graph.getNodes();if(o.length!==t.length)throw new Error(\"The size of nodes and OPs do not match.\");this._ops=t.map((e,r)=>new Xi(e,o[r])),this.reset(),this._starter=[],this._ops.forEach((e,r)=>{let n=!0;for(let s of e.node.inputs)if(!this._values[s]&&this.graph.getInputIndices().indexOf(s)===-1){n=!1;break}n&&this._starter.push(r)})})}reset(){this._values=this.graph.getValues().map(t=>t.tensor)}async execute(t,o){return this.profiler.event(\"session\",\"ExecutionPlan.execute\",async()=>{this.reset();let e=t.createInferenceHandler(),r=this.graph.getInputIndices();if(o.length!==r.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${o.length} expected: ${r.length}`);o.forEach((f,p)=>{let d=r[p];this._values[d]=f});let n=this._starter.slice(0),s=this.graph.getValues(),i=this.graph.getNodes(),u=0;for(;u<n.length;){let f=n[u++],p=this._ops[f],d=p.node.inputs.map(I=>this._values[I]);if(d.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${p.node}`);let T=d;ce.verbose(\"ExecPlan\",`Runing op:${p.node.name} (${T.map((I,L)=>`'${p.node.inputs[L]}': ${I.type}[${I.dims.join(\",\")}]`).join(\", \")})`);let v=await this.profiler.event(\"node\",p.node.name,async()=>p.op.impl(e,T,p.op.context));if(v.length!==p.node.outputs.length)throw new Error(\"the size of output does not match model definition.\");v.forEach((I,L)=>{let F=p.node.outputs[L];if(this._values[F])throw new Error(`output [${F}] already has value: op:${p.node.name}`);this._values[F]=I});let w=new Set;v.forEach((I,L)=>{let F=p.node.outputs[L];for(let C of s[F].to){let Y=i[C],j=!0;for(let M of Y.inputs)if(!this._values[M]){j=!1;break}j&&w.add(C)}}),n.push(...w)}let l=[];for(let f=0;f<this.graph.getOutputIndices().length;f++){let p=this.graph.getOutputIndices()[f],d=this._values[p];if(d===void 0)throw new Error(`required output [${p}] does not have value`);p===0?await d.getData():d.data,l.push(d)}return ce.verbose(\"ExecPlan\",\"disposing of inferenceHandler\"),e.dispose(),l})}}});var oe,dt,gn,Tp=E(()=>{\"use strict\";nn();oe=Er($r());br();fe();dt=W.experimental.fbs,gn=class a{constructor(t){if(this._attributes=new Map,t!=null){for(let o of t)o instanceof oe.onnx.AttributeProto?this._attributes.set(o.name,[a.getValue(o),a.getType(o)]):o instanceof dt.Attribute&&this._attributes.set(o.name(),[a.getValue(o),a.getType(o)]);if(this._attributes.size<t.length)throw new Error(\"duplicated attribute names\")}}set(t,o,e){this._attributes.set(t,[e,o])}delete(t){this._attributes.delete(t)}getFloat(t,o){return this.get(t,\"float\",o)}getInt(t,o){return this.get(t,\"int\",o)}getString(t,o){return this.get(t,\"string\",o)}getTensor(t,o){return this.get(t,\"tensor\",o)}getFloats(t,o){return this.get(t,\"floats\",o)}getInts(t,o){return this.get(t,\"ints\",o)}getStrings(t,o){return this.get(t,\"strings\",o)}getTensors(t,o){return this.get(t,\"tensors\",o)}get(t,o,e){let r=this._attributes.get(t);if(r===void 0){if(e!==void 0)return e;throw new Error(`required attribute not found: ${t}`)}if(r[1]!==o)throw new Error(`type mismatch: expected ${o} but got ${r[1]}`);return r[0]}static getType(t){let o=t instanceof oe.onnx.AttributeProto?t.type:t.type();switch(o){case oe.onnx.AttributeProto.AttributeType.FLOAT:return\"float\";case oe.onnx.AttributeProto.AttributeType.INT:return\"int\";case oe.onnx.AttributeProto.AttributeType.STRING:return\"string\";case oe.onnx.AttributeProto.AttributeType.TENSOR:return\"tensor\";case oe.onnx.AttributeProto.AttributeType.FLOATS:return\"floats\";case oe.onnx.AttributeProto.AttributeType.INTS:return\"ints\";case oe.onnx.AttributeProto.AttributeType.STRINGS:return\"strings\";case oe.onnx.AttributeProto.AttributeType.TENSORS:return\"tensors\";default:throw new Error(`attribute type is not supported yet: ${oe.onnx.AttributeProto.AttributeType[o]}`)}}static getValue(t){let o=t instanceof oe.onnx.AttributeProto?t.type:t.type();if(o===oe.onnx.AttributeProto.AttributeType.GRAPH||o===oe.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error(\"graph attribute is not supported yet\");let e=this.getValueNoCheck(t);if(o===oe.onnx.AttributeProto.AttributeType.INT&&nt.isLong(e))return nt.longToNumber(e);if(o===oe.onnx.AttributeProto.AttributeType.INTS){let r=e,n=new Array(r.length);for(let s=0;s<r.length;s++){let i=r[s];n[s]=nt.longToNumber(i)}return n}if(o===oe.onnx.AttributeProto.AttributeType.TENSOR)return t instanceof oe.onnx.AttributeProto?Ce.fromProto(e):Ce.fromOrtTensor(e);if(o===oe.onnx.AttributeProto.AttributeType.TENSORS){if(t instanceof oe.onnx.AttributeProto)return e.map(n=>Ce.fromProto(n));if(t instanceof dt.Attribute)return e.map(n=>Ce.fromOrtTensor(n))}return o===oe.onnx.AttributeProto.AttributeType.STRING&&t instanceof oe.onnx.AttributeProto?ln(e):o===oe.onnx.AttributeProto.AttributeType.STRINGS&&t instanceof oe.onnx.AttributeProto?e.map(ln):e}static getValueNoCheck(t){return t instanceof oe.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(t):this.getValueNoCheckFromOrtFormat(t)}static getValueNoCheckFromOnnxFormat(t){switch(t.type){case oe.onnx.AttributeProto.AttributeType.FLOAT:return t.f;case oe.onnx.AttributeProto.AttributeType.INT:return t.i;case oe.onnx.AttributeProto.AttributeType.STRING:return t.s;case oe.onnx.AttributeProto.AttributeType.TENSOR:return t.t;case oe.onnx.AttributeProto.AttributeType.GRAPH:return t.g;case oe.onnx.AttributeProto.AttributeType.FLOATS:return t.floats;case oe.onnx.AttributeProto.AttributeType.INTS:return t.ints;case oe.onnx.AttributeProto.AttributeType.STRINGS:return t.strings;case oe.onnx.AttributeProto.AttributeType.TENSORS:return t.tensors;case oe.onnx.AttributeProto.AttributeType.GRAPHS:return t.graphs;default:throw new Error(`unsupported attribute type: ${oe.onnx.AttributeProto.AttributeType[t.type]}`)}}static getValueNoCheckFromOrtFormat(t){switch(t.type()){case dt.AttributeType.FLOAT:return t.f();case dt.AttributeType.INT:return t.i();case dt.AttributeType.STRING:return t.s();case dt.AttributeType.TENSOR:return t.t();case dt.AttributeType.GRAPH:return t.g();case dt.AttributeType.FLOATS:return t.floatsArray();case dt.AttributeType.INTS:{let o=[];for(let e=0;e<t.intsLength();e++)o.push(t.ints(e));return o}case dt.AttributeType.STRINGS:{let o=[];for(let e=0;e<t.stringsLength();e++)o.push(t.strings(e));return o}case dt.AttributeType.TENSORS:{let o=[];for(let e=0;e<t.tensorsLength();e++)o.push(t.tensors(e));return o}default:throw new Error(`unsupported attribute type: ${dt.AttributeType[t.type()]}`)}}}});var Ji,_o,Zi,Rt,Oo,Ki,xp=E(()=>{\"use strict\";Tp();nn();Ji=Er($r());br();fe();_o=W.experimental.fbs,Zi={from:(a,t)=>new Ki(a,t)},Rt=class{constructor(t){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,t&&(this.type=Ve.tensorValueTypeFromProto(t.type.tensorType))}get from(){return this._from}get to(){return this._to}},Oo=class{constructor(t,o){t instanceof Ji.onnx.NodeProto?(this.name=t.name,this.opType=t.opType,this.attributes=new gn(t.attribute)):t instanceof _o.Node&&(this.name=o??t.name(),this.opType=t.opType(),this.attributes=new gn(Ve.tensorAttributesFromORTFormat(t))),this.inputs=[],this.outputs=[],this.executeNode=!0}},Ki=class{constructor(t,o){if(!t)throw new TypeError(\"graph is empty\");this.buildGraph(t),this.transformGraph(o),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(t){if(t instanceof Ji.onnx.GraphProto)this.buildGraphFromOnnxFormat(t);else if(t instanceof _o.Graph)this.buildGraphFromOrtFormat(t);else throw new TypeError(\"Graph type is not supported.\")}buildGraphFromOnnxFormat(t){let o=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let e=new Map;if(!t.input)throw new Error(\"missing information in graph: input\");let r=[];for(let n of t.input){if(o.has(n.name))throw new Error(`duplicated input name: ${n.name}`);let s=this._allData.push(new Rt(n))-1;o.set(n.name,s),r.push(n.name)}if(!t.initializer)throw new Error(\"missing information in graph: initializer\");for(let n of t.initializer){let s=o.get(n.name);if(s===void 0){let i=new Rt;i.type={shape:{dims:Ve.tensorDimsFromProto(n.dims)},tensorType:Ve.tensorDataTypeFromProto(n.dataType)},s=this._allData.push(i)-1,o.set(n.name,s)}this._allData[s]._from=-1,this._allData[s].tensor=Ce.fromProto(n)}for(let n=0;n<this._allData.length;n++)this._allData[n].tensor||(this._allInputIndices.push(n),this._allInputNames.push(r[n]));if(!t.output)throw new Error(\"missing information in graph: output\");for(let n of t.output){if(o.has(n.name))throw new Error(`duplicated output name: ${n.name}`);let s=this._allData.push(new Rt(n))-1;o.set(n.name,s),this._allOutputIndices.push(s),this._allOutputNames.push(n.name)}if(!t.node)throw new Error(\"missing information in graph: node\");for(let n of t.node){if(!n.name)for(let i=0;;i++){let u=`unnamed_${n.opType}_${i}`;if(!e.has(u)){n.name=u;break}}if(e.has(n.name))throw new Error(`duplicated node name: ${n.name}`);let s=this._nodes.push(new Oo(n))-1;e.set(n.name,s)}for(let n=0;n<this._nodes.length;n++){let s=this._nodes[n],i=t.node[n];if(!i.output)throw new Error(`missing output for node: ${i.name}`);for(let u of i.output){let l=o.get(u);if(typeof l>\"u\"&&(l=this._allData.push(new Rt)-1,o.set(u,l)),s.outputs.push(l),this._allData[l]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${l}`);if(this._allData[l]._from=n,i.opType===\"Constant\"){if(!i.attribute||i.attribute.length!==1||!i.attribute[0].t)throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");if(!i.output||i.output.length!==1)throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");s.outputs.pop(),s.executeNode=!1,this._allData[l]._from=-1,this._allData[l].tensor=Ce.fromProto(i.attribute[0].t)}}}for(let n=0;n<this._nodes.length;n++){let s=this._nodes[n],i=t.node[n];if(!i.input)throw new Error(`missing input for node: ${i.name}`);for(let u of i.input){let l=o.get(u);if(typeof l>\"u\"){if(u===\"\"&&(i.input.length===3||i.input.length===4)&&i.opType===\"Resize\")continue;throw new Error(`unrecognized input '${u}' for node: ${i.name}`)}s.inputs.push(l),this._allData[l]._to.push(n)}}return!0}buildGraphFromOrtFormat(t){let o=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let e=new Map,r=[];for(let n=0;n<t.inputsLength();n++){let s=t.inputs(n);if(o.has(s))throw new Error(`duplicated input name: ${s}`);for(let i=0;i<t.nodeArgsLength();i++)if(t.nodeArgs(i)?.name()===s){let u=new Rt;if(t.nodeArgs(i)?.type()?.valueType()!==_o.TypeInfoValue.tensor_type)throw new Error(\"Unexpected value type for the nodeArg.\");let f=t.nodeArgs(i).type().value(new _o.TensorTypeAndShape),p=Ve.tensorDataTypeFromProto(f.elemType()),d=f.shape(),T=[];for(let w=0;w<d.dimLength();w++)T.push(nt.longToNumber(d.dim(w).value().dimValue()));u.type={shape:{dims:T},tensorType:p};let v=this._allData.push(u)-1;o.set(s,v),r.push(s)}}for(let n=0;n<t.initializersLength();n++){let s=t.initializers(n),i=o.get(s.name());if(i===void 0){let u=new Rt,l=Ve.tensorDimsFromORTFormat(s),f=Ve.tensorDataTypeFromProto(s.dataType());u.type={shape:{dims:l},tensorType:f},i=this._allData.push(u)-1,o.set(s.name(),i)}this._allData[i]._from=-1,this._allData[i].tensor=Ce.fromOrtTensor(s)}for(let n=0;n<this._allData.length;n++)this._allData[n].tensor||(this._allInputIndices.push(n),this._allInputNames.push(r[n]));for(let n=0;n<t.outputsLength();n++){let s=t.outputs(n);if(o.has(s))throw new Error(`duplicated output name: ${s}`);let i=this._allData.push(new Rt)-1;o.set(s,i),this._allOutputIndices.push(i),this._allOutputNames.push(s)}if(!t.nodes)throw new Error(\"missing information in graph: node\");for(let n=0;n<t.nodesLength();n++){let s=t.nodes(n),i=s.name();if(!i)for(let l=0;i=`unnamed_${s.opType()}_${l}`,!!e.has(i);l++);if(e.has(i))throw new Error(`duplicated node name: ${i}`);let u=this._nodes.push(new Oo(s,i))-1;e.set(i,u)}for(let n=0;n<this._nodes.length;n++){let s=this._nodes[n],i=t.nodes(n);if(i==null)throw new Error(`No node exists at index ${n}`);if(i?.outputsLength()===0)throw new Error(`missing output for node: ${i.name}`);for(let u=0;u<i?.outputsLength();u++){let l=i?.outputs(u),f=o.get(l);if(typeof f>\"u\"&&(f=this._allData.push(new Rt)-1,o.set(l,f)),s.outputs.push(f),this._allData[f]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${f}`);if(this._allData[f]._from=n,i.opType()===\"Constant\"){if(i.attributesLength()!==1||!i.attributes(0).t())throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");if(i.outputsLength()!==1)throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");s.outputs.pop(),s.executeNode=!1,this._allData[f]._from=-1,this._allData[f].tensor=Ce.fromOrtTensor(i.attributes(0).t())}}}for(let n=0;n<this._nodes.length;n++){let s=this._nodes[n],i=t.nodes(n);if(i.inputsLength()===0)throw new Error(`missing input for node: ${i.name}`);for(let u=0;u<i.inputsLength();u++){let l=i.inputs(u),f=o.get(l);if(typeof f>\"u\")throw new Error(`unrecognized input '${l}' for node: ${i.name()}`);s.inputs.push(f),this._allData[f]._to.push(n)}}}checkIsAcyclic(){let t=new Set;this._allInputIndices.forEach(r=>{this._allData[r]._to.forEach(s=>{t.add(s)})});let o=Array.from(t),e=new Array(this._nodes.length).fill(\"white\");for(;o.length>0;){let r=o.pop();e[r]===\"gray\"?e[r]=\"black\":(o.push(r),e[r]=\"gray\",this._nodes[r].outputs.forEach(n=>{let s=this._allData[n];if(typeof s.tensor<\"u\")throw new Error(\"node outputs should not be initialized\");if(s._from!==r)throw new Error(\"from property of the Value object doesn't match index of Node being processed\");s._to.forEach(i=>{if(e[i]===\"gray\")throw new Error(\"model graph is cyclic\");e[i]===\"white\"&&o.push(i)})}))}}transformGraph(t){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),t&&t.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let t=0,o=new Array(this._nodes.length,0),e=0;for(let r=0;r<this._nodes.length;r++)o[r]=e,this._nodes[r].executeNode?(e!==r&&(this._nodes[e]=this._nodes[r]),e++):this._nodes[r].outputs.forEach(n=>{this._allData[n]._from=-2});this._nodes.splice(e,this._nodes.length-e);for(let r=0;r<this._allData.length;r++){let n=this._allData[r];n._from!==void 0&&n._from!==-1&&n._from!==-2&&(n._from=o[n._from]);for(let s=0;s<n._to.length;s++)if(n._to[s]>=0)n._to[s]=o[n._to[s]];else throw new Error(\"Trying to update a removed node\")}t=0;for(let r=0;r<this._allData.length;r++){if(this._allData[r].from===-2&&this._allOutputIndices.indexOf(r+t)===-1){t++,this._allData.splice(r,1),r--;continue}if(t>0){let n=-1;this._allData[r].from!==void 0&&this._allData[r].from!==-1?(n=this._nodes[this._allData[r].from].outputs.indexOf(r+t),n!==-1&&(this._nodes[this._allData[r].from].outputs[n]=r)):(n=this._allInputIndices.indexOf(r+t),n!==-1&&(this._allInputIndices[n]=r)),this._allData[r].to.forEach(s=>{n=this._nodes[s].inputs.indexOf(r+t),n!==-1&&(this._nodes[s].inputs[n]=r)}),this._allData[r].to.length===0&&(n=this._allOutputIndices.indexOf(r+t),n!==-1&&(this._allOutputIndices[n]=r))}}}deleteNode(t){let o=this._nodes[t];if(o.outputs.length>1){for(let i=1;i<o.outputs.length;i++)if(this._allData[o.outputs[i]].to.length>0)throw new Error(\"Node deletion with more than one output connected to other nodes is not supported. \")}o.executeNode=!1;let e=o.inputs[0],r=o.outputs[0],n=this._allData[r].to;for(let i=0;i<o.inputs.length;i++){let u=this._allData[o.inputs[i]].to.indexOf(t);if(u===-1)throw new Error(\"The Value object doesn't have the current Node in it's 'to' property \");this._allData[o.inputs[i]].to.splice(u,1)}this._allData[r]._to=[];let s=this._allOutputIndices.indexOf(r);if(s!==-1&&(this._allOutputIndices[s]=e),n&&n.length>0)for(let i of n){let u=this._nodes[i].inputs.indexOf(r);if(u===-1)throw new Error(\"The Node object doesn't have the output Value in it's 'inputs' property \");this._nodes[i].inputs[u]=e,this._allData[e].to.push(i)}}removeAllDropoutNodes(){let t=0;for(let o of this._nodes){if(o.opType===\"Dropout\"){if(o.inputs.length!==1)throw new Error(\"Dropout nodes should only contain one input. \");if(o.outputs.length!==1&&o.outputs.length!==2)throw new Error(\"Dropout nodes should contain either 1 or 2 output(s)\");if(o.outputs.length===2&&this._allData[o.outputs[1]]._to.length!==0)throw new Error(\"Dropout nodes's second output should not be referenced by other nodes\");this.deleteNode(t)}t++}}removeAllIdentityNodes(){let t=0;for(let o of this._nodes)o.opType===\"Identity\"&&this.deleteNode(t),t++}isActivation(t){switch(t.opType){case\"Relu\":case\"Sigmoid\":case\"Clip\":return!0;default:return!1}}fuseConvActivationNodes(){for(let t of this._nodes)if(t.opType===\"Conv\"){let o=this._allData[t.outputs[0]]._to;if(o.length===1&&this.isActivation(this._nodes[o[0]])){let e=this._nodes[o[0]];if(e.opType===\"Clip\")if(e.inputs.length===1)try{t.attributes.set(\"activation_params\",\"floats\",[e.attributes.getFloat(\"min\"),e.attributes.getFloat(\"max\")])}catch{t.attributes.set(\"activation_params\",\"floats\",[hr,mr])}else if(e.inputs.length>=3&&this._allData[e.inputs[1]].tensor!==void 0&&this._allData[e.inputs[2]].tensor!==void 0)t.attributes.set(\"activation_params\",\"floats\",[this._allData[e.inputs[1]].tensor.floatData[0],this._allData[e.inputs[2]].tensor.floatData[0]]);else continue;t.attributes.set(\"activation\",\"string\",e.opType),this.deleteNode(o[0])}}}}});var wp,tg,Io,vp=E(()=>{\"use strict\";Wn();xp();nn();wp=Er($r());fe();tg=W.experimental.fbs,Io=class{constructor(){}load(t,o,e){if(!e)try{this.loadFromOnnxFormat(t,o);return}catch(r){if(e!==void 0)throw r}this.loadFromOrtFormat(t,o)}loadFromOnnxFormat(t,o){let e=wp.onnx.ModelProto.decode(t);if(nt.longToNumber(e.irVersion)<3)throw new Error(\"only support ONNX model with IR_VERSION>=3\");this._opsets=e.opsetImport.map(n=>({domain:n.domain,version:nt.longToNumber(n.version)})),this._graph=Zi.from(e.graph,o)}loadFromOrtFormat(t,o){let e=new O.ByteBuffer(t),r=tg.InferenceSession.getRootAsInferenceSession(e).model();if(nt.longToNumber(r.irVersion())<3)throw new Error(\"only support ONNX model with IR_VERSION>=3\");this._opsets=[];for(let s=0;s<r.opsetImportLength();s++){let i=r.opsetImport(s);this._opsets.push({domain:i?.domain(),version:nt.longToNumber(i.version())})}this._graph=Zi.from(r.graph(),o)}get graph(){return this._graph}get opsets(){return this._opsets}}});var So,_p=E(()=>{\"use strict\";gp();yp();at();vp();So=class{constructor(t={}){this._initialized=!1,this.backendHint=t.backendHint,this.profiler=zn.create(t.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(t,o,e){await this.profiler.event(\"session\",\"Session.loadModel\",async()=>{let r=await Yi(this.backendHint);if(this.sessionHandler=r.createSessionHandler(this.context),this._model=new Io,typeof t==\"string\"){let n=t.endsWith(\".ort\");if(typeof process<\"u\"&&process.versions&&process.versions.node){let s=await(void 0)(t);this.initialize(s,n)}else{let i=await(await fetch(t)).arrayBuffer();this.initialize(new Uint8Array(i),n)}}else if(ArrayBuffer.isView(t))this.initialize(t);else{let n=new Uint8Array(t,o||0,e||t.byteLength);this.initialize(n)}})}initialize(t,o){if(this._initialized)throw new Error(\"already initialized\");this.profiler.event(\"session\",\"Session.initialize\",()=>{let e=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(t,e,o),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new vo(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(t){if(!this._initialized)throw new Error(\"session not initialized yet\");return this.profiler.event(\"session\",\"Session.run\",async()=>{let o=this.normalizeAndValidateInputs(t),e=await this._executionPlan.execute(this.sessionHandler,o);return this.createOutput(e)})}normalizeAndValidateInputs(t){let o=this._model.graph.getInputNames();if(Array.isArray(t)){if(t.length!==o.length)throw new Error(`incorrect input array length: expected ${o.length} but got ${t.length}`)}else{if(t.size!==o.length)throw new Error(`incorrect input map size: expected ${o.length} but got ${t.size}`);let e=new Array(t.size),r=0;for(let n=0;n<o.length;++n){let s=t.get(o[n]);if(!s)throw new Error(`missing input tensor for: '${name}'`);e[r++]=s}t=e}if(!this.context.graphInputTypes||this.context.graphInputTypes.length===0||!this.context.graphInputDims||this.context.graphInputDims.length===0){let e=this._model.graph.getInputIndices(),r=this._model.graph.getValues(),n=new Array(e.length);for(let s=0;s<e.length;++s){let i=r[e[s]];n[s]=i.type.shape.dims,this.context.graphInputTypes.push(i.type.tensorType),this.context.graphInputDims.push(t[s].dims)}this.validateInputTensorDims(n,t,!0)}else this.validateInputTensorDims(this.context.graphInputDims,t,!1);return this.validateInputTensorTypes(this.context.graphInputTypes,t),t}validateInputTensorTypes(t,o){for(let e=0;e<o.length;e++){let r=t[e],n=o[e].type;if(r!==n)throw new Error(`input tensor[${e}] check failed: expected type '${r}' but got ${n}`)}}validateInputTensorDims(t,o,e){for(let r=0;r<o.length;r++){let n=t[r],s=o[r].dims;if(!this.compareTensorDims(n,s,e))throw new Error(`input tensor[${r}] check failed: expected shape '[${n.join(\",\")}]' but got [${s.join(\",\")}]`)}}compareTensorDims(t,o,e){if(t.length!==o.length)return!1;for(let r=0;r<t.length;++r)if(t[r]!==o[r]&&(!e||t[r]!==0))return!1;return!0}createOutput(t){let o=this._model.graph.getOutputNames();if(t.length!==o.length)throw new Error(\"expected number of outputs do not match number of generated outputs\");let e=new Map;for(let r=0;r<o.length;++r)e.set(o[r],t[r]);return e}initializeOps(t){let o=t.getNodes();this._ops=new Array(o.length);for(let e=0;e<o.length;e++)this._ops[e]=this.sessionHandler.resolve(o[e],this._model.opsets,t)}}});var Ao,Op=E(()=>{\"use strict\";Tt();br();Ao=class{constructor(t){this.session=t;this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(t,o,e){let r=new Map;for(let i in t)if(Object.hasOwnProperty.call(t,i)){let u=t[i];r.set(i,new Ce(u.dims,u.type,void 0,void 0,u.data))}let n=await this.session.run(r),s={};return n.forEach((i,u)=>{s[u]=new Re(i.type,i.data,i.dims)}),s}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}});var Ip={};Pr(Ip,{onnxjsBackend:()=>ng});var Qi,ng,Sp=E(()=>{\"use strict\";_p();Op();Qi=class{async init(){}async createInferenceSessionHandler(t,o){let e=new So(o);return typeof t==\"string\"?await e.loadModel(t):await e.loadModel(t),new Ao(e)}},ng=new Qi});var ea={};Pr(ea,{createReadStream:()=>Ap,readFile:()=>og,readFileSync:()=>ig});var og,ig,Ap,ta=E(()=>{og=void 0,ig=void 0,Ap=void 0});var ra={};Pr(ra,{join:()=>ag});var ag,na=E(()=>{ag=void 0});var Dp=me((Ep,oa)=>{\"use strict\";var Pp=(()=>{var a=typeof document<\"u\"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<\"u\"&&(a=a||__filename),function(t={}){var o=t,e,r;o.ready=new Promise((b,x)=>{e=b,r=x});var n=Object.assign({},o),s=\"./this.program\",i=typeof window==\"object\",u=typeof importScripts==\"function\",l=typeof process==\"object\"&&typeof process.versions==\"object\"&&typeof process.versions.node==\"string\",f=\"\",p,d,T;if(l){var v=(ta(),or(ea)),w=(na(),or(ra));f=u?w.dirname(f)+\"/\":__dirname+\"/\",p=(b,x)=>(b=St(b)?new URL(b):w.normalize(b),v.readFileSync(b,x?void 0:\"utf8\")),T=b=>(b=p(b,!0),b.buffer||(b=new Uint8Array(b)),b),d=(b,x,_,D=!0)=>{b=St(b)?new URL(b):w.normalize(b),v.readFile(b,D?void 0:\"utf8\",(G,X)=>{G?_(G):x(D?X.buffer:X)})},!o.thisProgram&&1<process.argv.length&&(s=process.argv[1].replace(/\\\\/g,\"/\")),process.argv.slice(2),o.inspect=()=>\"[Emscripten Module object]\"}else(i||u)&&(u?f=self.location.href:typeof document<\"u\"&&document.currentScript&&(f=document.currentScript.src),a&&(f=a),f.indexOf(\"blob:\")!==0?f=f.substr(0,f.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):f=\"\",p=b=>{var x=new XMLHttpRequest;return x.open(\"GET\",b,!1),x.send(null),x.responseText},u&&(T=b=>{var x=new XMLHttpRequest;return x.open(\"GET\",b,!1),x.responseType=\"arraybuffer\",x.send(null),new Uint8Array(x.response)}),d=(b,x,_)=>{var D=new XMLHttpRequest;D.open(\"GET\",b,!0),D.responseType=\"arraybuffer\",D.onload=()=>{D.status==200||D.status==0&&D.response?x(D.response):_()},D.onerror=_,D.send(null)});var I=console.log.bind(console),L=console.error.bind(console);Object.assign(o,n),n=null,typeof WebAssembly!=\"object\"&&te(\"no native wasm support detected\");var F,C=!1,Y,j,M,ie,ot;function We(){var b=F.buffer;o.HEAP8=Y=new Int8Array(b),o.HEAP16=new Int16Array(b),o.HEAPU8=j=new Uint8Array(b),o.HEAPU16=new Uint16Array(b),o.HEAP32=M=new Int32Array(b),o.HEAPU32=ie=new Uint32Array(b),o.HEAPF32=new Float32Array(b),o.HEAPF64=ot=new Float64Array(b)}var Fe=[],V=[],Ae=[],It=0,mt=null,Be=null;function te(b){throw b=\"Aborted(\"+b+\")\",L(b),C=!0,b=new WebAssembly.RuntimeError(b+\". Build with -sASSERTIONS for more info.\"),r(b),b}var bt=b=>b.startsWith(\"data:application/octet-stream;base64,\"),St=b=>b.startsWith(\"file://\"),He;if(He=\"ort-wasm.wasm\",!bt(He)){var At=He;He=o.locateFile?o.locateFile(At,f):f+At}function we(b){if(T)return T(b);throw\"both async and sync fetching of the wasm failed\"}function Ze(b){if(i||u){if(typeof fetch==\"function\"&&!St(b))return fetch(b,{credentials:\"same-origin\"}).then(x=>{if(!x.ok)throw\"failed to load wasm binary file at '\"+b+\"'\";return x.arrayBuffer()}).catch(()=>we(b));if(d)return new Promise((x,_)=>{d(b,D=>x(new Uint8Array(D)),_)})}return Promise.resolve().then(()=>we(b))}function Qt(b,x,_){return Ze(b).then(D=>WebAssembly.instantiate(D,x)).then(D=>D).then(_,D=>{L(`failed to asynchronously prepare wasm: ${D}`),te(D)})}function Pt(b,x){var _=He;return typeof WebAssembly.instantiateStreaming!=\"function\"||bt(_)||St(_)||l||typeof fetch!=\"function\"?Qt(_,b,x):fetch(_,{credentials:\"same-origin\"}).then(D=>WebAssembly.instantiateStreaming(D,b).then(x,function(G){return L(`wasm streaming compile failed: ${G}`),L(\"falling back to ArrayBuffer instantiation\"),Qt(_,b,x)}))}var gt,yt={920016:(b,x,_,D)=>{if(typeof o>\"u\"||!o.za)return 1;if(b=ve(b>>>0),b.startsWith(\"./\")&&(b=b.substring(2)),b=o.za.get(b),!b)return 2;if(x>>>=0,_>>>=0,x+_>b.byteLength)return 3;try{return j.set(b.subarray(x,x+_),D>>>0>>>0),0}catch{return 4}}};function er(b){this.xa=b-24,this.Ha=function(x){ie[this.xa+4>>>2>>>0]=x},this.Ga=function(x){ie[this.xa+8>>>2>>>0]=x},this.Aa=function(x,_){this.Fa(),this.Ha(x),this.Ga(_)},this.Fa=function(){ie[this.xa+16>>>2>>>0]=0}}var Qe=0,Et=0,Mt=typeof TextDecoder<\"u\"?new TextDecoder(\"utf8\"):void 0,$e=(b,x,_)=>{x>>>=0;var D=x+_;for(_=x;b[_]&&!(_>=D);)++_;if(16<_-x&&b.buffer&&Mt)return Mt.decode(b.subarray(x,_));for(D=\"\";x<_;){var G=b[x++];if(G&128){var X=b[x++]&63;if((G&224)==192)D+=String.fromCharCode((G&31)<<6|X);else{var ne=b[x++]&63;G=(G&240)==224?(G&15)<<12|X<<6|ne:(G&7)<<18|X<<12|ne<<6|b[x++]&63,65536>G?D+=String.fromCharCode(G):(G-=65536,D+=String.fromCharCode(55296|G>>10,56320|G&1023))}}else D+=String.fromCharCode(G)}return D},ve=(b,x)=>(b>>>=0)?$e(j,b,x):\"\",qe=b=>{for(var x=0,_=0;_<b.length;++_){var D=b.charCodeAt(_);127>=D?x++:2047>=D?x+=2:55296<=D&&57343>=D?(x+=4,++_):x+=3}return x},Gt=(b,x,_,D)=>{if(_>>>=0,!(0<D))return 0;var G=_;D=_+D-1;for(var X=0;X<b.length;++X){var ne=b.charCodeAt(X);if(55296<=ne&&57343>=ne){var ke=b.charCodeAt(++X);ne=65536+((ne&1023)<<10)|ke&1023}if(127>=ne){if(_>=D)break;x[_++>>>0]=ne}else{if(2047>=ne){if(_+1>=D)break;x[_++>>>0]=192|ne>>6}else{if(65535>=ne){if(_+2>=D)break;x[_++>>>0]=224|ne>>12}else{if(_+3>=D)break;x[_++>>>0]=240|ne>>18,x[_++>>>0]=128|ne>>12&63}x[_++>>>0]=128|ne>>6&63}x[_++>>>0]=128|ne&63}}return x[_>>>0]=0,_-G},Dt=b=>b%4===0&&(b%100!==0||b%400===0),jr=[0,31,60,91,121,152,182,213,244,274,305,335],wn=[0,31,59,90,120,151,181,212,243,273,304,334],Ut=b=>{var x=qe(b)+1,_=_n(x);return _&&Gt(b,j,_,x),_},vr=[],qt={},_r=()=>{if(!Or){var b={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(typeof navigator==\"object\"&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:s||\"./this.program\"},x;for(x in qt)qt[x]===void 0?delete b[x]:b[x]=qt[x];var _=[];for(x in b)_.push(`${x}=${b[x]}`);Or=_}return Or},Or,tr=[null,[],[]],Yr=[31,29,31,30,31,30,31,31,30,31,30,31],Xr=[31,28,31,30,31,30,31,31,30,31,30,31];function Ir(b){var x=Array(qe(b)+1);return Gt(b,x,0,x.length),x}function vn(b,x,_,D){function G(A,pe,Te){for(A=typeof A==\"number\"?A.toString():A||\"\";A.length<pe;)A=Te[0]+A;return A}function X(A,pe){return G(A,pe,\"0\")}function ne(A,pe){function Te(en){return 0>en?-1:0<en?1:0}var Lt;return(Lt=Te(A.getFullYear()-pe.getFullYear()))===0&&(Lt=Te(A.getMonth()-pe.getMonth()))===0&&(Lt=Te(A.getDate()-pe.getDate())),Lt}function ke(A){switch(A.getDay()){case 0:return new Date(A.getFullYear()-1,11,29);case 1:return A;case 2:return new Date(A.getFullYear(),0,3);case 3:return new Date(A.getFullYear(),0,2);case 4:return new Date(A.getFullYear(),0,1);case 5:return new Date(A.getFullYear()-1,11,31);case 6:return new Date(A.getFullYear()-1,11,30)}}function Ye(A){var pe=A.ta;for(A=new Date(new Date(A.ua+1900,0,1).getTime());0<pe;){var Te=A.getMonth(),Lt=(Dt(A.getFullYear())?Yr:Xr)[Te];if(pe>Lt-A.getDate())pe-=Lt-A.getDate()+1,A.setDate(1),11>Te?A.setMonth(Te+1):(A.setMonth(0),A.setFullYear(A.getFullYear()+1));else{A.setDate(A.getDate()+pe);break}}return Te=new Date(A.getFullYear()+1,0,4),pe=ke(new Date(A.getFullYear(),0,4)),Te=ke(Te),0>=ne(pe,A)?0>=ne(Te,A)?A.getFullYear()+1:A.getFullYear():A.getFullYear()-1}b>>>=0,x>>>=0,_>>>=0,D>>>=0;var Ue=ie[D+40>>>2>>>0];D={Da:M[D>>>2>>>0],Ca:M[D+4>>>2>>>0],va:M[D+8>>>2>>>0],ya:M[D+12>>>2>>>0],wa:M[D+16>>>2>>>0],ua:M[D+20>>>2>>>0],oa:M[D+24>>>2>>>0],ta:M[D+28>>>2>>>0],Ia:M[D+32>>>2>>>0],Ba:M[D+36>>>2>>>0],Ea:Ue?ve(Ue):\"\"},_=ve(_),Ue={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"};for(var ze in Ue)_=_.replace(new RegExp(ze,\"g\"),Ue[ze]);var Zr=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),Qr=\"January February March April May June July August September October November December\".split(\" \");Ue={\"%a\":A=>Zr[A.oa].substring(0,3),\"%A\":A=>Zr[A.oa],\"%b\":A=>Qr[A.wa].substring(0,3),\"%B\":A=>Qr[A.wa],\"%C\":A=>X((A.ua+1900)/100|0,2),\"%d\":A=>X(A.ya,2),\"%e\":A=>G(A.ya,2,\" \"),\"%g\":A=>Ye(A).toString().substring(2),\"%G\":A=>Ye(A),\"%H\":A=>X(A.va,2),\"%I\":A=>(A=A.va,A==0?A=12:12<A&&(A-=12),X(A,2)),\"%j\":A=>{for(var pe=0,Te=0;Te<=A.wa-1;pe+=(Dt(A.ua+1900)?Yr:Xr)[Te++]);return X(A.ya+pe,3)},\"%m\":A=>X(A.wa+1,2),\"%M\":A=>X(A.Ca,2),\"%n\":()=>`\n`,\"%p\":A=>0<=A.va&&12>A.va?\"AM\":\"PM\",\"%S\":A=>X(A.Da,2),\"%t\":()=>\"\t\",\"%u\":A=>A.oa||7,\"%U\":A=>X(Math.floor((A.ta+7-A.oa)/7),2),\"%V\":A=>{var pe=Math.floor((A.ta+7-(A.oa+6)%7)/7);if(2>=(A.oa+371-A.ta-2)%7&&pe++,pe)pe==53&&(Te=(A.oa+371-A.ta)%7,Te==4||Te==3&&Dt(A.ua)||(pe=1));else{pe=52;var Te=(A.oa+7-A.ta-1)%7;(Te==4||Te==5&&Dt(A.ua%400-1))&&pe++}return X(pe,2)},\"%w\":A=>A.oa,\"%W\":A=>X(Math.floor((A.ta+7-(A.oa+6)%7)/7),2),\"%y\":A=>(A.ua+1900).toString().substring(2),\"%Y\":A=>A.ua+1900,\"%z\":A=>{A=A.Ba;var pe=0<=A;return A=Math.abs(A)/60,(pe?\"+\":\"-\")+(\"0000\"+(A/60*100+A%60)).slice(-4)},\"%Z\":A=>A.Ea,\"%%\":()=>\"%\"},_=_.replace(/%%/g,\"\\0\\0\");for(ze in Ue)_.includes(ze)&&(_=_.replace(new RegExp(ze,\"g\"),Ue[ze](D)));return _=_.replace(/\\0\\0/g,\"%\"),ze=Ir(_),ze.length>x?0:(Y.set(ze,b>>>0),ze.length-1)}var he={a:function(b,x,_){throw b>>>=0,new er(b).Aa(x>>>0,_>>>0),Qe=b,Et++,Qe},e:function(){return 0},H:function(){},x:function(){},z:function(){},J:function(){return 0},F:function(){},A:function(){},E:function(){},g:function(){},y:function(){},v:function(){},G:function(){},w:function(){},k:()=>1,n:function(b,x,_){b=x+2097152>>>0<4194305-!!b?(b>>>0)+4294967296*x:NaN,_>>>=0,b=new Date(1e3*b),M[_>>>2>>>0]=b.getUTCSeconds(),M[_+4>>>2>>>0]=b.getUTCMinutes(),M[_+8>>>2>>>0]=b.getUTCHours(),M[_+12>>>2>>>0]=b.getUTCDate(),M[_+16>>>2>>>0]=b.getUTCMonth(),M[_+20>>>2>>>0]=b.getUTCFullYear()-1900,M[_+24>>>2>>>0]=b.getUTCDay(),M[_+28>>>2>>>0]=(b.getTime()-Date.UTC(b.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(b,x,_){b=x+2097152>>>0<4194305-!!b?(b>>>0)+4294967296*x:NaN,_>>>=0,b=new Date(1e3*b),M[_>>>2>>>0]=b.getSeconds(),M[_+4>>>2>>>0]=b.getMinutes(),M[_+8>>>2>>>0]=b.getHours(),M[_+12>>>2>>>0]=b.getDate(),M[_+16>>>2>>>0]=b.getMonth(),M[_+20>>>2>>>0]=b.getFullYear()-1900,M[_+24>>>2>>>0]=b.getDay(),M[_+28>>>2>>>0]=(Dt(b.getFullYear())?jr:wn)[b.getMonth()]+b.getDate()-1|0,M[_+36>>>2>>>0]=-(60*b.getTimezoneOffset()),x=new Date(b.getFullYear(),6,1).getTimezoneOffset();var D=new Date(b.getFullYear(),0,1).getTimezoneOffset();M[_+32>>>2>>>0]=(x!=D&&b.getTimezoneOffset()==Math.min(D,x))|0},p:function(b){b>>>=0;var x=new Date(M[b+20>>>2>>>0]+1900,M[b+16>>>2>>>0],M[b+12>>>2>>>0],M[b+8>>>2>>>0],M[b+4>>>2>>>0],M[b>>>2>>>0],0),_=M[b+32>>>2>>>0],D=x.getTimezoneOffset(),G=new Date(x.getFullYear(),6,1).getTimezoneOffset(),X=new Date(x.getFullYear(),0,1).getTimezoneOffset(),ne=Math.min(X,G);return 0>_?M[b+32>>>2>>>0]=+(G!=X&&ne==D):0<_!=(ne==D)&&(G=Math.max(X,G),x.setTime(x.getTime()+6e4*((0<_?ne:G)-D))),M[b+24>>>2>>>0]=x.getDay(),M[b+28>>>2>>>0]=(Dt(x.getFullYear())?jr:wn)[x.getMonth()]+x.getDate()-1|0,M[b>>>2>>>0]=x.getSeconds(),M[b+4>>>2>>>0]=x.getMinutes(),M[b+8>>>2>>>0]=x.getHours(),M[b+12>>>2>>>0]=x.getDate(),M[b+16>>>2>>>0]=x.getMonth(),M[b+20>>>2>>>0]=x.getYear(),b=x.getTime(),isNaN(b)?(M[Sr()>>>2>>>0]=61,b=-1):b/=1e3,Kr((gt=b,1<=+Math.abs(gt)?0<gt?+Math.floor(gt/4294967296)>>>0:~~+Math.ceil((gt-+(~~gt>>>0))/4294967296)>>>0:0)),b>>>0},l:function(){return-52},m:function(){},t:function(b,x,_){function D(Ye){return(Ye=Ye.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?Ye[1]:\"GMT\"}_>>>=0;var G=new Date().getFullYear(),X=new Date(G,0,1),ne=new Date(G,6,1);G=X.getTimezoneOffset();var ke=ne.getTimezoneOffset();ie[b>>>0>>>2>>>0]=60*Math.max(G,ke),M[x>>>0>>>2>>>0]=+(G!=ke),b=D(X),x=D(ne),b=Ut(b),x=Ut(x),ke<G?(ie[_>>>2>>>0]=b,ie[_+4>>>2>>>0]=x):(ie[_>>>2>>>0]=x,ie[_+4>>>2>>>0]=b)},d:()=>{te(\"\")},B:function(b,x,_){b>>>=0,x>>>=0,_>>>=0,vr.length=0;for(var D;D=j[x++>>>0];){var G=D!=105;G&=D!=112,_+=G&&_%8?4:0,vr.push(D==112?ie[_>>>2>>>0]:D==105?M[_>>>2>>>0]:ot[_>>>3>>>0]),_+=G?8:4}return yt[b].apply(null,vr)},h:()=>Date.now(),u:function(){return 4294901760},b:()=>performance.now(),I:function(b,x,_){return x>>>=0,j.copyWithin(b>>>0>>>0,x>>>0,x+(_>>>0)>>>0)},s:function(b){b>>>=0;var x=j.length;if(4294901760<b)return!1;for(var _=1;4>=_;_*=2){var D=x*(1+.2/_);D=Math.min(D,b+100663296);var G=Math;D=Math.max(b,D);e:{G=(G.min.call(G,4294901760,D+(65536-D%65536)%65536)-F.buffer.byteLength+65535)/65536;try{F.grow(G),We();var X=1;break e}catch{}X=void 0}if(X)return!0}return!1},C:function(b,x){b>>>=0,x>>>=0;var _=0;return _r().forEach((D,G)=>{var X=x+_;for(G=ie[b+4*G>>>2>>>0]=X,X=0;X<D.length;++X)Y[G++>>>0>>>0]=D.charCodeAt(X);Y[G>>>0>>>0]=0,_+=D.length+1}),0},D:function(b,x){b>>>=0,x>>>=0;var _=_r();ie[b>>>2>>>0]=_.length;var D=0;return _.forEach(G=>D+=G.length+1),ie[x>>>2>>>0]=D,0},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(b,x,_,D){x>>>=0,_>>>=0,D>>>=0;for(var G=0,X=0;X<_;X++){var ne=ie[x>>>2>>>0],ke=ie[x+4>>>2>>>0];x+=8;for(var Ye=0;Ye<ke;Ye++){var Ue=j[ne+Ye>>>0],ze=tr[b];Ue===0||Ue===10?((b===1?I:L)($e(ze,0)),ze.length=0):ze.push(Ue)}G+=ke}return ie[D>>>2>>>0]=G,0},r:vn,c:function(b,x,_,D){return vn(b>>>0,x>>>0,_>>>0,D>>>0)}},Q=function(){function b(_){return Q=_.exports,Q=In(),F=Q.K,We(),V.unshift(Q.L),It--,It==0&&(mt!==null&&(clearInterval(mt),mt=null),Be&&(_=Be,Be=null,_())),Q}var x={a:he};if(It++,o.instantiateWasm)try{return o.instantiateWasm(x,b)}catch(_){L(`Module.instantiateWasm callback failed with error: ${_}`),r(_)}return Pt(x,function(_){b(_.instance)}).catch(r),{}}();o._OrtInit=(b,x)=>(o._OrtInit=Q.M)(b,x),o._OrtGetLastError=(b,x)=>(o._OrtGetLastError=Q.N)(b,x),o._OrtCreateSessionOptions=(b,x,_,D,G,X,ne,ke,Ye,Ue)=>(o._OrtCreateSessionOptions=Q.O)(b,x,_,D,G,X,ne,ke,Ye,Ue),o._OrtAppendExecutionProvider=(b,x)=>(o._OrtAppendExecutionProvider=Q.P)(b,x),o._OrtAddFreeDimensionOverride=(b,x,_)=>(o._OrtAddFreeDimensionOverride=Q.Q)(b,x,_),o._OrtAddSessionConfigEntry=(b,x,_)=>(o._OrtAddSessionConfigEntry=Q.R)(b,x,_),o._OrtReleaseSessionOptions=b=>(o._OrtReleaseSessionOptions=Q.S)(b),o._OrtCreateSession=(b,x,_)=>(o._OrtCreateSession=Q.T)(b,x,_),o._OrtReleaseSession=b=>(o._OrtReleaseSession=Q.U)(b),o._OrtGetInputOutputCount=(b,x,_)=>(o._OrtGetInputOutputCount=Q.V)(b,x,_),o._OrtGetInputName=(b,x)=>(o._OrtGetInputName=Q.W)(b,x),o._OrtGetOutputName=(b,x)=>(o._OrtGetOutputName=Q.X)(b,x),o._OrtFree=b=>(o._OrtFree=Q.Y)(b),o._OrtCreateTensor=(b,x,_,D,G,X)=>(o._OrtCreateTensor=Q.Z)(b,x,_,D,G,X),o._OrtGetTensorData=(b,x,_,D,G)=>(o._OrtGetTensorData=Q._)(b,x,_,D,G),o._OrtReleaseTensor=b=>(o._OrtReleaseTensor=Q.$)(b),o._OrtCreateRunOptions=(b,x,_,D)=>(o._OrtCreateRunOptions=Q.aa)(b,x,_,D),o._OrtAddRunConfigEntry=(b,x,_)=>(o._OrtAddRunConfigEntry=Q.ba)(b,x,_),o._OrtReleaseRunOptions=b=>(o._OrtReleaseRunOptions=Q.ca)(b),o._OrtCreateBinding=b=>(o._OrtCreateBinding=Q.da)(b),o._OrtBindInput=(b,x,_)=>(o._OrtBindInput=Q.ea)(b,x,_),o._OrtBindOutput=(b,x,_,D)=>(o._OrtBindOutput=Q.fa)(b,x,_,D),o._OrtClearBoundOutputs=b=>(o._OrtClearBoundOutputs=Q.ga)(b),o._OrtReleaseBinding=b=>(o._OrtReleaseBinding=Q.ha)(b),o._OrtRunWithBinding=(b,x,_,D,G)=>(o._OrtRunWithBinding=Q.ia)(b,x,_,D,G),o._OrtRun=(b,x,_,D,G,X,ne,ke)=>(o._OrtRun=Q.ja)(b,x,_,D,G,X,ne,ke),o._OrtEndProfiling=b=>(o._OrtEndProfiling=Q.ka)(b);var Sr=()=>(Sr=Q.la)(),_n=o._malloc=b=>(_n=o._malloc=Q.ma)(b);o._free=b=>(o._free=Q.na)(b);var Kr=b=>(Kr=Q.pa)(b),On=()=>(On=Q.qa)(),J=b=>(J=Q.ra)(b),rr=b=>(rr=Q.sa)(b);function In(){var b=Q;b=Object.assign({},b);var x=D=>()=>D()>>>0,_=D=>G=>D(G)>>>0;return b.la=x(b.la),b.ma=_(b.ma),b.qa=x(b.qa),b.sa=_(b.sa),b}o.stackAlloc=rr,o.stackSave=On,o.stackRestore=J,o.UTF8ToString=ve,o.stringToUTF8=(b,x,_)=>Gt(b,j,x,_),o.lengthBytesUTF8=qe;var zt;Be=function b(){zt||Jr(),zt||(Be=b)};function Jr(){if(!(0<It)){if(o.preRun)for(typeof o.preRun==\"function\"&&(o.preRun=[o.preRun]);o.preRun.length;){var b=o.preRun.shift();Fe.unshift(b)}for(;0<Fe.length;)Fe.shift()(o);if(!(0<It||zt||(zt=!0,o.calledRun=!0,C))){for(;0<V.length;)V.shift()(o);for(e(o);0<Ae.length;)Ae.shift()(o)}}}return Jr(),t.ready}})();typeof Ep==\"object\"&&typeof oa==\"object\"?oa.exports=Pp:typeof define==\"function\"&&define.amd&&define([],()=>Pp)});var Lp=me(()=>{});var Fp=me(()=>{});var Cp={};Pr(Cp,{cpus:()=>sg});var sg,$p=E(()=>{sg=void 0});var Np=me((Bp,ia)=>{\"use strict\";var kp=(()=>{var a=typeof document<\"u\"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<\"u\"&&(a=a||__filename),function(t={}){function o(){return Ae.buffer!=te.buffer&&we(),te}function e(){return Ae.buffer!=te.buffer&&we(),bt}function r(){return Ae.buffer!=te.buffer&&we(),St}function n(){return Ae.buffer!=te.buffer&&we(),He}function s(){return Ae.buffer!=te.buffer&&we(),At}var i=t,u,l;i.ready=new Promise((c,h)=>{u=c,l=h});var f=Object.assign({},i),p=\"./this.program\",d=(c,h)=>{throw h},T=typeof window==\"object\",v=typeof importScripts==\"function\",w=typeof process==\"object\"&&typeof process.versions==\"object\"&&typeof process.versions.node==\"string\",I=i.ENVIRONMENT_IS_PTHREAD||!1,L=\"\";function F(c){return i.locateFile?i.locateFile(c,L):L+c}var C,Y,j;if(w){var M=(ta(),or(ea)),ie=(na(),or(ra));L=v?ie.dirname(L)+\"/\":__dirname+\"/\",C=(h,g)=>(h=ve(h)?new URL(h):ie.normalize(h),M.readFileSync(h,g?void 0:\"utf8\")),j=h=>(h=C(h,!0),h.buffer||(h=new Uint8Array(h)),h),Y=(h,g,S,k=!0)=>{h=ve(h)?new URL(h):ie.normalize(h),M.readFile(h,k?void 0:\"utf8\",(B,z)=>{B?S(B):g(k?z.buffer:z)})},!i.thisProgram&&1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,\"/\")),process.argv.slice(2),d=(h,g)=>{throw process.exitCode=h,g},i.inspect=()=>\"[Emscripten Module object]\";let c;try{c=Lp()}catch(h){throw console.error('The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?'),h}global.Worker=c.Worker}else(T||v)&&(v?L=self.location.href:typeof document<\"u\"&&document.currentScript&&(L=document.currentScript.src),typeof a<\"u\"&&a&&(L=a),L.indexOf(\"blob:\")!==0?L=L.substr(0,L.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):L=\"\",w||(C=c=>{var h=new XMLHttpRequest;return h.open(\"GET\",c,!1),h.send(null),h.responseText},v&&(j=c=>{var h=new XMLHttpRequest;return h.open(\"GET\",c,!1),h.responseType=\"arraybuffer\",h.send(null),new Uint8Array(h.response)}),Y=(c,h,g)=>{var S=new XMLHttpRequest;S.open(\"GET\",c,!0),S.responseType=\"arraybuffer\",S.onload=()=>{S.status==200||S.status==0&&S.response?h(S.response):g()},S.onerror=g,S.send(null)}));w&&typeof performance>\"u\"&&(global.performance=Fp().performance);var ot=console.log.bind(console),We=console.error.bind(console);w&&(ot=(...c)=>M.writeSync(1,c.join(\" \")+`\n`),We=(...c)=>M.writeSync(2,c.join(\" \")+`\n`));var Fe=ot,V=We;Object.assign(i,f),f=null,typeof WebAssembly!=\"object\"&&Mt(\"no native wasm support detected\");var Ae,It,mt=!1,Be,te,bt,St,He,At;function we(){var c=Ae.buffer;i.HEAP8=te=new Int8Array(c),i.HEAP16=new Int16Array(c),i.HEAPU8=bt=new Uint8Array(c),i.HEAPU16=new Uint16Array(c),i.HEAP32=St=new Int32Array(c),i.HEAPU32=He=new Uint32Array(c),i.HEAPF32=new Float32Array(c),i.HEAPF64=At=new Float64Array(c)}var Ze=16777216;if(I)Ae=i.wasmMemory;else if(i.wasmMemory)Ae=i.wasmMemory;else if(Ae=new WebAssembly.Memory({initial:Ze/65536,maximum:65536,shared:!0}),!(Ae.buffer instanceof SharedArrayBuffer))throw V(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),w&&V(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)\"),Error(\"bad memory\");we(),Ze=Ae.buffer.byteLength;var Qt=[],Pt=[],gt=[],yt=0,er=null,Qe=null;function Et(){if(yt--,yt==0&&(er!==null&&(clearInterval(er),er=null),Qe)){var c=Qe;Qe=null,c()}}function Mt(c){throw c=\"Aborted(\"+c+\")\",V(c),mt=!0,Be=1,c=new WebAssembly.RuntimeError(c+\". Build with -sASSERTIONS for more info.\"),l(c),c}var $e=c=>c.startsWith(\"data:application/octet-stream;base64,\"),ve=c=>c.startsWith(\"file://\"),qe;qe=\"ort-wasm-threaded.wasm\",$e(qe)||(qe=F(qe));function Gt(c){if(j)return j(c);throw\"both async and sync fetching of the wasm failed\"}function Dt(c){if(T||v){if(typeof fetch==\"function\"&&!ve(c))return fetch(c,{credentials:\"same-origin\"}).then(h=>{if(!h.ok)throw\"failed to load wasm binary file at '\"+c+\"'\";return h.arrayBuffer()}).catch(()=>Gt(c));if(Y)return new Promise((h,g)=>{Y(c,S=>h(new Uint8Array(S)),g)})}return Promise.resolve().then(()=>Gt(c))}function jr(c,h,g){return Dt(c).then(S=>WebAssembly.instantiate(S,h)).then(S=>S).then(g,S=>{V(`failed to asynchronously prepare wasm: ${S}`),Mt(S)})}function wn(c,h){var g=qe;return typeof WebAssembly.instantiateStreaming!=\"function\"||$e(g)||ve(g)||w||typeof fetch!=\"function\"?jr(g,c,h):fetch(g,{credentials:\"same-origin\"}).then(S=>WebAssembly.instantiateStreaming(S,c).then(h,function(k){return V(`wasm streaming compile failed: ${k}`),V(\"falling back to ArrayBuffer instantiation\"),jr(g,c,h)}))}var Ut,vr={921388:(c,h,g,S)=>{if(typeof i>\"u\"||!i.cb)return 1;if(c=Ir(c>>>0),c.startsWith(\"./\")&&(c=c.substring(2)),c=i.cb.get(c),!c)return 2;if(h>>>=0,g>>>=0,S>>>=0,h+g>c.byteLength)return 3;try{return e().set(c.subarray(h,h+g),S>>>0),0}catch{return 4}}};function qt(c){this.name=\"ExitStatus\",this.message=`Program terminated with exit(${c})`,this.status=c}var _r=c=>{c.terminate(),c.onmessage=()=>{}},Or=c=>{J.Pa.length==0&&(Kr(),J.Ya(J.Pa[0]));var h=J.Pa.pop();if(!h)return 6;J.Qa.push(h),J.Ma[c.Oa]=h,h.Oa=c.Oa;var g={cmd:\"run\",start_routine:c.kb,arg:c.hb,pthread_ptr:c.Oa};return w&&h.unref(),h.postMessage(g,c.qb),0},tr=0,Yr=typeof TextDecoder<\"u\"?new TextDecoder(\"utf8\"):void 0,Xr=(c,h,g)=>{h>>>=0;var S=h+g;for(g=h;c[g]&&!(g>=S);)++g;if(16<g-h&&c.buffer&&Yr)return Yr.decode(c.buffer instanceof SharedArrayBuffer?c.slice(h,g):c.subarray(h,g));for(S=\"\";h<g;){var k=c[h++];if(k&128){var B=c[h++]&63;if((k&224)==192)S+=String.fromCharCode((k&31)<<6|B);else{var z=c[h++]&63;k=(k&240)==224?(k&15)<<12|B<<6|z:(k&7)<<18|B<<12|z<<6|c[h++]&63,65536>k?S+=String.fromCharCode(k):(k-=65536,S+=String.fromCharCode(55296|k>>10,56320|k&1023))}}else S+=String.fromCharCode(k)}return S},Ir=(c,h)=>(c>>>=0)?Xr(e(),c,h):\"\",vn=c=>{var h=Vo();return c=c(),Pn(h),c};function he(c,h){var g=arguments.length-2,S=arguments;return vn(()=>{for(var k=Wo(8*g),B=k>>>3,z=0;z<g;z++){var Ie=S[2+z];s()[B+z>>>0]=Ie}return Na(c,g,k,h)})}function Q(c){if(I)return he(0,1,c);Be=c,0<tr||(J.lb(),i.onExit?.(c),mt=!0),d(c,new qt(c))}var Sr=c=>{if(Be=c,I)throw In(c),\"unwind\";Q(c)};function _n(){for(var c=i.numThreads;c--;)Kr();Qt.unshift(()=>{yt++,On(()=>Et())})}function Kr(){var c=F(\"ort-wasm-threaded.worker.js\");c=new Worker(c),J.Pa.push(c)}function On(c){I?c():Promise.all(J.Pa.map(J.Ya)).then(c)}var J={Pa:[],Qa:[],bb:[],Ma:{},Wa(){I?(J.receiveObjectTransfer=J.jb,J.threadInitTLS=J.ab,J.setExitStatus=J.$a):_n()},$a:c=>Be=c,tb:[\"$terminateWorker\"],lb:()=>{for(var c of J.Qa)_r(c);for(c of J.Pa)_r(c);J.Pa=[],J.Qa=[],J.Ma=[]},Za:c=>{var h=c.Oa;delete J.Ma[h],J.Pa.push(c),J.Qa.splice(J.Qa.indexOf(c),1),c.Oa=0,Uo(h)},jb(){},ab(){J.bb.forEach(c=>c())},Ya:c=>new Promise(h=>{c.onmessage=B=>{B=B.data;var z=B.cmd;if(B.targetThread&&B.targetThread!=An()){var Ie=J.Ma[B.targetThread];Ie?Ie.postMessage(B,B.transferList):V(`Internal error! Worker sent a message \"${z}\" to target pthread ${B.targetThread}, but that thread no longer exists!`)}else z===\"checkMailbox\"?Sn():z===\"spawnThread\"?Or(B):z===\"cleanupThread\"?J.Za(J.Ma[B.thread]):z===\"killThread\"?(B=B.thread,z=J.Ma[B],delete J.Ma[B],_r(z),Uo(B),J.Qa.splice(J.Qa.indexOf(z),1),z.Oa=0):z===\"cancelThread\"?J.Ma[B.thread].postMessage({cmd:\"cancel\"}):z===\"loaded\"?(c.loaded=!0,w&&!c.Oa&&c.unref(),h(c)):z===\"alert\"?alert(`Thread ${B.threadId}: ${B.text}`):B.target===\"setimmediate\"?c.postMessage(B):z===\"callHandler\"?i[B.handler](...B.args):z&&V(`worker sent an unknown command ${z}`)},c.onerror=B=>{throw V(`worker sent an error! ${B.filename}:${B.lineno}: ${B.message}`),B},w&&(c.on(\"message\",B=>c.onmessage({data:B})),c.on(\"error\",B=>c.onerror(B)));var g=[],S=[\"onExit\"],k;for(k of S)i.hasOwnProperty(k)&&g.push(k);c.postMessage({cmd:\"load\",handlers:g,urlOrBlob:i.mainScriptUrlOrBlob||a,wasmMemory:Ae,wasmModule:It})})};i.PThread=J;var rr=c=>{for(;0<c.length;)c.shift()(i)};i.establishStackSpace=()=>{var c=An(),h=n()[c+52>>>2>>>0];c=n()[c+56>>>2>>>0],Ga(h,h-c),Pn(h)};function In(c){if(I)return he(1,0,c);Sr(c)}var zt=[],Jr;i.invokeEntryPoint=(c,h)=>{var g=zt[c];g||(c>=zt.length&&(zt.length=c+1),zt[c]=g=Jr.get(c)),c=g(h),0<tr?J.$a(c):zo(c)};function b(c){this.Va=c-24,this.gb=function(h){n()[this.Va+4>>>2>>>0]=h},this.fb=function(h){n()[this.Va+8>>>2>>>0]=h},this.Wa=function(h,g){this.eb(),this.gb(h),this.fb(g)},this.eb=function(){n()[this.Va+16>>>2>>>0]=0}}var x=0,_=0;function D(c,h,g,S){return I?he(2,1,c,h,g,S):G(c,h,g,S)}function G(c,h,g,S){if(c>>>=0,h>>>=0,g>>>=0,S>>>=0,typeof SharedArrayBuffer>\"u\")return V(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var k=[];return I&&k.length===0?D(c,h,g,S):(c={kb:g,Oa:c,hb:S,qb:k},I?(c.sb=\"spawnThread\",postMessage(c,k),0):Or(c))}function X(c,h,g){return I?he(3,1,c,h,g):0}function ne(c,h){if(I)return he(4,1,c,h)}var ke=c=>{for(var h=0,g=0;g<c.length;++g){var S=c.charCodeAt(g);127>=S?h++:2047>=S?h+=2:55296<=S&&57343>=S?(h+=4,++g):h+=3}return h},Ye=(c,h,g,S)=>{if(g>>>=0,!(0<S))return 0;var k=g;S=g+S-1;for(var B=0;B<c.length;++B){var z=c.charCodeAt(B);if(55296<=z&&57343>=z){var Ie=c.charCodeAt(++B);z=65536+((z&1023)<<10)|Ie&1023}if(127>=z){if(g>=S)break;h[g++>>>0]=z}else{if(2047>=z){if(g+1>=S)break;h[g++>>>0]=192|z>>6}else{if(65535>=z){if(g+2>=S)break;h[g++>>>0]=224|z>>12}else{if(g+3>=S)break;h[g++>>>0]=240|z>>18,h[g++>>>0]=128|z>>12&63}h[g++>>>0]=128|z>>6&63}h[g++>>>0]=128|z&63}}return h[g>>>0]=0,g-k},Ue=(c,h,g)=>Ye(c,e(),h,g);function ze(c,h){if(I)return he(5,1,c,h)}function Zr(c,h,g){if(I)return he(6,1,c,h,g)}function Qr(c,h,g){return I?he(7,1,c,h,g):0}function A(c,h){if(I)return he(8,1,c,h)}function pe(c,h,g){if(I)return he(9,1,c,h,g)}function Te(c,h,g,S){if(I)return he(10,1,c,h,g,S)}function Lt(c,h,g,S){if(I)return he(11,1,c,h,g,S)}function en(c,h,g,S){if(I)return he(12,1,c,h,g,S)}function ba(c){if(I)return he(13,1,c)}function ga(c,h){if(I)return he(14,1,c,h)}function ya(c,h,g){if(I)return he(15,1,c,h,g)}function Bo(c){c>>>=0,typeof Atomics.rb==\"function\"&&(Atomics.rb(r(),c>>>2,c).value.then(Sn),c+=128,Atomics.store(r(),c>>>2,1))}i.__emscripten_thread_mailbox_await=Bo;var Sn=()=>{var c=An();if(c&&(Bo(c),c=Ra,!mt))try{if(c(),!(0<tr))try{I?zo(Be):Sr(Be)}catch(h){h instanceof qt||h==\"unwind\"||d(1,h)}}catch(h){h instanceof qt||h==\"unwind\"||d(1,h)}};i.checkMailbox=Sn;var No=[],Ar=c=>c%4===0&&(c%100!==0||c%400===0),Ta=[0,31,60,91,121,152,182,213,244,274,305,335],xa=[0,31,59,90,120,151,181,212,243,273,304,334];function wa(c,h,g,S,k,B,z,Ie){return I?he(16,1,c,h,g,S,k,B,z,Ie):-52}function va(c,h,g,S,k,B,z){if(I)return he(17,1,c,h,g,S,k,B,z)}var _a=c=>{var h=ke(c)+1,g=ka(h);return g&&Ue(c,g,h),g},Ro=[],Mo={},Oa=()=>{if(!Go){var c={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(typeof navigator==\"object\"&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:p||\"./this.program\"},h;for(h in Mo)Mo[h]===void 0?delete c[h]:c[h]=Mo[h];var g=[];for(h in c)g.push(`${h}=${c[h]}`);Go=g}return Go},Go;function Ia(c,h){if(I)return he(18,1,c,h);c>>>=0,h>>>=0;var g=0;return Oa().forEach((S,k)=>{var B=h+g;for(k=n()[c+4*k>>>2>>>0]=B,B=0;B<S.length;++B)o()[k++>>>0>>>0]=S.charCodeAt(B);o()[k>>>0>>>0]=0,g+=S.length+1}),0}function Sa(c,h){if(I)return he(19,1,c,h);c>>>=0,h>>>=0;var g=Oa();n()[c>>>2>>>0]=g.length;var S=0;return g.forEach(k=>S+=k.length+1),n()[h>>>2>>>0]=S,0}function Aa(c){return I?he(20,1,c):52}function Pa(c,h,g,S){return I?he(21,1,c,h,g,S):52}function Ea(c,h,g,S,k){return I?he(22,1,c,h,g,S,k):70}var yd=[null,[],[]];function Da(c,h,g,S){if(I)return he(23,1,c,h,g,S);h>>>=0,g>>>=0,S>>>=0;for(var k=0,B=0;B<g;B++){var z=n()[h>>>2>>>0],Ie=n()[h+4>>>2>>>0];h+=8;for(var Ft=0;Ft<Ie;Ft++){var Ne=e()[z+Ft>>>0],et=yd[c];Ne===0||Ne===10?((c===1?Fe:V)(Xr(et,0)),et.length=0):et.push(Ne)}k+=Ie}return n()[S>>>2>>>0]=k,0}var La=[31,29,31,30,31,30,31,31,30,31,30,31],Fa=[31,28,31,30,31,30,31,31,30,31,30,31];function Td(c){var h=Array(ke(c)+1);return Ye(c,h,0,h.length),h}var xd=(c,h)=>{o().set(c,h>>>0)};function Ca(c,h,g,S){function k(P,de,Se){for(P=typeof P==\"number\"?P.toString():P||\"\";P.length<de;)P=Se[0]+P;return P}function B(P,de){return k(P,de,\"0\")}function z(P,de){function Se(Wa){return 0>Wa?-1:0<Wa?1:0}var nr;return(nr=Se(P.getFullYear()-de.getFullYear()))===0&&(nr=Se(P.getMonth()-de.getMonth()))===0&&(nr=Se(P.getDate()-de.getDate())),nr}function Ie(P){switch(P.getDay()){case 0:return new Date(P.getFullYear()-1,11,29);case 1:return P;case 2:return new Date(P.getFullYear(),0,3);case 3:return new Date(P.getFullYear(),0,2);case 4:return new Date(P.getFullYear(),0,1);case 5:return new Date(P.getFullYear()-1,11,31);case 6:return new Date(P.getFullYear()-1,11,30)}}function Ft(P){var de=P.Ra;for(P=new Date(new Date(P.Sa+1900,0,1).getTime());0<de;){var Se=P.getMonth(),nr=(Ar(P.getFullYear())?La:Fa)[Se];if(de>nr-P.getDate())de-=nr-P.getDate()+1,P.setDate(1),11>Se?P.setMonth(Se+1):(P.setMonth(0),P.setFullYear(P.getFullYear()+1));else{P.setDate(P.getDate()+de);break}}return Se=new Date(P.getFullYear()+1,0,4),de=Ie(new Date(P.getFullYear(),0,4)),Se=Ie(Se),0>=z(de,P)?0>=z(Se,P)?P.getFullYear()+1:P.getFullYear():P.getFullYear()-1}c>>>=0,h>>>=0,g>>>=0,S>>>=0;var Ne=n()[S+40>>>2>>>0];S={ob:r()[S>>>2>>>0],nb:r()[S+4>>>2>>>0],Ta:r()[S+8>>>2>>>0],Xa:r()[S+12>>>2>>>0],Ua:r()[S+16>>>2>>>0],Sa:r()[S+20>>>2>>>0],Na:r()[S+24>>>2>>>0],Ra:r()[S+28>>>2>>>0],ub:r()[S+32>>>2>>>0],mb:r()[S+36>>>2>>>0],pb:Ne?Ir(Ne):\"\"},g=Ir(g),Ne={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"};for(var et in Ne)g=g.replace(new RegExp(et,\"g\"),Ne[et]);var za=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),Va=\"January February March April May June July August September October November December\".split(\" \");Ne={\"%a\":P=>za[P.Na].substring(0,3),\"%A\":P=>za[P.Na],\"%b\":P=>Va[P.Ua].substring(0,3),\"%B\":P=>Va[P.Ua],\"%C\":P=>B((P.Sa+1900)/100|0,2),\"%d\":P=>B(P.Xa,2),\"%e\":P=>k(P.Xa,2,\" \"),\"%g\":P=>Ft(P).toString().substring(2),\"%G\":P=>Ft(P),\"%H\":P=>B(P.Ta,2),\"%I\":P=>(P=P.Ta,P==0?P=12:12<P&&(P-=12),B(P,2)),\"%j\":P=>{for(var de=0,Se=0;Se<=P.Ua-1;de+=(Ar(P.Sa+1900)?La:Fa)[Se++]);return B(P.Xa+de,3)},\"%m\":P=>B(P.Ua+1,2),\"%M\":P=>B(P.nb,2),\"%n\":()=>`\n`,\"%p\":P=>0<=P.Ta&&12>P.Ta?\"AM\":\"PM\",\"%S\":P=>B(P.ob,2),\"%t\":()=>\"\t\",\"%u\":P=>P.Na||7,\"%U\":P=>B(Math.floor((P.Ra+7-P.Na)/7),2),\"%V\":P=>{var de=Math.floor((P.Ra+7-(P.Na+6)%7)/7);if(2>=(P.Na+371-P.Ra-2)%7&&de++,de)de==53&&(Se=(P.Na+371-P.Ra)%7,Se==4||Se==3&&Ar(P.Sa)||(de=1));else{de=52;var Se=(P.Na+7-P.Ra-1)%7;(Se==4||Se==5&&Ar(P.Sa%400-1))&&de++}return B(de,2)},\"%w\":P=>P.Na,\"%W\":P=>B(Math.floor((P.Ra+7-(P.Na+6)%7)/7),2),\"%y\":P=>(P.Sa+1900).toString().substring(2),\"%Y\":P=>P.Sa+1900,\"%z\":P=>{P=P.mb;var de=0<=P;return P=Math.abs(P)/60,(de?\"+\":\"-\")+(\"0000\"+(P/60*100+P%60)).slice(-4)},\"%Z\":P=>P.pb,\"%%\":()=>\"%\"},g=g.replace(/%%/g,\"\\0\\0\");for(et in Ne)g.includes(et)&&(g=g.replace(new RegExp(et,\"g\"),Ne[et](S)));return g=g.replace(/\\0\\0/g,\"%\"),et=Td(g),et.length>h?0:(xd(et,c),et.length-1)}J.Wa();var wd=[Q,In,D,X,ne,ze,Zr,Qr,A,pe,Te,Lt,en,ba,ga,ya,wa,va,Ia,Sa,Aa,Pa,Ea,Da],vd={b:function(c,h,g){throw c>>>=0,new b(c).Wa(h>>>0,g>>>0),x=c,_++,x},L:function(c){Ba(c>>>0,!v,1,!T,131072,!1),J.ab()},j:function(c){c>>>=0,I?postMessage({cmd:\"cleanupThread\",thread:c}):J.Za(J.Ma[c])},H:G,h:X,S:ne,D:ze,F:Zr,T:Qr,Q:A,J:pe,P:Te,n:Lt,E:en,B:ba,R:ga,C:ya,p:()=>1,z:function(c,h){c>>>=0,c==h>>>0?setTimeout(()=>Sn()):I?postMessage({targetThread:c,cmd:\"checkMailbox\"}):(c=J.Ma[c])&&c.postMessage({cmd:\"checkMailbox\"})},I:function(c,h,g,S){h>>>=0,No.length=g,S=S>>>0>>>3;for(var k=0;k<g;k++)No[k]=s()[S+k>>>0];return c=0>c?vr[-c-1]:wd[c],J.ib=h,h=c.apply(null,No),J.ib=0,h},K:Bo,o:function(c){w&&J.Ma[c>>>0].ref()},s:function(c,h,g){c=h+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*h:NaN,g>>>=0,c=new Date(1e3*c),r()[g>>>2>>>0]=c.getUTCSeconds(),r()[g+4>>>2>>>0]=c.getUTCMinutes(),r()[g+8>>>2>>>0]=c.getUTCHours(),r()[g+12>>>2>>>0]=c.getUTCDate(),r()[g+16>>>2>>>0]=c.getUTCMonth(),r()[g+20>>>2>>>0]=c.getUTCFullYear()-1900,r()[g+24>>>2>>>0]=c.getUTCDay(),c=(c.getTime()-Date.UTC(c.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,r()[g+28>>>2>>>0]=c},t:function(c,h,g){c=h+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*h:NaN,g>>>=0,c=new Date(1e3*c),r()[g>>>2>>>0]=c.getSeconds(),r()[g+4>>>2>>>0]=c.getMinutes(),r()[g+8>>>2>>>0]=c.getHours(),r()[g+12>>>2>>>0]=c.getDate(),r()[g+16>>>2>>>0]=c.getMonth(),r()[g+20>>>2>>>0]=c.getFullYear()-1900,r()[g+24>>>2>>>0]=c.getDay(),h=(Ar(c.getFullYear())?Ta:xa)[c.getMonth()]+c.getDate()-1|0,r()[g+28>>>2>>>0]=h,r()[g+36>>>2>>>0]=-(60*c.getTimezoneOffset()),h=new Date(c.getFullYear(),6,1).getTimezoneOffset();var S=new Date(c.getFullYear(),0,1).getTimezoneOffset();c=(h!=S&&c.getTimezoneOffset()==Math.min(S,h))|0,r()[g+32>>>2>>>0]=c},u:function(c){c>>>=0;var h=new Date(r()[c+20>>>2>>>0]+1900,r()[c+16>>>2>>>0],r()[c+12>>>2>>>0],r()[c+8>>>2>>>0],r()[c+4>>>2>>>0],r()[c>>>2>>>0],0),g=r()[c+32>>>2>>>0],S=h.getTimezoneOffset(),k=new Date(h.getFullYear(),6,1).getTimezoneOffset(),B=new Date(h.getFullYear(),0,1).getTimezoneOffset(),z=Math.min(B,k);return 0>g?r()[c+32>>>2>>>0]=+(k!=B&&z==S):0<g!=(z==S)&&(k=Math.max(B,k),h.setTime(h.getTime()+6e4*((0<g?z:k)-S))),r()[c+24>>>2>>>0]=h.getDay(),g=(Ar(h.getFullYear())?Ta:xa)[h.getMonth()]+h.getDate()-1|0,r()[c+28>>>2>>>0]=g,r()[c>>>2>>>0]=h.getSeconds(),r()[c+4>>>2>>>0]=h.getMinutes(),r()[c+8>>>2>>>0]=h.getHours(),r()[c+12>>>2>>>0]=h.getDate(),r()[c+16>>>2>>>0]=h.getMonth(),r()[c+20>>>2>>>0]=h.getYear(),c=h.getTime(),isNaN(c)?(r()[$a()>>>2>>>0]=61,c=-1):c/=1e3,Ma((Ut=c,1<=+Math.abs(Ut)?0<Ut?+Math.floor(Ut/4294967296)>>>0:~~+Math.ceil((Ut-+(~~Ut>>>0))/4294967296)>>>0:0)),c>>>0},q:wa,r:va,y:function(c,h,g){function S(Ne){return(Ne=Ne.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?Ne[1]:\"GMT\"}c>>>=0,h>>>=0,g>>>=0;var k=new Date().getFullYear(),B=new Date(k,0,1),z=new Date(k,6,1);k=B.getTimezoneOffset();var Ie=z.getTimezoneOffset(),Ft=Math.max(k,Ie);n()[c>>>2>>>0]=60*Ft,r()[h>>>2>>>0]=+(k!=Ie),c=S(B),h=S(z),c=_a(c),h=_a(h),Ie<k?(n()[g>>>2>>>0]=c,n()[g+4>>>2>>>0]=h):(n()[g>>>2>>>0]=h,n()[g+4>>>2>>>0]=c)},c:()=>{Mt(\"\")},O:function(c,h,g){c>>>=0,h>>>=0,g>>>=0,Ro.length=0;for(var S;S=e()[h++>>>0];){var k=S!=105;k&=S!=112,g+=k&&g%8?4:0,Ro.push(S==112?n()[g>>>2>>>0]:S==105?r()[g>>>2>>>0]:s()[g>>>3>>>0]),g+=k?8:4}return vr[c].apply(null,Ro)},k:()=>{},i:()=>Date.now(),U:()=>{throw tr+=1,\"unwind\"},A:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:()=>w?($p(),or(Cp)).cpus().length:navigator.hardwareConcurrency,x:function(c){c>>>=0;var h=e().length;if(c<=h||4294901760<c)return!1;for(var g=1;4>=g;g*=2){var S=h*(1+.2/g);S=Math.min(S,c+100663296);var k=Math;S=Math.max(c,S);e:{k=(k.min.call(k,4294901760,S+(65536-S%65536)%65536)-Ae.buffer.byteLength+65535)/65536;try{Ae.grow(k),we();var B=1;break e}catch{}B=void 0}if(B)return!0}return!1},M:Ia,N:Sa,G:Sr,g:Aa,m:Pa,v:Ea,l:Da,a:Ae||i.wasmMemory,w:Ca,d:function(c,h,g,S){return Ca(c>>>0,h>>>0,g>>>0,S>>>0)}},K=function(){function c(g,S){return K=g.exports,K=_d(),J.bb.push(K.za),Jr=K.Aa,Pt.unshift(K.V),It=S,Et(),K}var h={a:vd};if(yt++,i.instantiateWasm)try{return i.instantiateWasm(h,c)}catch(g){V(`Module.instantiateWasm callback failed with error: ${g}`),l(g)}return wn(h,function(g){c(g.instance,g.module)}).catch(l),{}}();i._OrtInit=(c,h)=>(i._OrtInit=K.W)(c,h),i._OrtGetLastError=(c,h)=>(i._OrtGetLastError=K.X)(c,h),i._OrtCreateSessionOptions=(c,h,g,S,k,B,z,Ie,Ft,Ne)=>(i._OrtCreateSessionOptions=K.Y)(c,h,g,S,k,B,z,Ie,Ft,Ne),i._OrtAppendExecutionProvider=(c,h)=>(i._OrtAppendExecutionProvider=K.Z)(c,h),i._OrtAddFreeDimensionOverride=(c,h,g)=>(i._OrtAddFreeDimensionOverride=K._)(c,h,g),i._OrtAddSessionConfigEntry=(c,h,g)=>(i._OrtAddSessionConfigEntry=K.$)(c,h,g),i._OrtReleaseSessionOptions=c=>(i._OrtReleaseSessionOptions=K.aa)(c),i._OrtCreateSession=(c,h,g)=>(i._OrtCreateSession=K.ba)(c,h,g),i._OrtReleaseSession=c=>(i._OrtReleaseSession=K.ca)(c),i._OrtGetInputOutputCount=(c,h,g)=>(i._OrtGetInputOutputCount=K.da)(c,h,g),i._OrtGetInputName=(c,h)=>(i._OrtGetInputName=K.ea)(c,h),i._OrtGetOutputName=(c,h)=>(i._OrtGetOutputName=K.fa)(c,h),i._OrtFree=c=>(i._OrtFree=K.ga)(c),i._OrtCreateTensor=(c,h,g,S,k,B)=>(i._OrtCreateTensor=K.ha)(c,h,g,S,k,B),i._OrtGetTensorData=(c,h,g,S,k)=>(i._OrtGetTensorData=K.ia)(c,h,g,S,k),i._OrtReleaseTensor=c=>(i._OrtReleaseTensor=K.ja)(c),i._OrtCreateRunOptions=(c,h,g,S)=>(i._OrtCreateRunOptions=K.ka)(c,h,g,S),i._OrtAddRunConfigEntry=(c,h,g)=>(i._OrtAddRunConfigEntry=K.la)(c,h,g),i._OrtReleaseRunOptions=c=>(i._OrtReleaseRunOptions=K.ma)(c),i._OrtCreateBinding=c=>(i._OrtCreateBinding=K.na)(c),i._OrtBindInput=(c,h,g)=>(i._OrtBindInput=K.oa)(c,h,g),i._OrtBindOutput=(c,h,g,S)=>(i._OrtBindOutput=K.pa)(c,h,g,S),i._OrtClearBoundOutputs=c=>(i._OrtClearBoundOutputs=K.qa)(c),i._OrtReleaseBinding=c=>(i._OrtReleaseBinding=K.ra)(c),i._OrtRunWithBinding=(c,h,g,S,k)=>(i._OrtRunWithBinding=K.sa)(c,h,g,S,k),i._OrtRun=(c,h,g,S,k,B,z,Ie)=>(i._OrtRun=K.ta)(c,h,g,S,k,B,z,Ie),i._OrtEndProfiling=c=>(i._OrtEndProfiling=K.ua)(c);var $a=()=>($a=K.va)(),An=i._pthread_self=()=>(An=i._pthread_self=K.wa)(),ka=i._malloc=c=>(ka=i._malloc=K.xa)(c);i._free=c=>(i._free=K.ya)(c),i.__emscripten_tls_init=()=>(i.__emscripten_tls_init=K.za)();var Ba=i.__emscripten_thread_init=(c,h,g,S,k,B)=>(Ba=i.__emscripten_thread_init=K.Ba)(c,h,g,S,k,B);i.__emscripten_thread_crashed=()=>(i.__emscripten_thread_crashed=K.Ca)();var Na=(c,h,g,S)=>(Na=K.Da)(c,h,g,S),Uo=c=>(Uo=K.Ea)(c),zo=i.__emscripten_thread_exit=c=>(zo=i.__emscripten_thread_exit=K.Fa)(c),Ra=()=>(Ra=K.Ga)(),Ma=c=>(Ma=K.Ha)(c),Ga=(c,h)=>(Ga=K.Ia)(c,h),Vo=()=>(Vo=K.Ja)(),Pn=c=>(Pn=K.Ka)(c),Wo=c=>(Wo=K.La)(c);function _d(){var c=K;c=Object.assign({},c);var h=S=>()=>S()>>>0,g=S=>k=>S(k)>>>0;return c.va=h(c.va),c.wa=h(c.wa),c.xa=g(c.xa),c.emscripten_main_runtime_thread_id=h(c.emscripten_main_runtime_thread_id),c.Ja=h(c.Ja),c.La=g(c.La),c}i.wasmMemory=Ae,i.stackAlloc=Wo,i.stackSave=Vo,i.stackRestore=Pn,i.keepRuntimeAlive=()=>0<tr,i.UTF8ToString=Ir,i.stringToUTF8=Ue,i.lengthBytesUTF8=ke,i.ExitStatus=qt,i.PThread=J;var En;Qe=function c(){En||Ua(),En||(Qe=c)};function Ua(){if(!(0<yt))if(I)u(i),I||rr(Pt),startWorker(i);else{if(i.preRun)for(typeof i.preRun==\"function\"&&(i.preRun=[i.preRun]);i.preRun.length;)Qt.unshift(i.preRun.shift());rr(Qt),0<yt||En||(En=!0,i.calledRun=!0,mt||(I||rr(Pt),u(i),I||rr(gt)))}}return Ua(),t.ready}})();typeof Bp==\"object\"&&typeof ia==\"object\"?ia.exports=kp:typeof define==\"function\"&&define.amd&&define([],()=>kp)});var Rp=me((uO,ug)=>{ug.exports='\"use strict\";var Module={},ENVIRONMENT_IS_NODE=typeof process==\"object\"&&typeof process.versions==\"object\"&&typeof process.versions.node==\"string\";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require(\"worker_threads\"),parentPort=nodeWorkerThreads.parentPort;parentPort.on(\"message\",e=>onmessage({data:e}));var fs=require(\"fs\"),vm=require(\"vm\");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,\"utf8\"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(\" \");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd===\"load\"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:\"loaded\"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:\"callHandler\",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob==\"string\")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd===\"run\"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!=\"unwind\")throw a}}else e.data.cmd===\"cancel\"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target===\"setimmediate\"||(e.data.cmd===\"checkMailbox\"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed?.(),a}}self.onmessage=handleMessage;\\n'});var Gp,lg,aa,sa,Po,Mp,fg,cg,pg,Up,Le,Vr=E(()=>{\"use strict\";Gp=Dp();lg=Np(),sa=!1,Po=!1,Mp=!1,fg=a=>{if(a===1)return!1;if(typeof SharedArrayBuffer>\"u\")return typeof self<\"u\"&&!self.crossOriginIsolated&&console.warn(\"env.wasm.numThreads is set to \"+a+\", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info.\"),!1;typeof process<\"u\"&&process.versions&&process.versions.node&&console.warn(\"env.wasm.numThreads is set to \"+a+\", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.\");try{return typeof MessageChannel<\"u\"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},cg=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},pg=(a,t)=>a?t?\"ort-wasm-simd-threaded.wasm\":\"ort-wasm-simd.wasm\":t?\"ort-wasm-threaded.wasm\":\"ort-wasm.wasm\",Up=async a=>{if(sa)return Promise.resolve();if(Po)throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");if(Mp)throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");Po=!0;let t=a.initTimeout,o=a.numThreads,e=a.simd,r=fg(o),n=e&&cg(),s=a.wasmPaths,i=typeof s==\"string\"?s:void 0,u=pg(n,r),l=typeof s==\"object\"?s[u]:void 0,f=!1,p=[];if(t>0&&p.push(new Promise(d=>{setTimeout(()=>{f=!0,d()},t)})),p.push(new Promise((d,T)=>{let v=r?lg:Gp,w={locateFile:(I,L)=>r&&I.endsWith(\".worker.js\")&&typeof Blob<\"u\"?URL.createObjectURL(new Blob([Rp()],{type:\"text/javascript\"})):I.endsWith(\".wasm\")?l||(i??L)+u:L+I};if(r)if(w.numThreads=o,typeof Blob>\"u\")w.mainScriptUrlOrBlob=(void 0)(__dirname,\"ort-wasm-threaded.js\");else{let I=`var ortWasmThreaded=${v.toString()};`;w.mainScriptUrlOrBlob=new Blob([I],{type:\"text/javascript\"})}v(w).then(I=>{Po=!1,sa=!0,aa=I,d()},I=>{Po=!1,Mp=!0,T(I)})})),await Promise.race(p),f)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Le=()=>{if(sa&&aa)return aa;throw new Error(\"WebAssembly is not initialized yet.\")}});var _e,yn,Oe,Eo=E(()=>{\"use strict\";Vr();_e=(a,t)=>{let o=Le(),e=o.lengthBytesUTF8(a)+1,r=o._malloc(e);return o.stringToUTF8(a,r,e),t.push(r),r},yn=(a,t,o,e)=>{if(typeof a==\"object\"&&a!==null){if(o.has(a))throw new Error(\"Circular reference in options\");o.add(a)}Object.entries(a).forEach(([r,n])=>{let s=t?t+r:r;if(typeof n==\"object\")yn(n,s+\".\",o,e);else if(typeof n==\"string\"||typeof n==\"number\")e(s,n.toString());else if(typeof n==\"boolean\")e(s,n?\"1\":\"0\");else throw new Error(`Can't handle extra config type: ${typeof n}`)})},Oe=a=>{let t=Le(),o=t.stackSave();try{let e=t.stackAlloc(8);t._OrtGetLastError(e,e+4);let r=t.HEAP32[e/4],n=t.HEAPU32[e/4+1],s=n?t.UTF8ToString(n):\"\";throw new Error(`${a} ERROR_CODE: ${r}, ERROR_MESSAGE: ${s}`)}finally{t.stackRestore(o)}}});var zp,Vp=E(()=>{\"use strict\";Vr();Eo();zp=a=>{let t=Le(),o=0,e=[],r=a||{};try{if(a?.logSeverityLevel===void 0)r.logSeverityLevel=2;else if(typeof a.logSeverityLevel!=\"number\"||!Number.isInteger(a.logSeverityLevel)||a.logSeverityLevel<0||a.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${a.logSeverityLevel}`);if(a?.logVerbosityLevel===void 0)r.logVerbosityLevel=0;else if(typeof a.logVerbosityLevel!=\"number\"||!Number.isInteger(a.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${a.logVerbosityLevel}`);a?.terminate===void 0&&(r.terminate=!1);let n=0;return a?.tag!==void 0&&(n=_e(a.tag,e)),o=t._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,n),o===0&&Oe(\"Can't create run options.\"),a?.extra!==void 0&&yn(a.extra,\"\",new WeakSet,(s,i)=>{let u=_e(s,e),l=_e(i,e);t._OrtAddRunConfigEntry(o,u,l)!==0&&Oe(`Can't set a run config entry: ${s} - ${i}.`)}),[o,e]}catch(n){throw o!==0&&t._OrtReleaseRunOptions(o),e.forEach(s=>t._free(s)),n}}});var dg,hg,mg,bg,Wp,Hp=E(()=>{\"use strict\";Vr();Eo();dg=a=>{switch(a){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${a}`)}},hg=a=>{switch(a){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${a}`)}},mg=a=>{a.extra||(a.extra={}),a.extra.session||(a.extra.session={});let t=a.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly=\"1\"),a.executionProviders&&a.executionProviders.some(o=>(typeof o==\"string\"?o:o.name)===\"webgpu\")&&(a.enableMemPattern=!1)},bg=(a,t,o)=>{for(let e of t){let r=typeof e==\"string\"?e:e.name;switch(r){case\"webnn\":if(r=\"WEBNN\",typeof e!=\"string\"){let s=e;if(s?.deviceType){let i=_e(\"deviceType\",o),u=_e(s.deviceType,o);Le()._OrtAddSessionConfigEntry(a,i,u)!==0&&Oe(`Can't set a session config entry: 'deviceType' - ${s.deviceType}.`)}if(s?.numThreads){let i=s.numThreads;(typeof i!=\"number\"||!Number.isInteger(i)||i<0)&&(i=0);let u=_e(\"numThreads\",o),l=_e(i.toString(),o);Le()._OrtAddSessionConfigEntry(a,u,l)!==0&&Oe(`Can't set a session config entry: 'numThreads' - ${s.numThreads}.`)}if(s?.powerPreference){let i=_e(\"powerPreference\",o),u=_e(s.powerPreference,o);Le()._OrtAddSessionConfigEntry(a,i,u)!==0&&Oe(`Can't set a session config entry: 'powerPreference' - ${s.powerPreference}.`)}}break;case\"webgpu\":if(r=\"JS\",typeof e!=\"string\"){let s=e;if(s?.preferredLayout){if(s.preferredLayout!==\"NCHW\"&&s.preferredLayout!==\"NHWC\")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let i=_e(\"preferredLayout\",o),u=_e(s.preferredLayout,o);Le()._OrtAddSessionConfigEntry(a,i,u)!==0&&Oe(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported execution provider: ${r}`)}let n=_e(r,o);Le()._OrtAppendExecutionProvider(a,n)!==0&&Oe(`Can't append execution provider: ${r}.`)}},Wp=a=>{let t=Le(),o=0,e=[],r=a||{};mg(r);try{let n=dg(r.graphOptimizationLevel??\"all\"),s=hg(r.executionMode??\"sequential\"),i=typeof r.logId==\"string\"?_e(r.logId,e):0,u=r.logSeverityLevel??2;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log serverity level is not valid: ${u}`);let l=r.logVerbosityLevel??0;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log verbosity level is not valid: ${l}`);let f=typeof r.optimizedModelFilePath==\"string\"?_e(r.optimizedModelFilePath,e):0;if(o=t._OrtCreateSessionOptions(n,!!r.enableCpuMemArena,!!r.enableMemPattern,s,!!r.enableProfiling,0,i,u,l,f),o===0&&Oe(\"Can't create session options.\"),r.executionProviders&&bg(o,r.executionProviders,e),r.enableGraphCapture!==void 0){if(typeof r.enableGraphCapture!=\"boolean\")throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);let p=_e(\"enableGraphCapture\",e),d=_e(r.enableGraphCapture.toString(),e);t._OrtAddSessionConfigEntry(o,p,d)!==0&&Oe(`Can't set a session config entry: 'enableGraphCapture' - ${r.enableGraphCapture}.`)}if(r.freeDimensionOverrides)for(let[p,d]of Object.entries(r.freeDimensionOverrides)){if(typeof p!=\"string\")throw new Error(`free dimension override name must be a string: ${p}`);if(typeof d!=\"number\"||!Number.isInteger(d)||d<0)throw new Error(`free dimension override value must be a non-negative integer: ${d}`);let T=_e(p,e);t._OrtAddFreeDimensionOverride(o,T,d)!==0&&Oe(`Can't set a free dimension override: ${p} - ${d}.`)}return r.extra!==void 0&&yn(r.extra,\"\",new WeakSet,(p,d)=>{let T=_e(p,e),v=_e(d,e);t._OrtAddSessionConfigEntry(o,T,v)!==0&&Oe(`Can't set a session config entry: ${p} - ${d}.`)}),[o,e]}catch(n){throw o!==0&&t._OrtReleaseSessionOptions(o),e.forEach(s=>t._free(s)),n}}});var ua,qp,la,jp,Yp,Do,Xp,fa=E(()=>{\"use strict\";ua=a=>{switch(a){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float16\":return 10;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;default:throw new Error(`unsupported data type: ${a}`)}},qp=a=>{switch(a){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 10:return\"float16\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";default:throw new Error(`unsupported data type: ${a}`)}},la=a=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][a],jp=a=>{switch(a){case\"float16\":return typeof Float16Array<\"u\"&&Float16Array.from?Float16Array:Uint16Array;case\"float32\":return Float32Array;case\"uint8\":return Uint8Array;case\"int8\":return Int8Array;case\"uint16\":return Uint16Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"bool\":return Uint8Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${a}`)}},Yp=a=>{switch(a){case\"verbose\":return 0;case\"info\":return 1;case\"warning\":return 2;case\"error\":return 3;case\"fatal\":return 4;default:throw new Error(`unsupported logging level: ${a}`)}},Do=a=>a===\"float32\"||a===\"float16\"||a===\"int32\"||a===\"int64\"||a===\"uint32\"||a===\"uint8\"||a===\"bool\",Xp=a=>{switch(a){case\"none\":return 0;case\"cpu\":return 1;case\"cpu-pinned\":return 2;case\"texture\":return 3;case\"gpu-buffer\":return 4;default:throw new Error(`unsupported data location: ${a}`)}}});var Tn,ca=E(()=>{\"use strict\";Tn=async a=>{if(typeof a==\"string\")if(typeof process<\"u\"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(a))}catch(t){if(t.code===\"ERR_FS_FILE_TOO_LARGE\"){let o=(void 0)(a),e=[];for await(let r of o)e.push(r);return new Uint8Array(Buffer.concat(e))}throw t}else{let t=await fetch(a);if(!t.ok)throw new Error(`failed to load external data file: ${a}`);let o=t.headers.get(\"Content-Length\"),e=o?parseInt(o,10):0;if(e<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${a}, no response body.`);let r=t.body.getReader(),n;try{n=new ArrayBuffer(e)}catch(i){if(i instanceof RangeError){let u=Math.ceil(e/65536);n=new WebAssembly.Memory({initial:u,maximum:u}).buffer}else throw i}let s=0;for(;;){let{done:i,value:u}=await r.read();if(i)break;let l=u.byteLength;new Uint8Array(n,s,l).set(u),s+=l}return new Uint8Array(n,0,e)}}else return a instanceof Blob?new Uint8Array(await a.arrayBuffer()):a instanceof Uint8Array?a:new Uint8Array(a)}});var gg,Jp,Zp,Wr,yg,pa,Qp,ed,Kp,td,rd,nd,od=E(()=>{\"use strict\";Vp();Hp();fa();Vr();Eo();ca();gg=(a,t)=>{Le()._OrtInit(a,t)!==0&&Oe(\"Can't initialize onnxruntime.\")},Jp=async a=>{gg(a.wasm.numThreads,Yp(a.logLevel))},Zp=async(a,t)=>{},Wr=new Map,yg=a=>{let t=Le(),o=t.stackSave();try{let e=t.stackAlloc(8);return t._OrtGetInputOutputCount(a,e,e+4)!==0&&Oe(\"Can't get session input/output count.\"),[t.HEAP32[e/4],t.HEAP32[e/4+1]]}finally{t.stackRestore(o)}},pa=a=>{let t=Le(),o=t._malloc(a.byteLength);if(o===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${a.byteLength}.`);return t.HEAPU8.set(a,o),[o,a.byteLength]},Qp=async(a,t)=>{let o,e,r=Le();Array.isArray(a)?[o,e]=a:a.buffer===r.HEAPU8.buffer?[o,e]=[a.byteOffset,a.byteLength]:[o,e]=pa(a);let n=0,s=0,i=0,u=[],l=[],f=[];try{if([s,u]=Wp(t),t?.externalData&&r.mountExternalData){let F=[];for(let C of t.externalData){let Y=typeof C==\"string\"?C:C.path;F.push(Tn(typeof C==\"string\"?C:C.data).then(j=>{r.mountExternalData(Y,j)}))}await Promise.all(F)}n=await r._OrtCreateSession(o,e,s),n===0&&Oe(\"Can't create a session.\");let[p,d]=yg(n),T=!!t?.enableGraphCapture,v=[],w=[],I=[];for(let F=0;F<p;F++){let C=r._OrtGetInputName(n,F);C===0&&Oe(\"Can't get an input name.\"),l.push(C),v.push(r.UTF8ToString(C))}for(let F=0;F<d;F++){let C=r._OrtGetOutputName(n,F);C===0&&Oe(\"Can't get an output name.\"),f.push(C);let Y=r.UTF8ToString(C);w.push(Y)}let L=null;return Wr.set(n,[n,l,f,L,T,!1]),[n,v,w]}catch(p){throw l.forEach(d=>r._OrtFree(d)),f.forEach(d=>r._OrtFree(d)),i!==0&&r._OrtReleaseBinding(i),n!==0&&r._OrtReleaseSession(n),p}finally{r._free(o),s!==0&&r._OrtReleaseSessionOptions(s),u.forEach(p=>r._free(p)),r.unmountExternalData?.()}},ed=a=>{let t=Le(),o=Wr.get(a);if(!o)throw new Error(`cannot release session. invalid session id: ${a}`);let[e,r,n,s,i]=o;s&&(i&&t._OrtClearBoundOutputs(s.handle),t._OrtReleaseBinding(s.handle)),t.jsepOnReleaseSession?.(a),r.forEach(u=>t._OrtFree(u)),n.forEach(u=>t._OrtFree(u)),t._OrtReleaseSession(e),Wr.delete(a)},Kp=(a,t,o,e,r,n=!1)=>{if(!a){t.push(0);return}let s=Le(),i=a[0],u=a[1],l=a[3],f,p;if(i===\"string\"&&l===\"gpu-buffer\")throw new Error(\"String tensor is not supported on GPU.\");if(n&&l!==\"gpu-buffer\")throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);if(l===\"gpu-buffer\"){let v=a[2].gpuBuffer,w=la(ua(i));p=u.reduce((L,F)=>L*F,1)*w;let I=s.jsepRegisterBuffer;if(!I)throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');f=I(e,r,v,p)}else{let v=a[2];if(Array.isArray(v)){p=4*v.length,f=s._malloc(p),o.push(f);let w=f/4;for(let I=0;I<v.length;I++){if(typeof v[I]!=\"string\")throw new TypeError(`tensor data at index ${I} is not a string`);s.HEAPU32[w++]=_e(v[I],o)}}else p=v.byteLength,f=s._malloc(p),o.push(f),s.HEAPU8.set(new Uint8Array(v.buffer,v.byteOffset,p),f)}let d=s.stackSave(),T=s.stackAlloc(4*u.length);try{let v=T/4;u.forEach(I=>s.HEAP32[v++]=I);let w=s._OrtCreateTensor(ua(i),f,p,T,u.length,Xp(l));w===0&&Oe(`Can't create tensor for input/output. session=${e}, index=${r}.`),t.push(w)}finally{s.stackRestore(d)}},td=async(a,t,o,e,r,n)=>{let s=Le(),i=Wr.get(a);if(!i)throw new Error(`cannot run inference. invalid session id: ${a}`);let u=i[0],l=i[1],f=i[2],p=i[3],d=i[4],T=i[5],v=t.length,w=e.length,I=0,L=[],F=[],C=[],Y=[],j=s.stackSave(),M=s.stackAlloc(v*4),ie=s.stackAlloc(v*4),ot=s.stackAlloc(w*4),We=s.stackAlloc(w*4);try{[I,L]=zp(n);for(let te=0;te<v;te++)Kp(o[te],F,Y,a,t[te],d);for(let te=0;te<w;te++)Kp(r[te],C,Y,a,v+e[te],d);let Fe=M/4,V=ie/4,Ae=ot/4,It=We/4;for(let te=0;te<v;te++)s.HEAPU32[Fe++]=F[te],s.HEAPU32[V++]=l[t[te]];for(let te=0;te<w;te++)s.HEAPU32[Ae++]=C[te],s.HEAPU32[It++]=f[e[te]];s.jsepOnRunStart?.(u);let mt;mt=await s._OrtRun(u,ie,M,v,We,w,ot,I),mt!==0&&Oe(\"failed to call OrtRun().\");let Be=[];for(let te=0;te<w;te++){let bt=s.HEAPU32[ot/4+te];if(bt===C[te]){Be.push(r[te]);continue}let St=s.stackSave(),He=s.stackAlloc(4*4),At=!1,we,Ze=0;try{s._OrtGetTensorData(bt,He,He+4,He+8,He+12)!==0&&Oe(`Can't access output tensor data on index ${te}.`);let Pt=He/4,gt=s.HEAPU32[Pt++];Ze=s.HEAPU32[Pt++];let yt=s.HEAPU32[Pt++],er=s.HEAPU32[Pt++],Qe=[];for(let $e=0;$e<er;$e++)Qe.push(s.HEAPU32[yt/4+$e]);s._OrtFree(yt);let Et=Qe.reduce(($e,ve)=>$e*ve,1);we=qp(gt);let Mt=p?.outputPreferredLocations[e[te]];if(we===\"string\"){if(Mt===\"gpu-buffer\")throw new Error(\"String tensor is not supported on GPU.\");let $e=[],ve=Ze/4;for(let qe=0;qe<Et;qe++){let Gt=s.HEAPU32[ve++],Dt=qe===Et-1?void 0:s.HEAPU32[ve]-Gt;$e.push(s.UTF8ToString(Gt,Dt))}Be.push([we,Qe,$e,\"cpu\"])}else if(Mt===\"gpu-buffer\"&&Et>0){let $e=s.jsepGetBuffer;if(!$e)throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');let ve=$e(Ze),qe=la(gt);if(qe===void 0||!Do(we))throw new Error(`Unsupported data type: ${we}`);At=!0,Be.push([we,Qe,{gpuBuffer:ve,download:s.jsepCreateDownloader(ve,Et*qe,we),dispose:()=>{s._OrtReleaseTensor(bt)}},\"gpu-buffer\"])}else{let $e=jp(we),ve=new $e(Et);new Uint8Array(ve.buffer,ve.byteOffset,ve.byteLength).set(s.HEAPU8.subarray(Ze,Ze+ve.byteLength)),Be.push([we,Qe,ve,\"cpu\"])}}finally{s.stackRestore(St),we===\"string\"&&Ze&&s._free(Ze),At||s._OrtReleaseTensor(bt)}}return p&&!d&&(s._OrtClearBoundOutputs(p.handle),Wr.set(a,[u,l,f,p,d,!1])),Be}finally{s.stackRestore(j),F.forEach(Fe=>s._OrtReleaseTensor(Fe)),C.forEach(Fe=>s._OrtReleaseTensor(Fe)),Y.forEach(Fe=>s._free(Fe)),I!==0&&s._OrtReleaseRunOptions(I),L.forEach(Fe=>s._free(Fe))}},rd=a=>{let t=Le(),o=Wr.get(a);if(!o)throw new Error(\"invalid session id\");let e=o[0],r=t._OrtEndProfiling(e);r===0&&Oe(\"Can't get an profile file name.\"),t._OrtFree(r)},nd=a=>{let t=[];for(let o of a){let e=o[2];!Array.isArray(e)&&\"buffer\"in e&&t.push(e.buffer)}return t}});var id=me((AO,xg)=>{xg.exports='/*!\\n * ONNX Runtime Web v1.17.3\\n * Copyright (c) Microsoft Corporation. All rights reserved.\\n * Licensed under the MIT License.\\n */\\n\"use strict\";(()=>{var Et=Object.defineProperty;var Jr=Object.getOwnPropertyDescriptor;var Xr=Object.getOwnPropertyNames;var Qr=Object.prototype.hasOwnProperty;var St=(u,c)=>()=>(u&&(c=u(u=0)),c);var tt=(u,c)=>()=>(c||u((c={exports:{}}).exports,c),c.exports),At=(u,c)=>{for(var a in c)Et(u,a,{get:c[a],enumerable:!0})},Zr=(u,c,a,h)=>{if(c&&typeof c==\"object\"||typeof c==\"function\")for(let f of Xr(c))!Qr.call(u,f)&&f!==a&&Et(u,f,{get:()=>c[f],enumerable:!(h=Jr(c,f))||h.enumerable});return u};var rt=u=>Zr(Et({},\"__esModule\",{value:!0}),u);var Tt={};At(Tt,{createReadStream:()=>dr,readFile:()=>Kr,readFileSync:()=>en});var Kr,en,dr,Mt=St(()=>{Kr=void 0,en=void 0,dr=void 0});var Ct={};At(Ct,{join:()=>tn});var tn,Dt=St(()=>{tn=void 0});var gr=tt((mr,Ft)=>{\"use strict\";var pr=(()=>{var u=typeof document<\"u\"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<\"u\"&&(u=u||__filename),function(c={}){var a=c,h,f;a.ready=new Promise((r,o)=>{h=r,f=o});var w=Object.assign({},a),g=\"./this.program\",i=typeof window==\"object\",E=typeof importScripts==\"function\",P=typeof process==\"object\"&&typeof process.versions==\"object\"&&typeof process.versions.node==\"string\",U=\"\",D,x,K;if(P){var R=(Mt(),rt(Tt)),I=(Dt(),rt(Ct));U=E?I.dirname(U)+\"/\":__dirname+\"/\",D=(r,o)=>(r=ve(r)?new URL(r):I.normalize(r),R.readFileSync(r,o?void 0:\"utf8\")),K=r=>(r=D(r,!0),r.buffer||(r=new Uint8Array(r)),r),x=(r,o,s,m=!0)=>{r=ve(r)?new URL(r):I.normalize(r),R.readFile(r,m?void 0:\"utf8\",(O,A)=>{O?s(O):o(m?A.buffer:A)})},!a.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\\\\\\\/g,\"/\")),process.argv.slice(2),a.inspect=()=>\"[Emscripten Module object]\"}else(i||E)&&(E?U=self.location.href:typeof document<\"u\"&&document.currentScript&&(U=document.currentScript.src),u&&(U=u),U.indexOf(\"blob:\")!==0?U=U.substr(0,U.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):U=\"\",D=r=>{var o=new XMLHttpRequest;return o.open(\"GET\",r,!1),o.send(null),o.responseText},E&&(K=r=>{var o=new XMLHttpRequest;return o.open(\"GET\",r,!1),o.responseType=\"arraybuffer\",o.send(null),new Uint8Array(o.response)}),x=(r,o,s)=>{var m=new XMLHttpRequest;m.open(\"GET\",r,!0),m.responseType=\"arraybuffer\",m.onload=()=>{m.status==200||m.status==0&&m.response?o(m.response):s()},m.onerror=s,m.send(null)});var v=console.log.bind(console),k=console.error.bind(console);Object.assign(a,w),w=null,typeof WebAssembly!=\"object\"&&F(\"no native wasm support detected\");var W,H=!1,se,ee,S,j,Ce;function Ue(){var r=W.buffer;a.HEAP8=se=new Int8Array(r),a.HEAP16=new Int16Array(r),a.HEAPU8=ee=new Uint8Array(r),a.HEAPU16=new Uint16Array(r),a.HEAP32=S=new Int32Array(r),a.HEAPU32=j=new Uint32Array(r),a.HEAPF32=new Float32Array(r),a.HEAPF64=Ce=new Float64Array(r)}var ce=[],ne=[],Q=[],Oe=0,he=null,ae=null;function F(r){throw r=\"Aborted(\"+r+\")\",k(r),H=!0,r=new WebAssembly.RuntimeError(r+\". Build with -sASSERTIONS for more info.\"),f(r),r}var ye=r=>r.startsWith(\"data:application/octet-stream;base64,\"),ve=r=>r.startsWith(\"file://\"),fe;if(fe=\"ort-wasm.wasm\",!ye(fe)){var _e=fe;fe=a.locateFile?a.locateFile(_e,U):U+_e}function Y(r){if(K)return K(r);throw\"both async and sync fetching of the wasm failed\"}function pe(r){if(i||E){if(typeof fetch==\"function\"&&!ve(r))return fetch(r,{credentials:\"same-origin\"}).then(o=>{if(!o.ok)throw\"failed to load wasm binary file at \\'\"+r+\"\\'\";return o.arrayBuffer()}).catch(()=>Y(r));if(x)return new Promise((o,s)=>{x(r,m=>o(new Uint8Array(m)),s)})}return Promise.resolve().then(()=>Y(r))}function Ie(r,o,s){return pe(r).then(m=>WebAssembly.instantiate(m,o)).then(m=>m).then(s,m=>{k(`failed to asynchronously prepare wasm: ${m}`),F(m)})}function Ee(r,o){var s=fe;return typeof WebAssembly.instantiateStreaming!=\"function\"||ye(s)||ve(s)||P||typeof fetch!=\"function\"?Ie(s,r,o):fetch(s,{credentials:\"same-origin\"}).then(m=>WebAssembly.instantiateStreaming(m,r).then(o,function(O){return k(`wasm streaming compile failed: ${O}`),k(\"falling back to ArrayBuffer instantiation\"),Ie(s,r,o)}))}var be,we={920016:(r,o,s,m)=>{if(typeof a>\"u\"||!a.za)return 1;if(r=z(r>>>0),r.startsWith(\"./\")&&(r=r.substring(2)),r=a.za.get(r),!r)return 2;if(o>>>=0,s>>>=0,o+s>r.byteLength)return 3;try{return ee.set(r.subarray(o,o+s),m>>>0>>>0),0}catch{return 4}}};function Le(r){this.xa=r-24,this.Ha=function(o){j[this.xa+4>>>2>>>0]=o},this.Ga=function(o){j[this.xa+8>>>2>>>0]=o},this.Aa=function(o,s){this.Fa(),this.Ha(o),this.Ga(s)},this.Fa=function(){j[this.xa+16>>>2>>>0]=0}}var me=0,Se=0,De=typeof TextDecoder<\"u\"?new TextDecoder(\"utf8\"):void 0,te=(r,o,s)=>{o>>>=0;var m=o+s;for(s=o;r[s]&&!(s>=m);)++s;if(16<s-o&&r.buffer&&De)return De.decode(r.subarray(o,s));for(m=\"\";o<s;){var O=r[o++];if(O&128){var A=r[o++]&63;if((O&224)==192)m+=String.fromCharCode((O&31)<<6|A);else{var L=r[o++]&63;O=(O&240)==224?(O&15)<<12|A<<6|L:(O&7)<<18|A<<12|L<<6|r[o++]&63,65536>O?m+=String.fromCharCode(O):(O-=65536,m+=String.fromCharCode(55296|O>>10,56320|O&1023))}}else m+=String.fromCharCode(O)}return m},z=(r,o)=>(r>>>=0)?te(ee,r,o):\"\",le=r=>{for(var o=0,s=0;s<r.length;++s){var m=r.charCodeAt(s);127>=m?o++:2047>=m?o+=2:55296<=m&&57343>=m?(o+=4,++s):o+=3}return o},Fe=(r,o,s,m)=>{if(s>>>=0,!(0<m))return 0;var O=s;m=s+m-1;for(var A=0;A<r.length;++A){var L=r.charCodeAt(A);if(55296<=L&&57343>=L){var re=r.charCodeAt(++A);L=65536+((L&1023)<<10)|re&1023}if(127>=L){if(s>=m)break;o[s++>>>0]=L}else{if(2047>=L){if(s+1>=m)break;o[s++>>>0]=192|L>>6}else{if(65535>=L){if(s+2>=m)break;o[s++>>>0]=224|L>>12}else{if(s+3>=m)break;o[s++>>>0]=240|L>>18,o[s++>>>0]=128|L>>12&63}o[s++>>>0]=128|L>>6&63}o[s++>>>0]=128|L&63}}return o[s>>>0]=0,s-O},Ae=r=>r%4===0&&(r%100!==0||r%400===0),qe=[0,31,60,91,121,152,182,213,244,274,305,335],at=[0,31,59,90,120,151,181,212,243,273,304,334],xe=r=>{var o=le(r)+1,s=st(o);return s&&Fe(r,ee,s,o),s},Ne=[],Re={},He=()=>{if(!Ge){var r={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(typeof navigator==\"object\"&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:g||\"./this.program\"},o;for(o in Re)Re[o]===void 0?delete r[o]:r[o]=Re[o];var s=[];for(o in r)s.push(`${o}=${r[o]}`);Ge=s}return Ge},Ge,Be=[null,[],[]],Ve=[31,29,31,30,31,30,31,31,30,31,30,31],Je=[31,28,31,30,31,30,31,31,30,31,30,31];function $e(r){var o=Array(le(r)+1);return Fe(r,o,0,o.length),o}function ot(r,o,s,m){function O(d,B,$){for(d=typeof d==\"number\"?d.toString():d||\"\";d.length<B;)d=$[0]+d;return d}function A(d,B){return O(d,B,\"0\")}function L(d,B){function $(et){return 0>et?-1:0<et?1:0}var Te;return(Te=$(d.getFullYear()-B.getFullYear()))===0&&(Te=$(d.getMonth()-B.getMonth()))===0&&(Te=$(d.getDate()-B.getDate())),Te}function re(d){switch(d.getDay()){case 0:return new Date(d.getFullYear()-1,11,29);case 1:return d;case 2:return new Date(d.getFullYear(),0,3);case 3:return new Date(d.getFullYear(),0,2);case 4:return new Date(d.getFullYear(),0,1);case 5:return new Date(d.getFullYear()-1,11,31);case 6:return new Date(d.getFullYear()-1,11,30)}}function de(d){var B=d.ta;for(d=new Date(new Date(d.ua+1900,0,1).getTime());0<B;){var $=d.getMonth(),Te=(Ae(d.getFullYear())?Ve:Je)[$];if(B>Te-d.getDate())B-=Te-d.getDate()+1,d.setDate(1),11>$?d.setMonth($+1):(d.setMonth(0),d.setFullYear(d.getFullYear()+1));else{d.setDate(d.getDate()+B);break}}return $=new Date(d.getFullYear()+1,0,4),B=re(new Date(d.getFullYear(),0,4)),$=re($),0>=L(B,d)?0>=L($,d)?d.getFullYear()+1:d.getFullYear():d.getFullYear()-1}r>>>=0,o>>>=0,s>>>=0,m>>>=0;var ie=j[m+40>>>2>>>0];m={Da:S[m>>>2>>>0],Ca:S[m+4>>>2>>>0],va:S[m+8>>>2>>>0],ya:S[m+12>>>2>>>0],wa:S[m+16>>>2>>>0],ua:S[m+20>>>2>>>0],oa:S[m+24>>>2>>>0],ta:S[m+28>>>2>>>0],Ia:S[m+32>>>2>>>0],Ba:S[m+36>>>2>>>0],Ea:ie?z(ie):\"\"},s=z(s),ie={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"};for(var ue in ie)s=s.replace(new RegExp(ue,\"g\"),ie[ue]);var Ze=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),Ke=\"January February March April May June July August September October November December\".split(\" \");ie={\"%a\":d=>Ze[d.oa].substring(0,3),\"%A\":d=>Ze[d.oa],\"%b\":d=>Ke[d.wa].substring(0,3),\"%B\":d=>Ke[d.wa],\"%C\":d=>A((d.ua+1900)/100|0,2),\"%d\":d=>A(d.ya,2),\"%e\":d=>O(d.ya,2,\" \"),\"%g\":d=>de(d).toString().substring(2),\"%G\":d=>de(d),\"%H\":d=>A(d.va,2),\"%I\":d=>(d=d.va,d==0?d=12:12<d&&(d-=12),A(d,2)),\"%j\":d=>{for(var B=0,$=0;$<=d.wa-1;B+=(Ae(d.ua+1900)?Ve:Je)[$++]);return A(d.ya+B,3)},\"%m\":d=>A(d.wa+1,2),\"%M\":d=>A(d.Ca,2),\"%n\":()=>`\\n`,\"%p\":d=>0<=d.va&&12>d.va?\"AM\":\"PM\",\"%S\":d=>A(d.Da,2),\"%t\":()=>\"\t\",\"%u\":d=>d.oa||7,\"%U\":d=>A(Math.floor((d.ta+7-d.oa)/7),2),\"%V\":d=>{var B=Math.floor((d.ta+7-(d.oa+6)%7)/7);if(2>=(d.oa+371-d.ta-2)%7&&B++,B)B==53&&($=(d.oa+371-d.ta)%7,$==4||$==3&&Ae(d.ua)||(B=1));else{B=52;var $=(d.oa+7-d.ta-1)%7;($==4||$==5&&Ae(d.ua%400-1))&&B++}return A(B,2)},\"%w\":d=>d.oa,\"%W\":d=>A(Math.floor((d.ta+7-(d.oa+6)%7)/7),2),\"%y\":d=>(d.ua+1900).toString().substring(2),\"%Y\":d=>d.ua+1900,\"%z\":d=>{d=d.Ba;var B=0<=d;return d=Math.abs(d)/60,(B?\"+\":\"-\")+(\"0000\"+(d/60*100+d%60)).slice(-4)},\"%Z\":d=>d.Ea,\"%%\":()=>\"%\"},s=s.replace(/%%/g,\"\\\\0\\\\0\");for(ue in ie)s.includes(ue)&&(s=s.replace(new RegExp(ue,\"g\"),ie[ue](m)));return s=s.replace(/\\\\0\\\\0/g,\"%\"),ue=$e(s),ue.length>o?0:(se.set(ue,r>>>0),ue.length-1)}var G={a:function(r,o,s){throw r>>>=0,new Le(r).Aa(o>>>0,s>>>0),me=r,Se++,me},e:function(){return 0},H:function(){},x:function(){},z:function(){},J:function(){return 0},F:function(){},A:function(){},E:function(){},g:function(){},y:function(){},v:function(){},G:function(){},w:function(){},k:()=>1,n:function(r,o,s){r=o+2097152>>>0<4194305-!!r?(r>>>0)+4294967296*o:NaN,s>>>=0,r=new Date(1e3*r),S[s>>>2>>>0]=r.getUTCSeconds(),S[s+4>>>2>>>0]=r.getUTCMinutes(),S[s+8>>>2>>>0]=r.getUTCHours(),S[s+12>>>2>>>0]=r.getUTCDate(),S[s+16>>>2>>>0]=r.getUTCMonth(),S[s+20>>>2>>>0]=r.getUTCFullYear()-1900,S[s+24>>>2>>>0]=r.getUTCDay(),S[s+28>>>2>>>0]=(r.getTime()-Date.UTC(r.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(r,o,s){r=o+2097152>>>0<4194305-!!r?(r>>>0)+4294967296*o:NaN,s>>>=0,r=new Date(1e3*r),S[s>>>2>>>0]=r.getSeconds(),S[s+4>>>2>>>0]=r.getMinutes(),S[s+8>>>2>>>0]=r.getHours(),S[s+12>>>2>>>0]=r.getDate(),S[s+16>>>2>>>0]=r.getMonth(),S[s+20>>>2>>>0]=r.getFullYear()-1900,S[s+24>>>2>>>0]=r.getDay(),S[s+28>>>2>>>0]=(Ae(r.getFullYear())?qe:at)[r.getMonth()]+r.getDate()-1|0,S[s+36>>>2>>>0]=-(60*r.getTimezoneOffset()),o=new Date(r.getFullYear(),6,1).getTimezoneOffset();var m=new Date(r.getFullYear(),0,1).getTimezoneOffset();S[s+32>>>2>>>0]=(o!=m&&r.getTimezoneOffset()==Math.min(m,o))|0},p:function(r){r>>>=0;var o=new Date(S[r+20>>>2>>>0]+1900,S[r+16>>>2>>>0],S[r+12>>>2>>>0],S[r+8>>>2>>>0],S[r+4>>>2>>>0],S[r>>>2>>>0],0),s=S[r+32>>>2>>>0],m=o.getTimezoneOffset(),O=new Date(o.getFullYear(),6,1).getTimezoneOffset(),A=new Date(o.getFullYear(),0,1).getTimezoneOffset(),L=Math.min(A,O);return 0>s?S[r+32>>>2>>>0]=+(O!=A&&L==m):0<s!=(L==m)&&(O=Math.max(A,O),o.setTime(o.getTime()+6e4*((0<s?L:O)-m))),S[r+24>>>2>>>0]=o.getDay(),S[r+28>>>2>>>0]=(Ae(o.getFullYear())?qe:at)[o.getMonth()]+o.getDate()-1|0,S[r>>>2>>>0]=o.getSeconds(),S[r+4>>>2>>>0]=o.getMinutes(),S[r+8>>>2>>>0]=o.getHours(),S[r+12>>>2>>>0]=o.getDate(),S[r+16>>>2>>>0]=o.getMonth(),S[r+20>>>2>>>0]=o.getYear(),r=o.getTime(),isNaN(r)?(S[je()>>>2>>>0]=61,r=-1):r/=1e3,Xe((be=r,1<=+Math.abs(be)?0<be?+Math.floor(be/4294967296)>>>0:~~+Math.ceil((be-+(~~be>>>0))/4294967296)>>>0:0)),r>>>0},l:function(){return-52},m:function(){},t:function(r,o,s){function m(de){return(de=de.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?de[1]:\"GMT\"}s>>>=0;var O=new Date().getFullYear(),A=new Date(O,0,1),L=new Date(O,6,1);O=A.getTimezoneOffset();var re=L.getTimezoneOffset();j[r>>>0>>>2>>>0]=60*Math.max(O,re),S[o>>>0>>>2>>>0]=+(O!=re),r=m(A),o=m(L),r=xe(r),o=xe(o),re<O?(j[s>>>2>>>0]=r,j[s+4>>>2>>>0]=o):(j[s>>>2>>>0]=o,j[s+4>>>2>>>0]=r)},d:()=>{F(\"\")},B:function(r,o,s){r>>>=0,o>>>=0,s>>>=0,Ne.length=0;for(var m;m=ee[o++>>>0];){var O=m!=105;O&=m!=112,s+=O&&s%8?4:0,Ne.push(m==112?j[s>>>2>>>0]:m==105?S[s>>>2>>>0]:Ce[s>>>3>>>0]),s+=O?8:4}return we[r].apply(null,Ne)},h:()=>Date.now(),u:function(){return 4294901760},b:()=>performance.now(),I:function(r,o,s){return o>>>=0,ee.copyWithin(r>>>0>>>0,o>>>0,o+(s>>>0)>>>0)},s:function(r){r>>>=0;var o=ee.length;if(4294901760<r)return!1;for(var s=1;4>=s;s*=2){var m=o*(1+.2/s);m=Math.min(m,r+100663296);var O=Math;m=Math.max(r,m);e:{O=(O.min.call(O,4294901760,m+(65536-m%65536)%65536)-W.buffer.byteLength+65535)/65536;try{W.grow(O),Ue();var A=1;break e}catch{}A=void 0}if(A)return!0}return!1},C:function(r,o){r>>>=0,o>>>=0;var s=0;return He().forEach((m,O)=>{var A=o+s;for(O=j[r+4*O>>>2>>>0]=A,A=0;A<m.length;++A)se[O++>>>0>>>0]=m.charCodeAt(A);se[O>>>0>>>0]=0,s+=m.length+1}),0},D:function(r,o){r>>>=0,o>>>=0;var s=He();j[r>>>2>>>0]=s.length;var m=0;return s.forEach(O=>m+=O.length+1),j[o>>>2>>>0]=m,0},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(r,o,s,m){o>>>=0,s>>>=0,m>>>=0;for(var O=0,A=0;A<s;A++){var L=j[o>>>2>>>0],re=j[o+4>>>2>>>0];o+=8;for(var de=0;de<re;de++){var ie=ee[L+de>>>0],ue=Be[r];ie===0||ie===10?((r===1?v:k)(te(ue,0)),ue.length=0):ue.push(ie)}O+=re}return j[m>>>2>>>0]=O,0},r:ot,c:function(r,o,s,m){return ot(r>>>0,o>>>0,s>>>0,m>>>0)}},C=function(){function r(s){return C=s.exports,C=ut(),W=C.K,Ue(),ne.unshift(C.L),Oe--,Oe==0&&(he!==null&&(clearInterval(he),he=null),ae&&(s=ae,ae=null,s())),C}var o={a:G};if(Oe++,a.instantiateWasm)try{return a.instantiateWasm(o,r)}catch(s){k(`Module.instantiateWasm callback failed with error: ${s}`),f(s)}return Ee(o,function(s){r(s.instance)}).catch(f),{}}();a._OrtInit=(r,o)=>(a._OrtInit=C.M)(r,o),a._OrtGetLastError=(r,o)=>(a._OrtGetLastError=C.N)(r,o),a._OrtCreateSessionOptions=(r,o,s,m,O,A,L,re,de,ie)=>(a._OrtCreateSessionOptions=C.O)(r,o,s,m,O,A,L,re,de,ie),a._OrtAppendExecutionProvider=(r,o)=>(a._OrtAppendExecutionProvider=C.P)(r,o),a._OrtAddFreeDimensionOverride=(r,o,s)=>(a._OrtAddFreeDimensionOverride=C.Q)(r,o,s),a._OrtAddSessionConfigEntry=(r,o,s)=>(a._OrtAddSessionConfigEntry=C.R)(r,o,s),a._OrtReleaseSessionOptions=r=>(a._OrtReleaseSessionOptions=C.S)(r),a._OrtCreateSession=(r,o,s)=>(a._OrtCreateSession=C.T)(r,o,s),a._OrtReleaseSession=r=>(a._OrtReleaseSession=C.U)(r),a._OrtGetInputOutputCount=(r,o,s)=>(a._OrtGetInputOutputCount=C.V)(r,o,s),a._OrtGetInputName=(r,o)=>(a._OrtGetInputName=C.W)(r,o),a._OrtGetOutputName=(r,o)=>(a._OrtGetOutputName=C.X)(r,o),a._OrtFree=r=>(a._OrtFree=C.Y)(r),a._OrtCreateTensor=(r,o,s,m,O,A)=>(a._OrtCreateTensor=C.Z)(r,o,s,m,O,A),a._OrtGetTensorData=(r,o,s,m,O)=>(a._OrtGetTensorData=C._)(r,o,s,m,O),a._OrtReleaseTensor=r=>(a._OrtReleaseTensor=C.$)(r),a._OrtCreateRunOptions=(r,o,s,m)=>(a._OrtCreateRunOptions=C.aa)(r,o,s,m),a._OrtAddRunConfigEntry=(r,o,s)=>(a._OrtAddRunConfigEntry=C.ba)(r,o,s),a._OrtReleaseRunOptions=r=>(a._OrtReleaseRunOptions=C.ca)(r),a._OrtCreateBinding=r=>(a._OrtCreateBinding=C.da)(r),a._OrtBindInput=(r,o,s)=>(a._OrtBindInput=C.ea)(r,o,s),a._OrtBindOutput=(r,o,s,m)=>(a._OrtBindOutput=C.fa)(r,o,s,m),a._OrtClearBoundOutputs=r=>(a._OrtClearBoundOutputs=C.ga)(r),a._OrtReleaseBinding=r=>(a._OrtReleaseBinding=C.ha)(r),a._OrtRunWithBinding=(r,o,s,m,O)=>(a._OrtRunWithBinding=C.ia)(r,o,s,m,O),a._OrtRun=(r,o,s,m,O,A,L,re)=>(a._OrtRun=C.ja)(r,o,s,m,O,A,L,re),a._OrtEndProfiling=r=>(a._OrtEndProfiling=C.ka)(r);var je=()=>(je=C.la)(),st=a._malloc=r=>(st=a._malloc=C.ma)(r);a._free=r=>(a._free=C.na)(r);var Xe=r=>(Xe=C.pa)(r),it=()=>(it=C.qa)(),M=r=>(M=C.ra)(r),ke=r=>(ke=C.sa)(r);function ut(){var r=C;r=Object.assign({},r);var o=m=>()=>m()>>>0,s=m=>O=>m(O)>>>0;return r.la=o(r.la),r.ma=s(r.ma),r.qa=o(r.qa),r.sa=s(r.sa),r}a.stackAlloc=ke,a.stackSave=it,a.stackRestore=M,a.UTF8ToString=z,a.stringToUTF8=(r,o,s)=>Fe(r,ee,o,s),a.lengthBytesUTF8=le;var Pe;ae=function r(){Pe||Qe(),Pe||(ae=r)};function Qe(){if(!(0<Oe)){if(a.preRun)for(typeof a.preRun==\"function\"&&(a.preRun=[a.preRun]);a.preRun.length;){var r=a.preRun.shift();ce.unshift(r)}for(;0<ce.length;)ce.shift()(a);if(!(0<Oe||Pe||(Pe=!0,a.calledRun=!0,H))){for(;0<ne.length;)ne.shift()(a);for(h(a);0<Q.length;)Q.shift()(a)}}}return Qe(),c.ready}})();typeof mr==\"object\"&&typeof Ft==\"object\"?Ft.exports=pr:typeof define==\"function\"&&define.amd&&define([],()=>pr)});var hr=tt(()=>{});var yr=tt(()=>{});var br={};At(br,{cpus:()=>rn});var rn,wr=St(()=>{rn=void 0});var _r=tt((vr,xt)=>{\"use strict\";var Or=(()=>{var u=typeof document<\"u\"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<\"u\"&&(u=u||__filename),function(c={}){function a(){return Q.buffer!=F.buffer&&Y(),F}function h(){return Q.buffer!=F.buffer&&Y(),ye}function f(){return Q.buffer!=F.buffer&&Y(),ve}function w(){return Q.buffer!=F.buffer&&Y(),fe}function g(){return Q.buffer!=F.buffer&&Y(),_e}var i=c,E,P;i.ready=new Promise((e,t)=>{E=e,P=t});var U=Object.assign({},i),D=\"./this.program\",x=(e,t)=>{throw t},K=typeof window==\"object\",R=typeof importScripts==\"function\",I=typeof process==\"object\"&&typeof process.versions==\"object\"&&typeof process.versions.node==\"string\",v=i.ENVIRONMENT_IS_PTHREAD||!1,k=\"\";function W(e){return i.locateFile?i.locateFile(e,k):k+e}var H,se,ee;if(I){var S=(Mt(),rt(Tt)),j=(Dt(),rt(Ct));k=R?j.dirname(k)+\"/\":__dirname+\"/\",H=(t,n)=>(t=z(t)?new URL(t):j.normalize(t),S.readFileSync(t,n?void 0:\"utf8\")),ee=t=>(t=H(t,!0),t.buffer||(t=new Uint8Array(t)),t),se=(t,n,l,y=!0)=>{t=z(t)?new URL(t):j.normalize(t),S.readFile(t,y?void 0:\"utf8\",(b,_)=>{b?l(b):n(y?_.buffer:_)})},!i.thisProgram&&1<process.argv.length&&(D=process.argv[1].replace(/\\\\\\\\/g,\"/\")),process.argv.slice(2),x=(t,n)=>{throw process.exitCode=t,n},i.inspect=()=>\"[Emscripten Module object]\";let e;try{e=hr()}catch(t){throw console.error(\\'The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?\\'),t}global.Worker=e.Worker}else(K||R)&&(R?k=self.location.href:typeof document<\"u\"&&document.currentScript&&(k=document.currentScript.src),typeof u<\"u\"&&u&&(k=u),k.indexOf(\"blob:\")!==0?k=k.substr(0,k.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):k=\"\",I||(H=e=>{var t=new XMLHttpRequest;return t.open(\"GET\",e,!1),t.send(null),t.responseText},R&&(ee=e=>{var t=new XMLHttpRequest;return t.open(\"GET\",e,!1),t.responseType=\"arraybuffer\",t.send(null),new Uint8Array(t.response)}),se=(e,t,n)=>{var l=new XMLHttpRequest;l.open(\"GET\",e,!0),l.responseType=\"arraybuffer\",l.onload=()=>{l.status==200||l.status==0&&l.response?t(l.response):n()},l.onerror=n,l.send(null)}));I&&typeof performance>\"u\"&&(global.performance=yr().performance);var Ce=console.log.bind(console),Ue=console.error.bind(console);I&&(Ce=(...e)=>S.writeSync(1,e.join(\" \")+`\\n`),Ue=(...e)=>S.writeSync(2,e.join(\" \")+`\\n`));var ce=Ce,ne=Ue;Object.assign(i,U),U=null,typeof WebAssembly!=\"object\"&&De(\"no native wasm support detected\");var Q,Oe,he=!1,ae,F,ye,ve,fe,_e;function Y(){var e=Q.buffer;i.HEAP8=F=new Int8Array(e),i.HEAP16=new Int16Array(e),i.HEAPU8=ye=new Uint8Array(e),i.HEAPU16=new Uint16Array(e),i.HEAP32=ve=new Int32Array(e),i.HEAPU32=fe=new Uint32Array(e),i.HEAPF32=new Float32Array(e),i.HEAPF64=_e=new Float64Array(e)}var pe=16777216;if(v)Q=i.wasmMemory;else if(i.wasmMemory)Q=i.wasmMemory;else if(Q=new WebAssembly.Memory({initial:pe/65536,maximum:65536,shared:!0}),!(Q.buffer instanceof SharedArrayBuffer))throw ne(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),I&&ne(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)\"),Error(\"bad memory\");Y(),pe=Q.buffer.byteLength;var Ie=[],Ee=[],be=[],we=0,Le=null,me=null;function Se(){if(we--,we==0&&(Le!==null&&(clearInterval(Le),Le=null),me)){var e=me;me=null,e()}}function De(e){throw e=\"Aborted(\"+e+\")\",ne(e),he=!0,ae=1,e=new WebAssembly.RuntimeError(e+\". Build with -sASSERTIONS for more info.\"),P(e),e}var te=e=>e.startsWith(\"data:application/octet-stream;base64,\"),z=e=>e.startsWith(\"file://\"),le;le=\"ort-wasm-threaded.wasm\",te(le)||(le=W(le));function Fe(e){if(ee)return ee(e);throw\"both async and sync fetching of the wasm failed\"}function Ae(e){if(K||R){if(typeof fetch==\"function\"&&!z(e))return fetch(e,{credentials:\"same-origin\"}).then(t=>{if(!t.ok)throw\"failed to load wasm binary file at \\'\"+e+\"\\'\";return t.arrayBuffer()}).catch(()=>Fe(e));if(se)return new Promise((t,n)=>{se(e,l=>t(new Uint8Array(l)),n)})}return Promise.resolve().then(()=>Fe(e))}function qe(e,t,n){return Ae(e).then(l=>WebAssembly.instantiate(l,t)).then(l=>l).then(n,l=>{ne(`failed to asynchronously prepare wasm: ${l}`),De(l)})}function at(e,t){var n=le;return typeof WebAssembly.instantiateStreaming!=\"function\"||te(n)||z(n)||I||typeof fetch!=\"function\"?qe(n,e,t):fetch(n,{credentials:\"same-origin\"}).then(l=>WebAssembly.instantiateStreaming(l,e).then(t,function(y){return ne(`wasm streaming compile failed: ${y}`),ne(\"falling back to ArrayBuffer instantiation\"),qe(n,e,t)}))}var xe,Ne={921388:(e,t,n,l)=>{if(typeof i>\"u\"||!i.cb)return 1;if(e=$e(e>>>0),e.startsWith(\"./\")&&(e=e.substring(2)),e=i.cb.get(e),!e)return 2;if(t>>>=0,n>>>=0,l>>>=0,t+n>e.byteLength)return 3;try{return h().set(e.subarray(t,t+n),l>>>0),0}catch{return 4}}};function Re(e){this.name=\"ExitStatus\",this.message=`Program terminated with exit(${e})`,this.status=e}var He=e=>{e.terminate(),e.onmessage=()=>{}},Ge=e=>{M.Pa.length==0&&(Xe(),M.Ya(M.Pa[0]));var t=M.Pa.pop();if(!t)return 6;M.Qa.push(t),M.Ma[e.Oa]=t,t.Oa=e.Oa;var n={cmd:\"run\",start_routine:e.kb,arg:e.hb,pthread_ptr:e.Oa};return I&&t.unref(),t.postMessage(n,e.qb),0},Be=0,Ve=typeof TextDecoder<\"u\"?new TextDecoder(\"utf8\"):void 0,Je=(e,t,n)=>{t>>>=0;var l=t+n;for(n=t;e[n]&&!(n>=l);)++n;if(16<n-t&&e.buffer&&Ve)return Ve.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(l=\"\";t<n;){var y=e[t++];if(y&128){var b=e[t++]&63;if((y&224)==192)l+=String.fromCharCode((y&31)<<6|b);else{var _=e[t++]&63;y=(y&240)==224?(y&15)<<12|b<<6|_:(y&7)<<18|b<<12|_<<6|e[t++]&63,65536>y?l+=String.fromCharCode(y):(y-=65536,l+=String.fromCharCode(55296|y>>10,56320|y&1023))}}else l+=String.fromCharCode(y)}return l},$e=(e,t)=>(e>>>=0)?Je(h(),e,t):\"\",ot=e=>{var t=vt();return e=e(),ct(t),e};function G(e,t){var n=arguments.length-2,l=arguments;return ot(()=>{for(var y=_t(8*n),b=y>>>3,_=0;_<n;_++){var J=l[2+_];g()[b+_>>>0]=J}return ar(e,n,y,t)})}function C(e){if(v)return G(0,1,e);ae=e,0<Be||(M.lb(),i.onExit?.(e),he=!0),x(e,new Re(e))}var je=e=>{if(ae=e,v)throw ut(e),\"unwind\";C(e)};function st(){for(var e=i.numThreads;e--;)Xe();Ie.unshift(()=>{we++,it(()=>Se())})}function Xe(){var e=W(\"ort-wasm-threaded.worker.js\");e=new Worker(e),M.Pa.push(e)}function it(e){v?e():Promise.all(M.Pa.map(M.Ya)).then(e)}var M={Pa:[],Qa:[],bb:[],Ma:{},Wa(){v?(M.receiveObjectTransfer=M.jb,M.threadInitTLS=M.ab,M.setExitStatus=M.$a):st()},$a:e=>ae=e,tb:[\"$terminateWorker\"],lb:()=>{for(var e of M.Qa)He(e);for(e of M.Pa)He(e);M.Pa=[],M.Qa=[],M.Ma=[]},Za:e=>{var t=e.Oa;delete M.Ma[t],M.Pa.push(e),M.Qa.splice(M.Qa.indexOf(e),1),e.Oa=0,wt(t)},jb(){},ab(){M.bb.forEach(e=>e())},Ya:e=>new Promise(t=>{e.onmessage=b=>{b=b.data;var _=b.cmd;if(b.targetThread&&b.targetThread!=lt()){var J=M.Ma[b.targetThread];J?J.postMessage(b,b.transferList):ne(`Internal error! Worker sent a message \"${_}\" to target pthread ${b.targetThread}, but that thread no longer exists!`)}else _===\"checkMailbox\"?ft():_===\"spawnThread\"?Ge(b):_===\"cleanupThread\"?M.Za(M.Ma[b.thread]):_===\"killThread\"?(b=b.thread,_=M.Ma[b],delete M.Ma[b],He(_),wt(b),M.Qa.splice(M.Qa.indexOf(_),1),_.Oa=0):_===\"cancelThread\"?M.Ma[b.thread].postMessage({cmd:\"cancel\"}):_===\"loaded\"?(e.loaded=!0,I&&!e.Oa&&e.unref(),t(e)):_===\"alert\"?alert(`Thread ${b.threadId}: ${b.text}`):b.target===\"setimmediate\"?e.postMessage(b):_===\"callHandler\"?i[b.handler](...b.args):_&&ne(`worker sent an unknown command ${_}`)},e.onerror=b=>{throw ne(`worker sent an error! ${b.filename}:${b.lineno}: ${b.message}`),b},I&&(e.on(\"message\",b=>e.onmessage({data:b})),e.on(\"error\",b=>e.onerror(b)));var n=[],l=[\"onExit\"],y;for(y of l)i.hasOwnProperty(y)&&n.push(y);e.postMessage({cmd:\"load\",handlers:n,urlOrBlob:i.mainScriptUrlOrBlob||u,wasmMemory:Q,wasmModule:Oe})})};i.PThread=M;var ke=e=>{for(;0<e.length;)e.shift()(i)};i.establishStackSpace=()=>{var e=lt(),t=w()[e+52>>>2>>>0];e=w()[e+56>>>2>>>0],ir(t,t-e),ct(t)};function ut(e){if(v)return G(1,0,e);je(e)}var Pe=[],Qe;i.invokeEntryPoint=(e,t)=>{var n=Pe[e];n||(e>=Pe.length&&(Pe.length=e+1),Pe[e]=n=Qe.get(e)),e=n(t),0<Be?M.$a(e):Ot(e)};function r(e){this.Va=e-24,this.gb=function(t){w()[this.Va+4>>>2>>>0]=t},this.fb=function(t){w()[this.Va+8>>>2>>>0]=t},this.Wa=function(t,n){this.eb(),this.gb(t),this.fb(n)},this.eb=function(){w()[this.Va+16>>>2>>>0]=0}}var o=0,s=0;function m(e,t,n,l){return v?G(2,1,e,t,n,l):O(e,t,n,l)}function O(e,t,n,l){if(e>>>=0,t>>>=0,n>>>=0,l>>>=0,typeof SharedArrayBuffer>\"u\")return ne(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var y=[];return v&&y.length===0?m(e,t,n,l):(e={kb:n,Oa:e,hb:l,qb:y},v?(e.sb=\"spawnThread\",postMessage(e,y),0):Ge(e))}function A(e,t,n){return v?G(3,1,e,t,n):0}function L(e,t){if(v)return G(4,1,e,t)}var re=e=>{for(var t=0,n=0;n<e.length;++n){var l=e.charCodeAt(n);127>=l?t++:2047>=l?t+=2:55296<=l&&57343>=l?(t+=4,++n):t+=3}return t},de=(e,t,n,l)=>{if(n>>>=0,!(0<l))return 0;var y=n;l=n+l-1;for(var b=0;b<e.length;++b){var _=e.charCodeAt(b);if(55296<=_&&57343>=_){var J=e.charCodeAt(++b);_=65536+((_&1023)<<10)|J&1023}if(127>=_){if(n>=l)break;t[n++>>>0]=_}else{if(2047>=_){if(n+1>=l)break;t[n++>>>0]=192|_>>6}else{if(65535>=_){if(n+2>=l)break;t[n++>>>0]=224|_>>12}else{if(n+3>=l)break;t[n++>>>0]=240|_>>18,t[n++>>>0]=128|_>>12&63}t[n++>>>0]=128|_>>6&63}t[n++>>>0]=128|_&63}}return t[n>>>0]=0,n-y},ie=(e,t,n)=>de(e,h(),t,n);function ue(e,t){if(v)return G(5,1,e,t)}function Ze(e,t,n){if(v)return G(6,1,e,t,n)}function Ke(e,t,n){return v?G(7,1,e,t,n):0}function d(e,t){if(v)return G(8,1,e,t)}function B(e,t,n){if(v)return G(9,1,e,t,n)}function $(e,t,n,l){if(v)return G(10,1,e,t,n,l)}function Te(e,t,n,l){if(v)return G(11,1,e,t,n,l)}function et(e,t,n,l){if(v)return G(12,1,e,t,n,l)}function Bt(e){if(v)return G(13,1,e)}function kt(e,t){if(v)return G(14,1,e,t)}function Wt(e,t,n){if(v)return G(15,1,e,t,n)}function mt(e){e>>>=0,typeof Atomics.rb==\"function\"&&(Atomics.rb(f(),e>>>2,e).value.then(ft),e+=128,Atomics.store(f(),e>>>2,1))}i.__emscripten_thread_mailbox_await=mt;var ft=()=>{var e=lt();if(e&&(mt(e),e=or,!he))try{if(e(),!(0<Be))try{v?Ot(ae):je(ae)}catch(t){t instanceof Re||t==\"unwind\"||x(1,t)}}catch(t){t instanceof Re||t==\"unwind\"||x(1,t)}};i.checkMailbox=ft;var gt=[],Ye=e=>e%4===0&&(e%100!==0||e%400===0),Nt=[0,31,60,91,121,152,182,213,244,274,305,335],Ht=[0,31,59,90,120,151,181,212,243,273,304,334];function Gt(e,t,n,l,y,b,_,J){return v?G(16,1,e,t,n,l,y,b,_,J):-52}function $t(e,t,n,l,y,b,_){if(v)return G(17,1,e,t,n,l,y,b,_)}var jt=e=>{var t=re(e)+1,n=rr(t);return n&&ie(e,n,t),n},ht=[],yt={},Yt=()=>{if(!bt){var e={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(typeof navigator==\"object\"&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:D||\"./this.program\"},t;for(t in yt)yt[t]===void 0?delete e[t]:e[t]=yt[t];var n=[];for(t in e)n.push(`${t}=${e[t]}`);bt=n}return bt},bt;function zt(e,t){if(v)return G(18,1,e,t);e>>>=0,t>>>=0;var n=0;return Yt().forEach((l,y)=>{var b=t+n;for(y=w()[e+4*y>>>2>>>0]=b,b=0;b<l.length;++b)a()[y++>>>0>>>0]=l.charCodeAt(b);a()[y>>>0>>>0]=0,n+=l.length+1}),0}function qt(e,t){if(v)return G(19,1,e,t);e>>>=0,t>>>=0;var n=Yt();w()[e>>>2>>>0]=n.length;var l=0;return n.forEach(y=>l+=y.length+1),w()[t>>>2>>>0]=l,0}function Vt(e){return v?G(20,1,e):52}function Jt(e,t,n,l){return v?G(21,1,e,t,n,l):52}function Xt(e,t,n,l,y){return v?G(22,1,e,t,n,l,y):70}var $r=[null,[],[]];function Qt(e,t,n,l){if(v)return G(23,1,e,t,n,l);t>>>=0,n>>>=0,l>>>=0;for(var y=0,b=0;b<n;b++){var _=w()[t>>>2>>>0],J=w()[t+4>>>2>>>0];t+=8;for(var Me=0;Me<J;Me++){var oe=h()[_+Me>>>0],ge=$r[e];oe===0||oe===10?((e===1?ce:ne)(Je(ge,0)),ge.length=0):ge.push(oe)}y+=J}return w()[l>>>2>>>0]=y,0}var Zt=[31,29,31,30,31,30,31,31,30,31,30,31],Kt=[31,28,31,30,31,30,31,31,30,31,30,31];function jr(e){var t=Array(re(e)+1);return de(e,t,0,t.length),t}var Yr=(e,t)=>{a().set(e,t>>>0)};function er(e,t,n,l){function y(p,N,X){for(p=typeof p==\"number\"?p.toString():p||\"\";p.length<N;)p=X[0]+p;return p}function b(p,N){return y(p,N,\"0\")}function _(p,N){function X(cr){return 0>cr?-1:0<cr?1:0}var We;return(We=X(p.getFullYear()-N.getFullYear()))===0&&(We=X(p.getMonth()-N.getMonth()))===0&&(We=X(p.getDate()-N.getDate())),We}function J(p){switch(p.getDay()){case 0:return new Date(p.getFullYear()-1,11,29);case 1:return p;case 2:return new Date(p.getFullYear(),0,3);case 3:return new Date(p.getFullYear(),0,2);case 4:return new Date(p.getFullYear(),0,1);case 5:return new Date(p.getFullYear()-1,11,31);case 6:return new Date(p.getFullYear()-1,11,30)}}function Me(p){var N=p.Ra;for(p=new Date(new Date(p.Sa+1900,0,1).getTime());0<N;){var X=p.getMonth(),We=(Ye(p.getFullYear())?Zt:Kt)[X];if(N>We-p.getDate())N-=We-p.getDate()+1,p.setDate(1),11>X?p.setMonth(X+1):(p.setMonth(0),p.setFullYear(p.getFullYear()+1));else{p.setDate(p.getDate()+N);break}}return X=new Date(p.getFullYear()+1,0,4),N=J(new Date(p.getFullYear(),0,4)),X=J(X),0>=_(N,p)?0>=_(X,p)?p.getFullYear()+1:p.getFullYear():p.getFullYear()-1}e>>>=0,t>>>=0,n>>>=0,l>>>=0;var oe=w()[l+40>>>2>>>0];l={ob:f()[l>>>2>>>0],nb:f()[l+4>>>2>>>0],Ta:f()[l+8>>>2>>>0],Xa:f()[l+12>>>2>>>0],Ua:f()[l+16>>>2>>>0],Sa:f()[l+20>>>2>>>0],Na:f()[l+24>>>2>>>0],Ra:f()[l+28>>>2>>>0],ub:f()[l+32>>>2>>>0],mb:f()[l+36>>>2>>>0],pb:oe?$e(oe):\"\"},n=$e(n),oe={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"};for(var ge in oe)n=n.replace(new RegExp(ge,\"g\"),oe[ge]);var fr=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),lr=\"January February March April May June July August September October November December\".split(\" \");oe={\"%a\":p=>fr[p.Na].substring(0,3),\"%A\":p=>fr[p.Na],\"%b\":p=>lr[p.Ua].substring(0,3),\"%B\":p=>lr[p.Ua],\"%C\":p=>b((p.Sa+1900)/100|0,2),\"%d\":p=>b(p.Xa,2),\"%e\":p=>y(p.Xa,2,\" \"),\"%g\":p=>Me(p).toString().substring(2),\"%G\":p=>Me(p),\"%H\":p=>b(p.Ta,2),\"%I\":p=>(p=p.Ta,p==0?p=12:12<p&&(p-=12),b(p,2)),\"%j\":p=>{for(var N=0,X=0;X<=p.Ua-1;N+=(Ye(p.Sa+1900)?Zt:Kt)[X++]);return b(p.Xa+N,3)},\"%m\":p=>b(p.Ua+1,2),\"%M\":p=>b(p.nb,2),\"%n\":()=>`\\n`,\"%p\":p=>0<=p.Ta&&12>p.Ta?\"AM\":\"PM\",\"%S\":p=>b(p.ob,2),\"%t\":()=>\"\t\",\"%u\":p=>p.Na||7,\"%U\":p=>b(Math.floor((p.Ra+7-p.Na)/7),2),\"%V\":p=>{var N=Math.floor((p.Ra+7-(p.Na+6)%7)/7);if(2>=(p.Na+371-p.Ra-2)%7&&N++,N)N==53&&(X=(p.Na+371-p.Ra)%7,X==4||X==3&&Ye(p.Sa)||(N=1));else{N=52;var X=(p.Na+7-p.Ra-1)%7;(X==4||X==5&&Ye(p.Sa%400-1))&&N++}return b(N,2)},\"%w\":p=>p.Na,\"%W\":p=>b(Math.floor((p.Ra+7-(p.Na+6)%7)/7),2),\"%y\":p=>(p.Sa+1900).toString().substring(2),\"%Y\":p=>p.Sa+1900,\"%z\":p=>{p=p.mb;var N=0<=p;return p=Math.abs(p)/60,(N?\"+\":\"-\")+(\"0000\"+(p/60*100+p%60)).slice(-4)},\"%Z\":p=>p.pb,\"%%\":()=>\"%\"},n=n.replace(/%%/g,\"\\\\0\\\\0\");for(ge in oe)n.includes(ge)&&(n=n.replace(new RegExp(ge,\"g\"),oe[ge](l)));return n=n.replace(/\\\\0\\\\0/g,\"%\"),ge=jr(n),ge.length>t?0:(Yr(ge,e),ge.length-1)}M.Wa();var zr=[C,ut,m,A,L,ue,Ze,Ke,d,B,$,Te,et,Bt,kt,Wt,Gt,$t,zt,qt,Vt,Jt,Xt,Qt],qr={b:function(e,t,n){throw e>>>=0,new r(e).Wa(t>>>0,n>>>0),o=e,s++,o},L:function(e){nr(e>>>0,!R,1,!K,131072,!1),M.ab()},j:function(e){e>>>=0,v?postMessage({cmd:\"cleanupThread\",thread:e}):M.Za(M.Ma[e])},H:O,h:A,S:L,D:ue,F:Ze,T:Ke,Q:d,J:B,P:$,n:Te,E:et,B:Bt,R:kt,C:Wt,p:()=>1,z:function(e,t){e>>>=0,e==t>>>0?setTimeout(()=>ft()):v?postMessage({targetThread:e,cmd:\"checkMailbox\"}):(e=M.Ma[e])&&e.postMessage({cmd:\"checkMailbox\"})},I:function(e,t,n,l){t>>>=0,gt.length=n,l=l>>>0>>>3;for(var y=0;y<n;y++)gt[y]=g()[l+y>>>0];return e=0>e?Ne[-e-1]:zr[e],M.ib=t,t=e.apply(null,gt),M.ib=0,t},K:mt,o:function(e){I&&M.Ma[e>>>0].ref()},s:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),f()[n>>>2>>>0]=e.getUTCSeconds(),f()[n+4>>>2>>>0]=e.getUTCMinutes(),f()[n+8>>>2>>>0]=e.getUTCHours(),f()[n+12>>>2>>>0]=e.getUTCDate(),f()[n+16>>>2>>>0]=e.getUTCMonth(),f()[n+20>>>2>>>0]=e.getUTCFullYear()-1900,f()[n+24>>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,f()[n+28>>>2>>>0]=e},t:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),f()[n>>>2>>>0]=e.getSeconds(),f()[n+4>>>2>>>0]=e.getMinutes(),f()[n+8>>>2>>>0]=e.getHours(),f()[n+12>>>2>>>0]=e.getDate(),f()[n+16>>>2>>>0]=e.getMonth(),f()[n+20>>>2>>>0]=e.getFullYear()-1900,f()[n+24>>>2>>>0]=e.getDay(),t=(Ye(e.getFullYear())?Nt:Ht)[e.getMonth()]+e.getDate()-1|0,f()[n+28>>>2>>>0]=t,f()[n+36>>>2>>>0]=-(60*e.getTimezoneOffset()),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var l=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=(t!=l&&e.getTimezoneOffset()==Math.min(l,t))|0,f()[n+32>>>2>>>0]=e},u:function(e){e>>>=0;var t=new Date(f()[e+20>>>2>>>0]+1900,f()[e+16>>>2>>>0],f()[e+12>>>2>>>0],f()[e+8>>>2>>>0],f()[e+4>>>2>>>0],f()[e>>>2>>>0],0),n=f()[e+32>>>2>>>0],l=t.getTimezoneOffset(),y=new Date(t.getFullYear(),6,1).getTimezoneOffset(),b=new Date(t.getFullYear(),0,1).getTimezoneOffset(),_=Math.min(b,y);return 0>n?f()[e+32>>>2>>>0]=+(y!=b&&_==l):0<n!=(_==l)&&(y=Math.max(b,y),t.setTime(t.getTime()+6e4*((0<n?_:y)-l))),f()[e+24>>>2>>>0]=t.getDay(),n=(Ye(t.getFullYear())?Nt:Ht)[t.getMonth()]+t.getDate()-1|0,f()[e+28>>>2>>>0]=n,f()[e>>>2>>>0]=t.getSeconds(),f()[e+4>>>2>>>0]=t.getMinutes(),f()[e+8>>>2>>>0]=t.getHours(),f()[e+12>>>2>>>0]=t.getDate(),f()[e+16>>>2>>>0]=t.getMonth(),f()[e+20>>>2>>>0]=t.getYear(),e=t.getTime(),isNaN(e)?(f()[tr()>>>2>>>0]=61,e=-1):e/=1e3,sr((xe=e,1<=+Math.abs(xe)?0<xe?+Math.floor(xe/4294967296)>>>0:~~+Math.ceil((xe-+(~~xe>>>0))/4294967296)>>>0:0)),e>>>0},q:Gt,r:$t,y:function(e,t,n){function l(oe){return(oe=oe.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?oe[1]:\"GMT\"}e>>>=0,t>>>=0,n>>>=0;var y=new Date().getFullYear(),b=new Date(y,0,1),_=new Date(y,6,1);y=b.getTimezoneOffset();var J=_.getTimezoneOffset(),Me=Math.max(y,J);w()[e>>>2>>>0]=60*Me,f()[t>>>2>>>0]=+(y!=J),e=l(b),t=l(_),e=jt(e),t=jt(t),J<y?(w()[n>>>2>>>0]=e,w()[n+4>>>2>>>0]=t):(w()[n>>>2>>>0]=t,w()[n+4>>>2>>>0]=e)},c:()=>{De(\"\")},O:function(e,t,n){e>>>=0,t>>>=0,n>>>=0,ht.length=0;for(var l;l=h()[t++>>>0];){var y=l!=105;y&=l!=112,n+=y&&n%8?4:0,ht.push(l==112?w()[n>>>2>>>0]:l==105?f()[n>>>2>>>0]:g()[n>>>3>>>0]),n+=y?8:4}return Ne[e].apply(null,ht)},k:()=>{},i:()=>Date.now(),U:()=>{throw Be+=1,\"unwind\"},A:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:()=>I?(wr(),rt(br)).cpus().length:navigator.hardwareConcurrency,x:function(e){e>>>=0;var t=h().length;if(e<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var l=t*(1+.2/n);l=Math.min(l,e+100663296);var y=Math;l=Math.max(e,l);e:{y=(y.min.call(y,4294901760,l+(65536-l%65536)%65536)-Q.buffer.byteLength+65535)/65536;try{Q.grow(y),Y();var b=1;break e}catch{}b=void 0}if(b)return!0}return!1},M:zt,N:qt,G:je,g:Vt,m:Jt,v:Xt,l:Qt,a:Q||i.wasmMemory,w:er,d:function(e,t,n,l){return er(e>>>0,t>>>0,n>>>0,l>>>0)}},T=function(){function e(n,l){return T=n.exports,T=Vr(),M.bb.push(T.za),Qe=T.Aa,Ee.unshift(T.V),Oe=l,Se(),T}var t={a:qr};if(we++,i.instantiateWasm)try{return i.instantiateWasm(t,e)}catch(n){ne(`Module.instantiateWasm callback failed with error: ${n}`),P(n)}return at(t,function(n){e(n.instance,n.module)}).catch(P),{}}();i._OrtInit=(e,t)=>(i._OrtInit=T.W)(e,t),i._OrtGetLastError=(e,t)=>(i._OrtGetLastError=T.X)(e,t),i._OrtCreateSessionOptions=(e,t,n,l,y,b,_,J,Me,oe)=>(i._OrtCreateSessionOptions=T.Y)(e,t,n,l,y,b,_,J,Me,oe),i._OrtAppendExecutionProvider=(e,t)=>(i._OrtAppendExecutionProvider=T.Z)(e,t),i._OrtAddFreeDimensionOverride=(e,t,n)=>(i._OrtAddFreeDimensionOverride=T._)(e,t,n),i._OrtAddSessionConfigEntry=(e,t,n)=>(i._OrtAddSessionConfigEntry=T.$)(e,t,n),i._OrtReleaseSessionOptions=e=>(i._OrtReleaseSessionOptions=T.aa)(e),i._OrtCreateSession=(e,t,n)=>(i._OrtCreateSession=T.ba)(e,t,n),i._OrtReleaseSession=e=>(i._OrtReleaseSession=T.ca)(e),i._OrtGetInputOutputCount=(e,t,n)=>(i._OrtGetInputOutputCount=T.da)(e,t,n),i._OrtGetInputName=(e,t)=>(i._OrtGetInputName=T.ea)(e,t),i._OrtGetOutputName=(e,t)=>(i._OrtGetOutputName=T.fa)(e,t),i._OrtFree=e=>(i._OrtFree=T.ga)(e),i._OrtCreateTensor=(e,t,n,l,y,b)=>(i._OrtCreateTensor=T.ha)(e,t,n,l,y,b),i._OrtGetTensorData=(e,t,n,l,y)=>(i._OrtGetTensorData=T.ia)(e,t,n,l,y),i._OrtReleaseTensor=e=>(i._OrtReleaseTensor=T.ja)(e),i._OrtCreateRunOptions=(e,t,n,l)=>(i._OrtCreateRunOptions=T.ka)(e,t,n,l),i._OrtAddRunConfigEntry=(e,t,n)=>(i._OrtAddRunConfigEntry=T.la)(e,t,n),i._OrtReleaseRunOptions=e=>(i._OrtReleaseRunOptions=T.ma)(e),i._OrtCreateBinding=e=>(i._OrtCreateBinding=T.na)(e),i._OrtBindInput=(e,t,n)=>(i._OrtBindInput=T.oa)(e,t,n),i._OrtBindOutput=(e,t,n,l)=>(i._OrtBindOutput=T.pa)(e,t,n,l),i._OrtClearBoundOutputs=e=>(i._OrtClearBoundOutputs=T.qa)(e),i._OrtReleaseBinding=e=>(i._OrtReleaseBinding=T.ra)(e),i._OrtRunWithBinding=(e,t,n,l,y)=>(i._OrtRunWithBinding=T.sa)(e,t,n,l,y),i._OrtRun=(e,t,n,l,y,b,_,J)=>(i._OrtRun=T.ta)(e,t,n,l,y,b,_,J),i._OrtEndProfiling=e=>(i._OrtEndProfiling=T.ua)(e);var tr=()=>(tr=T.va)(),lt=i._pthread_self=()=>(lt=i._pthread_self=T.wa)(),rr=i._malloc=e=>(rr=i._malloc=T.xa)(e);i._free=e=>(i._free=T.ya)(e),i.__emscripten_tls_init=()=>(i.__emscripten_tls_init=T.za)();var nr=i.__emscripten_thread_init=(e,t,n,l,y,b)=>(nr=i.__emscripten_thread_init=T.Ba)(e,t,n,l,y,b);i.__emscripten_thread_crashed=()=>(i.__emscripten_thread_crashed=T.Ca)();var ar=(e,t,n,l)=>(ar=T.Da)(e,t,n,l),wt=e=>(wt=T.Ea)(e),Ot=i.__emscripten_thread_exit=e=>(Ot=i.__emscripten_thread_exit=T.Fa)(e),or=()=>(or=T.Ga)(),sr=e=>(sr=T.Ha)(e),ir=(e,t)=>(ir=T.Ia)(e,t),vt=()=>(vt=T.Ja)(),ct=e=>(ct=T.Ka)(e),_t=e=>(_t=T.La)(e);function Vr(){var e=T;e=Object.assign({},e);var t=l=>()=>l()>>>0,n=l=>y=>l(y)>>>0;return e.va=t(e.va),e.wa=t(e.wa),e.xa=n(e.xa),e.emscripten_main_runtime_thread_id=t(e.emscripten_main_runtime_thread_id),e.Ja=t(e.Ja),e.La=n(e.La),e}i.wasmMemory=Q,i.stackAlloc=_t,i.stackSave=vt,i.stackRestore=ct,i.keepRuntimeAlive=()=>0<Be,i.UTF8ToString=$e,i.stringToUTF8=ie,i.lengthBytesUTF8=re,i.ExitStatus=Re,i.PThread=M;var dt;me=function e(){dt||ur(),dt||(me=e)};function ur(){if(!(0<we))if(v)E(i),v||ke(Ee),startWorker(i);else{if(i.preRun)for(typeof i.preRun==\"function\"&&(i.preRun=[i.preRun]);i.preRun.length;)Ie.unshift(i.preRun.shift());ke(Ie),0<we||dt||(dt=!0,i.calledRun=!0,he||(v||ke(Ee),E(i),v||ke(be)))}}return ur(),c.ready}})();typeof vr==\"object\"&&typeof xt==\"object\"?xt.exports=Or:typeof define==\"function\"&&define.amd&&define([],()=>Or)});var Er=tt((On,nn)=>{nn.exports=\\'\"use strict\";var Module={},ENVIRONMENT_IS_NODE=typeof process==\"object\"&&typeof process.versions==\"object\"&&typeof process.versions.node==\"string\";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require(\"worker_threads\"),parentPort=nodeWorkerThreads.parentPort;parentPort.on(\"message\",e=>onmessage({data:e}));var fs=require(\"fs\"),vm=require(\"vm\");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,\"utf8\"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(\" \");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd===\"load\"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:\"loaded\"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:\"callHandler\",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob==\"string\")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd===\"run\"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!=\"unwind\")throw a}}else e.data.cmd===\"cancel\"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target===\"setimmediate\"||(e.data.cmd===\"checkMailbox\"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed?.(),a}}self.onmessage=handleMessage;\\\\n\\'});var Ar;Ar=gr();var an=_r(),Pt,Ut=!1,pt=!1,Sr=!1,on=u=>{if(u===1)return!1;if(typeof SharedArrayBuffer>\"u\")return typeof self<\"u\"&&!self.crossOriginIsolated&&console.warn(\"env.wasm.numThreads is set to \"+u+\", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info.\"),!1;typeof process<\"u\"&&process.versions&&process.versions.node&&console.warn(\"env.wasm.numThreads is set to \"+u+\", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.\");try{return typeof MessageChannel<\"u\"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},sn=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},un=(u,c)=>u?c?\"ort-wasm-simd-threaded.wasm\":\"ort-wasm-simd.wasm\":c?\"ort-wasm-threaded.wasm\":\"ort-wasm.wasm\",Tr=async u=>{if(Ut)return Promise.resolve();if(pt)throw new Error(\"multiple calls to \\'initializeWebAssembly()\\' detected.\");if(Sr)throw new Error(\"previous call to \\'initializeWebAssembly()\\' failed.\");pt=!0;let c=u.initTimeout,a=u.numThreads,h=u.simd,f=on(a),w=h&&sn(),g=u.wasmPaths,i=typeof g==\"string\"?g:void 0,E=un(w,f),P=typeof g==\"object\"?g[E]:void 0,U=!1,D=[];if(c>0&&D.push(new Promise(x=>{setTimeout(()=>{U=!0,x()},c)})),D.push(new Promise((x,K)=>{let R=f?an:Ar,I={locateFile:(v,k)=>f&&v.endsWith(\".worker.js\")&&typeof Blob<\"u\"?URL.createObjectURL(new Blob([Er()],{type:\"text/javascript\"})):v.endsWith(\".wasm\")?P||(i??k)+E:k+v};if(f)if(I.numThreads=a,typeof Blob>\"u\")I.mainScriptUrlOrBlob=(void 0)(__dirname,\"ort-wasm-threaded.js\");else{let v=`var ortWasmThreaded=${R.toString()};`;I.mainScriptUrlOrBlob=new Blob([v],{type:\"text/javascript\"})}R(I).then(v=>{pt=!1,Ut=!0,Pt=v,x()},v=>{pt=!1,Sr=!0,K(v)})})),await Promise.race(D),U)throw new Error(`WebAssembly backend initializing failed due to timeout: ${c}ms`)},Z=()=>{if(Ut&&Pt)return Pt;throw new Error(\"WebAssembly is not initialized yet.\")};var q=(u,c)=>{let a=Z(),h=a.lengthBytesUTF8(u)+1,f=a._malloc(h);return a.stringToUTF8(u,f,h),c.push(f),f},nt=(u,c,a,h)=>{if(typeof u==\"object\"&&u!==null){if(a.has(u))throw new Error(\"Circular reference in options\");a.add(u)}Object.entries(u).forEach(([f,w])=>{let g=c?c+f:f;if(typeof w==\"object\")nt(w,g+\".\",a,h);else if(typeof w==\"string\"||typeof w==\"number\")h(g,w.toString());else if(typeof w==\"boolean\")h(g,w?\"1\":\"0\");else throw new Error(`Can\\'t handle extra config type: ${typeof w}`)})},V=u=>{let c=Z(),a=c.stackSave();try{let h=c.stackAlloc(8);c._OrtGetLastError(h,h+4);let f=c.HEAP32[h/4],w=c.HEAPU32[h/4+1],g=w?c.UTF8ToString(w):\"\";throw new Error(`${u} ERROR_CODE: ${f}, ERROR_MESSAGE: ${g}`)}finally{c.stackRestore(a)}};var Mr=u=>{let c=Z(),a=0,h=[],f=u||{};try{if(u?.logSeverityLevel===void 0)f.logSeverityLevel=2;else if(typeof u.logSeverityLevel!=\"number\"||!Number.isInteger(u.logSeverityLevel)||u.logSeverityLevel<0||u.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${u.logSeverityLevel}`);if(u?.logVerbosityLevel===void 0)f.logVerbosityLevel=0;else if(typeof u.logVerbosityLevel!=\"number\"||!Number.isInteger(u.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${u.logVerbosityLevel}`);u?.terminate===void 0&&(f.terminate=!1);let w=0;return u?.tag!==void 0&&(w=q(u.tag,h)),a=c._OrtCreateRunOptions(f.logSeverityLevel,f.logVerbosityLevel,!!f.terminate,w),a===0&&V(\"Can\\'t create run options.\"),u?.extra!==void 0&&nt(u.extra,\"\",new WeakSet,(g,i)=>{let E=q(g,h),P=q(i,h);c._OrtAddRunConfigEntry(a,E,P)!==0&&V(`Can\\'t set a run config entry: ${g} - ${i}.`)}),[a,h]}catch(w){throw a!==0&&c._OrtReleaseRunOptions(a),h.forEach(g=>c._free(g)),w}};var fn=u=>{switch(u){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${u}`)}},ln=u=>{switch(u){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${u}`)}},cn=u=>{u.extra||(u.extra={}),u.extra.session||(u.extra.session={});let c=u.extra.session;c.use_ort_model_bytes_directly||(c.use_ort_model_bytes_directly=\"1\"),u.executionProviders&&u.executionProviders.some(a=>(typeof a==\"string\"?a:a.name)===\"webgpu\")&&(u.enableMemPattern=!1)},dn=(u,c,a)=>{for(let h of c){let f=typeof h==\"string\"?h:h.name;switch(f){case\"webnn\":if(f=\"WEBNN\",typeof h!=\"string\"){let g=h;if(g?.deviceType){let i=q(\"deviceType\",a),E=q(g.deviceType,a);Z()._OrtAddSessionConfigEntry(u,i,E)!==0&&V(`Can\\'t set a session config entry: \\'deviceType\\' - ${g.deviceType}.`)}if(g?.numThreads){let i=g.numThreads;(typeof i!=\"number\"||!Number.isInteger(i)||i<0)&&(i=0);let E=q(\"numThreads\",a),P=q(i.toString(),a);Z()._OrtAddSessionConfigEntry(u,E,P)!==0&&V(`Can\\'t set a session config entry: \\'numThreads\\' - ${g.numThreads}.`)}if(g?.powerPreference){let i=q(\"powerPreference\",a),E=q(g.powerPreference,a);Z()._OrtAddSessionConfigEntry(u,i,E)!==0&&V(`Can\\'t set a session config entry: \\'powerPreference\\' - ${g.powerPreference}.`)}}break;case\"webgpu\":if(f=\"JS\",typeof h!=\"string\"){let g=h;if(g?.preferredLayout){if(g.preferredLayout!==\"NCHW\"&&g.preferredLayout!==\"NHWC\")throw new Error(`preferredLayout must be either \\'NCHW\\' or \\'NHWC\\': ${g.preferredLayout}`);let i=q(\"preferredLayout\",a),E=q(g.preferredLayout,a);Z()._OrtAddSessionConfigEntry(u,i,E)!==0&&V(`Can\\'t set a session config entry: \\'preferredLayout\\' - ${g.preferredLayout}.`)}}break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported execution provider: ${f}`)}let w=q(f,a);Z()._OrtAppendExecutionProvider(u,w)!==0&&V(`Can\\'t append execution provider: ${f}.`)}},Cr=u=>{let c=Z(),a=0,h=[],f=u||{};cn(f);try{let w=fn(f.graphOptimizationLevel??\"all\"),g=ln(f.executionMode??\"sequential\"),i=typeof f.logId==\"string\"?q(f.logId,h):0,E=f.logSeverityLevel??2;if(!Number.isInteger(E)||E<0||E>4)throw new Error(`log serverity level is not valid: ${E}`);let P=f.logVerbosityLevel??0;if(!Number.isInteger(P)||P<0||P>4)throw new Error(`log verbosity level is not valid: ${P}`);let U=typeof f.optimizedModelFilePath==\"string\"?q(f.optimizedModelFilePath,h):0;if(a=c._OrtCreateSessionOptions(w,!!f.enableCpuMemArena,!!f.enableMemPattern,g,!!f.enableProfiling,0,i,E,P,U),a===0&&V(\"Can\\'t create session options.\"),f.executionProviders&&dn(a,f.executionProviders,h),f.enableGraphCapture!==void 0){if(typeof f.enableGraphCapture!=\"boolean\")throw new Error(`enableGraphCapture must be a boolean value: ${f.enableGraphCapture}`);let D=q(\"enableGraphCapture\",h),x=q(f.enableGraphCapture.toString(),h);c._OrtAddSessionConfigEntry(a,D,x)!==0&&V(`Can\\'t set a session config entry: \\'enableGraphCapture\\' - ${f.enableGraphCapture}.`)}if(f.freeDimensionOverrides)for(let[D,x]of Object.entries(f.freeDimensionOverrides)){if(typeof D!=\"string\")throw new Error(`free dimension override name must be a string: ${D}`);if(typeof x!=\"number\"||!Number.isInteger(x)||x<0)throw new Error(`free dimension override value must be a non-negative integer: ${x}`);let K=q(D,h);c._OrtAddFreeDimensionOverride(a,K,x)!==0&&V(`Can\\'t set a free dimension override: ${D} - ${x}.`)}return f.extra!==void 0&&nt(f.extra,\"\",new WeakSet,(D,x)=>{let K=q(D,h),R=q(x,h);c._OrtAddSessionConfigEntry(a,K,R)!==0&&V(`Can\\'t set a session config entry: ${D} - ${x}.`)}),[a,h]}catch(w){throw a!==0&&c._OrtReleaseSessionOptions(a),h.forEach(g=>c._free(g)),w}};var Rt=u=>{switch(u){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float16\":return 10;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;default:throw new Error(`unsupported data type: ${u}`)}},Dr=u=>{switch(u){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 10:return\"float16\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";default:throw new Error(`unsupported data type: ${u}`)}},It=u=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][u],Fr=u=>{switch(u){case\"float16\":return typeof Float16Array<\"u\"&&Float16Array.from?Float16Array:Uint16Array;case\"float32\":return Float32Array;case\"uint8\":return Uint8Array;case\"int8\":return Int8Array;case\"uint16\":return Uint16Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"bool\":return Uint8Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${u}`)}},xr=u=>{switch(u){case\"verbose\":return 0;case\"info\":return 1;case\"warning\":return 2;case\"error\":return 3;case\"fatal\":return 4;default:throw new Error(`unsupported logging level: ${u}`)}},Pr=u=>u===\"float32\"||u===\"float16\"||u===\"int32\"||u===\"int64\"||u===\"uint32\"||u===\"uint8\"||u===\"bool\",Ur=u=>{switch(u){case\"none\":return 0;case\"cpu\":return 1;case\"cpu-pinned\":return 2;case\"texture\":return 3;case\"gpu-buffer\":return 4;default:throw new Error(`unsupported data location: ${u}`)}};var Rr=async u=>{if(typeof u==\"string\")if(typeof process<\"u\"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(u))}catch(c){if(c.code===\"ERR_FS_FILE_TOO_LARGE\"){let a=(void 0)(u),h=[];for await(let f of a)h.push(f);return new Uint8Array(Buffer.concat(h))}throw c}else{let c=await fetch(u);if(!c.ok)throw new Error(`failed to load external data file: ${u}`);let a=c.headers.get(\"Content-Length\"),h=a?parseInt(a,10):0;if(h<1073741824)return new Uint8Array(await c.arrayBuffer());{if(!c.body)throw new Error(`failed to load external data file: ${u}, no response body.`);let f=c.body.getReader(),w;try{w=new ArrayBuffer(h)}catch(i){if(i instanceof RangeError){let E=Math.ceil(h/65536);w=new WebAssembly.Memory({initial:E,maximum:E}).buffer}else throw i}let g=0;for(;;){let{done:i,value:E}=await f.read();if(i)break;let P=E.byteLength;new Uint8Array(w,g,P).set(E),g+=P}return new Uint8Array(w,0,h)}}else return u instanceof Blob?new Uint8Array(await u.arrayBuffer()):u instanceof Uint8Array?u:new Uint8Array(u)};var pn=(u,c)=>{Z()._OrtInit(u,c)!==0&&V(\"Can\\'t initialize onnxruntime.\")},Lr=async u=>{pn(u.wasm.numThreads,xr(u.logLevel))},Br=async(u,c)=>{},ze=new Map,mn=u=>{let c=Z(),a=c.stackSave();try{let h=c.stackAlloc(8);return c._OrtGetInputOutputCount(u,h,h+4)!==0&&V(\"Can\\'t get session input/output count.\"),[c.HEAP32[h/4],c.HEAP32[h/4+1]]}finally{c.stackRestore(a)}},Lt=u=>{let c=Z(),a=c._malloc(u.byteLength);if(a===0)throw new Error(`Can\\'t create a session. failed to allocate a buffer of size ${u.byteLength}.`);return c.HEAPU8.set(u,a),[a,u.byteLength]},kr=async(u,c)=>{let a,h,f=Z();Array.isArray(u)?[a,h]=u:u.buffer===f.HEAPU8.buffer?[a,h]=[u.byteOffset,u.byteLength]:[a,h]=Lt(u);let w=0,g=0,i=0,E=[],P=[],U=[];try{if([g,E]=Cr(c),c?.externalData&&f.mountExternalData){let W=[];for(let H of c.externalData){let se=typeof H==\"string\"?H:H.path;W.push(Rr(typeof H==\"string\"?H:H.data).then(ee=>{f.mountExternalData(se,ee)}))}await Promise.all(W)}w=await f._OrtCreateSession(a,h,g),w===0&&V(\"Can\\'t create a session.\");let[D,x]=mn(w),K=!!c?.enableGraphCapture,R=[],I=[],v=[];for(let W=0;W<D;W++){let H=f._OrtGetInputName(w,W);H===0&&V(\"Can\\'t get an input name.\"),P.push(H),R.push(f.UTF8ToString(H))}for(let W=0;W<x;W++){let H=f._OrtGetOutputName(w,W);H===0&&V(\"Can\\'t get an output name.\"),U.push(H);let se=f.UTF8ToString(H);I.push(se)}let k=null;return ze.set(w,[w,P,U,k,K,!1]),[w,R,I]}catch(D){throw P.forEach(x=>f._OrtFree(x)),U.forEach(x=>f._OrtFree(x)),i!==0&&f._OrtReleaseBinding(i),w!==0&&f._OrtReleaseSession(w),D}finally{f._free(a),g!==0&&f._OrtReleaseSessionOptions(g),E.forEach(D=>f._free(D)),f.unmountExternalData?.()}},Wr=u=>{let c=Z(),a=ze.get(u);if(!a)throw new Error(`cannot release session. invalid session id: ${u}`);let[h,f,w,g,i]=a;g&&(i&&c._OrtClearBoundOutputs(g.handle),c._OrtReleaseBinding(g.handle)),c.jsepOnReleaseSession?.(u),f.forEach(E=>c._OrtFree(E)),w.forEach(E=>c._OrtFree(E)),c._OrtReleaseSession(h),ze.delete(u)},Ir=(u,c,a,h,f,w=!1)=>{if(!u){c.push(0);return}let g=Z(),i=u[0],E=u[1],P=u[3],U,D;if(i===\"string\"&&P===\"gpu-buffer\")throw new Error(\"String tensor is not supported on GPU.\");if(w&&P!==\"gpu-buffer\")throw new Error(`External buffer must be provided for input/output index ${f} when enableGraphCapture is true.`);if(P===\"gpu-buffer\"){let R=u[2].gpuBuffer,I=It(Rt(i));D=E.reduce((k,W)=>k*W,1)*I;let v=g.jsepRegisterBuffer;if(!v)throw new Error(\\'Tensor location \"gpu-buffer\" is not supported without using WebGPU.\\');U=v(h,f,R,D)}else{let R=u[2];if(Array.isArray(R)){D=4*R.length,U=g._malloc(D),a.push(U);let I=U/4;for(let v=0;v<R.length;v++){if(typeof R[v]!=\"string\")throw new TypeError(`tensor data at index ${v} is not a string`);g.HEAPU32[I++]=q(R[v],a)}}else D=R.byteLength,U=g._malloc(D),a.push(U),g.HEAPU8.set(new Uint8Array(R.buffer,R.byteOffset,D),U)}let x=g.stackSave(),K=g.stackAlloc(4*E.length);try{let R=K/4;E.forEach(v=>g.HEAP32[R++]=v);let I=g._OrtCreateTensor(Rt(i),U,D,K,E.length,Ur(P));I===0&&V(`Can\\'t create tensor for input/output. session=${h}, index=${f}.`),c.push(I)}finally{g.stackRestore(x)}},Nr=async(u,c,a,h,f,w)=>{let g=Z(),i=ze.get(u);if(!i)throw new Error(`cannot run inference. invalid session id: ${u}`);let E=i[0],P=i[1],U=i[2],D=i[3],x=i[4],K=i[5],R=c.length,I=h.length,v=0,k=[],W=[],H=[],se=[],ee=g.stackSave(),S=g.stackAlloc(R*4),j=g.stackAlloc(R*4),Ce=g.stackAlloc(I*4),Ue=g.stackAlloc(I*4);try{[v,k]=Mr(w);for(let F=0;F<R;F++)Ir(a[F],W,se,u,c[F],x);for(let F=0;F<I;F++)Ir(f[F],H,se,u,R+h[F],x);let ce=S/4,ne=j/4,Q=Ce/4,Oe=Ue/4;for(let F=0;F<R;F++)g.HEAPU32[ce++]=W[F],g.HEAPU32[ne++]=P[c[F]];for(let F=0;F<I;F++)g.HEAPU32[Q++]=H[F],g.HEAPU32[Oe++]=U[h[F]];g.jsepOnRunStart?.(E);let he;he=await g._OrtRun(E,j,S,R,Ue,I,Ce,v),he!==0&&V(\"failed to call OrtRun().\");let ae=[];for(let F=0;F<I;F++){let ye=g.HEAPU32[Ce/4+F];if(ye===H[F]){ae.push(f[F]);continue}let ve=g.stackSave(),fe=g.stackAlloc(4*4),_e=!1,Y,pe=0;try{g._OrtGetTensorData(ye,fe,fe+4,fe+8,fe+12)!==0&&V(`Can\\'t access output tensor data on index ${F}.`);let Ee=fe/4,be=g.HEAPU32[Ee++];pe=g.HEAPU32[Ee++];let we=g.HEAPU32[Ee++],Le=g.HEAPU32[Ee++],me=[];for(let te=0;te<Le;te++)me.push(g.HEAPU32[we/4+te]);g._OrtFree(we);let Se=me.reduce((te,z)=>te*z,1);Y=Dr(be);let De=D?.outputPreferredLocations[h[F]];if(Y===\"string\"){if(De===\"gpu-buffer\")throw new Error(\"String tensor is not supported on GPU.\");let te=[],z=pe/4;for(let le=0;le<Se;le++){let Fe=g.HEAPU32[z++],Ae=le===Se-1?void 0:g.HEAPU32[z]-Fe;te.push(g.UTF8ToString(Fe,Ae))}ae.push([Y,me,te,\"cpu\"])}else if(De===\"gpu-buffer\"&&Se>0){let te=g.jsepGetBuffer;if(!te)throw new Error(\\'preferredLocation \"gpu-buffer\" is not supported without using WebGPU.\\');let z=te(pe),le=It(be);if(le===void 0||!Pr(Y))throw new Error(`Unsupported data type: ${Y}`);_e=!0,ae.push([Y,me,{gpuBuffer:z,download:g.jsepCreateDownloader(z,Se*le,Y),dispose:()=>{g._OrtReleaseTensor(ye)}},\"gpu-buffer\"])}else{let te=Fr(Y),z=new te(Se);new Uint8Array(z.buffer,z.byteOffset,z.byteLength).set(g.HEAPU8.subarray(pe,pe+z.byteLength)),ae.push([Y,me,z,\"cpu\"])}}finally{g.stackRestore(ve),Y===\"string\"&&pe&&g._free(pe),_e||g._OrtReleaseTensor(ye)}}return D&&!x&&(g._OrtClearBoundOutputs(D.handle),ze.set(u,[E,P,U,D,x,!1])),ae}finally{g.stackRestore(ee),W.forEach(ce=>g._OrtReleaseTensor(ce)),H.forEach(ce=>g._OrtReleaseTensor(ce)),se.forEach(ce=>g._free(ce)),v!==0&&g._OrtReleaseRunOptions(v),k.forEach(ce=>g._free(ce))}},Hr=u=>{let c=Z(),a=ze.get(u);if(!a)throw new Error(\"invalid session id\");let h=a[0],f=c._OrtEndProfiling(h);f===0&&V(\"Can\\'t get an profile file name.\"),c._OrtFree(f)},Gr=u=>{let c=[];for(let a of u){let h=a[2];!Array.isArray(h)&&\"buffer\"in h&&c.push(h.buffer)}return c};self.onmessage=u=>{let{type:c,in:a}=u.data;try{switch(c){case\"init-wasm\":Tr(a.wasm).then(()=>{Lr(a).then(()=>{postMessage({type:c})},h=>{postMessage({type:c,err:h})})},h=>{postMessage({type:c,err:h})});break;case\"init-ep\":{let{epName:h,env:f}=a;Br(f,h).then(()=>{postMessage({type:c})},w=>{postMessage({type:c,err:w})});break}case\"copy-from\":{let{buffer:h}=a,f=Lt(h);postMessage({type:c,out:f});break}case\"create\":{let{model:h,options:f}=a;kr(h,f).then(w=>{postMessage({type:c,out:w})},w=>{postMessage({type:c,err:w})});break}case\"release\":Wr(a),postMessage({type:c});break;case\"run\":{let{sessionId:h,inputIndices:f,inputs:w,outputIndices:g,options:i}=a;Nr(h,f,w,g,new Array(g.length).fill(null),i).then(E=>{E.some(P=>P[3]!==\"cpu\")?postMessage({type:c,err:\"Proxy does not support non-cpu tensor location.\"}):postMessage({type:c,out:E},Gr([...w,...E]))},E=>{postMessage({type:c,err:E})});break}case\"end-profiling\":Hr(a),postMessage({type:c});break;default:}}catch(h){postMessage({type:c,err:h})}};})();\\n'});var wr,ht,xn,Fo,Co,da,ha,Hr,qr,wg,Lo,ad,sd,ud,ld,fd,cd,pd,ma=E(()=>{\"use strict\";Tt();od();Vr();wr=()=>!!Z.wasm.proxy&&typeof document<\"u\",xn=!1,Fo=!1,Co=!1,ha=new Map,Hr=(a,t)=>{let o=ha.get(a);o?o.push(t):ha.set(a,[t])},qr=()=>{if(xn||!Fo||Co||!ht)throw new Error(\"worker not ready\")},wg=a=>{switch(a.data.type){case\"init-wasm\":xn=!1,a.data.err?(Co=!0,da[1](a.data.err)):(Fo=!0,da[0]());break;case\"init-ep\":case\"copy-from\":case\"create\":case\"release\":case\"run\":case\"end-profiling\":{let t=ha.get(a.data.type);a.data.err?t.shift()[1](a.data.err):t.shift()[0](a.data.out);break}default:}},Lo=typeof document<\"u\"?document?.currentScript?.src:void 0,ad=async()=>{if(!Fo){if(xn)throw new Error(\"multiple calls to 'initWasm()' detected.\");if(Co)throw new Error(\"previous call to 'initWasm()' failed.\");if(xn=!0,wr())return Z.wasm.wasmPaths===void 0&&Lo&&Lo.indexOf(\"blob:\")!==0&&(Z.wasm.wasmPaths=Lo.substr(0,+Lo.lastIndexOf(\"/\")+1)),new Promise((a,t)=>{ht?.terminate();let o=URL.createObjectURL(new Blob([id()],{type:\"text/javascript\"}));ht=new Worker(o,{name:\"ort-wasm-proxy-worker\"}),ht.onerror=r=>t(r),ht.onmessage=wg,URL.revokeObjectURL(o),da=[a,t];let e={type:\"init-wasm\",in:Z};ht.postMessage(e)});try{await Up(Z.wasm),await Jp(Z),Fo=!0}catch(a){throw Co=!0,a}finally{xn=!1}}},sd=async a=>{if(wr())return qr(),new Promise((t,o)=>{Hr(\"init-ep\",[t,o]);let e={type:\"init-ep\",in:{epName:a,env:Z}};ht.postMessage(e)});await Zp(Z,a)},ud=async a=>wr()?(qr(),new Promise((t,o)=>{Hr(\"copy-from\",[t,o]);let e={type:\"copy-from\",in:{buffer:a}};ht.postMessage(e,[a.buffer])})):pa(a),ld=async(a,t)=>{if(wr()){if(t?.preferredOutputLocation)throw new Error('session option \"preferredOutputLocation\" is not supported for proxy.');return qr(),new Promise((o,e)=>{Hr(\"create\",[o,e]);let r={type:\"create\",in:{model:a,options:{...t}}},n=[];a instanceof Uint8Array&&n.push(a.buffer),ht.postMessage(r,n)})}else return Qp(a,t)},fd=async a=>{if(wr())return qr(),new Promise((t,o)=>{Hr(\"release\",[t,o]);let e={type:\"release\",in:a};ht.postMessage(e)});ed(a)},cd=async(a,t,o,e,r,n)=>{if(wr()){if(o.some(s=>s[3]!==\"cpu\"))throw new Error(\"input tensor on GPU is not supported for proxy.\");if(r.some(s=>s))throw new Error(\"pre-allocated output tensor is not supported for proxy.\");return qr(),new Promise((s,i)=>{Hr(\"run\",[s,i]);let u=o,l={type:\"run\",in:{sessionId:a,inputIndices:t,inputs:u,outputIndices:e,options:n}};ht.postMessage(l,nd(u))})}else return td(a,t,o,e,r,n)},pd=async a=>{if(wr())return qr(),new Promise((t,o)=>{Hr(\"end-profiling\",[t,o]);let e={type:\"end-profiling\",in:a};ht.postMessage(e)});rd(a)}});var dd,vg,$o,hd=E(()=>{\"use strict\";Tt();ma();fa();ca();dd=(a,t)=>{switch(a.location){case\"cpu\":return[a.type,a.dims,a.data,\"cpu\"];case\"gpu-buffer\":return[a.type,a.dims,{gpuBuffer:a.gpuBuffer},\"gpu-buffer\"];default:throw new Error(`invalid data location: ${a.location} for ${t()}`)}},vg=a=>{switch(a[3]){case\"cpu\":return new Re(a[0],a[2],a[1]);case\"gpu-buffer\":{let t=a[0];if(!Do(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:o,download:e,dispose:r}=a[2];return Re.fromGpuBuffer(o,{dataType:t,dims:a[1],download:e,dispose:r})}default:throw new Error(`invalid data location: ${a[3]}`)}},$o=class{async fetchModelAndCopyToWasmMemory(t){return ud(await Tn(t))}async loadModel(t,o){sr();let e;typeof t==\"string\"?typeof process<\"u\"&&process.versions&&process.versions.node?e=await Tn(t):e=await this.fetchModelAndCopyToWasmMemory(t):e=t,[this.sessionId,this.inputNames,this.outputNames]=await ld(e,o),ur()}async dispose(){return fd(this.sessionId)}async run(t,o,e){sr();let r=[],n=[];Object.entries(t).forEach(d=>{let T=d[0],v=d[1],w=this.inputNames.indexOf(T);if(w===-1)throw new Error(`invalid input '${T}'`);r.push(v),n.push(w)});let s=[],i=[];Object.entries(o).forEach(d=>{let T=d[0],v=d[1],w=this.outputNames.indexOf(T);if(w===-1)throw new Error(`invalid output '${T}'`);s.push(v),i.push(w)});let u=r.map((d,T)=>dd(d,()=>`input \"${this.inputNames[n[T]]}\"`)),l=s.map((d,T)=>d?dd(d,()=>`output \"${this.outputNames[i[T]]}\"`):null),f=await cd(this.sessionId,n,u,i,l,e),p={};for(let d=0;d<f.length;d++)p[this.outputNames[i[d]]]=s[d]??vg(f[d]);return ur(),p}startProfiling(){}endProfiling(){pd(this.sessionId)}}});var _g,ko,md=E(()=>{\"use strict\";Tt();ma();hd();_g=()=>{if((typeof Z.wasm.initTimeout!=\"number\"||Z.wasm.initTimeout<0)&&(Z.wasm.initTimeout=0),typeof Z.wasm.simd!=\"boolean\"&&(Z.wasm.simd=!0),typeof Z.wasm.proxy!=\"boolean\"&&(Z.wasm.proxy=!1),typeof Z.wasm.trace!=\"boolean\"&&(Z.wasm.trace=!1),typeof Z.wasm.numThreads!=\"number\"||!Number.isInteger(Z.wasm.numThreads)||Z.wasm.numThreads<=0){(typeof self<\"u\"&&!self.crossOriginIsolated||typeof process<\"u\"&&process.versions&&process.versions.node)&&(Z.wasm.numThreads=1);let a=typeof navigator>\"u\"?(void 0)().length:navigator.hardwareConcurrency;Z.wasm.numThreads=Math.min(4,Math.ceil((a||1)/2))}},ko=class{async init(t){_g(),await ad(),await sd(t)}async createInferenceSessionHandler(t,o){let e=new $o;return await e.loadModel(t,o),Promise.resolve(e)}}});var bd={};Pr(bd,{wasmBackend:()=>Og});var Og,gd=E(()=>{\"use strict\";md();Og=new ko});Tt();Tt();Tt();var ws=\"1.17.3\";var XO=Yo;{let a=(Sp(),or(Ip)).onnxjsBackend;Dr(\"webgl\",a,-10)}{let a=(gd(),or(bd)).wasmBackend;Dr(\"cpu\",a,10),Dr(\"wasm\",a,10)}Object.defineProperty(Z.versions,\"web\",{value:ws,enumerable:!0});\n/*! Bundled license information:\n\nlong/index.js:\n  (**\n   * @license\n   * Copyright 2009 The Closure Library Authors\n   * Copyright 2020 Daniel Wirtz / The long.js Authors.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n*/\n//# sourceMappingURL=ort.min.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9lc20vb3J0Lm1pbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkJBQTZCLHVDQUF1QyxrQ0FBa0MsZ0VBQWdFLG1DQUFtQyw0QkFBNEIsV0FBVyxtQ0FBbUMsdUJBQXVCLHVCQUF1QixFQUFFLGdCQUFnQixnR0FBZ0csbURBQW1ELEVBQUUsVUFBVSx1Q0FBdUMseUNBQXlDLHNCQUFzQixzQkFBc0IsZUFBZSxTQUFTLEtBQUssNkJBQTZCLGFBQWEsOEJBQThCLHFGQUFxRixnQkFBZ0Isd0JBQXdCLHFCQUFxQixFQUFFLEtBQUssdUJBQXVCLDZFQUE2RSxFQUFFLG1CQUFtQixFQUFFLEdBQUcsU0FBUyxvQkFBb0IsdUJBQXVCLFlBQVksWUFBWSxrQ0FBa0MsaUJBQWlCLE9BQU8sV0FBVyxPQUFPLDJDQUEyQyxjQUFjLGdCQUFnQixpQ0FBaUMsa0NBQWtDLDZCQUE2QixzQkFBc0IsSUFBSSwyRkFBMkYsU0FBUyxzQkFBc0IsRUFBRSx3QkFBd0IsUUFBUSx1QkFBdUIsY0FBYyw0R0FBNEcsZ0JBQWdCLGtCQUFrQiwyQkFBMkIsYUFBYSw2QkFBNkIsMERBQTBELGFBQWEsT0FBTyxJQUFJLE1BQU0sY0FBYyxHQUFHLFFBQVEsYUFBYSwyRUFBMkUsRUFBRSxzREFBc0QsRUFBRSxHQUFHLHNEQUFzRCxzQkFBc0IsdURBQXVELElBQUksRUFBRSxjQUFjLGFBQWEsS0FBSyxFQUFFLGlCQUFpQixhQUFhLFlBQVksRUFBRSxvQkFBb0IsYUFBYSxLQUFLLGlCQUFpQixPQUFPLFNBQVMsVUFBVSxXQUFXLFVBQVUsaUJBQWlCLGVBQWUsa0lBQWtJLEVBQUUsR0FBRyxNQUFNLGdCQUFnQixZQUFZLHFDQUFxQyxjQUFjLEVBQUUsRUFBRSxnQkFBZ0IsYUFBYSxLQUFLLEtBQUssRUFBRSxvQkFBb0IsYUFBYSxX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YUFBYSxtREFBbUQsRUFBRSxVQUFVLE9BQU8sbUJBQW1CLEVBQUUsaUJBQWlCLGFBQWEsS0FBSyxVQUFVLEVBQUUsS0FBSyxLQUFLLEtBQUssZ0JBQWdCLFdBQVcsa0NBQWtDLG1CQUFtQixnQ0FBZ0MsK0JBQStCLHdDQUF3Qyx1QkFBdUIsRUFBeUs7QUFDNzJ6Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3QvZXNtL29ydC5taW4uanM/OWIzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE9OTlggUnVudGltZSBXZWIgdjEuMTcuM1xuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbnZhciBPZD1PYmplY3QuY3JlYXRlO3ZhciBEbj1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIElkPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7dmFyIFNkPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO3ZhciBBZD1PYmplY3QuZ2V0UHJvdG90eXBlT2YsUGQ9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTt2YXIgRT0oYSx0KT0+KCk9PihhJiYodD1hKGE9MCkpLHQpO3ZhciBtZT0oYSx0KT0+KCk9Pih0fHxhKCh0PXtleHBvcnRzOnt9fSkuZXhwb3J0cyx0KSx0LmV4cG9ydHMpLFByPShhLHQpPT57Zm9yKHZhciBvIGluIHQpRG4oYSxvLHtnZXQ6dFtvXSxlbnVtZXJhYmxlOiEwfSl9LEhhPShhLHQsbyxlKT0+e2lmKHQmJnR5cGVvZiB0PT1cIm9iamVjdFwifHx0eXBlb2YgdD09XCJmdW5jdGlvblwiKWZvcihsZXQgciBvZiBTZCh0KSkhUGQuY2FsbChhLHIpJiZyIT09byYmRG4oYSxyLHtnZXQ6KCk9PnRbcl0sZW51bWVyYWJsZTohKGU9SWQodCxyKSl8fGUuZW51bWVyYWJsZX0pO3JldHVybiBhfTt2YXIgRXI9KGEsdCxvKT0+KG89YSE9bnVsbD9PZChBZChhKSk6e30sSGEodHx8IWF8fCFhLl9fZXNNb2R1bGU/RG4obyxcImRlZmF1bHRcIix7dmFsdWU6YSxlbnVtZXJhYmxlOiEwfSk6byxhKSksb3I9YT0+SGEoRG4oe30sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksYSk7dmFyIExuLGlyLERyLEVkLEZuLENuPUUoKCk9PntcInVzZSBzdHJpY3RcIjtMbj1uZXcgTWFwLGlyPVtdLERyPShhLHQsbyk9PntpZih0JiZ0eXBlb2YgdC5pbml0PT1cImZ1bmN0aW9uXCImJnR5cGVvZiB0LmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyPT1cImZ1bmN0aW9uXCIpe2xldCBlPUxuLmdldChhKTtpZihlPT09dm9pZCAwKUxuLnNldChhLHtiYWNrZW5kOnQscHJpb3JpdHk6b30pO2Vsc2V7aWYoZS5wcmlvcml0eT5vKXJldHVybjtpZihlLnByaW9yaXR5PT09byYmZS5iYWNrZW5kIT09dCl0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWdpc3RlciBiYWNrZW5kIFwiJHthfVwiIHVzaW5nIHByaW9yaXR5ICR7b31gKX1pZihvPj0wKXtsZXQgcj1pci5pbmRleE9mKGEpO3IhPT0tMSYmaXIuc3BsaWNlKHIsMSk7Zm9yKGxldCBuPTA7bjxpci5sZW5ndGg7bisrKWlmKExuLmdldChpcltuXSkucHJpb3JpdHk8PW8pe2lyLnNwbGljZShuLDAsYSk7cmV0dXJufWlyLnB1c2goYSl9cmV0dXJufXRocm93IG5ldyBUeXBlRXJyb3IoXCJub3QgYSB2YWxpZCBiYWNrZW5kXCIpfSxFZD1hc3luYyBhPT57bGV0IHQ9TG4uZ2V0KGEpO2lmKCF0KXJldHVyblwiYmFja2VuZCBub3QgZm91bmQuXCI7aWYodC5pbml0aWFsaXplZClyZXR1cm4gdC5iYWNrZW5kO2lmKHQuYWJvcnRlZClyZXR1cm4gdC5lcnJvcjt7bGV0IG89ISF0LmluaXRQcm9taXNlO3RyeXtyZXR1cm4gb3x8KHQuaW5pdFByb21pc2U9dC5iYWNrZW5kLmluaXQoYSkpLGF3YWl0IHQuaW5pdFByb21pc2UsdC5pbml0aWFsaXplZD0hMCx0LmJhY2tlbmR9Y2F0Y2goZSl7cmV0dXJuIG98fCh0LmVycm9yPWAke2V9YCx0LmFib3J0ZWQ9ITApLHQuZXJyb3J9ZmluYWxseXtkZWxldGUgdC5pbml0UHJvbWlzZX19fSxGbj1hc3luYyBhPT57bGV0IHQ9YS5leGVjdXRpb25Qcm92aWRlcnN8fFtdLG89dC5tYXAodT0+dHlwZW9mIHU9PVwic3RyaW5nXCI/dTp1Lm5hbWUpLGU9by5sZW5ndGg9PT0wP2lyOm8scixuPVtdLHM9bmV3IFNldDtmb3IobGV0IHUgb2YgZSl7bGV0IGw9YXdhaXQgRWQodSk7dHlwZW9mIGw9PVwic3RyaW5nXCI/bi5wdXNoKHtuYW1lOnUsZXJyOmx9KToocnx8KHI9bCkscj09PWwmJnMuYWRkKHUpKX1pZighcil0aHJvdyBuZXcgRXJyb3IoYG5vIGF2YWlsYWJsZSBiYWNrZW5kIGZvdW5kLiBFUlI6ICR7bi5tYXAodT0+YFske3UubmFtZX1dICR7dS5lcnJ9YCkuam9pbihcIiwgXCIpfWApO2ZvcihsZXR7bmFtZTp1LGVycjpsfW9mIG4pby5pbmNsdWRlcyh1KSYmY29uc29sZS53YXJuKGByZW1vdmluZyByZXF1ZXN0ZWQgZXhlY3V0aW9uIHByb3ZpZGVyIFwiJHt1fVwiIGZyb20gc2Vzc2lvbiBvcHRpb25zIGJlY2F1c2UgaXQgaXMgbm90IGF2YWlsYWJsZTogJHtsfWApO2xldCBpPXQuZmlsdGVyKHU9PnMuaGFzKHR5cGVvZiB1PT1cInN0cmluZ1wiP3U6dS5uYW1lKSk7cmV0dXJuW3IsbmV3IFByb3h5KGEse2dldDoodSxsKT0+bD09PVwiZXhlY3V0aW9uUHJvdmlkZXJzXCI/aTpSZWZsZWN0LmdldCh1LGwpfSldfX0pO3ZhciBxYT1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Q24oKX0pO3ZhciBqYSxZYT1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7amE9XCIxLjE3LjNcIn0pO3ZhciBYYSxpdCxIbz1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7WWEoKTtYYT1cIndhcm5pbmdcIixpdD17d2FzbTp7fSx3ZWJnbDp7fSx3ZWJncHU6e30sdmVyc2lvbnM6e2NvbW1vbjpqYX0sc2V0IGxvZ0xldmVsKGEpe2lmKGEhPT12b2lkIDApe2lmKHR5cGVvZiBhIT1cInN0cmluZ1wifHxbXCJ2ZXJib3NlXCIsXCJpbmZvXCIsXCJ3YXJuaW5nXCIsXCJlcnJvclwiLFwiZmF0YWxcIl0uaW5kZXhPZihhKT09PS0xKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHthfWApO1hhPWF9fSxnZXQgbG9nTGV2ZWwoKXtyZXR1cm4gWGF9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoaXQsXCJsb2dMZXZlbFwiLHtlbnVtZXJhYmxlOiEwfSl9KTt2YXIgWixLYT1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SG8oKTtaPWl0fSk7dmFyIEphLFphLFFhPUUoKCk9PntcInVzZSBzdHJpY3RcIjtKYT0oYSx0KT0+e2xldCBvPXR5cGVvZiBkb2N1bWVudDxcInVcIj9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpOm5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKTtvLndpZHRoPWEuZGltc1szXSxvLmhlaWdodD1hLmRpbXNbMl07bGV0IGU9by5nZXRDb250ZXh0KFwiMmRcIik7aWYoZSE9bnVsbCl7bGV0IHIsbjt0Py50ZW5zb3JMYXlvdXQhPT12b2lkIDAmJnQudGVuc29yTGF5b3V0PT09XCJOSFdDXCI/KHI9YS5kaW1zWzJdLG49YS5kaW1zWzNdKToocj1hLmRpbXNbM10sbj1hLmRpbXNbMl0pO2xldCBzPXQ/LmZvcm1hdCE9PXZvaWQgMD90LmZvcm1hdDpcIlJHQlwiLGk9dD8ubm9ybSx1LGw7aT09PXZvaWQgMHx8aS5tZWFuPT09dm9pZCAwP3U9WzI1NSwyNTUsMjU1LDI1NV06dHlwZW9mIGkubWVhbj09XCJudW1iZXJcIj91PVtpLm1lYW4saS5tZWFuLGkubWVhbixpLm1lYW5dOih1PVtpLm1lYW5bMF0saS5tZWFuWzFdLGkubWVhblsyXSwwXSxpLm1lYW5bM10hPT12b2lkIDAmJih1WzNdPWkubWVhblszXSkpLGk9PT12b2lkIDB8fGkuYmlhcz09PXZvaWQgMD9sPVswLDAsMCwwXTp0eXBlb2YgaS5iaWFzPT1cIm51bWJlclwiP2w9W2kuYmlhcyxpLmJpYXMsaS5iaWFzLGkuYmlhc106KGw9W2kuYmlhc1swXSxpLmJpYXNbMV0saS5iaWFzWzJdLDBdLGkuYmlhc1szXSE9PXZvaWQgMCYmKGxbM109aS5iaWFzWzNdKSk7bGV0IGY9bipyLHA9MCxkPWYsVD1mKjIsdj0tMTtzPT09XCJSR0JBXCI/KHA9MCxkPWYsVD1mKjIsdj1mKjMpOnM9PT1cIlJHQlwiPyhwPTAsZD1mLFQ9ZioyKTpzPT09XCJSQkdcIiYmKHA9MCxUPWYsZD1mKjIpO2ZvcihsZXQgdz0wO3c8bjt3KyspZm9yKGxldCBJPTA7STxyO0krKyl7bGV0IEw9KGEuZGF0YVtwKytdLWxbMF0pKnVbMF0sRj0oYS5kYXRhW2QrK10tbFsxXSkqdVsxXSxDPShhLmRhdGFbVCsrXS1sWzJdKSp1WzJdLFk9dj09PS0xPzI1NTooYS5kYXRhW3YrK10tbFszXSkqdVszXTtlLmZpbGxTdHlsZT1cInJnYmEoXCIrTCtcIixcIitGK1wiLFwiK0MrXCIsXCIrWStcIilcIixlLmZpbGxSZWN0KEksdywxLDEpfWlmKFwidG9EYXRhVVJMXCJpbiBvKXJldHVybiBvLnRvRGF0YVVSTCgpO3Rocm93IG5ldyBFcnJvcihcInRvRGF0YVVSTCBpcyBub3Qgc3VwcG9ydGVkXCIpfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX0sWmE9KGEsdCk9PntsZXQgbz10eXBlb2YgZG9jdW1lbnQ8XCJ1XCI/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIik6bmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpLmdldENvbnRleHQoXCIyZFwiKSxlO2lmKG8hPW51bGwpe2xldCByLG4sczt0Py50ZW5zb3JMYXlvdXQhPT12b2lkIDAmJnQudGVuc29yTGF5b3V0PT09XCJOSFdDXCI/KHI9YS5kaW1zWzJdLG49YS5kaW1zWzFdLHM9YS5kaW1zWzNdKToocj1hLmRpbXNbM10sbj1hLmRpbXNbMl0scz1hLmRpbXNbMV0pO2xldCBpPXQhPT12b2lkIDAmJnQuZm9ybWF0IT09dm9pZCAwP3QuZm9ybWF0OlwiUkdCXCIsdT10Py5ub3JtLGwsZjt1PT09dm9pZCAwfHx1Lm1lYW49PT12b2lkIDA/bD1bMjU1LDI1NSwyNTUsMjU1XTp0eXBlb2YgdS5tZWFuPT1cIm51bWJlclwiP2w9W3UubWVhbix1Lm1lYW4sdS5tZWFuLHUubWVhbl06KGw9W3UubWVhblswXSx1Lm1lYW5bMV0sdS5tZWFuWzJdLDI1NV0sdS5tZWFuWzNdIT09dm9pZCAwJiYobFszXT11Lm1lYW5bM10pKSx1PT09dm9pZCAwfHx1LmJpYXM9PT12b2lkIDA/Zj1bMCwwLDAsMF06dHlwZW9mIHUuYmlhcz09XCJudW1iZXJcIj9mPVt1LmJpYXMsdS5iaWFzLHUuYmlhcyx1LmJpYXNdOihmPVt1LmJpYXNbMF0sdS5iaWFzWzFdLHUuYmlhc1syXSwwXSx1LmJpYXNbM10hPT12b2lkIDAmJihmWzNdPXUuYmlhc1szXSkpO2xldCBwPW4qcjtpZih0IT09dm9pZCAwJiYodC5mb3JtYXQhPT12b2lkIDAmJnM9PT00JiZ0LmZvcm1hdCE9PVwiUkdCQVwifHxzPT09MyYmdC5mb3JtYXQhPT1cIlJHQlwiJiZ0LmZvcm1hdCE9PVwiQkdSXCIpKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBmb3JtYXQgZG9lc24ndCBtYXRjaCBpbnB1dCB0ZW5zb3IgZGltc1wiKTtsZXQgZD00LFQ9MCx2PTEsdz0yLEk9MyxMPTAsRj1wLEM9cCoyLFk9LTE7aT09PVwiUkdCQVwiPyhMPTAsRj1wLEM9cCoyLFk9cCozKTppPT09XCJSR0JcIj8oTD0wLEY9cCxDPXAqMik6aT09PVwiUkJHXCImJihMPTAsQz1wLEY9cCoyKSxlPW8uY3JlYXRlSW1hZ2VEYXRhKHIsbik7Zm9yKGxldCBqPTA7ajxuKnI7VCs9ZCx2Kz1kLHcrPWQsSSs9ZCxqKyspZS5kYXRhW1RdPShhLmRhdGFbTCsrXS1mWzBdKSpsWzBdLGUuZGF0YVt2XT0oYS5kYXRhW0YrK10tZlsxXSkqbFsxXSxlLmRhdGFbd109KGEuZGF0YVtDKytdLWZbMl0pKmxbMl0sZS5kYXRhW0ldPVk9PT0tMT8yNTU6KGEuZGF0YVtZKytdLWZbM10pKmxbM119ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpO3JldHVybiBlfX0pO3ZhciBxbyxlcyx0cyxycyxucyxvcz1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7JG4oKTtxbz0oYSx0KT0+e2lmKGE9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgYnVmZmVyIG11c3QgYmUgZGVmaW5lZFwiKTtpZih0LmhlaWdodD09PXZvaWQgMHx8dC53aWR0aD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBoZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgZGVmaW5lZFwiKTtpZih0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihcIk5IV0MgVGVuc29yIGxheW91dCBpcyBub3Qgc3VwcG9ydGVkIHlldFwiKTtsZXR7aGVpZ2h0Om8sd2lkdGg6ZX09dCxyPXQubm9ybT8/e21lYW46MjU1LGJpYXM6MH0sbixzO3R5cGVvZiByLm1lYW49PVwibnVtYmVyXCI/bj1bci5tZWFuLHIubWVhbixyLm1lYW4sci5tZWFuXTpuPVtyLm1lYW5bMF0sci5tZWFuWzFdLHIubWVhblsyXSxyLm1lYW5bM10/PzI1NV0sdHlwZW9mIHIuYmlhcz09XCJudW1iZXJcIj9zPVtyLmJpYXMsci5iaWFzLHIuYmlhcyxyLmJpYXNdOnM9W3IuYmlhc1swXSxyLmJpYXNbMV0sci5iaWFzWzJdLHIuYmlhc1szXT8/MF07bGV0IGk9dC5mb3JtYXQhPT12b2lkIDA/dC5mb3JtYXQ6XCJSR0JBXCIsdT10LnRlbnNvckZvcm1hdCE9PXZvaWQgMCYmdC50ZW5zb3JGb3JtYXQhPT12b2lkIDA/dC50ZW5zb3JGb3JtYXQ6XCJSR0JcIixsPW8qZSxmPXU9PT1cIlJHQkFcIj9uZXcgRmxvYXQzMkFycmF5KGwqNCk6bmV3IEZsb2F0MzJBcnJheShsKjMpLHA9NCxkPTAsVD0xLHY9Mix3PTMsST0wLEw9bCxGPWwqMixDPS0xO2k9PT1cIlJHQlwiJiYocD0zLGQ9MCxUPTEsdj0yLHc9LTEpLHU9PT1cIlJHQkFcIj9DPWwqMzp1PT09XCJSQkdcIj8oST0wLEY9bCxMPWwqMik6dT09PVwiQkdSXCImJihGPTAsTD1sLEk9bCoyKTtmb3IobGV0IGo9MDtqPGw7aisrLGQrPXAsdis9cCxUKz1wLHcrPXApZltJKytdPShhW2RdK3NbMF0pL25bMF0sZltMKytdPShhW1RdK3NbMV0pL25bMV0sZltGKytdPShhW3ZdK3NbMl0pL25bMl0sQyE9PS0xJiZ3IT09LTEmJihmW0MrK109KGFbd10rc1szXSkvblszXSk7cmV0dXJuIHU9PT1cIlJHQkFcIj9uZXcgWGUoXCJmbG9hdDMyXCIsZixbMSw0LG8sZV0pOm5ldyBYZShcImZsb2F0MzJcIixmLFsxLDMsbyxlXSl9LGVzPWFzeW5jKGEsdCk9PntsZXQgbz10eXBlb2YgSFRNTEltYWdlRWxlbWVudDxcInVcIiYmYSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQsZT10eXBlb2YgSW1hZ2VEYXRhPFwidVwiJiZhIGluc3RhbmNlb2YgSW1hZ2VEYXRhLHI9dHlwZW9mIEltYWdlQml0bWFwPFwidVwiJiZhIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAsbj10eXBlb2YgYT09XCJzdHJpbmdcIixzLGk9dD8/e30sdT0oKT0+e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIilyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtpZih0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzPFwidVwiKXJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsMSk7dGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzdXBwb3J0ZWRcIil9LGw9Zj0+ZiBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50fHxmIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzP2YuZ2V0Q29udGV4dChcIjJkXCIpOm51bGw7aWYobyl7bGV0IGY9dSgpO2Yud2lkdGg9YS53aWR0aCxmLmhlaWdodD1hLmhlaWdodDtsZXQgcD1sKGYpO2lmKHAhPW51bGwpe2xldCBkPWEuaGVpZ2h0LFQ9YS53aWR0aDtpZih0IT09dm9pZCAwJiZ0LnJlc2l6ZWRIZWlnaHQhPT12b2lkIDAmJnQucmVzaXplZFdpZHRoIT09dm9pZCAwJiYoZD10LnJlc2l6ZWRIZWlnaHQsVD10LnJlc2l6ZWRXaWR0aCksdCE9PXZvaWQgMCl7aWYoaT10LHQudGVuc29yRm9ybWF0IT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBSR0JBIGZvciBIVE1MSW1hZ2VFbGVtZW50XCIpO2kudGVuc29yRm9ybWF0PVwiUkdCQVwiLGkuaGVpZ2h0PWQsaS53aWR0aD1UfWVsc2UgaS50ZW5zb3JGb3JtYXQ9XCJSR0JBXCIsaS5oZWlnaHQ9ZCxpLndpZHRoPVQ7cC5kcmF3SW1hZ2UoYSwwLDApLHM9cC5nZXRJbWFnZURhdGEoMCwwLFQsZCkuZGF0YX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9ZWxzZSBpZihlKXtsZXQgZixwO2lmKHQhPT12b2lkIDAmJnQucmVzaXplZFdpZHRoIT09dm9pZCAwJiZ0LnJlc2l6ZWRIZWlnaHQhPT12b2lkIDA/KGY9dC5yZXNpemVkSGVpZ2h0LHA9dC5yZXNpemVkV2lkdGgpOihmPWEuaGVpZ2h0LHA9YS53aWR0aCksdCE9PXZvaWQgMCYmKGk9dCksaS5mb3JtYXQ9XCJSR0JBXCIsaS5oZWlnaHQ9ZixpLndpZHRoPXAsdCE9PXZvaWQgMCl7bGV0IGQ9dSgpO2Qud2lkdGg9cCxkLmhlaWdodD1mO2xldCBUPWwoZCk7aWYoVCE9bnVsbClULnB1dEltYWdlRGF0YShhLDAsMCkscz1ULmdldEltYWdlRGF0YSgwLDAscCxmKS5kYXRhO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1lbHNlIHM9YS5kYXRhfWVsc2UgaWYocil7aWYodD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBpbWFnZSBjb25maWcgd2l0aCBmb3JtYXQgZm9yIEltYWdlYml0bWFwXCIpO2xldCBmPXUoKTtmLndpZHRoPWEud2lkdGgsZi5oZWlnaHQ9YS5oZWlnaHQ7bGV0IHA9bChmKTtpZihwIT1udWxsKXtsZXQgZD1hLmhlaWdodCxUPWEud2lkdGg7cmV0dXJuIHAuZHJhd0ltYWdlKGEsMCwwLFQsZCkscz1wLmdldEltYWdlRGF0YSgwLDAsVCxkKS5kYXRhLGkuaGVpZ2h0PWQsaS53aWR0aD1ULHFvKHMsaSl9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfWVsc2V7aWYobilyZXR1cm4gbmV3IFByb21pc2UoKGYscCk9PntsZXQgZD11KCksVD1sKGQpO2lmKCFhfHwhVClyZXR1cm4gcCgpO2xldCB2PW5ldyBJbWFnZTt2LmNyb3NzT3JpZ2luPVwiQW5vbnltb3VzXCIsdi5zcmM9YSx2Lm9ubG9hZD0oKT0+e2Qud2lkdGg9di53aWR0aCxkLmhlaWdodD12LmhlaWdodCxULmRyYXdJbWFnZSh2LDAsMCxkLndpZHRoLGQuaGVpZ2h0KTtsZXQgdz1ULmdldEltYWdlRGF0YSgwLDAsZC53aWR0aCxkLmhlaWdodCk7aS5oZWlnaHQ9ZC5oZWlnaHQsaS53aWR0aD1kLndpZHRoLGYocW8ody5kYXRhLGkpKX19KTt0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvblwiKX1pZihzIT09dm9pZCAwKXJldHVybiBxbyhzLGkpO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfSx0cz0oYSx0KT0+e2xldHt3aWR0aDpvLGhlaWdodDplLGRvd25sb2FkOnIsZGlzcG9zZTpufT10LHM9WzEsZSxvLDRdO3JldHVybiBuZXcgWGUoe2xvY2F0aW9uOlwidGV4dHVyZVwiLHR5cGU6XCJmbG9hdDMyXCIsdGV4dHVyZTphLGRpbXM6cyxkb3dubG9hZDpyLGRpc3Bvc2U6bn0pfSxycz0oYSx0KT0+e2xldHtkYXRhVHlwZTpvLGRpbXM6ZSxkb3dubG9hZDpyLGRpc3Bvc2U6bn09dDtyZXR1cm4gbmV3IFhlKHtsb2NhdGlvbjpcImdwdS1idWZmZXJcIix0eXBlOm8/P1wiZmxvYXQzMlwiLGdwdUJ1ZmZlcjphLGRpbXM6ZSxkb3dubG9hZDpyLGRpc3Bvc2U6bn0pfSxucz0oYSx0LG8pPT5uZXcgWGUoe2xvY2F0aW9uOlwiY3B1LXBpbm5lZFwiLHR5cGU6YSxkYXRhOnQsZGltczpvPz9bdC5sZW5ndGhdfSl9KTt2YXIgYXIsdG4saXMsYXMsc3M9RSgoKT0+e1widXNlIHN0cmljdFwiO2FyPW5ldyBNYXAoW1tcImZsb2F0MzJcIixGbG9hdDMyQXJyYXldLFtcInVpbnQ4XCIsVWludDhBcnJheV0sW1wiaW50OFwiLEludDhBcnJheV0sW1widWludDE2XCIsVWludDE2QXJyYXldLFtcImludDE2XCIsSW50MTZBcnJheV0sW1wiaW50MzJcIixJbnQzMkFycmF5XSxbXCJib29sXCIsVWludDhBcnJheV0sW1wiZmxvYXQ2NFwiLEZsb2F0NjRBcnJheV0sW1widWludDMyXCIsVWludDMyQXJyYXldXSksdG49bmV3IE1hcChbW0Zsb2F0MzJBcnJheSxcImZsb2F0MzJcIl0sW1VpbnQ4QXJyYXksXCJ1aW50OFwiXSxbSW50OEFycmF5LFwiaW50OFwiXSxbVWludDE2QXJyYXksXCJ1aW50MTZcIl0sW0ludDE2QXJyYXksXCJpbnQxNlwiXSxbSW50MzJBcnJheSxcImludDMyXCJdLFtGbG9hdDY0QXJyYXksXCJmbG9hdDY0XCJdLFtVaW50MzJBcnJheSxcInVpbnQzMlwiXV0pLGlzPSExLGFzPSgpPT57aWYoIWlzKXtpcz0hMDtsZXQgYT10eXBlb2YgQmlnSW50NjRBcnJheTxcInVcIiYmQmlnSW50NjRBcnJheS5mcm9tLHQ9dHlwZW9mIEJpZ1VpbnQ2NEFycmF5PFwidVwiJiZCaWdVaW50NjRBcnJheS5mcm9tLG89dHlwZW9mIEZsb2F0MTZBcnJheTxcInVcIiYmRmxvYXQxNkFycmF5LmZyb207YSYmKGFyLnNldChcImludDY0XCIsQmlnSW50NjRBcnJheSksdG4uc2V0KEJpZ0ludDY0QXJyYXksXCJpbnQ2NFwiKSksdCYmKGFyLnNldChcInVpbnQ2NFwiLEJpZ1VpbnQ2NEFycmF5KSx0bi5zZXQoQmlnVWludDY0QXJyYXksXCJ1aW50NjRcIikpLG8/KGFyLnNldChcImZsb2F0MTZcIixGbG9hdDE2QXJyYXkpLHRuLnNldChGbG9hdDE2QXJyYXksXCJmbG9hdDE2XCIpKTphci5zZXQoXCJmbG9hdDE2XCIsVWludDE2QXJyYXkpfX19KTt2YXIgdXMsbHMsZnM9RSgoKT0+e1widXNlIHN0cmljdFwiOyRuKCk7dXM9YT0+e2xldCB0PTE7Zm9yKGxldCBvPTA7bzxhLmxlbmd0aDtvKyspe2xldCBlPWFbb107aWYodHlwZW9mIGUhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNTYWZlSW50ZWdlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBkaW1zWyR7b31dIG11c3QgYmUgYW4gaW50ZWdlciwgZ290OiAke2V9YCk7aWYoZTwwKXRocm93IG5ldyBSYW5nZUVycm9yKGBkaW1zWyR7b31dIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290OiAke2V9YCk7dCo9ZX1yZXR1cm4gdH0sbHM9KGEsdCk9Pntzd2l0Y2goYS5sb2NhdGlvbil7Y2FzZVwiY3B1XCI6cmV0dXJuIG5ldyBYZShhLnR5cGUsYS5kYXRhLHQpO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gbmV3IFhlKHtsb2NhdGlvbjpcImNwdS1waW5uZWRcIixkYXRhOmEuZGF0YSx0eXBlOmEudHlwZSxkaW1zOnR9KTtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIG5ldyBYZSh7bG9jYXRpb246XCJ0ZXh0dXJlXCIsdGV4dHVyZTphLnRleHR1cmUsdHlwZTphLnR5cGUsZGltczp0fSk7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiBuZXcgWGUoe2xvY2F0aW9uOlwiZ3B1LWJ1ZmZlclwiLGdwdUJ1ZmZlcjphLmdwdUJ1ZmZlcix0eXBlOmEudHlwZSxkaW1zOnR9KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdGVuc29yUmVzaGFwZTogdGVuc29yIGxvY2F0aW9uICR7YS5sb2NhdGlvbn0gaXMgbm90IHN1cHBvcnRlZGApfX19KTt2YXIgWGUsJG49RSgoKT0+e1widXNlIHN0cmljdFwiO1FhKCk7b3MoKTtzcygpO2ZzKCk7WGU9Y2xhc3N7Y29uc3RydWN0b3IodCxvLGUpe2FzKCk7bGV0IHIsbjtpZih0eXBlb2YgdD09XCJvYmplY3RcIiYmXCJsb2NhdGlvblwiaW4gdClzd2l0Y2godGhpcy5kYXRhTG9jYXRpb249dC5sb2NhdGlvbixyPXQudHlwZSxuPXQuZGltcyx0LmxvY2F0aW9uKXtjYXNlXCJjcHUtcGlubmVkXCI6e2xldCBpPWFyLmdldChyKTtpZighaSl0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtyfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBwaW5uZWQgYnVmZmVyYCk7aWYoISh0LmRhdGEgaW5zdGFuY2VvZiBpKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBidWZmZXIgc2hvdWxkIGJlIG9mIHR5cGUgJHtpLm5hbWV9YCk7dGhpcy5jcHVEYXRhPXQuZGF0YTticmVha31jYXNlXCJ0ZXh0dXJlXCI6e2lmKHIhPT1cImZsb2F0MzJcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtyfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSB0ZXh0dXJlYCk7dGhpcy5ncHVUZXh0dXJlRGF0YT10LnRleHR1cmUsdGhpcy5kb3dubG9hZGVyPXQuZG93bmxvYWQsdGhpcy5kaXNwb3Nlcj10LmRpc3Bvc2U7YnJlYWt9Y2FzZVwiZ3B1LWJ1ZmZlclwiOntpZihyIT09XCJmbG9hdDMyXCImJnIhPT1cImZsb2F0MTZcIiYmciE9PVwiaW50MzJcIiYmciE9PVwiaW50NjRcIiYmciE9PVwidWludDMyXCImJnIhPT1cInVpbnQ4XCImJnIhPT1cImJvb2xcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtyfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBncHUgYnVmZmVyYCk7dGhpcy5ncHVCdWZmZXJEYXRhPXQuZ3B1QnVmZmVyLHRoaXMuZG93bmxvYWRlcj10LmRvd25sb2FkLHRoaXMuZGlzcG9zZXI9dC5kaXNwb3NlO2JyZWFrfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBUZW5zb3IgY29uc3RydWN0b3I6IHVuc3VwcG9ydGVkIGxvY2F0aW9uICcke3RoaXMuZGF0YUxvY2F0aW9ufSdgKX1lbHNle2xldCBpLHU7aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpaWYocj10LHU9ZSx0PT09XCJzdHJpbmdcIil7aWYoIUFycmF5LmlzQXJyYXkobykpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgc3RyaW5nIHRlbnNvcidzIGRhdGEgbXVzdCBiZSBhIHN0cmluZyBhcnJheS5cIik7aT1vfWVsc2V7bGV0IGw9YXIuZ2V0KHQpO2lmKGw9PT12b2lkIDApdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdGVuc29yIHR5cGU6ICR7dH0uYCk7aWYoQXJyYXkuaXNBcnJheShvKSl7aWYodD09PVwiZmxvYXQxNlwiJiZsPT09VWludDE2QXJyYXkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNyZWF0aW5nIGEgZmxvYXQxNiB0ZW5zb3IgZnJvbSBudW1iZXIgYXJyYXkgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVzZSBVaW50MTZBcnJheSBhcyBkYXRhLlwiKTt0PT09XCJ1aW50NjRcInx8dD09PVwiaW50NjRcIj9pPWwuZnJvbShvLEJpZ0ludCk6aT1sLmZyb20obyl9ZWxzZSBpZihvIGluc3RhbmNlb2YgbClpPW87ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBBICR7cn0gdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgJHtsfWApfWVsc2UgaWYodT1vLEFycmF5LmlzQXJyYXkodCkpe2lmKHQubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGVuc29yIHR5cGUgY2Fubm90IGJlIGluZmVycmVkIGZyb20gYW4gZW1wdHkgYXJyYXkuXCIpO2xldCBsPXR5cGVvZiB0WzBdO2lmKGw9PT1cInN0cmluZ1wiKXI9XCJzdHJpbmdcIixpPXQ7ZWxzZSBpZihsPT09XCJib29sZWFuXCIpcj1cImJvb2xcIixpPVVpbnQ4QXJyYXkuZnJvbSh0KTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZWxlbWVudCB0eXBlIG9mIGRhdGEgYXJyYXk6ICR7bH0uYCl9ZWxzZXtsZXQgbD10bi5nZXQodC5jb25zdHJ1Y3Rvcik7aWYobD09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIGZvciB0ZW5zb3IgZGF0YTogJHt0LmNvbnN0cnVjdG9yfS5gKTtyPWwsaT10fWlmKHU9PT12b2lkIDApdT1baS5sZW5ndGhdO2Vsc2UgaWYoIUFycmF5LmlzQXJyYXkodSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgdGVuc29yJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5XCIpO249dSx0aGlzLmNwdURhdGE9aSx0aGlzLmRhdGFMb2NhdGlvbj1cImNwdVwifWxldCBzPXVzKG4pO2lmKHRoaXMuY3B1RGF0YSYmcyE9PXRoaXMuY3B1RGF0YS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IncyBzaXplKCR7c30pIGRvZXMgbm90IG1hdGNoIGRhdGEgbGVuZ3RoKCR7dGhpcy5jcHVEYXRhLmxlbmd0aH0pLmApO3RoaXMudHlwZT1yLHRoaXMuZGltcz1uLHRoaXMuc2l6ZT1zfXN0YXRpYyBhc3luYyBmcm9tSW1hZ2UodCxvKXtyZXR1cm4gZXModCxvKX1zdGF0aWMgZnJvbVRleHR1cmUodCxvKXtyZXR1cm4gdHModCxvKX1zdGF0aWMgZnJvbUdwdUJ1ZmZlcih0LG8pe3JldHVybiBycyh0LG8pfXN0YXRpYyBmcm9tUGlubmVkQnVmZmVyKHQsbyxlKXtyZXR1cm4gbnModCxvLGUpfXRvRGF0YVVSTCh0KXtyZXR1cm4gSmEodGhpcyx0KX10b0ltYWdlRGF0YSh0KXtyZXR1cm4gWmEodGhpcyx0KX1nZXQgZGF0YSgpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5jcHVEYXRhKXRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIGlzIG5vdCBvbiBDUFUuIFVzZSBgZ2V0RGF0YSgpYCB0byBkb3dubG9hZCBHUFUgZGF0YSB0byBDUFUsIG9yIHVzZSBgdGV4dHVyZWAgb3IgYGdwdUJ1ZmZlcmAgcHJvcGVydHkgdG8gYWNjZXNzIHRoZSBHUFUgZGF0YSBkaXJlY3RseS5cIik7cmV0dXJuIHRoaXMuY3B1RGF0YX1nZXQgbG9jYXRpb24oKXtyZXR1cm4gdGhpcy5kYXRhTG9jYXRpb259Z2V0IHRleHR1cmUoKXtpZih0aGlzLmVuc3VyZVZhbGlkKCksIXRoaXMuZ3B1VGV4dHVyZURhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdMIHRleHR1cmUuXCIpO3JldHVybiB0aGlzLmdwdVRleHR1cmVEYXRhfWdldCBncHVCdWZmZXIoKXtpZih0aGlzLmVuc3VyZVZhbGlkKCksIXRoaXMuZ3B1QnVmZmVyRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViR1BVIGJ1ZmZlci5cIik7cmV0dXJuIHRoaXMuZ3B1QnVmZmVyRGF0YX1hc3luYyBnZXREYXRhKHQpe3N3aXRjaCh0aGlzLmVuc3VyZVZhbGlkKCksdGhpcy5kYXRhTG9jYXRpb24pe2Nhc2VcImNwdVwiOmNhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gdGhpcy5kYXRhO2Nhc2VcInRleHR1cmVcIjpjYXNlXCJncHUtYnVmZmVyXCI6e2lmKCF0aGlzLmRvd25sb2FkZXIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIG5vdCBjcmVhdGVkIHdpdGggYSBzcGVjaWZpZWQgZGF0YSBkb3dubG9hZGVyLlwiKTtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RyeXt0aGlzLmlzRG93bmxvYWRpbmc9ITA7bGV0IG89YXdhaXQgdGhpcy5kb3dubG9hZGVyKCk7cmV0dXJuIHRoaXMuZG93bmxvYWRlcj12b2lkIDAsdGhpcy5kYXRhTG9jYXRpb249XCJjcHVcIix0aGlzLmNwdURhdGE9byx0JiZ0aGlzLmRpc3Bvc2VyJiYodGhpcy5kaXNwb3NlcigpLHRoaXMuZGlzcG9zZXI9dm9pZCAwKSxvfWZpbmFsbHl7dGhpcy5pc0Rvd25sb2FkaW5nPSExfX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGdldCBkYXRhIGZyb20gbG9jYXRpb246ICR7dGhpcy5kYXRhTG9jYXRpb259YCl9fWRpc3Bvc2UoKXtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RoaXMuZGlzcG9zZXImJih0aGlzLmRpc3Bvc2VyKCksdGhpcy5kaXNwb3Nlcj12b2lkIDApLHRoaXMuY3B1RGF0YT12b2lkIDAsdGhpcy5ncHVUZXh0dXJlRGF0YT12b2lkIDAsdGhpcy5ncHVCdWZmZXJEYXRhPXZvaWQgMCx0aGlzLmRvd25sb2FkZXI9dm9pZCAwLHRoaXMuaXNEb3dubG9hZGluZz12b2lkIDAsdGhpcy5kYXRhTG9jYXRpb249XCJub25lXCJ9ZW5zdXJlVmFsaWQoKXtpZih0aGlzLmRhdGFMb2NhdGlvbj09PVwibm9uZVwiKXRocm93IG5ldyBFcnJvcihcIlRoZSB0ZW5zb3IgaXMgZGlzcG9zZWQuXCIpfXJlc2hhcGUodCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLHRoaXMuZG93bmxvYWRlcnx8dGhpcy5kaXNwb3Nlcil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzaGFwZSBhIHRlbnNvciB0aGF0IG93bnMgR1BVIHJlc291cmNlLlwiKTtyZXR1cm4gbHModGhpcyx0KX19fSk7dmFyIFJlLGtuPUUoKCk9PntcInVzZSBzdHJpY3RcIjskbigpO1JlPVhlfSk7dmFyIGNzLHBzLHNyLHVyLGpvPUUoKCk9PntcInVzZSBzdHJpY3RcIjtIbygpO2NzPShhLHQpPT57KHR5cGVvZiBpdC50cmFjZT5cInVcIj8haXQud2FzbS50cmFjZTohaXQudHJhY2UpfHxjb25zb2xlLnRpbWVTdGFtcChgJHthfTo6T1JUOjoke3R9YCl9LHBzPShhLHQpPT57bGV0IG89bmV3IEVycm9yKCkuc3RhY2s/LnNwbGl0KC9cXHJcXG58XFxyfFxcbi9nKXx8W10sZT0hMTtmb3IobGV0IHI9MDtyPG8ubGVuZ3RoO3IrKyl7aWYoZSYmIW9bcl0uaW5jbHVkZXMoXCJUUkFDRV9GVU5DXCIpKXtsZXQgbj1gRlVOQ18ke2F9Ojoke29bcl0udHJpbSgpLnNwbGl0KFwiIFwiKVsxXX1gO3QmJihuKz1gOjoke3R9YCksY3MoXCJDUFVcIixuKTtyZXR1cm59b1tyXS5pbmNsdWRlcyhcIlRSQUNFX0ZVTkNcIikmJihlPSEwKX19LHNyPWE9PnsodHlwZW9mIGl0LnRyYWNlPlwidVwiPyFpdC53YXNtLnRyYWNlOiFpdC50cmFjZSl8fHBzKFwiQkVHSU5cIixhKX0sdXI9YT0+eyh0eXBlb2YgaXQudHJhY2U+XCJ1XCI/IWl0Lndhc20udHJhY2U6IWl0LnRyYWNlKXx8cHMoXCJFTkRcIixhKX19KTt2YXIgQm4sZHM9RSgoKT0+e1widXNlIHN0cmljdFwiO0NuKCk7a24oKTtqbygpO0JuPWNsYXNzIGF7Y29uc3RydWN0b3IodCl7dGhpcy5oYW5kbGVyPXR9YXN5bmMgcnVuKHQsbyxlKXtzcigpO2xldCByPXt9LG49e307aWYodHlwZW9mIHQhPVwib2JqZWN0XCJ8fHQ9PT1udWxsfHx0IGluc3RhbmNlb2YgUmV8fEFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZWVkcycgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlwiKTtsZXQgcz0hMDtpZih0eXBlb2Ygbz09XCJvYmplY3RcIil7aWYobz09PW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMV06IGNhbm5vdCBiZSBudWxsLlwiKTtpZihvIGluc3RhbmNlb2YgUmUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYSBUZW5zb3JcIik7aWYoQXJyYXkuaXNBcnJheShvKSl7aWYoby5sZW5ndGg9PT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGFuIGVtcHR5IGFycmF5LlwiKTtzPSExO2ZvcihsZXQgbCBvZiBvKXtpZih0eXBlb2YgbCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkgb3IgYW4gb2JqZWN0LlwiKTtpZih0aGlzLm91dHB1dE5hbWVzLmluZGV4T2YobCk9PT0tMSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2ZldGNoZXMnIGNvbnRhaW5zIGludmFsaWQgb3V0cHV0IG5hbWU6ICR7bH0uYCk7cltsXT1udWxsfWlmKHR5cGVvZiBlPT1cIm9iamVjdFwiJiZlIT09bnVsbCluPWU7ZWxzZSBpZih0eXBlb2YgZTxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNle2xldCBsPSExLGY9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobyk7Zm9yKGxldCBwIG9mIHRoaXMub3V0cHV0TmFtZXMpaWYoZi5pbmRleE9mKHApIT09LTEpe2xldCBkPW9bcF07KGQ9PT1udWxsfHxkIGluc3RhbmNlb2YgUmUpJiYobD0hMCxzPSExLHJbcF09ZCl9aWYobCl7aWYodHlwZW9mIGU9PVwib2JqZWN0XCImJmUhPT1udWxsKW49ZTtlbHNlIGlmKHR5cGVvZiBlPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2Ugbj1vfX1lbHNlIGlmKHR5cGVvZiBvPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBtdXN0IGJlICdmZXRjaGVzJyBvciAnb3B0aW9ucycuXCIpO2ZvcihsZXQgbCBvZiB0aGlzLmlucHV0TmFtZXMpaWYodHlwZW9mIHRbbF0+XCJ1XCIpdGhyb3cgbmV3IEVycm9yKGBpbnB1dCAnJHtsfScgaXMgbWlzc2luZyBpbiAnZmVlZHMnLmApO2lmKHMpZm9yKGxldCBsIG9mIHRoaXMub3V0cHV0TmFtZXMpcltsXT1udWxsO2xldCBpPWF3YWl0IHRoaXMuaGFuZGxlci5ydW4odCxyLG4pLHU9e307Zm9yKGxldCBsIGluIGkpaWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoaSxsKSl7bGV0IGY9aVtsXTtmIGluc3RhbmNlb2YgUmU/dVtsXT1mOnVbbF09bmV3IFJlKGYudHlwZSxmLmRhdGEsZi5kaW1zKX1yZXR1cm4gdXIoKSx1fWFzeW5jIHJlbGVhc2UoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKX1zdGF0aWMgYXN5bmMgY3JlYXRlKHQsbyxlLHIpe3NyKCk7bGV0IG4scz17fTtpZih0eXBlb2YgdD09XCJzdHJpbmdcIil7aWYobj10LHR5cGVvZiBvPT1cIm9iamVjdFwiJiZvIT09bnVsbClzPW87ZWxzZSBpZih0eXBlb2YgbzxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KXtpZihuPXQsdHlwZW9mIG89PVwib2JqZWN0XCImJm8hPT1udWxsKXM9bztlbHNlIGlmKHR5cGVvZiBvPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYodCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHx0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI8XCJ1XCImJnQgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcil7bGV0IGY9dCxwPTAsZD10LmJ5dGVMZW5ndGg7aWYodHlwZW9mIG89PVwib2JqZWN0XCImJm8hPT1udWxsKXM9bztlbHNlIGlmKHR5cGVvZiBvPT1cIm51bWJlclwiKXtpZihwPW8sIU51bWJlci5pc1NhZmVJbnRlZ2VyKHApKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2J5dGVPZmZzZXQnIG11c3QgYmUgYW4gaW50ZWdlci5cIik7aWYocDwwfHxwPj1mLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlT2Zmc2V0JyBpcyBvdXQgb2YgcmFuZ2UgWzAsICR7Zi5ieXRlTGVuZ3RofSkuYCk7aWYoZD10LmJ5dGVMZW5ndGgtcCx0eXBlb2YgZT09XCJudW1iZXJcIil7aWYoZD1lLCFOdW1iZXIuaXNTYWZlSW50ZWdlcihkKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO2lmKGQ8PTB8fHArZD5mLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlTGVuZ3RoJyBpcyBvdXQgb2YgcmFuZ2UgKDAsICR7Zi5ieXRlTGVuZ3RoLXB9XS5gKTtpZih0eXBlb2Ygcj09XCJvYmplY3RcIiYmciE9PW51bGwpcz1yO2Vsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZih0eXBlb2YgZTxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2J5dGVMZW5ndGgnIG11c3QgYmUgYSBudW1iZXIuXCIpfWVsc2UgaWYodHlwZW9mIG88XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7bj1uZXcgVWludDhBcnJheShmLHAsZCl9ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFswXTogbXVzdCBiZSAncGF0aCcgb3IgJ2J1ZmZlcicuXCIpO2xldFtpLHVdPWF3YWl0IEZuKHMpLGw9YXdhaXQgaS5jcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcihuLHUpO3JldHVybiB1cigpLG5ldyBhKGwpfXN0YXJ0UHJvZmlsaW5nKCl7dGhpcy5oYW5kbGVyLnN0YXJ0UHJvZmlsaW5nKCl9ZW5kUHJvZmlsaW5nKCl7dGhpcy5oYW5kbGVyLmVuZFByb2ZpbGluZygpfWdldCBpbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5pbnB1dE5hbWVzfWdldCBvdXRwdXROYW1lcygpe3JldHVybiB0aGlzLmhhbmRsZXIub3V0cHV0TmFtZXN9fX0pO3ZhciBEZCxocz1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZHMoKTtEZD1Cbn0pO3ZhciBtcz1FKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgYnM9RSgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIGdzPUUoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciB5cz1FKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgTGQsTm4sVHM9RSgoKT0+e1widXNlIHN0cmljdFwiO0NuKCk7a24oKTtMZD1cIlRyYWluaW5nIGJhY2tlbmQgY291bGQgbm90IGJlIHJlc29sdmVkLiBNYWtlIHN1cmUgeW91J3JlIHVzaW5nIHRoZSBjb3JyZWN0IGNvbmZpZ3VyYXRpb24gJiBXZWJBc3NlbWJseSBmaWxlcy5cIixObj1jbGFzcyBhe2NvbnN0cnVjdG9yKHQsbyxlKXt0aGlzLmhhbmRsZXI9dCx0aGlzLmhhc09wdGltaXplck1vZGVsPW8sdGhpcy5oYXNFdmFsTW9kZWw9ZX1nZXQgdHJhaW5pbmdJbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5pbnB1dE5hbWVzfWdldCB0cmFpbmluZ091dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lc31nZXQgZXZhbElucHV0TmFtZXMoKXtpZih0aGlzLmhhc0V2YWxNb2RlbClyZXR1cm4gdGhpcy5oYW5kbGVyLmV2YWxJbnB1dE5hbWVzO3Rocm93IG5ldyBFcnJvcihcIlRoaXMgdHJhaW5pbmcgc2Vzc2lvbiBoYXMgbm8gZXZhbE1vZGVsIGxvYWRlZC5cIil9Z2V0IGV2YWxPdXRwdXROYW1lcygpe2lmKHRoaXMuaGFzRXZhbE1vZGVsKXJldHVybiB0aGlzLmhhbmRsZXIuZXZhbE91dHB1dE5hbWVzO3Rocm93IG5ldyBFcnJvcihcIlRoaXMgdHJhaW5pbmcgc2Vzc2lvbiBoYXMgbm8gZXZhbE1vZGVsIGxvYWRlZC5cIil9c3RhdGljIGFzeW5jIGNyZWF0ZSh0LG8pe2xldCBlPXQuZXZhbE1vZGVsfHxcIlwiLHI9dC5vcHRpbWl6ZXJNb2RlbHx8XCJcIixuPW98fHt9LFtzLGldPWF3YWl0IEZuKG4pO2lmKHMuY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlcil7bGV0IHU9YXdhaXQgcy5jcmVhdGVUcmFpbmluZ1Nlc3Npb25IYW5kbGVyKHQuY2hlY2twb2ludFN0YXRlLHQudHJhaW5Nb2RlbCxlLHIsaSk7cmV0dXJuIG5ldyBhKHUsISF0Lm9wdGltaXplck1vZGVsLCEhdC5ldmFsTW9kZWwpfWVsc2UgdGhyb3cgbmV3IEVycm9yKExkKX10eXBlTmFycm93aW5nRm9yUnVuU3RlcCh0LG8sZSxyLG4pe2xldCBzPXt9LGk9e307aWYodHlwZW9mIGUhPVwib2JqZWN0XCJ8fGU9PT1udWxsfHxlIGluc3RhbmNlb2YgUmV8fEFycmF5LmlzQXJyYXkoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZWVkcycgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlwiKTtsZXQgdT0hMDtpZih0eXBlb2Ygcj09XCJvYmplY3RcIil7aWYocj09PW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMV06IGNhbm5vdCBiZSBudWxsLlwiKTtpZihyIGluc3RhbmNlb2YgUmUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYSBUZW5zb3JcIik7aWYoQXJyYXkuaXNBcnJheShyKSl7aWYoci5sZW5ndGg9PT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGFuIGVtcHR5IGFycmF5LlwiKTt1PSExO2ZvcihsZXQgbCBvZiByKXtpZih0eXBlb2YgbCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkgb3IgYW4gb2JqZWN0LlwiKTtpZihvLmluZGV4T2YobCk9PT0tMSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2ZldGNoZXMnIGNvbnRhaW5zIGludmFsaWQgb3V0cHV0IG5hbWU6ICR7bH0uYCk7c1tsXT1udWxsfWlmKHR5cGVvZiBuPT1cIm9iamVjdFwiJiZuIT09bnVsbClpPW47ZWxzZSBpZih0eXBlb2YgbjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNle2xldCBsPSExLGY9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocik7Zm9yKGxldCBwIG9mIG8paWYoZi5pbmRleE9mKHApIT09LTEpe2xldCBkPXJbcF07KGQ9PT1udWxsfHxkIGluc3RhbmNlb2YgUmUpJiYobD0hMCx1PSExLHNbcF09ZCl9aWYobCl7aWYodHlwZW9mIG49PVwib2JqZWN0XCImJm4hPT1udWxsKWk9bjtlbHNlIGlmKHR5cGVvZiBuPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaT1yfX1lbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBtdXN0IGJlICdmZXRjaGVzJyBvciAnb3B0aW9ucycuXCIpO2ZvcihsZXQgbCBvZiB0KWlmKHR5cGVvZiBlW2xdPlwidVwiKXRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7bH0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtpZih1KWZvcihsZXQgbCBvZiBvKXNbbF09bnVsbDtyZXR1cm5bcyxpXX1jb252ZXJ0SGFuZGxlclJldHVyblR5cGVUb01hcE9mVGVuc29ycyh0KXtsZXQgbz17fTtmb3IobGV0IGUgaW4gdClpZihPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpKXtsZXQgcj10W2VdO3IgaW5zdGFuY2VvZiBSZT9vW2VdPXI6b1tlXT1uZXcgUmUoci50eXBlLHIuZGF0YSxyLmRpbXMpfXJldHVybiBvfWFzeW5jIGxhenlSZXNldEdyYWQoKXthd2FpdCB0aGlzLmhhbmRsZXIubGF6eVJlc2V0R3JhZCgpfWFzeW5jIHJ1blRyYWluU3RlcCh0LG8sZSl7bGV0W3Isbl09dGhpcy50eXBlTmFycm93aW5nRm9yUnVuU3RlcCh0aGlzLnRyYWluaW5nSW5wdXROYW1lcyx0aGlzLnRyYWluaW5nT3V0cHV0TmFtZXMsdCxvLGUpLHM9YXdhaXQgdGhpcy5oYW5kbGVyLnJ1blRyYWluU3RlcCh0LHIsbik7cmV0dXJuIHRoaXMuY29udmVydEhhbmRsZXJSZXR1cm5UeXBlVG9NYXBPZlRlbnNvcnMocyl9YXN5bmMgcnVuT3B0aW1pemVyU3RlcCh0KXtpZih0aGlzLmhhc09wdGltaXplck1vZGVsKWF3YWl0IHRoaXMuaGFuZGxlci5ydW5PcHRpbWl6ZXJTdGVwKHR8fHt9KTtlbHNlIHRocm93IG5ldyBFcnJvcihcIlRoaXMgVHJhaW5pbmdTZXNzaW9uIGhhcyBubyBPcHRpbWl6ZXJNb2RlbCBsb2FkZWQuXCIpfWFzeW5jIHJ1bkV2YWxTdGVwKHQsbyxlKXtpZih0aGlzLmhhc0V2YWxNb2RlbCl7bGV0W3Isbl09dGhpcy50eXBlTmFycm93aW5nRm9yUnVuU3RlcCh0aGlzLmV2YWxJbnB1dE5hbWVzLHRoaXMuZXZhbE91dHB1dE5hbWVzLHQsbyxlKSxzPWF3YWl0IHRoaXMuaGFuZGxlci5ydW5FdmFsU3RlcCh0LHIsbik7cmV0dXJuIHRoaXMuY29udmVydEhhbmRsZXJSZXR1cm5UeXBlVG9NYXBPZlRlbnNvcnMocyl9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIFRyYWluaW5nU2Vzc2lvbiBoYXMgbm8gRXZhbE1vZGVsIGxvYWRlZC5cIil9YXN5bmMgZ2V0UGFyYW1ldGVyc1NpemUodD0hMCl7cmV0dXJuIHRoaXMuaGFuZGxlci5nZXRQYXJhbWV0ZXJzU2l6ZSh0KX1hc3luYyBsb2FkUGFyYW1ldGVyc0J1ZmZlcih0LG89ITApe2xldCBlPWF3YWl0IHRoaXMuZ2V0UGFyYW1ldGVyc1NpemUobyk7aWYodC5sZW5ndGghPT00KmUpdGhyb3cgbmV3IEVycm9yKFwiU2l6ZSBvZiB0aGUgYnVmZmVyIHBhc3NlZCBpbnRvIGxvYWRQYXJhbWV0ZXJzQnVmZmVyIG11c3QgbWF0Y2ggdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzIGluIHRoZSBtb2RlbC4gUGxlYXNlIHVzZSBnZXRQYXJhbWV0ZXJzU2l6ZSBtZXRob2QgdG8gY2hlY2suXCIpO3JldHVybiB0aGlzLmhhbmRsZXIubG9hZFBhcmFtZXRlcnNCdWZmZXIodCxvKX1hc3luYyBnZXRDb250aWd1b3VzUGFyYW1ldGVycyh0PSEwKXtyZXR1cm4gdGhpcy5oYW5kbGVyLmdldENvbnRpZ3VvdXNQYXJhbWV0ZXJzKHQpfWFzeW5jIHJlbGVhc2UoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKX19fSk7dmFyIEZkLHhzPUUoKCk9PntcInVzZSBzdHJpY3RcIjtUcygpO0ZkPU5ufSk7dmFyIFlvPXt9O1ByKFlvLHtJbmZlcmVuY2VTZXNzaW9uOigpPT5EZCxUUkFDRTooKT0+Y3MsVFJBQ0VfRlVOQ19CRUdJTjooKT0+c3IsVFJBQ0VfRlVOQ19FTkQ6KCk9PnVyLFRlbnNvcjooKT0+UmUsVHJhaW5pbmdTZXNzaW9uOigpPT5GZCxlbnY6KCk9PloscmVnaXN0ZXJCYWNrZW5kOigpPT5Ecn0pO3ZhciBUdD1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7cWEoKTtLYSgpO2hzKCk7a24oKTttcygpO2JzKCk7am8oKTtncygpO3lzKCk7eHMoKX0pO2Z1bmN0aW9uIGp0KGEsdCxvLGUpe2lmKHQ9PT12b2lkIDApcmV0dXJuICRkKGEpO2lmKG89PT12b2lkIDApUm4oYSx0LDEpO2Vsc2UgaWYodHlwZW9mIG89PVwibnVtYmVyXCImJmU9PT12b2lkIDApUm4oYSx0LG8pO2Vsc2UgaWYodHlwZW9mIG89PVwic3RyaW5nXCImJmU9PT12b2lkIDApUm4oYSxvLDEsdCk7ZWxzZSBpZih0eXBlb2Ygbz09XCJzdHJpbmdcIiYmdHlwZW9mIGU9PVwibnVtYmVyXCIpUm4oYSxvLGUsdCk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW5wdXQgaXMgdmFsaWRcIil9ZnVuY3Rpb24gJGQoYSl7cmV0dXJue3ZlcmJvc2U6anQudmVyYm9zZS5iaW5kKG51bGwsYSksaW5mbzpqdC5pbmZvLmJpbmQobnVsbCxhKSx3YXJuaW5nOmp0Lndhcm5pbmcuYmluZChudWxsLGEpLGVycm9yOmp0LmVycm9yLmJpbmQobnVsbCxhKSxmYXRhbDpqdC5mYXRhbC5iaW5kKG51bGwsYSl9fWZ1bmN0aW9uIFJuKGEsdCxvLGUpe2xldCByPXJuW2V8fFwiXCJdfHxybltcIlwiXTt2c1thXTx2c1tyLm1pbmltYWxTZXZlcml0eV18fChyLmxvZ0RhdGVUaW1lJiYodD1gJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9fCR7dH1gKSxyLmxvZ1NvdXJjZUxvY2F0aW9uLENkW3IucHJvdmlkZXJdLmxvZyhhLHQsZSkpfXZhciBYbyxLbyx2cyxDZCxfcyxybixjZSxHbixVbix6bixNbixhdD1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7WG89Y2xhc3N7bG9nKHQsbyxlKXt9fSxLbz1jbGFzc3tsb2codCxvLGUpe2NvbnNvbGUubG9nKGAke3RoaXMuY29sb3IodCl9ICR7ZT9cIlxceDFCWzM1bVwiK2UrXCJcXHgxQlswbSBcIjpcIlwifSR7b31gKX1jb2xvcih0KXtzd2l0Y2godCl7Y2FzZVwidmVyYm9zZVwiOnJldHVyblwiXFx4MUJbMzQ7NDBtdlxceDFCWzBtXCI7Y2FzZVwiaW5mb1wiOnJldHVyblwiXFx4MUJbMzJtaVxceDFCWzBtXCI7Y2FzZVwid2FybmluZ1wiOnJldHVyblwiXFx4MUJbMzA7NDNtd1xceDFCWzBtXCI7Y2FzZVwiZXJyb3JcIjpyZXR1cm5cIlxceDFCWzMxOzQwbWVcXHgxQlswbVwiO2Nhc2VcImZhdGFsXCI6cmV0dXJuXCJcXHgxQlsxMDFtZlxceDFCWzBtXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHNldmVyaXR5OiAke3R9YCl9fX0sdnM9e3ZlcmJvc2U6MWUzLGluZm86MmUzLHdhcm5pbmc6NGUzLGVycm9yOjVlMyxmYXRhbDo2ZTN9LENkPXtub25lOm5ldyBYbyxjb25zb2xlOm5ldyBLb30sX3M9e3Byb3ZpZGVyOlwiY29uc29sZVwiLG1pbmltYWxTZXZlcml0eTpcIndhcm5pbmdcIixsb2dEYXRlVGltZTohMCxsb2dTb3VyY2VMb2NhdGlvbjohMX0scm49e1wiXCI6X3N9Oyh1PT57ZnVuY3Rpb24gYShsLGYpe3UoXCJ2ZXJib3NlXCIsbCxmKX11LnZlcmJvc2U9YTtmdW5jdGlvbiB0KGwsZil7dShcImluZm9cIixsLGYpfXUuaW5mbz10O2Z1bmN0aW9uIG8obCxmKXt1KFwid2FybmluZ1wiLGwsZil9dS53YXJuaW5nPW87ZnVuY3Rpb24gZShsLGYpe3UoXCJlcnJvclwiLGwsZil9dS5lcnJvcj1lO2Z1bmN0aW9uIHIobCxmKXt1KFwiZmF0YWxcIixsLGYpfXUuZmF0YWw9cjtmdW5jdGlvbiBuKGwpe3JuPXt9LHMoXCJcIixsfHx7fSl9dS5yZXNldD1uO2Z1bmN0aW9uIHMobCxmKXtpZihsPT09XCIqXCIpbihmKTtlbHNle2xldCBwPXJuW2xdfHxfcztybltsXT17cHJvdmlkZXI6Zi5wcm92aWRlcnx8cC5wcm92aWRlcixtaW5pbWFsU2V2ZXJpdHk6Zi5taW5pbWFsU2V2ZXJpdHl8fHAubWluaW1hbFNldmVyaXR5LGxvZ0RhdGVUaW1lOmYubG9nRGF0ZVRpbWU9PT12b2lkIDA/cC5sb2dEYXRlVGltZTpmLmxvZ0RhdGVUaW1lLGxvZ1NvdXJjZUxvY2F0aW9uOmYubG9nU291cmNlTG9jYXRpb249PT12b2lkIDA/cC5sb2dTb3VyY2VMb2NhdGlvbjpmLmxvZ1NvdXJjZUxvY2F0aW9ufX19dS5zZXQ9cztmdW5jdGlvbiBpKGwpe2xldCBmPXt9O2wubG9nTGV2ZWwmJihmLm1pbmltYWxTZXZlcml0eT1sLmxvZ0xldmVsKSxzKFwiXCIsZil9dS5zZXRXaXRoRW52PWl9KShqdHx8PXt9KTtjZT1qdCxHbj1jbGFzc3tjb25zdHJ1Y3Rvcih0LG8sZSxyLG4scyl7dGhpcy5jYXRlZ29yeT10O3RoaXMubmFtZT1vO3RoaXMuc3RhcnRUaW1lPWU7dGhpcy5lbmRDYWxsYmFjaz1yO3RoaXMudGltZXI9bjt0aGlzLmN0eD1zfWFzeW5jIGVuZCgpe3JldHVybiB0aGlzLmVuZENhbGxiYWNrKHRoaXMpfWFzeW5jIGNoZWNrVGltZXIoKXtpZih0aGlzLmN0eD09PXZvaWQgMHx8dGhpcy50aW1lcj09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJObyB3ZWJnbCB0aW1lciBmb3VuZFwiKTtyZXR1cm4gdGhpcy5jdHguZW5kVGltZXIoKSx0aGlzLmN0eC53YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKHRoaXMudGltZXIpfX0sVW49Y2xhc3N7Y29uc3RydWN0b3IodCxvLGUscil7dGhpcy5jYXRlZ29yeT10O3RoaXMubmFtZT1vO3RoaXMuc3RhcnRUaW1lPWU7dGhpcy5lbmRUaW1lPXJ9fSx6bj1jbGFzc3tjb25zdHJ1Y3Rvcih0LG8sZSl7dGhpcy5fc3RhcnRlZD0hMTt0aGlzLl9mbHVzaFBvaW50ZXI9MDt0aGlzLl9zdGFydGVkPSExLHRoaXMuX21heE51bWJlckV2ZW50cz10PT09dm9pZCAwPzFlNDp0LHRoaXMuX2ZsdXNoQmF0Y2hTaXplPW89PT12b2lkIDA/MTA6byx0aGlzLl9mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHM9ZT09PXZvaWQgMD81ZTM6ZX1zdGF0aWMgY3JlYXRlKHQpe3JldHVybiB0PT09dm9pZCAwP25ldyB0aGlzOm5ldyB0aGlzKHQubWF4TnVtYmVyRXZlbnRzLHQuZmx1c2hCYXRjaFNpemUsdC5mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHMpfXN0YXJ0KCl7dGhpcy5fc3RhcnRlZD0hMCx0aGlzLl90aW1pbmdFdmVudHM9W10sdGhpcy5fZmx1c2hUaW1lPU1uKCksdGhpcy5fZmx1c2hQb2ludGVyPTB9c3RvcCgpe2Zvcih0aGlzLl9zdGFydGVkPSExO3RoaXMuX2ZsdXNoUG9pbnRlcjx0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoO3RoaXMuX2ZsdXNoUG9pbnRlcisrKXRoaXMubG9nT25lRXZlbnQodGhpcy5fdGltaW5nRXZlbnRzW3RoaXMuX2ZsdXNoUG9pbnRlcl0pfWV2ZW50KHQsbyxlLHIpe2xldCBuPXRoaXMuX3N0YXJ0ZWQ/dGhpcy5iZWdpbih0LG8scik6dm9pZCAwLHM9ITEsaT1lKCk7aWYoaSYmdHlwZW9mIGkudGhlbj09XCJmdW5jdGlvblwiKXJldHVybiBzPSEwLG5ldyBQcm9taXNlKCh1LGwpPT57aS50aGVuKGFzeW5jIGY9PntuJiZhd2FpdCBuLmVuZCgpLHUoZil9LGFzeW5jIGY9PntuJiZhd2FpdCBuLmVuZCgpLGwoZil9KX0pO2lmKCFzJiZuKXtsZXQgdT1uLmVuZCgpO2lmKHUmJnR5cGVvZiB1LnRoZW49PVwiZnVuY3Rpb25cIilyZXR1cm4gbmV3IFByb21pc2UoKGwsZik9Pnt1LnRoZW4oKCk9PntsKGkpfSxwPT57ZihwKX0pfSl9cmV0dXJuIGl9YmVnaW4odCxvLGUpe2lmKCF0aGlzLl9zdGFydGVkKXRocm93IG5ldyBFcnJvcihcInByb2ZpbGVyIGlzIG5vdCBzdGFydGVkIHlldFwiKTtpZihlPT09dm9pZCAwKXtsZXQgcj1NbigpO3JldHVybiB0aGlzLmZsdXNoKHIpLG5ldyBHbih0LG8scixuPT50aGlzLmVuZFN5bmMobikpfWVsc2V7bGV0IHI9ZS5iZWdpblRpbWVyKCk7cmV0dXJuIG5ldyBHbih0LG8sMCxhc3luYyBuPT50aGlzLmVuZChuKSxyLGUpfX1hc3luYyBlbmQodCl7bGV0IG89YXdhaXQgdC5jaGVja1RpbWVyKCk7dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDx0aGlzLl9tYXhOdW1iZXJFdmVudHMmJih0aGlzLl90aW1pbmdFdmVudHMucHVzaChuZXcgVW4odC5jYXRlZ29yeSx0Lm5hbWUsdC5zdGFydFRpbWUsbykpLHRoaXMuZmx1c2gobykpfWVuZFN5bmModCl7bGV0IG89TW4oKTt0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoPHRoaXMuX21heE51bWJlckV2ZW50cyYmKHRoaXMuX3RpbWluZ0V2ZW50cy5wdXNoKG5ldyBVbih0LmNhdGVnb3J5LHQubmFtZSx0LnN0YXJ0VGltZSxvKSksdGhpcy5mbHVzaChvKSl9bG9nT25lRXZlbnQodCl7Y2UudmVyYm9zZShgUHJvZmlsZXIuJHt0LmNhdGVnb3J5fWAsYCR7KHQuZW5kVGltZS10LnN0YXJ0VGltZSkudG9GaXhlZCgyKX1tcyBvbiBldmVudCAnJHt0Lm5hbWV9JyBhdCAke3QuZW5kVGltZS50b0ZpeGVkKDIpfWApfWZsdXNoKHQpe2lmKHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGgtdGhpcy5fZmx1c2hQb2ludGVyPj10aGlzLl9mbHVzaEJhdGNoU2l6ZXx8dC10aGlzLl9mbHVzaFRpbWU+PXRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyl7Zm9yKGxldCBvPXRoaXMuX2ZsdXNoUG9pbnRlcjt0aGlzLl9mbHVzaFBvaW50ZXI8byt0aGlzLl9mbHVzaEJhdGNoU2l6ZSYmdGhpcy5fZmx1c2hQb2ludGVyPHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGg7dGhpcy5fZmx1c2hQb2ludGVyKyspdGhpcy5sb2dPbmVFdmVudCh0aGlzLl90aW1pbmdFdmVudHNbdGhpcy5fZmx1c2hQb2ludGVyXSk7dGhpcy5fZmx1c2hUaW1lPU1uKCl9fWdldCBzdGFydGVkKCl7cmV0dXJuIHRoaXMuX3N0YXJ0ZWR9fSxNbj10eXBlb2YgcGVyZm9ybWFuY2U8XCJ1XCImJnBlcmZvcm1hbmNlLm5vdz8oKT0+cGVyZm9ybWFuY2Uubm93KCk6RGF0ZS5ub3d9KTtmdW5jdGlvbiBPcyhhLHQsbyl7Zm9yKGxldCBlIG9mIG8pe2xldCByPWVbMF0sbj1lWzFdLHM9ZVsyXSxpPWVbM10sdT1lWzRdO2lmKGEub3BUeXBlPT09cil7Zm9yKGxldCBsIG9mIHQpaWYoKGwuZG9tYWluPT09bnx8bC5kb21haW49PT1cImFpLm9ubnhcIiYmbj09PVwiXCIpJiZrZChsLnZlcnNpb24scykpcmV0dXJue29wSW1wbDppLG9wSW5pdDp1fX19dGhyb3cgbmV3IFR5cGVFcnJvcihgY2Fubm90IHJlc29sdmUgb3BlcmF0b3IgJyR7YS5vcFR5cGV9JyB3aXRoIG9wc2V0czogJHt0Lm1hcChlPT5gJHtlLmRvbWFpbnx8XCJhaS5vbm54XCJ9IHYke2UudmVyc2lvbn1gKS5qb2luKFwiLCBcIil9YCl9ZnVuY3Rpb24ga2QoYSx0KXtpZih0LmVuZHNXaXRoKFwiK1wiKSl7bGV0IG89TnVtYmVyLnBhcnNlSW50KHQuc3Vic3RyaW5nKDAsdC5sZW5ndGgtMSksMTApO3JldHVybiFpc05hTihvKSYmbzw9YX1lbHNlIGlmKHQuc3BsaXQoXCItXCIpLmxlbmd0aD09PTIpe2xldCBvPXQuc3BsaXQoXCItXCIpLGU9TnVtYmVyLnBhcnNlSW50KG9bMF0sMTApLHI9TnVtYmVyLnBhcnNlSW50KG9bMV0sMTApO3JldHVybiFpc05hTihlKSYmIWlzTmFOKHIpJiZlPD1hJiZhPD1yfWVsc2UgcmV0dXJuIE51bWJlci5wYXJzZUludCh0LDEwKT09PWF9dmFyIElzPUUoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBTcz1tZShKbz0+e1widXNlIHN0cmljdFwiO0pvLl9fZXNNb2R1bGU9ITA7dmFyIEJkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSh0KXtpZighdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudDsgYHZhbHVlYCBoYXMgbm8gdmFsdWUuXCIpO3RoaXMudmFsdWU9YS5FTVBUWSx0JiZhLmlzR3VpZCh0KSYmKHRoaXMudmFsdWU9dCl9cmV0dXJuIGEuaXNHdWlkPWZ1bmN0aW9uKHQpe3ZhciBvPXQudG9TdHJpbmcoKTtyZXR1cm4gdCYmKHQgaW5zdGFuY2VvZiBhfHxhLnZhbGlkYXRvci50ZXN0KG8pKX0sYS5jcmVhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEoW2EuZ2VuKDIpLGEuZ2VuKDEpLGEuZ2VuKDEpLGEuZ2VuKDEpLGEuZ2VuKDMpXS5qb2luKFwiLVwiKSl9LGEuY3JlYXRlRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEoXCJlbXB0eWd1aWRcIil9LGEucGFyc2U9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBhKHQpfSxhLnJhdz1mdW5jdGlvbigpe3JldHVyblthLmdlbigyKSxhLmdlbigxKSxhLmdlbigxKSxhLmdlbigxKSxhLmdlbigzKV0uam9pbihcIi1cIil9LGEuZ2VuPWZ1bmN0aW9uKHQpe2Zvcih2YXIgbz1cIlwiLGU9MDtlPHQ7ZSsrKW8rPSgoMStNYXRoLnJhbmRvbSgpKSo2NTUzNnwwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO3JldHVybiBvfSxhLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24odCl7cmV0dXJuIGEuaXNHdWlkKHQpJiZ0aGlzLnZhbHVlPT09dC50b1N0cmluZygpfSxhLnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWU9PT1hLkVNUFRZfSxhLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlfSxhLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm57dmFsdWU6dGhpcy52YWx1ZX19LGEudmFsaWRhdG9yPW5ldyBSZWdFeHAoXCJeW2EtejAtOV17OH0tW2EtejAtOV17NH0tW2EtejAtOV17NH0tW2EtejAtOV17NH0tW2EtejAtOV17MTJ9JFwiLFwiaVwiKSxhLkVNUFRZPVwiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwXCIsYX0oKTtKby5HdWlkPUJkfSk7ZnVuY3Rpb24gYmUoYSx0LG8pe3RoaXMubG93PWF8MCx0aGlzLmhpZ2g9dHwwLHRoaXMudW5zaWduZWQ9ISFvfWZ1bmN0aW9uIGplKGEpe3JldHVybihhJiZhLl9faXNMb25nX18pPT09ITB9ZnVuY3Rpb24gQXMoYSl7dmFyIHQ9TWF0aC5jbHozMihhJi1hKTtyZXR1cm4gYT8zMS10OnR9ZnVuY3Rpb24gbHIoYSx0KXt2YXIgbyxlLHI7cmV0dXJuIHQ/KGE+Pj49MCwocj0wPD1hJiZhPDI1NikmJihlPUVzW2FdLGUpP2U6KG89bGUoYSwwLCEwKSxyJiYoRXNbYV09byksbykpOihhfD0wLChyPS0xMjg8PWEmJmE8MTI4KSYmKGU9UHNbYV0sZSk/ZToobz1sZShhLGE8MD8tMTowLCExKSxyJiYoUHNbYV09byksbykpfWZ1bmN0aW9uIHV0KGEsdCl7aWYoaXNOYU4oYSkpcmV0dXJuIHQ/VnQ6eHQ7aWYodCl7aWYoYTwwKXJldHVybiBWdDtpZihhPj1DcylyZXR1cm4gQnN9ZWxzZXtpZihhPD0tTHMpcmV0dXJuIHR0O2lmKGErMT49THMpcmV0dXJuIGtzfXJldHVybiBhPDA/dXQoLWEsdCkubmVnKCk6bGUoYSVGcnwwLGEvRnJ8MCx0KX1mdW5jdGlvbiBsZShhLHQsbyl7cmV0dXJuIG5ldyBiZShhLHQsbyl9ZnVuY3Rpb24gUW8oYSx0LG8pe2lmKGEubGVuZ3RoPT09MCl0aHJvdyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtpZih0eXBlb2YgdD09XCJudW1iZXJcIj8obz10LHQ9ITEpOnQ9ISF0LGE9PT1cIk5hTlwifHxhPT09XCJJbmZpbml0eVwifHxhPT09XCIrSW5maW5pdHlcInx8YT09PVwiLUluZmluaXR5XCIpcmV0dXJuIHQ/VnQ6eHQ7aWYobz1vfHwxMCxvPDJ8fDM2PG8pdGhyb3cgUmFuZ2VFcnJvcihcInJhZGl4XCIpO3ZhciBlO2lmKChlPWEuaW5kZXhPZihcIi1cIikpPjApdGhyb3cgRXJyb3IoXCJpbnRlcmlvciBoeXBoZW5cIik7aWYoZT09PTApcmV0dXJuIFFvKGEuc3Vic3RyaW5nKDEpLHQsbykubmVnKCk7Zm9yKHZhciByPXV0KFZuKG8sOCkpLG49eHQscz0wO3M8YS5sZW5ndGg7cys9OCl7dmFyIGk9TWF0aC5taW4oOCxhLmxlbmd0aC1zKSx1PXBhcnNlSW50KGEuc3Vic3RyaW5nKHMscytpKSxvKTtpZihpPDgpe3ZhciBsPXV0KFZuKG8saSkpO249bi5tdWwobCkuYWRkKHV0KHUpKX1lbHNlIG49bi5tdWwociksbj1uLmFkZCh1dCh1KSl9cmV0dXJuIG4udW5zaWduZWQ9dCxufWZ1bmN0aW9uIHd0KGEsdCl7cmV0dXJuIHR5cGVvZiBhPT1cIm51bWJlclwiP3V0KGEsdCk6dHlwZW9mIGE9PVwic3RyaW5nXCI/UW8oYSx0KTpsZShhLmxvdyxhLmhpZ2gsdHlwZW9mIHQ9PVwiYm9vbGVhblwiP3Q6YS51bnNpZ25lZCl9dmFyIHN0LFBzLEVzLFZuLERzLE5kLEZyLENzLExzLEZzLHh0LFZ0LExyLCRzLFpvLGtzLEJzLHR0LCQsV3QsZWk9RSgoKT0+e3N0PW51bGw7dHJ5e3N0PW5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDEzLDIsOTYsMCwxLDEyNyw5Niw0LDEyNywxMjcsMTI3LDEyNywxLDEyNywzLDcsNiwwLDEsMSwxLDEsMSw2LDYsMSwxMjcsMSw2NSwwLDExLDcsNTAsNiwzLDEwOSwxMTcsMTA4LDAsMSw1LDEwMCwxMDUsMTE4LDk1LDExNSwwLDIsNSwxMDAsMTA1LDExOCw5NSwxMTcsMCwzLDUsMTE0LDEwMSwxMDksOTUsMTE1LDAsNCw1LDExNCwxMDEsMTA5LDk1LDExNywwLDUsOCwxMDMsMTAxLDExNiw5NSwxMDQsMTA1LDEwMywxMDQsMCwwLDEwLDE5MSwxLDYsNCwwLDM1LDAsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTI2LDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEyNywzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMSwzNiwxLDEsMTI2LDMyLDAsMTczLDMyLDEsMTczLDY2LDMyLDEzNCwxMzIsMzIsMiwxNzMsMzIsMywxNzMsNjYsMzIsMTM0LDEzMiwxMjgsMzQsNCw2NiwzMiwxMzUsMTY3LDM2LDAsMzIsNCwxNjcsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTI5LDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEzMCwzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMV0pKSx7fSkuZXhwb3J0c31jYXRjaHt9YmUucHJvdG90eXBlLl9faXNMb25nX187T2JqZWN0LmRlZmluZVByb3BlcnR5KGJlLnByb3RvdHlwZSxcIl9faXNMb25nX19cIix7dmFsdWU6ITB9KTtiZS5pc0xvbmc9amU7UHM9e30sRXM9e307YmUuZnJvbUludD1scjtiZS5mcm9tTnVtYmVyPXV0O2JlLmZyb21CaXRzPWxlO1ZuPU1hdGgucG93O2JlLmZyb21TdHJpbmc9UW87YmUuZnJvbVZhbHVlPXd0O0RzPTY1NTM2LE5kPTE8PDI0LEZyPURzKkRzLENzPUZyKkZyLExzPUNzLzIsRnM9bHIoTmQpLHh0PWxyKDApO2JlLlpFUk89eHQ7VnQ9bHIoMCwhMCk7YmUuVVpFUk89VnQ7THI9bHIoMSk7YmUuT05FPUxyOyRzPWxyKDEsITApO2JlLlVPTkU9JHM7Wm89bHIoLTEpO2JlLk5FR19PTkU9Wm87a3M9bGUoLTEsMjE0NzQ4MzY0NywhMSk7YmUuTUFYX1ZBTFVFPWtzO0JzPWxlKC0xLC0xLCEwKTtiZS5NQVhfVU5TSUdORURfVkFMVUU9QnM7dHQ9bGUoMCwtMjE0NzQ4MzY0OCwhMSk7YmUuTUlOX1ZBTFVFPXR0OyQ9YmUucHJvdG90eXBlOyQudG9JbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD90aGlzLmxvdz4+PjA6dGhpcy5sb3d9OyQudG9OdW1iZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD8odGhpcy5oaWdoPj4+MCkqRnIrKHRoaXMubG93Pj4+MCk6dGhpcy5oaWdoKkZyKyh0aGlzLmxvdz4+PjApfTskLnRvU3RyaW5nPWZ1bmN0aW9uKHQpe2lmKHQ9dHx8MTAsdDwyfHwzNjx0KXRocm93IFJhbmdlRXJyb3IoXCJyYWRpeFwiKTtpZih0aGlzLmlzWmVybygpKXJldHVyblwiMFwiO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKWlmKHRoaXMuZXEodHQpKXt2YXIgbz11dCh0KSxlPXRoaXMuZGl2KG8pLHI9ZS5tdWwobykuc3ViKHRoaXMpO3JldHVybiBlLnRvU3RyaW5nKHQpK3IudG9JbnQoKS50b1N0cmluZyh0KX1lbHNlIHJldHVyblwiLVwiK3RoaXMubmVnKCkudG9TdHJpbmcodCk7Zm9yKHZhciBuPXV0KFZuKHQsNiksdGhpcy51bnNpZ25lZCkscz10aGlzLGk9XCJcIjs7KXt2YXIgdT1zLmRpdihuKSxsPXMuc3ViKHUubXVsKG4pKS50b0ludCgpPj4+MCxmPWwudG9TdHJpbmcodCk7aWYocz11LHMuaXNaZXJvKCkpcmV0dXJuIGYraTtmb3IoO2YubGVuZ3RoPDY7KWY9XCIwXCIrZjtpPVwiXCIrZitpfX07JC5nZXRIaWdoQml0cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhpZ2h9OyQuZ2V0SGlnaEJpdHNVbnNpZ25lZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhpZ2g+Pj4wfTskLmdldExvd0JpdHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sb3d9OyQuZ2V0TG93Qml0c1Vuc2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubG93Pj4+MH07JC5nZXROdW1CaXRzQWJzPWZ1bmN0aW9uKCl7aWYodGhpcy5pc05lZ2F0aXZlKCkpcmV0dXJuIHRoaXMuZXEodHQpPzY0OnRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO2Zvcih2YXIgdD10aGlzLmhpZ2ghPTA/dGhpcy5oaWdoOnRoaXMubG93LG89MzE7bz4wJiYhKHQmMTw8byk7by0tKTtyZXR1cm4gdGhpcy5oaWdoIT0wP28rMzM6bysxfTskLmlzWmVybz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhpZ2g9PT0wJiZ0aGlzLmxvdz09PTB9OyQuZXF6PSQuaXNaZXJvOyQuaXNOZWdhdGl2ZT1mdW5jdGlvbigpe3JldHVybiF0aGlzLnVuc2lnbmVkJiZ0aGlzLmhpZ2g8MH07JC5pc1Bvc2l0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5zaWduZWR8fHRoaXMuaGlnaD49MH07JC5pc09kZD1mdW5jdGlvbigpe3JldHVybih0aGlzLmxvdyYxKT09PTF9OyQuaXNFdmVuPWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMubG93JjEpPT09MH07JC5lcXVhbHM9ZnVuY3Rpb24odCl7cmV0dXJuIGplKHQpfHwodD13dCh0KSksdGhpcy51bnNpZ25lZCE9PXQudW5zaWduZWQmJnRoaXMuaGlnaD4+PjMxPT09MSYmdC5oaWdoPj4+MzE9PT0xPyExOnRoaXMuaGlnaD09PXQuaGlnaCYmdGhpcy5sb3c9PT10Lmxvd307JC5lcT0kLmVxdWFsczskLm5vdEVxdWFscz1mdW5jdGlvbih0KXtyZXR1cm4hdGhpcy5lcSh0KX07JC5uZXE9JC5ub3RFcXVhbHM7JC5uZT0kLm5vdEVxdWFsczskLmxlc3NUaGFuPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbXAodCk8MH07JC5sdD0kLmxlc3NUaGFuOyQubGVzc1RoYW5PckVxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbXAodCk8PTB9OyQubHRlPSQubGVzc1RoYW5PckVxdWFsOyQubGU9JC5sZXNzVGhhbk9yRXF1YWw7JC5ncmVhdGVyVGhhbj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb21wKHQpPjB9OyQuZ3Q9JC5ncmVhdGVyVGhhbjskLmdyZWF0ZXJUaGFuT3JFcXVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb21wKHQpPj0wfTskLmd0ZT0kLmdyZWF0ZXJUaGFuT3JFcXVhbDskLmdlPSQuZ3JlYXRlclRoYW5PckVxdWFsOyQuY29tcGFyZT1mdW5jdGlvbih0KXtpZihqZSh0KXx8KHQ9d3QodCkpLHRoaXMuZXEodCkpcmV0dXJuIDA7dmFyIG89dGhpcy5pc05lZ2F0aXZlKCksZT10LmlzTmVnYXRpdmUoKTtyZXR1cm4gbyYmIWU/LTE6IW8mJmU/MTp0aGlzLnVuc2lnbmVkP3QuaGlnaD4+PjA+dGhpcy5oaWdoPj4+MHx8dC5oaWdoPT09dGhpcy5oaWdoJiZ0Lmxvdz4+PjA+dGhpcy5sb3c+Pj4wPy0xOjE6dGhpcy5zdWIodCkuaXNOZWdhdGl2ZSgpPy0xOjF9OyQuY29tcD0kLmNvbXBhcmU7JC5uZWdhdGU9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy51bnNpZ25lZCYmdGhpcy5lcSh0dCk/dHQ6dGhpcy5ub3QoKS5hZGQoTHIpfTskLm5lZz0kLm5lZ2F0ZTskLmFkZD1mdW5jdGlvbih0KXtqZSh0KXx8KHQ9d3QodCkpO3ZhciBvPXRoaXMuaGlnaD4+PjE2LGU9dGhpcy5oaWdoJjY1NTM1LHI9dGhpcy5sb3c+Pj4xNixuPXRoaXMubG93JjY1NTM1LHM9dC5oaWdoPj4+MTYsaT10LmhpZ2gmNjU1MzUsdT10Lmxvdz4+PjE2LGw9dC5sb3cmNjU1MzUsZj0wLHA9MCxkPTAsVD0wO3JldHVybiBUKz1uK2wsZCs9VD4+PjE2LFQmPTY1NTM1LGQrPXIrdSxwKz1kPj4+MTYsZCY9NjU1MzUscCs9ZStpLGYrPXA+Pj4xNixwJj02NTUzNSxmKz1vK3MsZiY9NjU1MzUsbGUoZDw8MTZ8VCxmPDwxNnxwLHRoaXMudW5zaWduZWQpfTskLnN1YnRyYWN0PWZ1bmN0aW9uKHQpe3JldHVybiBqZSh0KXx8KHQ9d3QodCkpLHRoaXMuYWRkKHQubmVnKCkpfTskLnN1Yj0kLnN1YnRyYWN0OyQubXVsdGlwbHk9ZnVuY3Rpb24odCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gdGhpcztpZihqZSh0KXx8KHQ9d3QodCkpLHN0KXt2YXIgbz1zdC5tdWwodGhpcy5sb3csdGhpcy5oaWdoLHQubG93LHQuaGlnaCk7cmV0dXJuIGxlKG8sc3QuZ2V0X2hpZ2goKSx0aGlzLnVuc2lnbmVkKX1pZih0LmlzWmVybygpKXJldHVybiB0aGlzLnVuc2lnbmVkP1Z0Onh0O2lmKHRoaXMuZXEodHQpKXJldHVybiB0LmlzT2RkKCk/dHQ6eHQ7aWYodC5lcSh0dCkpcmV0dXJuIHRoaXMuaXNPZGQoKT90dDp4dDtpZih0aGlzLmlzTmVnYXRpdmUoKSlyZXR1cm4gdC5pc05lZ2F0aXZlKCk/dGhpcy5uZWcoKS5tdWwodC5uZWcoKSk6dGhpcy5uZWcoKS5tdWwodCkubmVnKCk7aWYodC5pc05lZ2F0aXZlKCkpcmV0dXJuIHRoaXMubXVsKHQubmVnKCkpLm5lZygpO2lmKHRoaXMubHQoRnMpJiZ0Lmx0KEZzKSlyZXR1cm4gdXQodGhpcy50b051bWJlcigpKnQudG9OdW1iZXIoKSx0aGlzLnVuc2lnbmVkKTt2YXIgZT10aGlzLmhpZ2g+Pj4xNixyPXRoaXMuaGlnaCY2NTUzNSxuPXRoaXMubG93Pj4+MTYscz10aGlzLmxvdyY2NTUzNSxpPXQuaGlnaD4+PjE2LHU9dC5oaWdoJjY1NTM1LGw9dC5sb3c+Pj4xNixmPXQubG93JjY1NTM1LHA9MCxkPTAsVD0wLHY9MDtyZXR1cm4gdis9cypmLFQrPXY+Pj4xNix2Jj02NTUzNSxUKz1uKmYsZCs9VD4+PjE2LFQmPTY1NTM1LFQrPXMqbCxkKz1UPj4+MTYsVCY9NjU1MzUsZCs9cipmLHArPWQ+Pj4xNixkJj02NTUzNSxkKz1uKmwscCs9ZD4+PjE2LGQmPTY1NTM1LGQrPXMqdSxwKz1kPj4+MTYsZCY9NjU1MzUscCs9ZSpmK3IqbCtuKnUrcyppLHAmPTY1NTM1LGxlKFQ8PDE2fHYscDw8MTZ8ZCx0aGlzLnVuc2lnbmVkKX07JC5tdWw9JC5tdWx0aXBseTskLmRpdmlkZT1mdW5jdGlvbih0KXtpZihqZSh0KXx8KHQ9d3QodCkpLHQuaXNaZXJvKCkpdGhyb3cgRXJyb3IoXCJkaXZpc2lvbiBieSB6ZXJvXCIpO2lmKHN0KXtpZighdGhpcy51bnNpZ25lZCYmdGhpcy5oaWdoPT09LTIxNDc0ODM2NDgmJnQubG93PT09LTEmJnQuaGlnaD09PS0xKXJldHVybiB0aGlzO3ZhciBvPSh0aGlzLnVuc2lnbmVkP3N0LmRpdl91OnN0LmRpdl9zKSh0aGlzLmxvdyx0aGlzLmhpZ2gsdC5sb3csdC5oaWdoKTtyZXR1cm4gbGUobyxzdC5nZXRfaGlnaCgpLHRoaXMudW5zaWduZWQpfWlmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIHRoaXMudW5zaWduZWQ/VnQ6eHQ7dmFyIGUscixuO2lmKHRoaXMudW5zaWduZWQpe2lmKHQudW5zaWduZWR8fCh0PXQudG9VbnNpZ25lZCgpKSx0Lmd0KHRoaXMpKXJldHVybiBWdDtpZih0Lmd0KHRoaXMuc2hydSgxKSkpcmV0dXJuICRzO249VnR9ZWxzZXtpZih0aGlzLmVxKHR0KSl7aWYodC5lcShMcil8fHQuZXEoWm8pKXJldHVybiB0dDtpZih0LmVxKHR0KSlyZXR1cm4gTHI7dmFyIHM9dGhpcy5zaHIoMSk7cmV0dXJuIGU9cy5kaXYodCkuc2hsKDEpLGUuZXEoeHQpP3QuaXNOZWdhdGl2ZSgpP0xyOlpvOihyPXRoaXMuc3ViKHQubXVsKGUpKSxuPWUuYWRkKHIuZGl2KHQpKSxuKX1lbHNlIGlmKHQuZXEodHQpKXJldHVybiB0aGlzLnVuc2lnbmVkP1Z0Onh0O2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiB0LmlzTmVnYXRpdmUoKT90aGlzLm5lZygpLmRpdih0Lm5lZygpKTp0aGlzLm5lZygpLmRpdih0KS5uZWcoKTtpZih0LmlzTmVnYXRpdmUoKSlyZXR1cm4gdGhpcy5kaXYodC5uZWcoKSkubmVnKCk7bj14dH1mb3Iocj10aGlzO3IuZ3RlKHQpOyl7ZT1NYXRoLm1heCgxLE1hdGguZmxvb3Ioci50b051bWJlcigpL3QudG9OdW1iZXIoKSkpO2Zvcih2YXIgaT1NYXRoLmNlaWwoTWF0aC5sb2coZSkvTWF0aC5MTjIpLHU9aTw9NDg/MTpWbigyLGktNDgpLGw9dXQoZSksZj1sLm11bCh0KTtmLmlzTmVnYXRpdmUoKXx8Zi5ndChyKTspZS09dSxsPXV0KGUsdGhpcy51bnNpZ25lZCksZj1sLm11bCh0KTtsLmlzWmVybygpJiYobD1Mciksbj1uLmFkZChsKSxyPXIuc3ViKGYpfXJldHVybiBufTskLmRpdj0kLmRpdmlkZTskLm1vZHVsbz1mdW5jdGlvbih0KXtpZihqZSh0KXx8KHQ9d3QodCkpLHN0KXt2YXIgbz0odGhpcy51bnNpZ25lZD9zdC5yZW1fdTpzdC5yZW1fcykodGhpcy5sb3csdGhpcy5oaWdoLHQubG93LHQuaGlnaCk7cmV0dXJuIGxlKG8sc3QuZ2V0X2hpZ2goKSx0aGlzLnVuc2lnbmVkKX1yZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYodCkubXVsKHQpKX07JC5tb2Q9JC5tb2R1bG87JC5yZW09JC5tb2R1bG87JC5ub3Q9ZnVuY3Rpb24oKXtyZXR1cm4gbGUofnRoaXMubG93LH50aGlzLmhpZ2gsdGhpcy51bnNpZ25lZCl9OyQuY291bnRMZWFkaW5nWmVyb3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oaWdoP01hdGguY2x6MzIodGhpcy5oaWdoKTpNYXRoLmNsejMyKHRoaXMubG93KSszMn07JC5jbHo9JC5jb3VudExlYWRpbmdaZXJvczskLmNvdW50VHJhaWxpbmdaZXJvcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxvdz9Bcyh0aGlzLmxvdyk6QXModGhpcy5oaWdoKSszMn07JC5jdHo9JC5jb3VudFRyYWlsaW5nWmVyb3M7JC5hbmQ9ZnVuY3Rpb24odCl7cmV0dXJuIGplKHQpfHwodD13dCh0KSksbGUodGhpcy5sb3cmdC5sb3csdGhpcy5oaWdoJnQuaGlnaCx0aGlzLnVuc2lnbmVkKX07JC5vcj1mdW5jdGlvbih0KXtyZXR1cm4gamUodCl8fCh0PXd0KHQpKSxsZSh0aGlzLmxvd3x0Lmxvdyx0aGlzLmhpZ2h8dC5oaWdoLHRoaXMudW5zaWduZWQpfTskLnhvcj1mdW5jdGlvbih0KXtyZXR1cm4gamUodCl8fCh0PXd0KHQpKSxsZSh0aGlzLmxvd150Lmxvdyx0aGlzLmhpZ2hedC5oaWdoLHRoaXMudW5zaWduZWQpfTskLnNoaWZ0TGVmdD1mdW5jdGlvbih0KXtyZXR1cm4gamUodCkmJih0PXQudG9JbnQoKSksKHQmPTYzKT09PTA/dGhpczp0PDMyP2xlKHRoaXMubG93PDx0LHRoaXMuaGlnaDw8dHx0aGlzLmxvdz4+PjMyLXQsdGhpcy51bnNpZ25lZCk6bGUoMCx0aGlzLmxvdzw8dC0zMix0aGlzLnVuc2lnbmVkKX07JC5zaGw9JC5zaGlmdExlZnQ7JC5zaGlmdFJpZ2h0PWZ1bmN0aW9uKHQpe3JldHVybiBqZSh0KSYmKHQ9dC50b0ludCgpKSwodCY9NjMpPT09MD90aGlzOnQ8MzI/bGUodGhpcy5sb3c+Pj50fHRoaXMuaGlnaDw8MzItdCx0aGlzLmhpZ2g+PnQsdGhpcy51bnNpZ25lZCk6bGUodGhpcy5oaWdoPj50LTMyLHRoaXMuaGlnaD49MD8wOi0xLHRoaXMudW5zaWduZWQpfTskLnNocj0kLnNoaWZ0UmlnaHQ7JC5zaGlmdFJpZ2h0VW5zaWduZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIGplKHQpJiYodD10LnRvSW50KCkpLCh0Jj02Myk9PT0wP3RoaXM6dDwzMj9sZSh0aGlzLmxvdz4+PnR8dGhpcy5oaWdoPDwzMi10LHRoaXMuaGlnaD4+PnQsdGhpcy51bnNpZ25lZCk6dD09PTMyP2xlKHRoaXMuaGlnaCwwLHRoaXMudW5zaWduZWQpOmxlKHRoaXMuaGlnaD4+PnQtMzIsMCx0aGlzLnVuc2lnbmVkKX07JC5zaHJ1PSQuc2hpZnRSaWdodFVuc2lnbmVkOyQuc2hyX3U9JC5zaGlmdFJpZ2h0VW5zaWduZWQ7JC5yb3RhdGVMZWZ0PWZ1bmN0aW9uKHQpe3ZhciBvO3JldHVybiBqZSh0KSYmKHQ9dC50b0ludCgpKSwodCY9NjMpPT09MD90aGlzOnQ9PT0zMj9sZSh0aGlzLmhpZ2gsdGhpcy5sb3csdGhpcy51bnNpZ25lZCk6dDwzMj8obz0zMi10LGxlKHRoaXMubG93PDx0fHRoaXMuaGlnaD4+Pm8sdGhpcy5oaWdoPDx0fHRoaXMubG93Pj4+byx0aGlzLnVuc2lnbmVkKSk6KHQtPTMyLG89MzItdCxsZSh0aGlzLmhpZ2g8PHR8dGhpcy5sb3c+Pj5vLHRoaXMubG93PDx0fHRoaXMuaGlnaD4+Pm8sdGhpcy51bnNpZ25lZCkpfTskLnJvdGw9JC5yb3RhdGVMZWZ0OyQucm90YXRlUmlnaHQ9ZnVuY3Rpb24odCl7dmFyIG87cmV0dXJuIGplKHQpJiYodD10LnRvSW50KCkpLCh0Jj02Myk9PT0wP3RoaXM6dD09PTMyP2xlKHRoaXMuaGlnaCx0aGlzLmxvdyx0aGlzLnVuc2lnbmVkKTp0PDMyPyhvPTMyLXQsbGUodGhpcy5oaWdoPDxvfHRoaXMubG93Pj4+dCx0aGlzLmxvdzw8b3x0aGlzLmhpZ2g+Pj50LHRoaXMudW5zaWduZWQpKToodC09MzIsbz0zMi10LGxlKHRoaXMubG93PDxvfHRoaXMuaGlnaD4+PnQsdGhpcy5oaWdoPDxvfHRoaXMubG93Pj4+dCx0aGlzLnVuc2lnbmVkKSl9OyQucm90cj0kLnJvdGF0ZVJpZ2h0OyQudG9TaWduZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD9sZSh0aGlzLmxvdyx0aGlzLmhpZ2gsITEpOnRoaXN9OyQudG9VbnNpZ25lZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkP3RoaXM6bGUodGhpcy5sb3csdGhpcy5oaWdoLCEwKX07JC50b0J5dGVzPWZ1bmN0aW9uKHQpe3JldHVybiB0P3RoaXMudG9CeXRlc0xFKCk6dGhpcy50b0J5dGVzQkUoKX07JC50b0J5dGVzTEU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhpZ2gsbz10aGlzLmxvdztyZXR1cm5bbyYyNTUsbz4+PjgmMjU1LG8+Pj4xNiYyNTUsbz4+PjI0LHQmMjU1LHQ+Pj44JjI1NSx0Pj4+MTYmMjU1LHQ+Pj4yNF19OyQudG9CeXRlc0JFPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5oaWdoLG89dGhpcy5sb3c7cmV0dXJuW3Q+Pj4yNCx0Pj4+MTYmMjU1LHQ+Pj44JjI1NSx0JjI1NSxvPj4+MjQsbz4+PjE2JjI1NSxvPj4+OCYyNTUsbyYyNTVdfTtiZS5mcm9tQnl0ZXM9ZnVuY3Rpb24odCxvLGUpe3JldHVybiBlP2JlLmZyb21CeXRlc0xFKHQsbyk6YmUuZnJvbUJ5dGVzQkUodCxvKX07YmUuZnJvbUJ5dGVzTEU9ZnVuY3Rpb24odCxvKXtyZXR1cm4gbmV3IGJlKHRbMF18dFsxXTw8OHx0WzJdPDwxNnx0WzNdPDwyNCx0WzRdfHRbNV08PDh8dFs2XTw8MTZ8dFs3XTw8MjQsbyl9O2JlLmZyb21CeXRlc0JFPWZ1bmN0aW9uKHQsbyl7cmV0dXJuIG5ldyBiZSh0WzRdPDwyNHx0WzVdPDwxNnx0WzZdPDw4fHRbN10sdFswXTw8MjR8dFsxXTw8MTZ8dFsyXTw8OHx0WzNdLG8pfTtXdD1iZX0pO3ZhciBPLFduPUUoKCk9PntPPXt9O08uT2Zmc2V0O08uVGFibGU7Ty5TSVpFT0ZfU0hPUlQ9MjtPLlNJWkVPRl9JTlQ9NDtPLkZJTEVfSURFTlRJRklFUl9MRU5HVEg9NDtPLlNJWkVfUFJFRklYX0xFTkdUSD00O08uRW5jb2Rpbmc9e1VURjhfQllURVM6MSxVVEYxNl9TVFJJTkc6Mn07Ty5pbnQzMj1uZXcgSW50MzJBcnJheSgyKTtPLmZsb2F0MzI9bmV3IEZsb2F0MzJBcnJheShPLmludDMyLmJ1ZmZlcik7Ty5mbG9hdDY0PW5ldyBGbG9hdDY0QXJyYXkoTy5pbnQzMi5idWZmZXIpO08uaXNMaXR0bGVFbmRpYW49bmV3IFVpbnQxNkFycmF5KG5ldyBVaW50OEFycmF5KFsxLDBdKS5idWZmZXIpWzBdPT09MTtPLkxvbmc9ZnVuY3Rpb24oYSx0KXt0aGlzLmxvdz1hfDAsdGhpcy5oaWdoPXR8MH07Ty5Mb25nLmNyZWF0ZT1mdW5jdGlvbihhLHQpe3JldHVybiBhPT0wJiZ0PT0wP08uTG9uZy5aRVJPOm5ldyBPLkxvbmcoYSx0KX07Ty5Mb25nLnByb3RvdHlwZS50b0Zsb2F0NjQ9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5sb3c+Pj4wKSt0aGlzLmhpZ2gqNDI5NDk2NzI5Nn07Ty5Mb25nLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubG93PT1hLmxvdyYmdGhpcy5oaWdoPT1hLmhpZ2h9O08uTG9uZy5aRVJPPW5ldyBPLkxvbmcoMCwwKTtPLkJ1aWxkZXI9ZnVuY3Rpb24oYSl7aWYoYSl2YXIgdD1hO2Vsc2UgdmFyIHQ9MTAyNDt0aGlzLmJiPU8uQnl0ZUJ1ZmZlci5hbGxvY2F0ZSh0KSx0aGlzLnNwYWNlPXQsdGhpcy5taW5hbGlnbj0xLHRoaXMudnRhYmxlPW51bGwsdGhpcy52dGFibGVfaW5fdXNlPTAsdGhpcy5pc05lc3RlZD0hMSx0aGlzLm9iamVjdF9zdGFydD0wLHRoaXMudnRhYmxlcz1bXSx0aGlzLnZlY3Rvcl9udW1fZWxlbXM9MCx0aGlzLmZvcmNlX2RlZmF1bHRzPSExfTtPLkJ1aWxkZXIucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5iYi5jbGVhcigpLHRoaXMuc3BhY2U9dGhpcy5iYi5jYXBhY2l0eSgpLHRoaXMubWluYWxpZ249MSx0aGlzLnZ0YWJsZT1udWxsLHRoaXMudnRhYmxlX2luX3VzZT0wLHRoaXMuaXNOZXN0ZWQ9ITEsdGhpcy5vYmplY3Rfc3RhcnQ9MCx0aGlzLnZ0YWJsZXM9W10sdGhpcy52ZWN0b3JfbnVtX2VsZW1zPTAsdGhpcy5mb3JjZV9kZWZhdWx0cz0hMX07Ty5CdWlsZGVyLnByb3RvdHlwZS5mb3JjZURlZmF1bHRzPWZ1bmN0aW9uKGEpe3RoaXMuZm9yY2VfZGVmYXVsdHM9YX07Ty5CdWlsZGVyLnByb3RvdHlwZS5kYXRhQnVmZmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmJ9O08uQnVpbGRlci5wcm90b3R5cGUuYXNVaW50OEFycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmIuYnl0ZXMoKS5zdWJhcnJheSh0aGlzLmJiLnBvc2l0aW9uKCksdGhpcy5iYi5wb3NpdGlvbigpK3RoaXMub2Zmc2V0KCkpfTtPLkJ1aWxkZXIucHJvdG90eXBlLnByZXA9ZnVuY3Rpb24oYSx0KXthPnRoaXMubWluYWxpZ24mJih0aGlzLm1pbmFsaWduPWEpO2Zvcih2YXIgbz1+KHRoaXMuYmIuY2FwYWNpdHkoKS10aGlzLnNwYWNlK3QpKzEmYS0xO3RoaXMuc3BhY2U8bythK3Q7KXt2YXIgZT10aGlzLmJiLmNhcGFjaXR5KCk7dGhpcy5iYj1PLkJ1aWxkZXIuZ3Jvd0J5dGVCdWZmZXIodGhpcy5iYiksdGhpcy5zcGFjZSs9dGhpcy5iYi5jYXBhY2l0eSgpLWV9dGhpcy5wYWQobyl9O08uQnVpbGRlci5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKGEpe2Zvcih2YXIgdD0wO3Q8YTt0KyspdGhpcy5iYi53cml0ZUludDgoLS10aGlzLnNwYWNlLDApfTtPLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbihhKXt0aGlzLmJiLndyaXRlSW50OCh0aGlzLnNwYWNlLT0xLGEpfTtPLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlSW50MTY9ZnVuY3Rpb24oYSl7dGhpcy5iYi53cml0ZUludDE2KHRoaXMuc3BhY2UtPTIsYSl9O08uQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQzMj1mdW5jdGlvbihhKXt0aGlzLmJiLndyaXRlSW50MzIodGhpcy5zcGFjZS09NCxhKX07Ty5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDY0PWZ1bmN0aW9uKGEpe3RoaXMuYmIud3JpdGVJbnQ2NCh0aGlzLnNwYWNlLT04LGEpfTtPLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlRmxvYXQzMj1mdW5jdGlvbihhKXt0aGlzLmJiLndyaXRlRmxvYXQzMih0aGlzLnNwYWNlLT00LGEpfTtPLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlRmxvYXQ2ND1mdW5jdGlvbihhKXt0aGlzLmJiLndyaXRlRmxvYXQ2NCh0aGlzLnNwYWNlLT04LGEpfTtPLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDg9ZnVuY3Rpb24oYSl7dGhpcy5wcmVwKDEsMCksdGhpcy53cml0ZUludDgoYSl9O08uQnVpbGRlci5wcm90b3R5cGUuYWRkSW50MTY9ZnVuY3Rpb24oYSl7dGhpcy5wcmVwKDIsMCksdGhpcy53cml0ZUludDE2KGEpfTtPLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDMyPWZ1bmN0aW9uKGEpe3RoaXMucHJlcCg0LDApLHRoaXMud3JpdGVJbnQzMihhKX07Ty5CdWlsZGVyLnByb3RvdHlwZS5hZGRJbnQ2ND1mdW5jdGlvbihhKXt0aGlzLnByZXAoOCwwKSx0aGlzLndyaXRlSW50NjQoYSl9O08uQnVpbGRlci5wcm90b3R5cGUuYWRkRmxvYXQzMj1mdW5jdGlvbihhKXt0aGlzLnByZXAoNCwwKSx0aGlzLndyaXRlRmxvYXQzMihhKX07Ty5CdWlsZGVyLnByb3RvdHlwZS5hZGRGbG9hdDY0PWZ1bmN0aW9uKGEpe3RoaXMucHJlcCg4LDApLHRoaXMud3JpdGVGbG9hdDY0KGEpfTtPLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkSW50OD1mdW5jdGlvbihhLHQsbyl7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fHQhPW8pJiYodGhpcy5hZGRJbnQ4KHQpLHRoaXMuc2xvdChhKSl9O08uQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQxNj1mdW5jdGlvbihhLHQsbyl7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fHQhPW8pJiYodGhpcy5hZGRJbnQxNih0KSx0aGlzLnNsb3QoYSkpfTtPLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkSW50MzI9ZnVuY3Rpb24oYSx0LG8peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHx0IT1vKSYmKHRoaXMuYWRkSW50MzIodCksdGhpcy5zbG90KGEpKX07Ty5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDY0PWZ1bmN0aW9uKGEsdCxvKXsodGhpcy5mb3JjZV9kZWZhdWx0c3x8IXQuZXF1YWxzKG8pKSYmKHRoaXMuYWRkSW50NjQodCksdGhpcy5zbG90KGEpKX07Ty5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEZsb2F0MzI9ZnVuY3Rpb24oYSx0LG8peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHx0IT1vKSYmKHRoaXMuYWRkRmxvYXQzMih0KSx0aGlzLnNsb3QoYSkpfTtPLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkRmxvYXQ2ND1mdW5jdGlvbihhLHQsbyl7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fHQhPW8pJiYodGhpcy5hZGRGbG9hdDY0KHQpLHRoaXMuc2xvdChhKSl9O08uQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRPZmZzZXQ9ZnVuY3Rpb24oYSx0LG8peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHx0IT1vKSYmKHRoaXMuYWRkT2Zmc2V0KHQpLHRoaXMuc2xvdChhKSl9O08uQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRTdHJ1Y3Q9ZnVuY3Rpb24oYSx0LG8pe3QhPW8mJih0aGlzLm5lc3RlZCh0KSx0aGlzLnNsb3QoYSkpfTtPLkJ1aWxkZXIucHJvdG90eXBlLm5lc3RlZD1mdW5jdGlvbihhKXtpZihhIT10aGlzLm9mZnNldCgpKXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBzdHJ1Y3QgbXVzdCBiZSBzZXJpYWxpemVkIGlubGluZS5cIil9O08uQnVpbGRlci5wcm90b3R5cGUubm90TmVzdGVkPWZ1bmN0aW9uKCl7aWYodGhpcy5pc05lc3RlZCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogb2JqZWN0IHNlcmlhbGl6YXRpb24gbXVzdCBub3QgYmUgbmVzdGVkLlwiKX07Ty5CdWlsZGVyLnByb3RvdHlwZS5zbG90PWZ1bmN0aW9uKGEpe3RoaXMudnRhYmxlW2FdPXRoaXMub2Zmc2V0KCl9O08uQnVpbGRlci5wcm90b3R5cGUub2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmIuY2FwYWNpdHkoKS10aGlzLnNwYWNlfTtPLkJ1aWxkZXIuZ3Jvd0J5dGVCdWZmZXI9ZnVuY3Rpb24oYSl7dmFyIHQ9YS5jYXBhY2l0eSgpO2lmKHQmMzIyMTIyNTQ3Mil0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogY2Fubm90IGdyb3cgYnVmZmVyIGJleW9uZCAyIGdpZ2FieXRlcy5cIik7dmFyIG89dDw8MSxlPU8uQnl0ZUJ1ZmZlci5hbGxvY2F0ZShvKTtyZXR1cm4gZS5zZXRQb3NpdGlvbihvLXQpLGUuYnl0ZXMoKS5zZXQoYS5ieXRlcygpLG8tdCksZX07Ty5CdWlsZGVyLnByb3RvdHlwZS5hZGRPZmZzZXQ9ZnVuY3Rpb24oYSl7dGhpcy5wcmVwKE8uU0laRU9GX0lOVCwwKSx0aGlzLndyaXRlSW50MzIodGhpcy5vZmZzZXQoKS1hK08uU0laRU9GX0lOVCl9O08uQnVpbGRlci5wcm90b3R5cGUuc3RhcnRPYmplY3Q9ZnVuY3Rpb24oYSl7dGhpcy5ub3ROZXN0ZWQoKSx0aGlzLnZ0YWJsZT09bnVsbCYmKHRoaXMudnRhYmxlPVtdKSx0aGlzLnZ0YWJsZV9pbl91c2U9YTtmb3IodmFyIHQ9MDt0PGE7dCsrKXRoaXMudnRhYmxlW3RdPTA7dGhpcy5pc05lc3RlZD0hMCx0aGlzLm9iamVjdF9zdGFydD10aGlzLm9mZnNldCgpfTtPLkJ1aWxkZXIucHJvdG90eXBlLmVuZE9iamVjdD1mdW5jdGlvbigpe2lmKHRoaXMudnRhYmxlPT1udWxsfHwhdGhpcy5pc05lc3RlZCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogZW5kT2JqZWN0IGNhbGxlZCB3aXRob3V0IHN0YXJ0T2JqZWN0XCIpO3RoaXMuYWRkSW50MzIoMCk7Zm9yKHZhciBhPXRoaXMub2Zmc2V0KCksdD10aGlzLnZ0YWJsZV9pbl91c2UtMTt0Pj0wJiZ0aGlzLnZ0YWJsZVt0XT09MDt0LS0pO2Zvcih2YXIgbz10KzE7dD49MDt0LS0pdGhpcy5hZGRJbnQxNih0aGlzLnZ0YWJsZVt0XSE9MD9hLXRoaXMudnRhYmxlW3RdOjApO3ZhciBlPTI7dGhpcy5hZGRJbnQxNihhLXRoaXMub2JqZWN0X3N0YXJ0KTt2YXIgcj0obytlKSpPLlNJWkVPRl9TSE9SVDt0aGlzLmFkZEludDE2KHIpO3ZhciBuPTAscz10aGlzLnNwYWNlO2U6Zm9yKHQ9MDt0PHRoaXMudnRhYmxlcy5sZW5ndGg7dCsrKXt2YXIgaT10aGlzLmJiLmNhcGFjaXR5KCktdGhpcy52dGFibGVzW3RdO2lmKHI9PXRoaXMuYmIucmVhZEludDE2KGkpKXtmb3IodmFyIHU9Ty5TSVpFT0ZfU0hPUlQ7dTxyO3UrPU8uU0laRU9GX1NIT1JUKWlmKHRoaXMuYmIucmVhZEludDE2KHMrdSkhPXRoaXMuYmIucmVhZEludDE2KGkrdSkpY29udGludWUgZTtuPXRoaXMudnRhYmxlc1t0XTticmVha319cmV0dXJuIG4/KHRoaXMuc3BhY2U9dGhpcy5iYi5jYXBhY2l0eSgpLWEsdGhpcy5iYi53cml0ZUludDMyKHRoaXMuc3BhY2Usbi1hKSk6KHRoaXMudnRhYmxlcy5wdXNoKHRoaXMub2Zmc2V0KCkpLHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLmJiLmNhcGFjaXR5KCktYSx0aGlzLm9mZnNldCgpLWEpKSx0aGlzLmlzTmVzdGVkPSExLGF9O08uQnVpbGRlci5wcm90b3R5cGUuZmluaXNoPWZ1bmN0aW9uKGEsdCxvKXt2YXIgZT1vP08uU0laRV9QUkVGSVhfTEVOR1RIOjA7aWYodCl7dmFyIHI9dDtpZih0aGlzLnByZXAodGhpcy5taW5hbGlnbixPLlNJWkVPRl9JTlQrTy5GSUxFX0lERU5USUZJRVJfTEVOR1RIK2UpLHIubGVuZ3RoIT1PLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IGZpbGUgaWRlbnRpZmllciBtdXN0IGJlIGxlbmd0aCBcIitPLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpO2Zvcih2YXIgbj1PLkZJTEVfSURFTlRJRklFUl9MRU5HVEgtMTtuPj0wO24tLSl0aGlzLndyaXRlSW50OChyLmNoYXJDb2RlQXQobikpfXRoaXMucHJlcCh0aGlzLm1pbmFsaWduLE8uU0laRU9GX0lOVCtlKSx0aGlzLmFkZE9mZnNldChhKSxlJiZ0aGlzLmFkZEludDMyKHRoaXMuYmIuY2FwYWNpdHkoKS10aGlzLnNwYWNlKSx0aGlzLmJiLnNldFBvc2l0aW9uKHRoaXMuc3BhY2UpfTtPLkJ1aWxkZXIucHJvdG90eXBlLmZpbmlzaFNpemVQcmVmaXhlZD1mdW5jdGlvbihhLHQpe3RoaXMuZmluaXNoKGEsdCwhMCl9O08uQnVpbGRlci5wcm90b3R5cGUucmVxdWlyZWRGaWVsZD1mdW5jdGlvbihhLHQpe3ZhciBvPXRoaXMuYmIuY2FwYWNpdHkoKS1hLGU9by10aGlzLmJiLnJlYWRJbnQzMihvKSxyPXRoaXMuYmIucmVhZEludDE2KGUrdCkhPTA7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IGZpZWxkIFwiK3QrXCIgbXVzdCBiZSBzZXRcIil9O08uQnVpbGRlci5wcm90b3R5cGUuc3RhcnRWZWN0b3I9ZnVuY3Rpb24oYSx0LG8pe3RoaXMubm90TmVzdGVkKCksdGhpcy52ZWN0b3JfbnVtX2VsZW1zPXQsdGhpcy5wcmVwKE8uU0laRU9GX0lOVCxhKnQpLHRoaXMucHJlcChvLGEqdCl9O08uQnVpbGRlci5wcm90b3R5cGUuZW5kVmVjdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMud3JpdGVJbnQzMih0aGlzLnZlY3Rvcl9udW1fZWxlbXMpLHRoaXMub2Zmc2V0KCl9O08uQnVpbGRlci5wcm90b3R5cGUuY3JlYXRlU3RyaW5nPWZ1bmN0aW9uKGEpe2lmKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KXZhciB0PWE7ZWxzZSBmb3IodmFyIHQ9W10sbz0wO288YS5sZW5ndGg7KXt2YXIgZSxyPWEuY2hhckNvZGVBdChvKyspO2lmKHI8NTUyOTZ8fHI+PTU2MzIwKWU9cjtlbHNle3ZhciBuPWEuY2hhckNvZGVBdChvKyspO2U9KHI8PDEwKStuKyg2NTUzNi01NjYyMzEwNC01NjMyMCl9ZTwxMjg/dC5wdXNoKGUpOihlPDIwNDg/dC5wdXNoKGU+PjYmMzF8MTkyKTooZTw2NTUzNj90LnB1c2goZT4+MTImMTV8MjI0KTp0LnB1c2goZT4+MTgmN3wyNDAsZT4+MTImNjN8MTI4KSx0LnB1c2goZT4+NiY2M3wxMjgpKSx0LnB1c2goZSY2M3wxMjgpKX10aGlzLmFkZEludDgoMCksdGhpcy5zdGFydFZlY3RvcigxLHQubGVuZ3RoLDEpLHRoaXMuYmIuc2V0UG9zaXRpb24odGhpcy5zcGFjZS09dC5sZW5ndGgpO2Zvcih2YXIgbz0wLHM9dGhpcy5zcGFjZSxpPXRoaXMuYmIuYnl0ZXMoKTtvPHQubGVuZ3RoO28rKylpW3MrK109dFtvXTtyZXR1cm4gdGhpcy5lbmRWZWN0b3IoKX07Ty5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVMb25nPWZ1bmN0aW9uKGEsdCl7cmV0dXJuIE8uTG9uZy5jcmVhdGUoYSx0KX07Ty5CeXRlQnVmZmVyPWZ1bmN0aW9uKGEpe3RoaXMuYnl0ZXNfPWEsdGhpcy5wb3NpdGlvbl89MH07Ty5CeXRlQnVmZmVyLmFsbG9jYXRlPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgTy5CeXRlQnVmZmVyKG5ldyBVaW50OEFycmF5KGEpKX07Ty5CeXRlQnVmZmVyLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMucG9zaXRpb25fPTB9O08uQnl0ZUJ1ZmZlci5wcm90b3R5cGUuYnl0ZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ieXRlc199O08uQnl0ZUJ1ZmZlci5wcm90b3R5cGUucG9zaXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbl99O08uQnl0ZUJ1ZmZlci5wcm90b3R5cGUuc2V0UG9zaXRpb249ZnVuY3Rpb24oYSl7dGhpcy5wb3NpdGlvbl89YX07Ty5CeXRlQnVmZmVyLnByb3RvdHlwZS5jYXBhY2l0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ5dGVzXy5sZW5ndGh9O08uQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucmVhZFVpbnQ4KGEpPDwyND4+MjR9O08uQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmJ5dGVzX1thXX07Ty5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTY9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucmVhZFVpbnQxNihhKTw8MTY+PjE2fTtPLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTY9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYnl0ZXNfW2FdfHRoaXMuYnl0ZXNfW2ErMV08PDh9O08uQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmJ5dGVzX1thXXx0aGlzLmJ5dGVzX1thKzFdPDw4fHRoaXMuYnl0ZXNfW2ErMl08PDE2fHRoaXMuYnl0ZXNfW2ErM108PDI0fTtPLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzI9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucmVhZEludDMyKGEpPj4+MH07Ty5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50NjQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBPLkxvbmcodGhpcy5yZWFkSW50MzIoYSksdGhpcy5yZWFkSW50MzIoYSs0KSl9O08uQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ2ND1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IE8uTG9uZyh0aGlzLnJlYWRVaW50MzIoYSksdGhpcy5yZWFkVWludDMyKGErNCkpfTtPLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdDMyPWZ1bmN0aW9uKGEpe3JldHVybiBPLmludDMyWzBdPXRoaXMucmVhZEludDMyKGEpLE8uZmxvYXQzMlswXX07Ty5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXQ2ND1mdW5jdGlvbihhKXtyZXR1cm4gTy5pbnQzMltPLmlzTGl0dGxlRW5kaWFuPzA6MV09dGhpcy5yZWFkSW50MzIoYSksTy5pbnQzMltPLmlzTGl0dGxlRW5kaWFuPzE6MF09dGhpcy5yZWFkSW50MzIoYSs0KSxPLmZsb2F0NjRbMF19O08uQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uKGEsdCl7dGhpcy5ieXRlc19bYV09dH07Ty5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4PWZ1bmN0aW9uKGEsdCl7dGhpcy5ieXRlc19bYV09dH07Ty5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2PWZ1bmN0aW9uKGEsdCl7dGhpcy5ieXRlc19bYV09dCx0aGlzLmJ5dGVzX1thKzFdPXQ+Pjh9O08uQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTY9ZnVuY3Rpb24oYSx0KXt0aGlzLmJ5dGVzX1thXT10LHRoaXMuYnl0ZXNfW2ErMV09dD4+OH07Ty5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyPWZ1bmN0aW9uKGEsdCl7dGhpcy5ieXRlc19bYV09dCx0aGlzLmJ5dGVzX1thKzFdPXQ+PjgsdGhpcy5ieXRlc19bYSsyXT10Pj4xNix0aGlzLmJ5dGVzX1thKzNdPXQ+PjI0fTtPLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyPWZ1bmN0aW9uKGEsdCl7dGhpcy5ieXRlc19bYV09dCx0aGlzLmJ5dGVzX1thKzFdPXQ+PjgsdGhpcy5ieXRlc19bYSsyXT10Pj4xNix0aGlzLmJ5dGVzX1thKzNdPXQ+PjI0fTtPLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50NjQ9ZnVuY3Rpb24oYSx0KXt0aGlzLndyaXRlSW50MzIoYSx0LmxvdyksdGhpcy53cml0ZUludDMyKGErNCx0LmhpZ2gpfTtPLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDY0PWZ1bmN0aW9uKGEsdCl7dGhpcy53cml0ZVVpbnQzMihhLHQubG93KSx0aGlzLndyaXRlVWludDMyKGErNCx0LmhpZ2gpfTtPLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXQzMj1mdW5jdGlvbihhLHQpe08uZmxvYXQzMlswXT10LHRoaXMud3JpdGVJbnQzMihhLE8uaW50MzJbMF0pfTtPLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXQ2ND1mdW5jdGlvbihhLHQpe08uZmxvYXQ2NFswXT10LHRoaXMud3JpdGVJbnQzMihhLE8uaW50MzJbTy5pc0xpdHRsZUVuZGlhbj8wOjFdKSx0aGlzLndyaXRlSW50MzIoYSs0LE8uaW50MzJbTy5pc0xpdHRsZUVuZGlhbj8xOjBdKX07Ty5CeXRlQnVmZmVyLnByb3RvdHlwZS5nZXRCdWZmZXJJZGVudGlmaWVyPWZ1bmN0aW9uKCl7aWYodGhpcy5ieXRlc18ubGVuZ3RoPHRoaXMucG9zaXRpb25fK08uU0laRU9GX0lOVCtPLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IEJ5dGVCdWZmZXIgaXMgdG9vIHNob3J0IHRvIGNvbnRhaW4gYW4gaWRlbnRpZmllci5cIik7Zm9yKHZhciBhPVwiXCIsdD0wO3Q8Ty5GSUxFX0lERU5USUZJRVJfTEVOR1RIO3QrKylhKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZEludDgodGhpcy5wb3NpdGlvbl8rTy5TSVpFT0ZfSU5UK3QpKTtyZXR1cm4gYX07Ty5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX29mZnNldD1mdW5jdGlvbihhLHQpe3ZhciBvPWEtdGhpcy5yZWFkSW50MzIoYSk7cmV0dXJuIHQ8dGhpcy5yZWFkSW50MTYobyk/dGhpcy5yZWFkSW50MTYobyt0KTowfTtPLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fdW5pb249ZnVuY3Rpb24oYSx0KXtyZXR1cm4gYS5iYl9wb3M9dCt0aGlzLnJlYWRJbnQzMih0KSxhLmJiPXRoaXMsYX07Ty5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3N0cmluZz1mdW5jdGlvbihhLHQpe2ErPXRoaXMucmVhZEludDMyKGEpO3ZhciBvPXRoaXMucmVhZEludDMyKGEpLGU9XCJcIixyPTA7aWYoYSs9Ty5TSVpFT0ZfSU5ULHQ9PT1PLkVuY29kaW5nLlVURjhfQllURVMpcmV0dXJuIHRoaXMuYnl0ZXNfLnN1YmFycmF5KGEsYStvKTtmb3IoO3I8bzspe3ZhciBuLHM9dGhpcy5yZWFkVWludDgoYStyKyspO2lmKHM8MTkyKW49cztlbHNle3ZhciBpPXRoaXMucmVhZFVpbnQ4KGErcisrKTtpZihzPDIyNCluPShzJjMxKTw8NnxpJjYzO2Vsc2V7dmFyIHU9dGhpcy5yZWFkVWludDgoYStyKyspO2lmKHM8MjQwKW49KHMmMTUpPDwxMnwoaSY2Myk8PDZ8dSY2MztlbHNle3ZhciBsPXRoaXMucmVhZFVpbnQ4KGErcisrKTtuPShzJjcpPDwxOHwoaSY2Myk8PDEyfCh1JjYzKTw8NnxsJjYzfX19bjw2NTUzNj9lKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG4pOihuLT02NTUzNixlKz1TdHJpbmcuZnJvbUNoYXJDb2RlKChuPj4xMCkrNTUyOTYsKG4mMTAyNC0xKSs1NjMyMCkpfXJldHVybiBlfTtPLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9faW5kaXJlY3Q9ZnVuY3Rpb24oYSl7cmV0dXJuIGErdGhpcy5yZWFkSW50MzIoYSl9O08uQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX192ZWN0b3I9ZnVuY3Rpb24oYSl7cmV0dXJuIGErdGhpcy5yZWFkSW50MzIoYSkrTy5TSVpFT0ZfSU5UfTtPLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fdmVjdG9yX2xlbj1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5yZWFkSW50MzIoYSt0aGlzLnJlYWRJbnQzMihhKSl9O08uQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19oYXNfaWRlbnRpZmllcj1mdW5jdGlvbihhKXtpZihhLmxlbmd0aCE9Ty5GSUxFX0lERU5USUZJRVJfTEVOR1RIKXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBmaWxlIGlkZW50aWZpZXIgbXVzdCBiZSBsZW5ndGggXCIrTy5GSUxFX0lERU5USUZJRVJfTEVOR1RIKTtmb3IodmFyIHQ9MDt0PE8uRklMRV9JREVOVElGSUVSX0xFTkdUSDt0KyspaWYoYS5jaGFyQ29kZUF0KHQpIT10aGlzLnJlYWRJbnQ4KHRoaXMucG9zaXRpb25fK08uU0laRU9GX0lOVCt0KSlyZXR1cm4hMTtyZXR1cm4hMH07Ty5CeXRlQnVmZmVyLnByb3RvdHlwZS5jcmVhdGVMb25nPWZ1bmN0aW9uKGEsdCl7cmV0dXJuIE8uTG9uZy5jcmVhdGUoYSx0KX19KTt2YXIgVyxubj1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V24oKTsodD0+e2xldCBhOyhlPT57bGV0IG87KG49PntsZXQgcjsoQz0+KENbQy5VTkRFRklORUQ9MF09XCJVTkRFRklORURcIixDW0MuRkxPQVQ9MV09XCJGTE9BVFwiLENbQy5JTlQ9Ml09XCJJTlRcIixDW0MuU1RSSU5HPTNdPVwiU1RSSU5HXCIsQ1tDLlRFTlNPUj00XT1cIlRFTlNPUlwiLENbQy5HUkFQSD01XT1cIkdSQVBIXCIsQ1tDLkZMT0FUUz02XT1cIkZMT0FUU1wiLENbQy5JTlRTPTddPVwiSU5UU1wiLENbQy5TVFJJTkdTPThdPVwiU1RSSU5HU1wiLENbQy5URU5TT1JTPTldPVwiVEVOU09SU1wiLENbQy5HUkFQSFM9MTBdPVwiR1JBUEhTXCIsQ1tDLlNQQVJTRV9URU5TT1I9MTFdPVwiU1BBUlNFX1RFTlNPUlwiLENbQy5TUEFSU0VfVEVOU09SUz0xMl09XCJTUEFSU0VfVEVOU09SU1wiKSkocj1uLkF0dHJpYnV0ZVR5cGV8fD17fSl9KShvPWUuZmJzfHw9e30pfSkoYT10LmV4cGVyaW1lbnRhbHx8PXt9KX0pKFd8fD17fSk7KHQ9PntsZXQgYTsoZT0+e2xldCBvOyhuPT57bGV0IHI7KGw9PihsW2wuVU5LTk9XTj0wXT1cIlVOS05PV05cIixsW2wuVkFMVUU9MV09XCJWQUxVRVwiLGxbbC5QQVJBTT0yXT1cIlBBUkFNXCIpKShyPW4uRGltZW5zaW9uVmFsdWVUeXBlfHw9e30pfSkobz1lLmZic3x8PXt9KX0pKGE9dC5leHBlcmltZW50YWx8fD17fSl9KShXfHw9e30pOyh0PT57bGV0IGE7KGU9PntsZXQgbzsobj0+e2xldCByOyhWPT4oVltWLlVOREVGSU5FRD0wXT1cIlVOREVGSU5FRFwiLFZbVi5GTE9BVD0xXT1cIkZMT0FUXCIsVltWLlVJTlQ4PTJdPVwiVUlOVDhcIixWW1YuSU5UOD0zXT1cIklOVDhcIixWW1YuVUlOVDE2PTRdPVwiVUlOVDE2XCIsVltWLklOVDE2PTVdPVwiSU5UMTZcIixWW1YuSU5UMzI9Nl09XCJJTlQzMlwiLFZbVi5JTlQ2ND03XT1cIklOVDY0XCIsVltWLlNUUklORz04XT1cIlNUUklOR1wiLFZbVi5CT09MPTldPVwiQk9PTFwiLFZbVi5GTE9BVDE2PTEwXT1cIkZMT0FUMTZcIixWW1YuRE9VQkxFPTExXT1cIkRPVUJMRVwiLFZbVi5VSU5UMzI9MTJdPVwiVUlOVDMyXCIsVltWLlVJTlQ2ND0xM109XCJVSU5UNjRcIixWW1YuQ09NUExFWDY0PTE0XT1cIkNPTVBMRVg2NFwiLFZbVi5DT01QTEVYMTI4PTE1XT1cIkNPTVBMRVgxMjhcIixWW1YuQkZMT0FUMTY9MTZdPVwiQkZMT0FUMTZcIixWW1YuRkxPQVQ4RTRNM0ZOPTE3XT1cIkZMT0FUOEU0TTNGTlwiLFZbVi5GTE9BVDhFNE0zRk5VWj0xOF09XCJGTE9BVDhFNE0zRk5VWlwiLFZbVi5GTE9BVDhFNU0yPTE5XT1cIkZMT0FUOEU1TTJcIixWW1YuRkxPQVQ4RTVNMkZOVVo9MjBdPVwiRkxPQVQ4RTVNMkZOVVpcIikpKHI9bi5UZW5zb3JEYXRhVHlwZXx8PXt9KX0pKG89ZS5mYnN8fD17fSl9KShhPXQuZXhwZXJpbWVudGFsfHw9e30pfSkoV3x8PXt9KTsodD0+e2xldCBhOyhlPT57bGV0IG87KG49PntsZXQgcjsodT0+KHVbdS5QcmltaXRpdmU9MF09XCJQcmltaXRpdmVcIix1W3UuRnVzZWQ9MV09XCJGdXNlZFwiKSkocj1uLk5vZGVUeXBlfHw9e30pfSkobz1lLmZic3x8PXt9KX0pKGE9dC5leHBlcmltZW50YWx8fD17fSl9KShXfHw9e30pOyh0PT57bGV0IGE7KGU9PntsZXQgbzsobj0+e2xldCByOyhmPT4oZltmLk5PTkU9MF09XCJOT05FXCIsZltmLnRlbnNvcl90eXBlPTFdPVwidGVuc29yX3R5cGVcIixmW2Yuc2VxdWVuY2VfdHlwZT0yXT1cInNlcXVlbmNlX3R5cGVcIixmW2YubWFwX3R5cGU9M109XCJtYXBfdHlwZVwiKSkocj1uLlR5cGVJbmZvVmFsdWV8fD17fSl9KShvPWUuZmJzfHw9e30pfSkoYT10LmV4cGVyaW1lbnRhbHx8PXt9KX0pKFd8fD17fSk7KHQ9PntsZXQgYTsoZT0+e2xldCBvOyhuPT57Y2xhc3Mgcntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbDt0aGlzLmJiX3Bvcz0wfV9faW5pdChpLHUpe3JldHVybiB0aGlzLmJiX3Bvcz1pLHRoaXMuYmI9dSx0aGlzfXN0YXRpYyBnZXRSb290QXNTaGFwZShpLHUpe3JldHVybih1fHxuZXcgcikuX19pbml0KGkucmVhZEludDMyKGkucG9zaXRpb24oKSkraS5wb3NpdGlvbigpLGkpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTaGFwZShpLHUpe3JldHVybiBpLnNldFBvc2l0aW9uKGkucG9zaXRpb24oKStPLlNJWkVfUFJFRklYX0xFTkdUSCksKHV8fG5ldyByKS5fX2luaXQoaS5yZWFkSW50MzIoaS5wb3NpdGlvbigpKStpLnBvc2l0aW9uKCksaSl9ZGltKGksdSl7bGV0IGw9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gbD8odXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb24pLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytsKStpKjQpLHRoaXMuYmIpOm51bGx9ZGltTGVuZ3RoKCl7bGV0IGk9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gaT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytpKTowfXN0YXRpYyBzdGFydFNoYXBlKGkpe2kuc3RhcnRPYmplY3QoMSl9c3RhdGljIGFkZERpbShpLHUpe2kuYWRkRmllbGRPZmZzZXQoMCx1LDApfXN0YXRpYyBjcmVhdGVEaW1WZWN0b3IoaSx1KXtpLnN0YXJ0VmVjdG9yKDQsdS5sZW5ndGgsNCk7Zm9yKGxldCBsPXUubGVuZ3RoLTE7bD49MDtsLS0paS5hZGRPZmZzZXQodVtsXSk7cmV0dXJuIGkuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0RGltVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig0LHUsNCl9c3RhdGljIGVuZFNoYXBlKGkpe3JldHVybiBpLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVTaGFwZShpLHUpe3JldHVybiByLnN0YXJ0U2hhcGUoaSksci5hZGREaW0oaSx1KSxyLmVuZFNoYXBlKGkpfX1uLlNoYXBlPXJ9KShvPWUuZmJzfHw9e30pfSkoYT10LmV4cGVyaW1lbnRhbHx8PXt9KX0pKFd8fD17fSk7KHQ9PntsZXQgYTsoZT0+e2xldCBvOyhuPT57Y2xhc3Mgcntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbDt0aGlzLmJiX3Bvcz0wfV9faW5pdChpLHUpe3JldHVybiB0aGlzLmJiX3Bvcz1pLHRoaXMuYmI9dSx0aGlzfXN0YXRpYyBnZXRSb290QXNEaW1lbnNpb24oaSx1KXtyZXR1cm4odXx8bmV3IHIpLl9faW5pdChpLnJlYWRJbnQzMihpLnBvc2l0aW9uKCkpK2kucG9zaXRpb24oKSxpKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzRGltZW5zaW9uKGksdSl7cmV0dXJuIGkuc2V0UG9zaXRpb24oaS5wb3NpdGlvbigpK08uU0laRV9QUkVGSVhfTEVOR1RIKSwodXx8bmV3IHIpLl9faW5pdChpLnJlYWRJbnQzMihpLnBvc2l0aW9uKCkpK2kucG9zaXRpb24oKSxpKX12YWx1ZShpKXtsZXQgdT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB1PyhpfHxuZXcgdC5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK3UpLHRoaXMuYmIpOm51bGx9ZGVub3RhdGlvbihpKXtsZXQgdT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiB1P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdSxpKTpudWxsfXN0YXRpYyBzdGFydERpbWVuc2lvbihpKXtpLnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGRWYWx1ZShpLHUpe2kuYWRkRmllbGRPZmZzZXQoMCx1LDApfXN0YXRpYyBhZGREZW5vdGF0aW9uKGksdSl7aS5hZGRGaWVsZE9mZnNldCgxLHUsMCl9c3RhdGljIGVuZERpbWVuc2lvbihpKXtyZXR1cm4gaS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlRGltZW5zaW9uKGksdSxsKXtyZXR1cm4gci5zdGFydERpbWVuc2lvbihpKSxyLmFkZFZhbHVlKGksdSksci5hZGREZW5vdGF0aW9uKGksbCksci5lbmREaW1lbnNpb24oaSl9fW4uRGltZW5zaW9uPXJ9KShvPWUuZmJzfHw9e30pfSkoYT10LmV4cGVyaW1lbnRhbHx8PXt9KX0pKFd8fD17fSk7KHQ9PntsZXQgYTsoZT0+e2xldCBvOyhuPT57Y2xhc3Mgcntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbDt0aGlzLmJiX3Bvcz0wfV9faW5pdChpLHUpe3JldHVybiB0aGlzLmJiX3Bvcz1pLHRoaXMuYmI9dSx0aGlzfXN0YXRpYyBnZXRSb290QXNEaW1lbnNpb25WYWx1ZShpLHUpe3JldHVybih1fHxuZXcgcikuX19pbml0KGkucmVhZEludDMyKGkucG9zaXRpb24oKSkraS5wb3NpdGlvbigpLGkpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNEaW1lbnNpb25WYWx1ZShpLHUpe3JldHVybiBpLnNldFBvc2l0aW9uKGkucG9zaXRpb24oKStPLlNJWkVfUFJFRklYX0xFTkdUSCksKHV8fG5ldyByKS5fX2luaXQoaS5yZWFkSW50MzIoaS5wb3NpdGlvbigpKStpLnBvc2l0aW9uKCksaSl9ZGltVHlwZSgpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGk/dGhpcy5iYi5yZWFkSW50OCh0aGlzLmJiX3BvcytpKTowfWRpbVZhbHVlKCl7bGV0IGk9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gaT90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcytpKTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kaW1QYXJhbShpKXtsZXQgdT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiB1P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdSxpKTpudWxsfXN0YXRpYyBzdGFydERpbWVuc2lvblZhbHVlKGkpe2kuc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZERpbVR5cGUoaSx1KXtpLmFkZEZpZWxkSW50OCgwLHUsMCl9c3RhdGljIGFkZERpbVZhbHVlKGksdSl7aS5hZGRGaWVsZEludDY0KDEsdSxpLmNyZWF0ZUxvbmcoMCwwKSl9c3RhdGljIGFkZERpbVBhcmFtKGksdSl7aS5hZGRGaWVsZE9mZnNldCgyLHUsMCl9c3RhdGljIGVuZERpbWVuc2lvblZhbHVlKGkpe3JldHVybiBpLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVEaW1lbnNpb25WYWx1ZShpLHUsbCxmKXtyZXR1cm4gci5zdGFydERpbWVuc2lvblZhbHVlKGkpLHIuYWRkRGltVHlwZShpLHUpLHIuYWRkRGltVmFsdWUoaSxsKSxyLmFkZERpbVBhcmFtKGksZiksci5lbmREaW1lbnNpb25WYWx1ZShpKX19bi5EaW1lbnNpb25WYWx1ZT1yfSkobz1lLmZic3x8PXt9KX0pKGE9dC5leHBlcmltZW50YWx8fD17fSl9KShXfHw9e30pOyh0PT57bGV0IGE7KGU9PntsZXQgbzsobj0+e2NsYXNzIHJ7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGw7dGhpcy5iYl9wb3M9MH1fX2luaXQoaSx1KXtyZXR1cm4gdGhpcy5iYl9wb3M9aSx0aGlzLmJiPXUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzVGVuc29yVHlwZUFuZFNoYXBlKGksdSl7cmV0dXJuKHV8fG5ldyByKS5fX2luaXQoaS5yZWFkSW50MzIoaS5wb3NpdGlvbigpKStpLnBvc2l0aW9uKCksaSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1RlbnNvclR5cGVBbmRTaGFwZShpLHUpe3JldHVybiBpLnNldFBvc2l0aW9uKGkucG9zaXRpb24oKStPLlNJWkVfUFJFRklYX0xFTkdUSCksKHV8fG5ldyByKS5fX2luaXQoaS5yZWFkSW50MzIoaS5wb3NpdGlvbigpKStpLnBvc2l0aW9uKCksaSl9ZWxlbVR5cGUoKXtsZXQgaT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBpP3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK2kpOjB9c2hhcGUoaSl7bGV0IHU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdT8oaXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5TaGFwZSkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3Bvcyt1KSx0aGlzLmJiKTpudWxsfXN0YXRpYyBzdGFydFRlbnNvclR5cGVBbmRTaGFwZShpKXtpLnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGRFbGVtVHlwZShpLHUpe2kuYWRkRmllbGRJbnQzMigwLHUsMCl9c3RhdGljIGFkZFNoYXBlKGksdSl7aS5hZGRGaWVsZE9mZnNldCgxLHUsMCl9c3RhdGljIGVuZFRlbnNvclR5cGVBbmRTaGFwZShpKXtyZXR1cm4gaS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlVGVuc29yVHlwZUFuZFNoYXBlKGksdSxsKXtyZXR1cm4gci5zdGFydFRlbnNvclR5cGVBbmRTaGFwZShpKSxyLmFkZEVsZW1UeXBlKGksdSksci5hZGRTaGFwZShpLGwpLHIuZW5kVGVuc29yVHlwZUFuZFNoYXBlKGkpfX1uLlRlbnNvclR5cGVBbmRTaGFwZT1yfSkobz1lLmZic3x8PXt9KX0pKGE9dC5leHBlcmltZW50YWx8fD17fSl9KShXfHw9e30pOyh0PT57bGV0IGE7KGU9PntsZXQgbzsobj0+e2NsYXNzIHJ7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGw7dGhpcy5iYl9wb3M9MH1fX2luaXQoaSx1KXtyZXR1cm4gdGhpcy5iYl9wb3M9aSx0aGlzLmJiPXUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzTWFwVHlwZShpLHUpe3JldHVybih1fHxuZXcgcikuX19pbml0KGkucmVhZEludDMyKGkucG9zaXRpb24oKSkraS5wb3NpdGlvbigpLGkpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNNYXBUeXBlKGksdSl7cmV0dXJuIGkuc2V0UG9zaXRpb24oaS5wb3NpdGlvbigpK08uU0laRV9QUkVGSVhfTEVOR1RIKSwodXx8bmV3IHIpLl9faW5pdChpLnJlYWRJbnQzMihpLnBvc2l0aW9uKCkpK2kucG9zaXRpb24oKSxpKX1rZXlUeXBlKCl7bGV0IGk9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gaT90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3BvcytpKTowfXZhbHVlVHlwZShpKXtsZXQgdT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiB1PyhpfHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK3UpLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0TWFwVHlwZShpKXtpLnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGRLZXlUeXBlKGksdSl7aS5hZGRGaWVsZEludDMyKDAsdSwwKX1zdGF0aWMgYWRkVmFsdWVUeXBlKGksdSl7aS5hZGRGaWVsZE9mZnNldCgxLHUsMCl9c3RhdGljIGVuZE1hcFR5cGUoaSl7cmV0dXJuIGkuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZU1hcFR5cGUoaSx1LGwpe3JldHVybiByLnN0YXJ0TWFwVHlwZShpKSxyLmFkZEtleVR5cGUoaSx1KSxyLmFkZFZhbHVlVHlwZShpLGwpLHIuZW5kTWFwVHlwZShpKX19bi5NYXBUeXBlPXJ9KShvPWUuZmJzfHw9e30pfSkoYT10LmV4cGVyaW1lbnRhbHx8PXt9KX0pKFd8fD17fSk7KHQ9PntsZXQgYTsoZT0+e2xldCBvOyhuPT57Y2xhc3Mgcntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbDt0aGlzLmJiX3Bvcz0wfV9faW5pdChpLHUpe3JldHVybiB0aGlzLmJiX3Bvcz1pLHRoaXMuYmI9dSx0aGlzfXN0YXRpYyBnZXRSb290QXNTZXF1ZW5jZVR5cGUoaSx1KXtyZXR1cm4odXx8bmV3IHIpLl9faW5pdChpLnJlYWRJbnQzMihpLnBvc2l0aW9uKCkpK2kucG9zaXRpb24oKSxpKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2VxdWVuY2VUeXBlKGksdSl7cmV0dXJuIGkuc2V0UG9zaXRpb24oaS5wb3NpdGlvbigpK08uU0laRV9QUkVGSVhfTEVOR1RIKSwodXx8bmV3IHIpLl9faW5pdChpLnJlYWRJbnQzMihpLnBvc2l0aW9uKCkpK2kucG9zaXRpb24oKSxpKX1lbGVtVHlwZShpKXtsZXQgdT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB1PyhpfHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK3UpLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0U2VxdWVuY2VUeXBlKGkpe2kuc3RhcnRPYmplY3QoMSl9c3RhdGljIGFkZEVsZW1UeXBlKGksdSl7aS5hZGRGaWVsZE9mZnNldCgwLHUsMCl9c3RhdGljIGVuZFNlcXVlbmNlVHlwZShpKXtyZXR1cm4gaS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlU2VxdWVuY2VUeXBlKGksdSl7cmV0dXJuIHIuc3RhcnRTZXF1ZW5jZVR5cGUoaSksci5hZGRFbGVtVHlwZShpLHUpLHIuZW5kU2VxdWVuY2VUeXBlKGkpfX1uLlNlcXVlbmNlVHlwZT1yfSkobz1lLmZic3x8PXt9KX0pKGE9dC5leHBlcmltZW50YWx8fD17fSl9KShXfHw9e30pOyh0PT57bGV0IGE7KGU9PntsZXQgbzsobj0+e2NsYXNzIHJ7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGw7dGhpcy5iYl9wb3M9MH1fX2luaXQoaSx1KXtyZXR1cm4gdGhpcy5iYl9wb3M9aSx0aGlzLmJiPXUsdGhpc31ub2RlSW5kZXgoKXtyZXR1cm4gdGhpcy5iYi5yZWFkVWludDMyKHRoaXMuYmJfcG9zKX1zcmNBcmdJbmRleCgpe3JldHVybiB0aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcys0KX1kc3RBcmdJbmRleCgpe3JldHVybiB0aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcys4KX1zdGF0aWMgY3JlYXRlRWRnZUVuZChpLHUsbCxmKXtyZXR1cm4gaS5wcmVwKDQsMTIpLGkud3JpdGVJbnQzMihmKSxpLndyaXRlSW50MzIobCksaS53cml0ZUludDMyKHUpLGkub2Zmc2V0KCl9fW4uRWRnZUVuZD1yfSkobz1lLmZic3x8PXt9KX0pKGE9dC5leHBlcmltZW50YWx8fD17fSl9KShXfHw9e30pOyh0PT57bGV0IGE7KGU9PntsZXQgbzsobj0+e2NsYXNzIHJ7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGw7dGhpcy5iYl9wb3M9MH1fX2luaXQoaSx1KXtyZXR1cm4gdGhpcy5iYl9wb3M9aSx0aGlzLmJiPXUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzTm9kZUVkZ2UoaSx1KXtyZXR1cm4odXx8bmV3IHIpLl9faW5pdChpLnJlYWRJbnQzMihpLnBvc2l0aW9uKCkpK2kucG9zaXRpb24oKSxpKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTm9kZUVkZ2UoaSx1KXtyZXR1cm4gaS5zZXRQb3NpdGlvbihpLnBvc2l0aW9uKCkrTy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh1fHxuZXcgcikuX19pbml0KGkucmVhZEludDMyKGkucG9zaXRpb24oKSkraS5wb3NpdGlvbigpLGkpfW5vZGVJbmRleCgpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGk/dGhpcy5iYi5yZWFkVWludDMyKHRoaXMuYmJfcG9zK2kpOjB9aW5wdXRFZGdlcyhpLHUpe2xldCBsPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGw/KHV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCkuX19pbml0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbCkraSoxMix0aGlzLmJiKTpudWxsfWlucHV0RWRnZXNMZW5ndGgoKXtsZXQgaT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBpP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2kpOjB9b3V0cHV0RWRnZXMoaSx1KXtsZXQgbD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBsPyh1fHxuZXcgdC5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQpLl9faW5pdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2wpK2kqMTIsdGhpcy5iYik6bnVsbH1vdXRwdXRFZGdlc0xlbmd0aCgpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIGk/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MraSk6MH1zdGF0aWMgc3RhcnROb2RlRWRnZShpKXtpLnN0YXJ0T2JqZWN0KDMpfXN0YXRpYyBhZGROb2RlSW5kZXgoaSx1KXtpLmFkZEZpZWxkSW50MzIoMCx1LDApfXN0YXRpYyBhZGRJbnB1dEVkZ2VzKGksdSl7aS5hZGRGaWVsZE9mZnNldCgxLHUsMCl9c3RhdGljIHN0YXJ0SW5wdXRFZGdlc1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoMTIsdSw0KX1zdGF0aWMgYWRkT3V0cHV0RWRnZXMoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDIsdSwwKX1zdGF0aWMgc3RhcnRPdXRwdXRFZGdlc1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoMTIsdSw0KX1zdGF0aWMgZW5kTm9kZUVkZ2UoaSl7cmV0dXJuIGkuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZU5vZGVFZGdlKGksdSxsLGYpe3JldHVybiByLnN0YXJ0Tm9kZUVkZ2UoaSksci5hZGROb2RlSW5kZXgoaSx1KSxyLmFkZElucHV0RWRnZXMoaSxsKSxyLmFkZE91dHB1dEVkZ2VzKGksZiksci5lbmROb2RlRWRnZShpKX19bi5Ob2RlRWRnZT1yfSkobz1lLmZic3x8PXt9KX0pKGE9dC5leHBlcmltZW50YWx8fD17fSl9KShXfHw9e30pOyh0PT57bGV0IGE7KGU9PntsZXQgbzsobj0+e2NsYXNzIHJ7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGw7dGhpcy5iYl9wb3M9MH1fX2luaXQoaSx1KXtyZXR1cm4gdGhpcy5iYl9wb3M9aSx0aGlzLmJiPXUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzTm9kZShpLHUpe3JldHVybih1fHxuZXcgcikuX19pbml0KGkucmVhZEludDMyKGkucG9zaXRpb24oKSkraS5wb3NpdGlvbigpLGkpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNOb2RlKGksdSl7cmV0dXJuIGkuc2V0UG9zaXRpb24oaS5wb3NpdGlvbigpK08uU0laRV9QUkVGSVhfTEVOR1RIKSwodXx8bmV3IHIpLl9faW5pdChpLnJlYWRJbnQzMihpLnBvc2l0aW9uKCkpK2kucG9zaXRpb24oKSxpKX1uYW1lKGkpe2xldCB1PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt1LGkpOm51bGx9ZG9jU3RyaW5nKGkpe2xldCB1PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt1LGkpOm51bGx9ZG9tYWluKGkpe2xldCB1PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt1LGkpOm51bGx9c2luY2VWZXJzaW9uKCl7bGV0IGk9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMCk7cmV0dXJuIGk/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MraSk6MH1pbmRleCgpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiBpP3RoaXMuYmIucmVhZFVpbnQzMih0aGlzLmJiX3BvcytpKTowfW9wVHlwZShpKXtsZXQgdT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gdT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3UsaSk6bnVsbH10eXBlKCl7bGV0IGk9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIGk/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MraSk6MH1leGVjdXRpb25Qcm92aWRlclR5cGUoaSl7bGV0IHU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIHU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt1LGkpOm51bGx9aW5wdXRzKGksdSl7bGV0IGw9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIGw/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2wpK2kqNCx1KTpudWxsfWlucHV0c0xlbmd0aCgpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjApO3JldHVybiBpP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2kpOjB9b3V0cHV0cyhpLHUpe2xldCBsPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjIpO3JldHVybiBsP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytsKStpKjQsdSk6bnVsbH1vdXRwdXRzTGVuZ3RoKCl7bGV0IGk9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMik7cmV0dXJuIGk/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MraSk6MH1hdHRyaWJ1dGVzKGksdSl7bGV0IGw9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNCk7cmV0dXJuIGw/KHV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbCkraSo0KSx0aGlzLmJiKTpudWxsfWF0dHJpYnV0ZXNMZW5ndGgoKXtsZXQgaT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI0KTtyZXR1cm4gaT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytpKTowfWlucHV0QXJnQ291bnRzKGkpe2xldCB1PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjYpO3JldHVybiB1P3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrdSkraSo0KTowfWlucHV0QXJnQ291bnRzTGVuZ3RoKCl7bGV0IGk9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIGk/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MraSk6MH1pbnB1dEFyZ0NvdW50c0FycmF5KCl7bGV0IGk9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIGk/bmV3IEludDMyQXJyYXkodGhpcy5iYi5ieXRlcygpLmJ1ZmZlcix0aGlzLmJiLmJ5dGVzKCkuYnl0ZU9mZnNldCt0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2kpLHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2kpKTpudWxsfWltcGxpY2l0SW5wdXRzKGksdSl7bGV0IGw9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyOCk7cmV0dXJuIGw/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2wpK2kqNCx1KTpudWxsfWltcGxpY2l0SW5wdXRzTGVuZ3RoKCl7bGV0IGk9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyOCk7cmV0dXJuIGk/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MraSk6MH1zdGF0aWMgc3RhcnROb2RlKGkpe2kuc3RhcnRPYmplY3QoMTMpfXN0YXRpYyBhZGROYW1lKGksdSl7aS5hZGRGaWVsZE9mZnNldCgwLHUsMCl9c3RhdGljIGFkZERvY1N0cmluZyhpLHUpe2kuYWRkRmllbGRPZmZzZXQoMSx1LDApfXN0YXRpYyBhZGREb21haW4oaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDIsdSwwKX1zdGF0aWMgYWRkU2luY2VWZXJzaW9uKGksdSl7aS5hZGRGaWVsZEludDMyKDMsdSwwKX1zdGF0aWMgYWRkSW5kZXgoaSx1KXtpLmFkZEZpZWxkSW50MzIoNCx1LDApfXN0YXRpYyBhZGRPcFR5cGUoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDUsdSwwKX1zdGF0aWMgYWRkVHlwZShpLHUpe2kuYWRkRmllbGRJbnQzMig2LHUsMCl9c3RhdGljIGFkZEV4ZWN1dGlvblByb3ZpZGVyVHlwZShpLHUpe2kuYWRkRmllbGRPZmZzZXQoNyx1LDApfXN0YXRpYyBhZGRJbnB1dHMoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDgsdSwwKX1zdGF0aWMgY3JlYXRlSW5wdXRzVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig0LHUubGVuZ3RoLDQpO2ZvcihsZXQgbD11Lmxlbmd0aC0xO2w+PTA7bC0tKWkuYWRkT2Zmc2V0KHVbbF0pO3JldHVybiBpLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydElucHV0c1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoNCx1LDQpfXN0YXRpYyBhZGRPdXRwdXRzKGksdSl7aS5hZGRGaWVsZE9mZnNldCg5LHUsMCl9c3RhdGljIGNyZWF0ZU91dHB1dHNWZWN0b3IoaSx1KXtpLnN0YXJ0VmVjdG9yKDQsdS5sZW5ndGgsNCk7Zm9yKGxldCBsPXUubGVuZ3RoLTE7bD49MDtsLS0paS5hZGRPZmZzZXQodVtsXSk7cmV0dXJuIGkuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0T3V0cHV0c1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoNCx1LDQpfXN0YXRpYyBhZGRBdHRyaWJ1dGVzKGksdSl7aS5hZGRGaWVsZE9mZnNldCgxMCx1LDApfXN0YXRpYyBjcmVhdGVBdHRyaWJ1dGVzVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig0LHUubGVuZ3RoLDQpO2ZvcihsZXQgbD11Lmxlbmd0aC0xO2w+PTA7bC0tKWkuYWRkT2Zmc2V0KHVbbF0pO3JldHVybiBpLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEF0dHJpYnV0ZXNWZWN0b3IoaSx1KXtpLnN0YXJ0VmVjdG9yKDQsdSw0KX1zdGF0aWMgYWRkSW5wdXRBcmdDb3VudHMoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDExLHUsMCl9c3RhdGljIGNyZWF0ZUlucHV0QXJnQ291bnRzVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig0LHUubGVuZ3RoLDQpO2ZvcihsZXQgbD11Lmxlbmd0aC0xO2w+PTA7bC0tKWkuYWRkSW50MzIodVtsXSk7cmV0dXJuIGkuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW5wdXRBcmdDb3VudHNWZWN0b3IoaSx1KXtpLnN0YXJ0VmVjdG9yKDQsdSw0KX1zdGF0aWMgYWRkSW1wbGljaXRJbnB1dHMoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDEyLHUsMCl9c3RhdGljIGNyZWF0ZUltcGxpY2l0SW5wdXRzVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig0LHUubGVuZ3RoLDQpO2ZvcihsZXQgbD11Lmxlbmd0aC0xO2w+PTA7bC0tKWkuYWRkT2Zmc2V0KHVbbF0pO3JldHVybiBpLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEltcGxpY2l0SW5wdXRzVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig0LHUsNCl9c3RhdGljIGVuZE5vZGUoaSl7cmV0dXJuIGkuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZU5vZGUoaSx1LGwsZixwLGQsVCx2LHcsSSxMLEYsQyxZKXtyZXR1cm4gci5zdGFydE5vZGUoaSksci5hZGROYW1lKGksdSksci5hZGREb2NTdHJpbmcoaSxsKSxyLmFkZERvbWFpbihpLGYpLHIuYWRkU2luY2VWZXJzaW9uKGkscCksci5hZGRJbmRleChpLGQpLHIuYWRkT3BUeXBlKGksVCksci5hZGRUeXBlKGksdiksci5hZGRFeGVjdXRpb25Qcm92aWRlclR5cGUoaSx3KSxyLmFkZElucHV0cyhpLEkpLHIuYWRkT3V0cHV0cyhpLEwpLHIuYWRkQXR0cmlidXRlcyhpLEYpLHIuYWRkSW5wdXRBcmdDb3VudHMoaSxDKSxyLmFkZEltcGxpY2l0SW5wdXRzKGksWSksci5lbmROb2RlKGkpfX1uLk5vZGU9cn0pKG89ZS5mYnN8fD17fSl9KShhPXQuZXhwZXJpbWVudGFsfHw9e30pfSkoV3x8PXt9KTsodD0+e2xldCBhOyhlPT57bGV0IG87KG49PntjbGFzcyBye2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsO3RoaXMuYmJfcG9zPTB9X19pbml0KGksdSl7cmV0dXJuIHRoaXMuYmJfcG9zPWksdGhpcy5iYj11LHRoaXN9c3RhdGljIGdldFJvb3RBc1ZhbHVlSW5mbyhpLHUpe3JldHVybih1fHxuZXcgcikuX19pbml0KGkucmVhZEludDMyKGkucG9zaXRpb24oKSkraS5wb3NpdGlvbigpLGkpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNWYWx1ZUluZm8oaSx1KXtyZXR1cm4gaS5zZXRQb3NpdGlvbihpLnBvc2l0aW9uKCkrTy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh1fHxuZXcgcikuX19pbml0KGkucmVhZEludDMyKGkucG9zaXRpb24oKSkraS5wb3NpdGlvbigpLGkpfW5hbWUoaSl7bGV0IHU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3UsaSk6bnVsbH1kb2NTdHJpbmcoaSl7bGV0IHU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3UsaSk6bnVsbH10eXBlKGkpe2xldCB1PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHU/KGl8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrdSksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRWYWx1ZUluZm8oaSl7aS5zdGFydE9iamVjdCgzKX1zdGF0aWMgYWRkTmFtZShpLHUpe2kuYWRkRmllbGRPZmZzZXQoMCx1LDApfXN0YXRpYyBhZGREb2NTdHJpbmcoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDEsdSwwKX1zdGF0aWMgYWRkVHlwZShpLHUpe2kuYWRkRmllbGRPZmZzZXQoMix1LDApfXN0YXRpYyBlbmRWYWx1ZUluZm8oaSl7cmV0dXJuIGkuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZVZhbHVlSW5mbyhpLHUsbCxmKXtyZXR1cm4gci5zdGFydFZhbHVlSW5mbyhpKSxyLmFkZE5hbWUoaSx1KSxyLmFkZERvY1N0cmluZyhpLGwpLHIuYWRkVHlwZShpLGYpLHIuZW5kVmFsdWVJbmZvKGkpfX1uLlZhbHVlSW5mbz1yfSkobz1lLmZic3x8PXt9KX0pKGE9dC5leHBlcmltZW50YWx8fD17fSl9KShXfHw9e30pOyh0PT57bGV0IGE7KGU9PntsZXQgbzsobj0+e2NsYXNzIHJ7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGw7dGhpcy5iYl9wb3M9MH1fX2luaXQoaSx1KXtyZXR1cm4gdGhpcy5iYl9wb3M9aSx0aGlzLmJiPXUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzVHlwZUluZm8oaSx1KXtyZXR1cm4odXx8bmV3IHIpLl9faW5pdChpLnJlYWRJbnQzMihpLnBvc2l0aW9uKCkpK2kucG9zaXRpb24oKSxpKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVHlwZUluZm8oaSx1KXtyZXR1cm4gaS5zZXRQb3NpdGlvbihpLnBvc2l0aW9uKCkrTy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh1fHxuZXcgcikuX19pbml0KGkucmVhZEludDMyKGkucG9zaXRpb24oKSkraS5wb3NpdGlvbigpLGkpfWRlbm90YXRpb24oaSl7bGV0IHU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3UsaSk6bnVsbH12YWx1ZVR5cGUoKXtsZXQgaT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBpP3RoaXMuYmIucmVhZFVpbnQ4KHRoaXMuYmJfcG9zK2kpOjB9dmFsdWUoaSl7bGV0IHU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdT90aGlzLmJiLl9fdW5pb24oaSx0aGlzLmJiX3Bvcyt1KTpudWxsfXN0YXRpYyBzdGFydFR5cGVJbmZvKGkpe2kuc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZERlbm90YXRpb24oaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDAsdSwwKX1zdGF0aWMgYWRkVmFsdWVUeXBlKGksdSl7aS5hZGRGaWVsZEludDgoMSx1LDApfXN0YXRpYyBhZGRWYWx1ZShpLHUpe2kuYWRkRmllbGRPZmZzZXQoMix1LDApfXN0YXRpYyBlbmRUeXBlSW5mbyhpKXtyZXR1cm4gaS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlVHlwZUluZm8oaSx1LGwsZil7cmV0dXJuIHIuc3RhcnRUeXBlSW5mbyhpKSxyLmFkZERlbm90YXRpb24oaSx1KSxyLmFkZFZhbHVlVHlwZShpLGwpLHIuYWRkVmFsdWUoaSxmKSxyLmVuZFR5cGVJbmZvKGkpfX1uLlR5cGVJbmZvPXJ9KShvPWUuZmJzfHw9e30pfSkoYT10LmV4cGVyaW1lbnRhbHx8PXt9KX0pKFd8fD17fSk7KHQ9PntsZXQgYTsoZT0+e2xldCBvOyhuPT57Y2xhc3Mgcntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbDt0aGlzLmJiX3Bvcz0wfV9faW5pdChpLHUpe3JldHVybiB0aGlzLmJiX3Bvcz1pLHRoaXMuYmI9dSx0aGlzfXN0YXRpYyBnZXRSb290QXNPcGVyYXRvclNldElkKGksdSl7cmV0dXJuKHV8fG5ldyByKS5fX2luaXQoaS5yZWFkSW50MzIoaS5wb3NpdGlvbigpKStpLnBvc2l0aW9uKCksaSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc09wZXJhdG9yU2V0SWQoaSx1KXtyZXR1cm4gaS5zZXRQb3NpdGlvbihpLnBvc2l0aW9uKCkrTy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh1fHxuZXcgcikuX19pbml0KGkucmVhZEludDMyKGkucG9zaXRpb24oKSkraS5wb3NpdGlvbigpLGkpfWRvbWFpbihpKXtsZXQgdT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB1P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdSxpKTpudWxsfXZlcnNpb24oKXtsZXQgaT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBpP3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmJfcG9zK2kpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfXN0YXRpYyBzdGFydE9wZXJhdG9yU2V0SWQoaSl7aS5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkRG9tYWluKGksdSl7aS5hZGRGaWVsZE9mZnNldCgwLHUsMCl9c3RhdGljIGFkZFZlcnNpb24oaSx1KXtpLmFkZEZpZWxkSW50NjQoMSx1LGkuY3JlYXRlTG9uZygwLDApKX1zdGF0aWMgZW5kT3BlcmF0b3JTZXRJZChpKXtyZXR1cm4gaS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlT3BlcmF0b3JTZXRJZChpLHUsbCl7cmV0dXJuIHIuc3RhcnRPcGVyYXRvclNldElkKGkpLHIuYWRkRG9tYWluKGksdSksci5hZGRWZXJzaW9uKGksbCksci5lbmRPcGVyYXRvclNldElkKGkpfX1uLk9wZXJhdG9yU2V0SWQ9cn0pKG89ZS5mYnN8fD17fSl9KShhPXQuZXhwZXJpbWVudGFsfHw9e30pfSkoV3x8PXt9KTsodD0+e2xldCBhOyhlPT57bGV0IG87KG49PntjbGFzcyBye2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsO3RoaXMuYmJfcG9zPTB9X19pbml0KGksdSl7cmV0dXJuIHRoaXMuYmJfcG9zPWksdGhpcy5iYj11LHRoaXN9c3RhdGljIGdldFJvb3RBc1RlbnNvcihpLHUpe3JldHVybih1fHxuZXcgcikuX19pbml0KGkucmVhZEludDMyKGkucG9zaXRpb24oKSkraS5wb3NpdGlvbigpLGkpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNUZW5zb3IoaSx1KXtyZXR1cm4gaS5zZXRQb3NpdGlvbihpLnBvc2l0aW9uKCkrTy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh1fHxuZXcgcikuX19pbml0KGkucmVhZEludDMyKGkucG9zaXRpb24oKSkraS5wb3NpdGlvbigpLGkpfW5hbWUoaSl7bGV0IHU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3UsaSk6bnVsbH1kb2NTdHJpbmcoaSl7bGV0IHU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3UsaSk6bnVsbH1kaW1zKGkpe2xldCB1PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHU/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3Bvcyt1KStpKjgpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWRpbXNMZW5ndGgoKXtsZXQgaT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBpP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2kpOjB9ZGF0YVR5cGUoKXtsZXQgaT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEwKTtyZXR1cm4gaT90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3BvcytpKTowfXJhd0RhdGEoaSl7bGV0IHU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIHU/dGhpcy5iYi5yZWFkVWludDgodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3Bvcyt1KStpKTowfXJhd0RhdGFMZW5ndGgoKXtsZXQgaT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gaT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytpKTowfXJhd0RhdGFBcnJheSgpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiBpP25ldyBVaW50OEFycmF5KHRoaXMuYmIuYnl0ZXMoKS5idWZmZXIsdGhpcy5iYi5ieXRlcygpLmJ5dGVPZmZzZXQrdGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytpKSx0aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytpKSk6bnVsbH1zdHJpbmdEYXRhKGksdSl7bGV0IGw9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIGw/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2wpK2kqNCx1KTpudWxsfXN0cmluZ0RhdGFMZW5ndGgoKXtsZXQgaT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gaT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytpKTowfXN0YXRpYyBzdGFydFRlbnNvcihpKXtpLnN0YXJ0T2JqZWN0KDYpfXN0YXRpYyBhZGROYW1lKGksdSl7aS5hZGRGaWVsZE9mZnNldCgwLHUsMCl9c3RhdGljIGFkZERvY1N0cmluZyhpLHUpe2kuYWRkRmllbGRPZmZzZXQoMSx1LDApfXN0YXRpYyBhZGREaW1zKGksdSl7aS5hZGRGaWVsZE9mZnNldCgyLHUsMCl9c3RhdGljIGNyZWF0ZURpbXNWZWN0b3IoaSx1KXtpLnN0YXJ0VmVjdG9yKDgsdS5sZW5ndGgsOCk7Zm9yKGxldCBsPXUubGVuZ3RoLTE7bD49MDtsLS0paS5hZGRJbnQ2NCh1W2xdKTtyZXR1cm4gaS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnREaW1zVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig4LHUsOCl9c3RhdGljIGFkZERhdGFUeXBlKGksdSl7aS5hZGRGaWVsZEludDMyKDMsdSwwKX1zdGF0aWMgYWRkUmF3RGF0YShpLHUpe2kuYWRkRmllbGRPZmZzZXQoNCx1LDApfXN0YXRpYyBjcmVhdGVSYXdEYXRhVmVjdG9yKGksdSl7aS5zdGFydFZlY3RvcigxLHUubGVuZ3RoLDEpO2ZvcihsZXQgbD11Lmxlbmd0aC0xO2w+PTA7bC0tKWkuYWRkSW50OCh1W2xdKTtyZXR1cm4gaS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRSYXdEYXRhVmVjdG9yKGksdSl7aS5zdGFydFZlY3RvcigxLHUsMSl9c3RhdGljIGFkZFN0cmluZ0RhdGEoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDUsdSwwKX1zdGF0aWMgY3JlYXRlU3RyaW5nRGF0YVZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoNCx1Lmxlbmd0aCw0KTtmb3IobGV0IGw9dS5sZW5ndGgtMTtsPj0wO2wtLSlpLmFkZE9mZnNldCh1W2xdKTtyZXR1cm4gaS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRTdHJpbmdEYXRhVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig0LHUsNCl9c3RhdGljIGVuZFRlbnNvcihpKXtyZXR1cm4gaS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlVGVuc29yKGksdSxsLGYscCxkLFQpe3JldHVybiByLnN0YXJ0VGVuc29yKGkpLHIuYWRkTmFtZShpLHUpLHIuYWRkRG9jU3RyaW5nKGksbCksci5hZGREaW1zKGksZiksci5hZGREYXRhVHlwZShpLHApLHIuYWRkUmF3RGF0YShpLGQpLHIuYWRkU3RyaW5nRGF0YShpLFQpLHIuZW5kVGVuc29yKGkpfX1uLlRlbnNvcj1yfSkobz1lLmZic3x8PXt9KX0pKGE9dC5leHBlcmltZW50YWx8fD17fSl9KShXfHw9e30pOyh0PT57bGV0IGE7KGU9PntsZXQgbzsobj0+e2NsYXNzIHJ7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGw7dGhpcy5iYl9wb3M9MH1fX2luaXQoaSx1KXtyZXR1cm4gdGhpcy5iYl9wb3M9aSx0aGlzLmJiPXUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzU3BhcnNlVGVuc29yKGksdSl7cmV0dXJuKHV8fG5ldyByKS5fX2luaXQoaS5yZWFkSW50MzIoaS5wb3NpdGlvbigpKStpLnBvc2l0aW9uKCksaSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1NwYXJzZVRlbnNvcihpLHUpe3JldHVybiBpLnNldFBvc2l0aW9uKGkucG9zaXRpb24oKStPLlNJWkVfUFJFRklYX0xFTkdUSCksKHV8fG5ldyByKS5fX2luaXQoaS5yZWFkSW50MzIoaS5wb3NpdGlvbigpKStpLnBvc2l0aW9uKCksaSl9dmFsdWVzKGkpe2xldCB1PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHU/KGl8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK3UpLHRoaXMuYmIpOm51bGx9aW5kaWNlcyhpKXtsZXQgdT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiB1PyhpfHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlRlbnNvcikuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3Bvcyt1KSx0aGlzLmJiKTpudWxsfWRpbXMoaSl7bGV0IHU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdT90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3UpK2kqOCk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9ZGltc0xlbmd0aCgpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIGk/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MraSk6MH1zdGF0aWMgc3RhcnRTcGFyc2VUZW5zb3IoaSl7aS5zdGFydE9iamVjdCgzKX1zdGF0aWMgYWRkVmFsdWVzKGksdSl7aS5hZGRGaWVsZE9mZnNldCgwLHUsMCl9c3RhdGljIGFkZEluZGljZXMoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDEsdSwwKX1zdGF0aWMgYWRkRGltcyhpLHUpe2kuYWRkRmllbGRPZmZzZXQoMix1LDApfXN0YXRpYyBjcmVhdGVEaW1zVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig4LHUubGVuZ3RoLDgpO2ZvcihsZXQgbD11Lmxlbmd0aC0xO2w+PTA7bC0tKWkuYWRkSW50NjQodVtsXSk7cmV0dXJuIGkuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0RGltc1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoOCx1LDgpfXN0YXRpYyBlbmRTcGFyc2VUZW5zb3IoaSl7cmV0dXJuIGkuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZVNwYXJzZVRlbnNvcihpLHUsbCxmKXtyZXR1cm4gci5zdGFydFNwYXJzZVRlbnNvcihpKSxyLmFkZFZhbHVlcyhpLHUpLHIuYWRkSW5kaWNlcyhpLGwpLHIuYWRkRGltcyhpLGYpLHIuZW5kU3BhcnNlVGVuc29yKGkpfX1uLlNwYXJzZVRlbnNvcj1yfSkobz1lLmZic3x8PXt9KX0pKGE9dC5leHBlcmltZW50YWx8fD17fSl9KShXfHw9e30pOyh0PT57bGV0IGE7KGU9PntsZXQgbzsobj0+e2NsYXNzIHJ7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGw7dGhpcy5iYl9wb3M9MH1fX2luaXQoaSx1KXtyZXR1cm4gdGhpcy5iYl9wb3M9aSx0aGlzLmJiPXUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzQXR0cmlidXRlKGksdSl7cmV0dXJuKHV8fG5ldyByKS5fX2luaXQoaS5yZWFkSW50MzIoaS5wb3NpdGlvbigpKStpLnBvc2l0aW9uKCksaSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0F0dHJpYnV0ZShpLHUpe3JldHVybiBpLnNldFBvc2l0aW9uKGkucG9zaXRpb24oKStPLlNJWkVfUFJFRklYX0xFTkdUSCksKHV8fG5ldyByKS5fX2luaXQoaS5yZWFkSW50MzIoaS5wb3NpdGlvbigpKStpLnBvc2l0aW9uKCksaSl9bmFtZShpKXtsZXQgdT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB1P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdSxpKTpudWxsfWRvY1N0cmluZyhpKXtsZXQgdT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiB1P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdSxpKTpudWxsfXR5cGUoKXtsZXQgaT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBpP3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK2kpOjB9Zigpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiBpP3RoaXMuYmIucmVhZEZsb2F0MzIodGhpcy5iYl9wb3MraSk6MH1pKCl7bGV0IGk9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIGk/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MraSk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9cyhpKXtsZXQgdT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gdT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3UsaSk6bnVsbH10KGkpe2xldCB1PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTYpO3JldHVybiB1PyhpfHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlRlbnNvcikuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3Bvcyt1KSx0aGlzLmJiKTpudWxsfWcoaSl7bGV0IHU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIHU/KGl8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrdSksdGhpcy5iYik6bnVsbH1mbG9hdHMoaSl7bGV0IHU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIHU/dGhpcy5iYi5yZWFkRmxvYXQzMih0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3UpK2kqNCk6MH1mbG9hdHNMZW5ndGgoKXtsZXQgaT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gaT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytpKTowfWZsb2F0c0FycmF5KCl7bGV0IGk9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIGk/bmV3IEZsb2F0MzJBcnJheSh0aGlzLmJiLmJ5dGVzKCkuYnVmZmVyLHRoaXMuYmIuYnl0ZXMoKS5ieXRlT2Zmc2V0K3RoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MraSksdGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MraSkpOm51bGx9aW50cyhpKXtsZXQgdT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIyKTtyZXR1cm4gdT90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3UpK2kqOCk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9aW50c0xlbmd0aCgpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjIpO3JldHVybiBpP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2kpOjB9c3RyaW5ncyhpLHUpe2xldCBsPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjQpO3JldHVybiBsP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytsKStpKjQsdSk6bnVsbH1zdHJpbmdzTGVuZ3RoKCl7bGV0IGk9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNCk7cmV0dXJuIGk/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MraSk6MH10ZW5zb3JzKGksdSl7bGV0IGw9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIGw/KHV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbCkraSo0KSx0aGlzLmJiKTpudWxsfXRlbnNvcnNMZW5ndGgoKXtsZXQgaT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI2KTtyZXR1cm4gaT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytpKTowfWdyYXBocyhpLHUpe2xldCBsPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjgpO3JldHVybiBsPyh1fHxuZXcgdC5leHBlcmltZW50YWwuZmJzLkdyYXBoKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbCkraSo0KSx0aGlzLmJiKTpudWxsfWdyYXBoc0xlbmd0aCgpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjgpO3JldHVybiBpP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2kpOjB9c3RhdGljIHN0YXJ0QXR0cmlidXRlKGkpe2kuc3RhcnRPYmplY3QoMTMpfXN0YXRpYyBhZGROYW1lKGksdSl7aS5hZGRGaWVsZE9mZnNldCgwLHUsMCl9c3RhdGljIGFkZERvY1N0cmluZyhpLHUpe2kuYWRkRmllbGRPZmZzZXQoMSx1LDApfXN0YXRpYyBhZGRUeXBlKGksdSl7aS5hZGRGaWVsZEludDMyKDIsdSwwKX1zdGF0aWMgYWRkRihpLHUpe2kuYWRkRmllbGRGbG9hdDMyKDMsdSwwKX1zdGF0aWMgYWRkSShpLHUpe2kuYWRkRmllbGRJbnQ2NCg0LHUsaS5jcmVhdGVMb25nKDAsMCkpfXN0YXRpYyBhZGRTKGksdSl7aS5hZGRGaWVsZE9mZnNldCg1LHUsMCl9c3RhdGljIGFkZFQoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDYsdSwwKX1zdGF0aWMgYWRkRyhpLHUpe2kuYWRkRmllbGRPZmZzZXQoNyx1LDApfXN0YXRpYyBhZGRGbG9hdHMoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDgsdSwwKX1zdGF0aWMgY3JlYXRlRmxvYXRzVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig0LHUubGVuZ3RoLDQpO2ZvcihsZXQgbD11Lmxlbmd0aC0xO2w+PTA7bC0tKWkuYWRkRmxvYXQzMih1W2xdKTtyZXR1cm4gaS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRGbG9hdHNWZWN0b3IoaSx1KXtpLnN0YXJ0VmVjdG9yKDQsdSw0KX1zdGF0aWMgYWRkSW50cyhpLHUpe2kuYWRkRmllbGRPZmZzZXQoOSx1LDApfXN0YXRpYyBjcmVhdGVJbnRzVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig4LHUubGVuZ3RoLDgpO2ZvcihsZXQgbD11Lmxlbmd0aC0xO2w+PTA7bC0tKWkuYWRkSW50NjQodVtsXSk7cmV0dXJuIGkuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW50c1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoOCx1LDgpfXN0YXRpYyBhZGRTdHJpbmdzKGksdSl7aS5hZGRGaWVsZE9mZnNldCgxMCx1LDApfXN0YXRpYyBjcmVhdGVTdHJpbmdzVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig0LHUubGVuZ3RoLDQpO2ZvcihsZXQgbD11Lmxlbmd0aC0xO2w+PTA7bC0tKWkuYWRkT2Zmc2V0KHVbbF0pO3JldHVybiBpLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN0cmluZ3NWZWN0b3IoaSx1KXtpLnN0YXJ0VmVjdG9yKDQsdSw0KX1zdGF0aWMgYWRkVGVuc29ycyhpLHUpe2kuYWRkRmllbGRPZmZzZXQoMTEsdSwwKX1zdGF0aWMgY3JlYXRlVGVuc29yc1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoNCx1Lmxlbmd0aCw0KTtmb3IobGV0IGw9dS5sZW5ndGgtMTtsPj0wO2wtLSlpLmFkZE9mZnNldCh1W2xdKTtyZXR1cm4gaS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRUZW5zb3JzVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig0LHUsNCl9c3RhdGljIGFkZEdyYXBocyhpLHUpe2kuYWRkRmllbGRPZmZzZXQoMTIsdSwwKX1zdGF0aWMgY3JlYXRlR3JhcGhzVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig0LHUubGVuZ3RoLDQpO2ZvcihsZXQgbD11Lmxlbmd0aC0xO2w+PTA7bC0tKWkuYWRkT2Zmc2V0KHVbbF0pO3JldHVybiBpLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEdyYXBoc1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoNCx1LDQpfXN0YXRpYyBlbmRBdHRyaWJ1dGUoaSl7cmV0dXJuIGkuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZUF0dHJpYnV0ZShpLHUsbCxmLHAsZCxULHYsdyxJLEwsRixDLFkpe3JldHVybiByLnN0YXJ0QXR0cmlidXRlKGkpLHIuYWRkTmFtZShpLHUpLHIuYWRkRG9jU3RyaW5nKGksbCksci5hZGRUeXBlKGksZiksci5hZGRGKGkscCksci5hZGRJKGksZCksci5hZGRTKGksVCksci5hZGRUKGksdiksci5hZGRHKGksdyksci5hZGRGbG9hdHMoaSxJKSxyLmFkZEludHMoaSxMKSxyLmFkZFN0cmluZ3MoaSxGKSxyLmFkZFRlbnNvcnMoaSxDKSxyLmFkZEdyYXBocyhpLFkpLHIuZW5kQXR0cmlidXRlKGkpfX1uLkF0dHJpYnV0ZT1yfSkobz1lLmZic3x8PXt9KX0pKGE9dC5leHBlcmltZW50YWx8fD17fSl9KShXfHw9e30pOyh0PT57bGV0IGE7KGU9PntsZXQgbzsobj0+e2NsYXNzIHJ7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGw7dGhpcy5iYl9wb3M9MH1fX2luaXQoaSx1KXtyZXR1cm4gdGhpcy5iYl9wb3M9aSx0aGlzLmJiPXUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzR3JhcGgoaSx1KXtyZXR1cm4odXx8bmV3IHIpLl9faW5pdChpLnJlYWRJbnQzMihpLnBvc2l0aW9uKCkpK2kucG9zaXRpb24oKSxpKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzR3JhcGgoaSx1KXtyZXR1cm4gaS5zZXRQb3NpdGlvbihpLnBvc2l0aW9uKCkrTy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh1fHxuZXcgcikuX19pbml0KGkucmVhZEludDMyKGkucG9zaXRpb24oKSkraS5wb3NpdGlvbigpLGkpfWluaXRpYWxpemVycyhpLHUpe2xldCBsPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGw/KHV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbCkraSo0KSx0aGlzLmJiKTpudWxsfWluaXRpYWxpemVyc0xlbmd0aCgpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGk/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MraSk6MH1ub2RlQXJncyhpLHUpe2xldCBsPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGw/KHV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbCkraSo0KSx0aGlzLmJiKTpudWxsfW5vZGVBcmdzTGVuZ3RoKCl7bGV0IGk9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gaT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytpKTowfW5vZGVzKGksdSl7bGV0IGw9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gbD8odXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5Ob2RlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbCkraSo0KSx0aGlzLmJiKTpudWxsfW5vZGVzTGVuZ3RoKCl7bGV0IGk9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gaT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytpKTowfW1heE5vZGVJbmRleCgpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiBpP3RoaXMuYmIucmVhZFVpbnQzMih0aGlzLmJiX3BvcytpKTowfW5vZGVFZGdlcyhpLHUpe2xldCBsPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiBsPyh1fHxuZXcgdC5leHBlcmltZW50YWwuZmJzLk5vZGVFZGdlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbCkraSo0KSx0aGlzLmJiKTpudWxsfW5vZGVFZGdlc0xlbmd0aCgpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiBpP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2kpOjB9aW5wdXRzKGksdSl7bGV0IGw9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIGw/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2wpK2kqNCx1KTpudWxsfWlucHV0c0xlbmd0aCgpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiBpP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2kpOjB9b3V0cHV0cyhpLHUpe2xldCBsPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTYpO3JldHVybiBsP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytsKStpKjQsdSk6bnVsbH1vdXRwdXRzTGVuZ3RoKCl7bGV0IGk9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIGk/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MraSk6MH1zcGFyc2VJbml0aWFsaXplcnMoaSx1KXtsZXQgbD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE4KTtyZXR1cm4gbD8odXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytsKStpKjQpLHRoaXMuYmIpOm51bGx9c3BhcnNlSW5pdGlhbGl6ZXJzTGVuZ3RoKCl7bGV0IGk9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIGk/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MraSk6MH1zdGF0aWMgc3RhcnRHcmFwaChpKXtpLnN0YXJ0T2JqZWN0KDgpfXN0YXRpYyBhZGRJbml0aWFsaXplcnMoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDAsdSwwKX1zdGF0aWMgY3JlYXRlSW5pdGlhbGl6ZXJzVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig0LHUubGVuZ3RoLDQpO2ZvcihsZXQgbD11Lmxlbmd0aC0xO2w+PTA7bC0tKWkuYWRkT2Zmc2V0KHVbbF0pO3JldHVybiBpLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEluaXRpYWxpemVyc1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoNCx1LDQpfXN0YXRpYyBhZGROb2RlQXJncyhpLHUpe2kuYWRkRmllbGRPZmZzZXQoMSx1LDApfXN0YXRpYyBjcmVhdGVOb2RlQXJnc1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoNCx1Lmxlbmd0aCw0KTtmb3IobGV0IGw9dS5sZW5ndGgtMTtsPj0wO2wtLSlpLmFkZE9mZnNldCh1W2xdKTtyZXR1cm4gaS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnROb2RlQXJnc1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoNCx1LDQpfXN0YXRpYyBhZGROb2RlcyhpLHUpe2kuYWRkRmllbGRPZmZzZXQoMix1LDApfXN0YXRpYyBjcmVhdGVOb2Rlc1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoNCx1Lmxlbmd0aCw0KTtmb3IobGV0IGw9dS5sZW5ndGgtMTtsPj0wO2wtLSlpLmFkZE9mZnNldCh1W2xdKTtyZXR1cm4gaS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnROb2Rlc1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoNCx1LDQpfXN0YXRpYyBhZGRNYXhOb2RlSW5kZXgoaSx1KXtpLmFkZEZpZWxkSW50MzIoMyx1LDApfXN0YXRpYyBhZGROb2RlRWRnZXMoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDQsdSwwKX1zdGF0aWMgY3JlYXRlTm9kZUVkZ2VzVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig0LHUubGVuZ3RoLDQpO2ZvcihsZXQgbD11Lmxlbmd0aC0xO2w+PTA7bC0tKWkuYWRkT2Zmc2V0KHVbbF0pO3JldHVybiBpLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE5vZGVFZGdlc1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoNCx1LDQpfXN0YXRpYyBhZGRJbnB1dHMoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDUsdSwwKX1zdGF0aWMgY3JlYXRlSW5wdXRzVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig0LHUubGVuZ3RoLDQpO2ZvcihsZXQgbD11Lmxlbmd0aC0xO2w+PTA7bC0tKWkuYWRkT2Zmc2V0KHVbbF0pO3JldHVybiBpLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydElucHV0c1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoNCx1LDQpfXN0YXRpYyBhZGRPdXRwdXRzKGksdSl7aS5hZGRGaWVsZE9mZnNldCg2LHUsMCl9c3RhdGljIGNyZWF0ZU91dHB1dHNWZWN0b3IoaSx1KXtpLnN0YXJ0VmVjdG9yKDQsdS5sZW5ndGgsNCk7Zm9yKGxldCBsPXUubGVuZ3RoLTE7bD49MDtsLS0paS5hZGRPZmZzZXQodVtsXSk7cmV0dXJuIGkuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0T3V0cHV0c1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoNCx1LDQpfXN0YXRpYyBhZGRTcGFyc2VJbml0aWFsaXplcnMoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDcsdSwwKX1zdGF0aWMgY3JlYXRlU3BhcnNlSW5pdGlhbGl6ZXJzVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig0LHUubGVuZ3RoLDQpO2ZvcihsZXQgbD11Lmxlbmd0aC0xO2w+PTA7bC0tKWkuYWRkT2Zmc2V0KHVbbF0pO3JldHVybiBpLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFNwYXJzZUluaXRpYWxpemVyc1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoNCx1LDQpfXN0YXRpYyBlbmRHcmFwaChpKXtyZXR1cm4gaS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlR3JhcGgoaSx1LGwsZixwLGQsVCx2LHcpe3JldHVybiByLnN0YXJ0R3JhcGgoaSksci5hZGRJbml0aWFsaXplcnMoaSx1KSxyLmFkZE5vZGVBcmdzKGksbCksci5hZGROb2RlcyhpLGYpLHIuYWRkTWF4Tm9kZUluZGV4KGkscCksci5hZGROb2RlRWRnZXMoaSxkKSxyLmFkZElucHV0cyhpLFQpLHIuYWRkT3V0cHV0cyhpLHYpLHIuYWRkU3BhcnNlSW5pdGlhbGl6ZXJzKGksdyksci5lbmRHcmFwaChpKX19bi5HcmFwaD1yfSkobz1lLmZic3x8PXt9KX0pKGE9dC5leHBlcmltZW50YWx8fD17fSl9KShXfHw9e30pOyh0PT57bGV0IGE7KGU9PntsZXQgbzsobj0+e2NsYXNzIHJ7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGw7dGhpcy5iYl9wb3M9MH1fX2luaXQoaSx1KXtyZXR1cm4gdGhpcy5iYl9wb3M9aSx0aGlzLmJiPXUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzTW9kZWwoaSx1KXtyZXR1cm4odXx8bmV3IHIpLl9faW5pdChpLnJlYWRJbnQzMihpLnBvc2l0aW9uKCkpK2kucG9zaXRpb24oKSxpKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTW9kZWwoaSx1KXtyZXR1cm4gaS5zZXRQb3NpdGlvbihpLnBvc2l0aW9uKCkrTy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh1fHxuZXcgcikuX19pbml0KGkucmVhZEludDMyKGkucG9zaXRpb24oKSkraS5wb3NpdGlvbigpLGkpfWlyVmVyc2lvbigpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGk/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MraSk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9b3BzZXRJbXBvcnQoaSx1KXtsZXQgbD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBsPyh1fHxuZXcgdC5leHBlcmltZW50YWwuZmJzLk9wZXJhdG9yU2V0SWQpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytsKStpKjQpLHRoaXMuYmIpOm51bGx9b3BzZXRJbXBvcnRMZW5ndGgoKXtsZXQgaT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBpP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2kpOjB9cHJvZHVjZXJOYW1lKGkpe2xldCB1PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt1LGkpOm51bGx9cHJvZHVjZXJWZXJzaW9uKGkpe2xldCB1PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiB1P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdSxpKTpudWxsfWRvbWFpbihpKXtsZXQgdT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gdT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3UsaSk6bnVsbH1tb2RlbFZlcnNpb24oKXtsZXQgaT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gaT90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcytpKTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kb2NTdHJpbmcoaSl7bGV0IHU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIHU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt1LGkpOm51bGx9Z3JhcGgoaSl7bGV0IHU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIHU/KGl8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrdSksdGhpcy5iYik6bnVsbH1ncmFwaERvY1N0cmluZyhpKXtsZXQgdT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gdT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3UsaSk6bnVsbH1zdGF0aWMgc3RhcnRNb2RlbChpKXtpLnN0YXJ0T2JqZWN0KDkpfXN0YXRpYyBhZGRJclZlcnNpb24oaSx1KXtpLmFkZEZpZWxkSW50NjQoMCx1LGkuY3JlYXRlTG9uZygwLDApKX1zdGF0aWMgYWRkT3BzZXRJbXBvcnQoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDEsdSwwKX1zdGF0aWMgY3JlYXRlT3BzZXRJbXBvcnRWZWN0b3IoaSx1KXtpLnN0YXJ0VmVjdG9yKDQsdS5sZW5ndGgsNCk7Zm9yKGxldCBsPXUubGVuZ3RoLTE7bD49MDtsLS0paS5hZGRPZmZzZXQodVtsXSk7cmV0dXJuIGkuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0T3BzZXRJbXBvcnRWZWN0b3IoaSx1KXtpLnN0YXJ0VmVjdG9yKDQsdSw0KX1zdGF0aWMgYWRkUHJvZHVjZXJOYW1lKGksdSl7aS5hZGRGaWVsZE9mZnNldCgyLHUsMCl9c3RhdGljIGFkZFByb2R1Y2VyVmVyc2lvbihpLHUpe2kuYWRkRmllbGRPZmZzZXQoMyx1LDApfXN0YXRpYyBhZGREb21haW4oaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDQsdSwwKX1zdGF0aWMgYWRkTW9kZWxWZXJzaW9uKGksdSl7aS5hZGRGaWVsZEludDY0KDUsdSxpLmNyZWF0ZUxvbmcoMCwwKSl9c3RhdGljIGFkZERvY1N0cmluZyhpLHUpe2kuYWRkRmllbGRPZmZzZXQoNix1LDApfXN0YXRpYyBhZGRHcmFwaChpLHUpe2kuYWRkRmllbGRPZmZzZXQoNyx1LDApfXN0YXRpYyBhZGRHcmFwaERvY1N0cmluZyhpLHUpe2kuYWRkRmllbGRPZmZzZXQoOCx1LDApfXN0YXRpYyBlbmRNb2RlbChpKXtyZXR1cm4gaS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTW9kZWwoaSx1LGwsZixwLGQsVCx2LHcsSSl7cmV0dXJuIHIuc3RhcnRNb2RlbChpKSxyLmFkZElyVmVyc2lvbihpLHUpLHIuYWRkT3BzZXRJbXBvcnQoaSxsKSxyLmFkZFByb2R1Y2VyTmFtZShpLGYpLHIuYWRkUHJvZHVjZXJWZXJzaW9uKGkscCksci5hZGREb21haW4oaSxkKSxyLmFkZE1vZGVsVmVyc2lvbihpLFQpLHIuYWRkRG9jU3RyaW5nKGksdiksci5hZGRHcmFwaChpLHcpLHIuYWRkR3JhcGhEb2NTdHJpbmcoaSxJKSxyLmVuZE1vZGVsKGkpfX1uLk1vZGVsPXJ9KShvPWUuZmJzfHw9e30pfSkoYT10LmV4cGVyaW1lbnRhbHx8PXt9KX0pKFd8fD17fSk7KHQ9PntsZXQgYTsoZT0+e2xldCBvOyhuPT57Y2xhc3Mgcntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbDt0aGlzLmJiX3Bvcz0wfV9faW5pdChpLHUpe3JldHVybiB0aGlzLmJiX3Bvcz1pLHRoaXMuYmI9dSx0aGlzfXN0YXRpYyBnZXRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyhpLHUpe3JldHVybih1fHxuZXcgcikuX19pbml0KGkucmVhZEludDMyKGkucG9zaXRpb24oKSkraS5wb3NpdGlvbigpLGkpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyhpLHUpe3JldHVybiBpLnNldFBvc2l0aW9uKGkucG9zaXRpb24oKStPLlNJWkVfUFJFRklYX0xFTkdUSCksKHV8fG5ldyByKS5fX2luaXQoaS5yZWFkSW50MzIoaS5wb3NpdGlvbigpKStpLnBvc2l0aW9uKCksaSl9bm9kZUluZGljZXMoaSl7bGV0IHU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdT90aGlzLmJiLnJlYWRVaW50MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3Bvcyt1KStpKjQpOjB9bm9kZUluZGljZXNMZW5ndGgoKXtsZXQgaT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBpP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2kpOjB9bm9kZUluZGljZXNBcnJheSgpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGk/bmV3IFVpbnQzMkFycmF5KHRoaXMuYmIuYnl0ZXMoKS5idWZmZXIsdGhpcy5iYi5ieXRlcygpLmJ5dGVPZmZzZXQrdGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytpKSx0aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytpKSk6bnVsbH1rZXJuZWxEZWZIYXNoZXMoaSl7bGV0IHU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdT90aGlzLmJiLnJlYWRVaW50NjQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3Bvcyt1KStpKjgpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWtlcm5lbERlZkhhc2hlc0xlbmd0aCgpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGk/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MraSk6MH1zdGF0aWMgc3RhcnRLZXJuZWxDcmVhdGVJbmZvcyhpKXtpLnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGROb2RlSW5kaWNlcyhpLHUpe2kuYWRkRmllbGRPZmZzZXQoMCx1LDApfXN0YXRpYyBjcmVhdGVOb2RlSW5kaWNlc1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoNCx1Lmxlbmd0aCw0KTtmb3IobGV0IGw9dS5sZW5ndGgtMTtsPj0wO2wtLSlpLmFkZEludDMyKHVbbF0pO3JldHVybiBpLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE5vZGVJbmRpY2VzVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig0LHUsNCl9c3RhdGljIGFkZEtlcm5lbERlZkhhc2hlcyhpLHUpe2kuYWRkRmllbGRPZmZzZXQoMSx1LDApfXN0YXRpYyBjcmVhdGVLZXJuZWxEZWZIYXNoZXNWZWN0b3IoaSx1KXtpLnN0YXJ0VmVjdG9yKDgsdS5sZW5ndGgsOCk7Zm9yKGxldCBsPXUubGVuZ3RoLTE7bD49MDtsLS0paS5hZGRJbnQ2NCh1W2xdKTtyZXR1cm4gaS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRLZXJuZWxEZWZIYXNoZXNWZWN0b3IoaSx1KXtpLnN0YXJ0VmVjdG9yKDgsdSw4KX1zdGF0aWMgZW5kS2VybmVsQ3JlYXRlSW5mb3MoaSl7cmV0dXJuIGkuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZUtlcm5lbENyZWF0ZUluZm9zKGksdSxsKXtyZXR1cm4gci5zdGFydEtlcm5lbENyZWF0ZUluZm9zKGkpLHIuYWRkTm9kZUluZGljZXMoaSx1KSxyLmFkZEtlcm5lbERlZkhhc2hlcyhpLGwpLHIuZW5kS2VybmVsQ3JlYXRlSW5mb3MoaSl9fW4uS2VybmVsQ3JlYXRlSW5mb3M9cn0pKG89ZS5mYnN8fD17fSl9KShhPXQuZXhwZXJpbWVudGFsfHw9e30pfSkoV3x8PXt9KTsodD0+e2xldCBhOyhlPT57bGV0IG87KG49PntjbGFzcyBye2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsO3RoaXMuYmJfcG9zPTB9X19pbml0KGksdSl7cmV0dXJuIHRoaXMuYmJfcG9zPWksdGhpcy5iYj11LHRoaXN9c3RhdGljIGdldFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKGksdSl7cmV0dXJuKHV8fG5ldyByKS5fX2luaXQoaS5yZWFkSW50MzIoaS5wb3NpdGlvbigpKStpLnBvc2l0aW9uKCksaSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKGksdSl7cmV0dXJuIGkuc2V0UG9zaXRpb24oaS5wb3NpdGlvbigpK08uU0laRV9QUkVGSVhfTEVOR1RIKSwodXx8bmV3IHIpLl9faW5pdChpLnJlYWRJbnQzMihpLnBvc2l0aW9uKCkpK2kucG9zaXRpb24oKSxpKX1ncmFwaElkKGkpe2xldCB1PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt1LGkpOm51bGx9c2Vzc2lvblN0YXRlKGkpe2xldCB1PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHU/KGl8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK3UpLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUoaSl7aS5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkR3JhcGhJZChpLHUpe2kuYWRkRmllbGRPZmZzZXQoMCx1LDApfXN0YXRpYyBhZGRTZXNzaW9uU3RhdGUoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDEsdSwwKX1zdGF0aWMgZW5kU3ViR3JhcGhTZXNzaW9uU3RhdGUoaSl7bGV0IHU9aS5lbmRPYmplY3QoKTtyZXR1cm4gaS5yZXF1aXJlZEZpZWxkKHUsNCksdX1zdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGUoaSx1LGwpe3JldHVybiByLnN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUoaSksci5hZGRHcmFwaElkKGksdSksci5hZGRTZXNzaW9uU3RhdGUoaSxsKSxyLmVuZFN1YkdyYXBoU2Vzc2lvblN0YXRlKGkpfX1uLlN1YkdyYXBoU2Vzc2lvblN0YXRlPXJ9KShvPWUuZmJzfHw9e30pfSkoYT10LmV4cGVyaW1lbnRhbHx8PXt9KX0pKFd8fD17fSk7KHQ9PntsZXQgYTsoZT0+e2xldCBvOyhuPT57Y2xhc3Mgcntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbDt0aGlzLmJiX3Bvcz0wfV9faW5pdChpLHUpe3JldHVybiB0aGlzLmJiX3Bvcz1pLHRoaXMuYmI9dSx0aGlzfXN0YXRpYyBnZXRSb290QXNTZXNzaW9uU3RhdGUoaSx1KXtyZXR1cm4odXx8bmV3IHIpLl9faW5pdChpLnJlYWRJbnQzMihpLnBvc2l0aW9uKCkpK2kucG9zaXRpb24oKSxpKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2Vzc2lvblN0YXRlKGksdSl7cmV0dXJuIGkuc2V0UG9zaXRpb24oaS5wb3NpdGlvbigpK08uU0laRV9QUkVGSVhfTEVOR1RIKSwodXx8bmV3IHIpLl9faW5pdChpLnJlYWRJbnQzMihpLnBvc2l0aW9uKCkpK2kucG9zaXRpb24oKSxpKX1rZXJuZWxzKGkpe2xldCB1PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHU/KGl8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuS2VybmVsQ3JlYXRlSW5mb3MpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrdSksdGhpcy5iYik6bnVsbH1zdWJHcmFwaFNlc3Npb25TdGF0ZXMoaSx1KXtsZXQgbD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBsPyh1fHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbCkraSo0KSx0aGlzLmJiKTpudWxsfXN1YkdyYXBoU2Vzc2lvblN0YXRlc0xlbmd0aCgpe2xldCBpPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGk/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MraSk6MH1zdGF0aWMgc3RhcnRTZXNzaW9uU3RhdGUoaSl7aS5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkS2VybmVscyhpLHUpe2kuYWRkRmllbGRPZmZzZXQoMCx1LDApfXN0YXRpYyBhZGRTdWJHcmFwaFNlc3Npb25TdGF0ZXMoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDEsdSwwKX1zdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGVzVmVjdG9yKGksdSl7aS5zdGFydFZlY3Rvcig0LHUubGVuZ3RoLDQpO2ZvcihsZXQgbD11Lmxlbmd0aC0xO2w+PTA7bC0tKWkuYWRkT2Zmc2V0KHVbbF0pO3JldHVybiBpLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN1YkdyYXBoU2Vzc2lvblN0YXRlc1ZlY3RvcihpLHUpe2kuc3RhcnRWZWN0b3IoNCx1LDQpfXN0YXRpYyBlbmRTZXNzaW9uU3RhdGUoaSl7cmV0dXJuIGkuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZVNlc3Npb25TdGF0ZShpLHUsbCl7cmV0dXJuIHIuc3RhcnRTZXNzaW9uU3RhdGUoaSksci5hZGRLZXJuZWxzKGksdSksci5hZGRTdWJHcmFwaFNlc3Npb25TdGF0ZXMoaSxsKSxyLmVuZFNlc3Npb25TdGF0ZShpKX19bi5TZXNzaW9uU3RhdGU9cn0pKG89ZS5mYnN8fD17fSl9KShhPXQuZXhwZXJpbWVudGFsfHw9e30pfSkoV3x8PXt9KTsodD0+e2xldCBhOyhlPT57bGV0IG87KG49PntjbGFzcyBye2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsO3RoaXMuYmJfcG9zPTB9X19pbml0KGksdSl7cmV0dXJuIHRoaXMuYmJfcG9zPWksdGhpcy5iYj11LHRoaXN9c3RhdGljIGdldFJvb3RBc0luZmVyZW5jZVNlc3Npb24oaSx1KXtyZXR1cm4odXx8bmV3IHIpLl9faW5pdChpLnJlYWRJbnQzMihpLnBvc2l0aW9uKCkpK2kucG9zaXRpb24oKSxpKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzSW5mZXJlbmNlU2Vzc2lvbihpLHUpe3JldHVybiBpLnNldFBvc2l0aW9uKGkucG9zaXRpb24oKStPLlNJWkVfUFJFRklYX0xFTkdUSCksKHV8fG5ldyByKS5fX2luaXQoaS5yZWFkSW50MzIoaS5wb3NpdGlvbigpKStpLnBvc2l0aW9uKCksaSl9c3RhdGljIGJ1ZmZlckhhc0lkZW50aWZpZXIoaSl7cmV0dXJuIGkuX19oYXNfaWRlbnRpZmllcihcIk9SVE1cIil9b3J0VmVyc2lvbihpKXtsZXQgdT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB1P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdSxpKTpudWxsfW1vZGVsKGkpe2xldCB1PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHU/KGl8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuTW9kZWwpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrdSksdGhpcy5iYik6bnVsbH1zZXNzaW9uU3RhdGUoaSl7bGV0IHU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdT8oaXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrdSksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRJbmZlcmVuY2VTZXNzaW9uKGkpe2kuc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZE9ydFZlcnNpb24oaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDAsdSwwKX1zdGF0aWMgYWRkTW9kZWwoaSx1KXtpLmFkZEZpZWxkT2Zmc2V0KDEsdSwwKX1zdGF0aWMgYWRkU2Vzc2lvblN0YXRlKGksdSl7aS5hZGRGaWVsZE9mZnNldCgyLHUsMCl9c3RhdGljIGVuZEluZmVyZW5jZVNlc3Npb24oaSl7cmV0dXJuIGkuZW5kT2JqZWN0KCl9c3RhdGljIGZpbmlzaEluZmVyZW5jZVNlc3Npb25CdWZmZXIoaSx1KXtpLmZpbmlzaCh1LFwiT1JUTVwiKX1zdGF0aWMgZmluaXNoU2l6ZVByZWZpeGVkSW5mZXJlbmNlU2Vzc2lvbkJ1ZmZlcihpLHUpe2kuZmluaXNoKHUsXCJPUlRNXCIsITApfXN0YXRpYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uKGksdSxsLGYpe3JldHVybiByLnN0YXJ0SW5mZXJlbmNlU2Vzc2lvbihpKSxyLmFkZE9ydFZlcnNpb24oaSx1KSxyLmFkZE1vZGVsKGksbCksci5hZGRTZXNzaW9uU3RhdGUoaSxmKSxyLmVuZEluZmVyZW5jZVNlc3Npb24oaSl9fW4uSW5mZXJlbmNlU2Vzc2lvbj1yfSkobz1lLmZic3x8PXt9KX0pKGE9dC5leHBlcmltZW50YWx8fD17fSl9KShXfHw9e30pfSk7dmFyIFJzPW1lKChPeSxOcyk9PntcInVzZSBzdHJpY3RcIjtOcy5leHBvcnRzPVJkO2Z1bmN0aW9uIFJkKGEsdCl7Zm9yKHZhciBvPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpLGU9MCxyPTIsbj0hMDtyPGFyZ3VtZW50cy5sZW5ndGg7KW9bZSsrXT1hcmd1bWVudHNbcisrXTtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oaSx1KXtvW2VdPWZ1bmN0aW9uKGYpe2lmKG4paWYobj0hMSxmKXUoZik7ZWxzZXtmb3IodmFyIHA9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSksZD0wO2Q8cC5sZW5ndGg7KXBbZCsrXT1hcmd1bWVudHNbZF07aS5hcHBseShudWxsLHApfX07dHJ5e2EuYXBwbHkodHx8bnVsbCxvKX1jYXRjaChsKXtuJiYobj0hMSx1KGwpKX19KX19KTt2YXIgenM9bWUoVXM9PntcInVzZSBzdHJpY3RcIjt2YXIgSG49VXM7SG4ubGVuZ3RoPWZ1bmN0aW9uKHQpe3ZhciBvPXQubGVuZ3RoO2lmKCFvKXJldHVybiAwO2Zvcih2YXIgZT0wOy0tbyU0PjEmJnQuY2hhckF0KG8pPT09XCI9XCI7KSsrZTtyZXR1cm4gTWF0aC5jZWlsKHQubGVuZ3RoKjMpLzQtZX07dmFyIENyPW5ldyBBcnJheSg2NCksR3M9bmV3IEFycmF5KDEyMyk7Zm9yKHZ0PTA7dnQ8NjQ7KUdzW0NyW3Z0XT12dDwyNj92dCs2NTp2dDw1Mj92dCs3MTp2dDw2Mj92dC00OnZ0LTU5fDQzXT12dCsrO3ZhciB2dDtIbi5lbmNvZGU9ZnVuY3Rpb24odCxvLGUpe2Zvcih2YXIgcj1udWxsLG49W10scz0wLGk9MCx1O288ZTspe3ZhciBsPXRbbysrXTtzd2l0Y2goaSl7Y2FzZSAwOm5bcysrXT1DcltsPj4yXSx1PShsJjMpPDw0LGk9MTticmVhaztjYXNlIDE6bltzKytdPUNyW3V8bD4+NF0sdT0obCYxNSk8PDIsaT0yO2JyZWFrO2Nhc2UgMjpuW3MrK109Q3JbdXxsPj42XSxuW3MrK109Q3JbbCY2M10saT0wO2JyZWFrfXM+ODE5MSYmKChyfHwocj1bXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsbikpLHM9MCl9cmV0dXJuIGkmJihuW3MrK109Q3JbdV0sbltzKytdPTYxLGk9PT0xJiYobltzKytdPTYxKSkscj8ocyYmci5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLG4uc2xpY2UoMCxzKSkpLHIuam9pbihcIlwiKSk6U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsbi5zbGljZSgwLHMpKX07dmFyIE1zPVwiaW52YWxpZCBlbmNvZGluZ1wiO0huLmRlY29kZT1mdW5jdGlvbih0LG8sZSl7Zm9yKHZhciByPWUsbj0wLHMsaT0wO2k8dC5sZW5ndGg7KXt2YXIgdT10LmNoYXJDb2RlQXQoaSsrKTtpZih1PT09NjEmJm4+MSlicmVhaztpZigodT1Hc1t1XSk9PT12b2lkIDApdGhyb3cgRXJyb3IoTXMpO3N3aXRjaChuKXtjYXNlIDA6cz11LG49MTticmVhaztjYXNlIDE6b1tlKytdPXM8PDJ8KHUmNDgpPj40LHM9dSxuPTI7YnJlYWs7Y2FzZSAyOm9bZSsrXT0ocyYxNSk8PDR8KHUmNjApPj4yLHM9dSxuPTM7YnJlYWs7Y2FzZSAzOm9bZSsrXT0ocyYzKTw8Nnx1LG49MDticmVha319aWYobj09PTEpdGhyb3cgRXJyb3IoTXMpO3JldHVybiBlLXJ9O0huLnRlc3Q9ZnVuY3Rpb24odCl7cmV0dXJuL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvLnRlc3QodCl9fSk7dmFyIFdzPW1lKChTeSxWcyk9PntcInVzZSBzdHJpY3RcIjtWcy5leHBvcnRzPXFuO2Z1bmN0aW9uIHFuKCl7dGhpcy5fbGlzdGVuZXJzPXt9fXFuLnByb3RvdHlwZS5vbj1mdW5jdGlvbih0LG8sZSl7cmV0dXJuKHRoaXMuX2xpc3RlbmVyc1t0XXx8KHRoaXMuX2xpc3RlbmVyc1t0XT1bXSkpLnB1c2goe2ZuOm8sY3R4OmV8fHRoaXN9KSx0aGlzfTtxbi5wcm90b3R5cGUub2ZmPWZ1bmN0aW9uKHQsbyl7aWYodD09PXZvaWQgMCl0aGlzLl9saXN0ZW5lcnM9e307ZWxzZSBpZihvPT09dm9pZCAwKXRoaXMuX2xpc3RlbmVyc1t0XT1bXTtlbHNlIGZvcih2YXIgZT10aGlzLl9saXN0ZW5lcnNbdF0scj0wO3I8ZS5sZW5ndGg7KWVbcl0uZm49PT1vP2Uuc3BsaWNlKHIsMSk6KytyO3JldHVybiB0aGlzfTtxbi5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbih0KXt2YXIgbz10aGlzLl9saXN0ZW5lcnNbdF07aWYobyl7Zm9yKHZhciBlPVtdLHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7KWUucHVzaChhcmd1bWVudHNbcisrXSk7Zm9yKHI9MDtyPG8ubGVuZ3RoOylvW3JdLmZuLmFwcGx5KG9bcisrXS5jdHgsZSl9cmV0dXJuIHRoaXN9fSk7dmFyIEpzPW1lKChBeSxLcyk9PntcInVzZSBzdHJpY3RcIjtLcy5leHBvcnRzPUhzKEhzKTtmdW5jdGlvbiBIcyhhKXtyZXR1cm4gdHlwZW9mIEZsb2F0MzJBcnJheTxcInVcIj9mdW5jdGlvbigpe3ZhciB0PW5ldyBGbG9hdDMyQXJyYXkoWy0wXSksbz1uZXcgVWludDhBcnJheSh0LmJ1ZmZlciksZT1vWzNdPT09MTI4O2Z1bmN0aW9uIHIodSxsLGYpe3RbMF09dSxsW2ZdPW9bMF0sbFtmKzFdPW9bMV0sbFtmKzJdPW9bMl0sbFtmKzNdPW9bM119ZnVuY3Rpb24gbih1LGwsZil7dFswXT11LGxbZl09b1szXSxsW2YrMV09b1syXSxsW2YrMl09b1sxXSxsW2YrM109b1swXX1hLndyaXRlRmxvYXRMRT1lP3I6bixhLndyaXRlRmxvYXRCRT1lP246cjtmdW5jdGlvbiBzKHUsbCl7cmV0dXJuIG9bMF09dVtsXSxvWzFdPXVbbCsxXSxvWzJdPXVbbCsyXSxvWzNdPXVbbCszXSx0WzBdfWZ1bmN0aW9uIGkodSxsKXtyZXR1cm4gb1szXT11W2xdLG9bMl09dVtsKzFdLG9bMV09dVtsKzJdLG9bMF09dVtsKzNdLHRbMF19YS5yZWFkRmxvYXRMRT1lP3M6aSxhLnJlYWRGbG9hdEJFPWU/aTpzfSgpOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLHIsbixzKXt2YXIgaT1yPDA/MTowO2lmKGkmJihyPS1yKSxyPT09MCllKDEvcj4wPzA6MjE0NzQ4MzY0OCxuLHMpO2Vsc2UgaWYoaXNOYU4ocikpZSgyMTQzMjg5MzQ0LG4scyk7ZWxzZSBpZihyPjM0MDI4MjM0NjYzODUyODg2ZTIyKWUoKGk8PDMxfDIxMzkwOTUwNDApPj4+MCxuLHMpO2Vsc2UgaWYocjwxMTc1NDk0MzUwODIyMjg3NWUtNTQpZSgoaTw8MzF8TWF0aC5yb3VuZChyLzE0MDEyOTg0NjQzMjQ4MTdlLTYwKSk+Pj4wLG4scyk7ZWxzZXt2YXIgdT1NYXRoLmZsb29yKE1hdGgubG9nKHIpL01hdGguTE4yKSxsPU1hdGgucm91bmQocipNYXRoLnBvdygyLC11KSo4Mzg4NjA4KSY4Mzg4NjA3O2UoKGk8PDMxfHUrMTI3PDwyM3xsKT4+PjAsbixzKX19YS53cml0ZUZsb2F0TEU9dC5iaW5kKG51bGwscXMpLGEud3JpdGVGbG9hdEJFPXQuYmluZChudWxsLGpzKTtmdW5jdGlvbiBvKGUscixuKXt2YXIgcz1lKHIsbiksaT0ocz4+MzEpKjIrMSx1PXM+Pj4yMyYyNTUsbD1zJjgzODg2MDc7cmV0dXJuIHU9PT0yNTU/bD9OYU46aSooMS8wKTp1PT09MD9pKjE0MDEyOTg0NjQzMjQ4MTdlLTYwKmw6aSpNYXRoLnBvdygyLHUtMTUwKSoobCs4Mzg4NjA4KX1hLnJlYWRGbG9hdExFPW8uYmluZChudWxsLFlzKSxhLnJlYWRGbG9hdEJFPW8uYmluZChudWxsLFhzKX0oKSx0eXBlb2YgRmxvYXQ2NEFycmF5PFwidVwiP2Z1bmN0aW9uKCl7dmFyIHQ9bmV3IEZsb2F0NjRBcnJheShbLTBdKSxvPW5ldyBVaW50OEFycmF5KHQuYnVmZmVyKSxlPW9bN109PT0xMjg7ZnVuY3Rpb24gcih1LGwsZil7dFswXT11LGxbZl09b1swXSxsW2YrMV09b1sxXSxsW2YrMl09b1syXSxsW2YrM109b1szXSxsW2YrNF09b1s0XSxsW2YrNV09b1s1XSxsW2YrNl09b1s2XSxsW2YrN109b1s3XX1mdW5jdGlvbiBuKHUsbCxmKXt0WzBdPXUsbFtmXT1vWzddLGxbZisxXT1vWzZdLGxbZisyXT1vWzVdLGxbZiszXT1vWzRdLGxbZis0XT1vWzNdLGxbZis1XT1vWzJdLGxbZis2XT1vWzFdLGxbZis3XT1vWzBdfWEud3JpdGVEb3VibGVMRT1lP3I6bixhLndyaXRlRG91YmxlQkU9ZT9uOnI7ZnVuY3Rpb24gcyh1LGwpe3JldHVybiBvWzBdPXVbbF0sb1sxXT11W2wrMV0sb1syXT11W2wrMl0sb1szXT11W2wrM10sb1s0XT11W2wrNF0sb1s1XT11W2wrNV0sb1s2XT11W2wrNl0sb1s3XT11W2wrN10sdFswXX1mdW5jdGlvbiBpKHUsbCl7cmV0dXJuIG9bN109dVtsXSxvWzZdPXVbbCsxXSxvWzVdPXVbbCsyXSxvWzRdPXVbbCszXSxvWzNdPXVbbCs0XSxvWzJdPXVbbCs1XSxvWzFdPXVbbCs2XSxvWzBdPXVbbCs3XSx0WzBdfWEucmVhZERvdWJsZUxFPWU/czppLGEucmVhZERvdWJsZUJFPWU/aTpzfSgpOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLHIsbixzLGksdSl7dmFyIGw9czwwPzE6MDtpZihsJiYocz0tcykscz09PTApZSgwLGksdStyKSxlKDEvcz4wPzA6MjE0NzQ4MzY0OCxpLHUrbik7ZWxzZSBpZihpc05hTihzKSllKDAsaSx1K3IpLGUoMjE0Njk1OTM2MCxpLHUrbik7ZWxzZSBpZihzPjE3OTc2OTMxMzQ4NjIzMTU3ZTI5MillKDAsaSx1K3IpLGUoKGw8PDMxfDIxNDY0MzUwNzIpPj4+MCxpLHUrbik7ZWxzZXt2YXIgZjtpZihzPDIyMjUwNzM4NTg1MDcyMDE0ZS0zMjQpZj1zLzVlLTMyNCxlKGY+Pj4wLGksdStyKSxlKChsPDwzMXxmLzQyOTQ5NjcyOTYpPj4+MCxpLHUrbik7ZWxzZXt2YXIgcD1NYXRoLmZsb29yKE1hdGgubG9nKHMpL01hdGguTE4yKTtwPT09MTAyNCYmKHA9MTAyMyksZj1zKk1hdGgucG93KDIsLXApLGUoZio0NTAzNTk5NjI3MzcwNDk2Pj4+MCxpLHUrciksZSgobDw8MzF8cCsxMDIzPDwyMHxmKjEwNDg1NzYmMTA0ODU3NSk+Pj4wLGksdStuKX19fWEud3JpdGVEb3VibGVMRT10LmJpbmQobnVsbCxxcywwLDQpLGEud3JpdGVEb3VibGVCRT10LmJpbmQobnVsbCxqcyw0LDApO2Z1bmN0aW9uIG8oZSxyLG4scyxpKXt2YXIgdT1lKHMsaStyKSxsPWUocyxpK24pLGY9KGw+PjMxKSoyKzEscD1sPj4+MjAmMjA0NyxkPTQyOTQ5NjcyOTYqKGwmMTA0ODU3NSkrdTtyZXR1cm4gcD09PTIwNDc/ZD9OYU46ZiooMS8wKTpwPT09MD9mKjVlLTMyNCpkOmYqTWF0aC5wb3coMixwLTEwNzUpKihkKzQ1MDM1OTk2MjczNzA0OTYpfWEucmVhZERvdWJsZUxFPW8uYmluZChudWxsLFlzLDAsNCksYS5yZWFkRG91YmxlQkU9by5iaW5kKG51bGwsWHMsNCwwKX0oKSxhfWZ1bmN0aW9uIHFzKGEsdCxvKXt0W29dPWEmMjU1LHRbbysxXT1hPj4+OCYyNTUsdFtvKzJdPWE+Pj4xNiYyNTUsdFtvKzNdPWE+Pj4yNH1mdW5jdGlvbiBqcyhhLHQsbyl7dFtvXT1hPj4+MjQsdFtvKzFdPWE+Pj4xNiYyNTUsdFtvKzJdPWE+Pj44JjI1NSx0W28rM109YSYyNTV9ZnVuY3Rpb24gWXMoYSx0KXtyZXR1cm4oYVt0XXxhW3QrMV08PDh8YVt0KzJdPDwxNnxhW3QrM108PDI0KT4+PjB9ZnVuY3Rpb24gWHMoYSx0KXtyZXR1cm4oYVt0XTw8MjR8YVt0KzFdPDwxNnxhW3QrMl08PDh8YVt0KzNdKT4+PjB9fSk7dmFyIFpzPW1lKChleHBvcnRzLG1vZHVsZSk9PntcInVzZSBzdHJpY3RcIjttb2R1bGUuZXhwb3J0cz1pbnF1aXJlO2Z1bmN0aW9uIGlucXVpcmUobW9kdWxlTmFtZSl7dHJ5e3ZhciBtb2Q9ZXZhbChcInF1aXJlXCIucmVwbGFjZSgvXi8sXCJyZVwiKSkobW9kdWxlTmFtZSk7aWYobW9kJiYobW9kLmxlbmd0aHx8T2JqZWN0LmtleXMobW9kKS5sZW5ndGgpKXJldHVybiBtb2R9Y2F0Y2goYSl7fXJldHVybiBudWxsfX0pO3ZhciBldT1tZShRcz0+e1widXNlIHN0cmljdFwiO3ZhciB0aT1Rczt0aS5sZW5ndGg9ZnVuY3Rpb24odCl7Zm9yKHZhciBvPTAsZT0wLHI9MDtyPHQubGVuZ3RoOysrcillPXQuY2hhckNvZGVBdChyKSxlPDEyOD9vKz0xOmU8MjA0OD9vKz0yOihlJjY0NTEyKT09PTU1Mjk2JiYodC5jaGFyQ29kZUF0KHIrMSkmNjQ1MTIpPT09NTYzMjA/KCsrcixvKz00KTpvKz0zO3JldHVybiBvfTt0aS5yZWFkPWZ1bmN0aW9uKHQsbyxlKXt2YXIgcj1lLW87aWYocjwxKXJldHVyblwiXCI7Zm9yKHZhciBuPW51bGwscz1bXSxpPTAsdTtvPGU7KXU9dFtvKytdLHU8MTI4P3NbaSsrXT11OnU+MTkxJiZ1PDIyND9zW2krK109KHUmMzEpPDw2fHRbbysrXSY2Mzp1PjIzOSYmdTwzNjU/KHU9KCh1JjcpPDwxOHwodFtvKytdJjYzKTw8MTJ8KHRbbysrXSY2Myk8PDZ8dFtvKytdJjYzKS02NTUzNixzW2krK109NTUyOTYrKHU+PjEwKSxzW2krK109NTYzMjArKHUmMTAyMykpOnNbaSsrXT0odSYxNSk8PDEyfCh0W28rK10mNjMpPDw2fHRbbysrXSY2MyxpPjgxOTEmJigobnx8KG49W10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLHMpKSxpPTApO3JldHVybiBuPyhpJiZuLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcscy5zbGljZSgwLGkpKSksbi5qb2luKFwiXCIpKTpTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxzLnNsaWNlKDAsaSkpfTt0aS53cml0ZT1mdW5jdGlvbih0LG8sZSl7Zm9yKHZhciByPWUsbixzLGk9MDtpPHQubGVuZ3RoOysraSluPXQuY2hhckNvZGVBdChpKSxuPDEyOD9vW2UrK109bjpuPDIwNDg/KG9bZSsrXT1uPj42fDE5MixvW2UrK109biY2M3wxMjgpOihuJjY0NTEyKT09PTU1Mjk2JiYoKHM9dC5jaGFyQ29kZUF0KGkrMSkpJjY0NTEyKT09PTU2MzIwPyhuPTY1NTM2KygobiYxMDIzKTw8MTApKyhzJjEwMjMpLCsraSxvW2UrK109bj4+MTh8MjQwLG9bZSsrXT1uPj4xMiY2M3wxMjgsb1tlKytdPW4+PjYmNjN8MTI4LG9bZSsrXT1uJjYzfDEyOCk6KG9bZSsrXT1uPj4xMnwyMjQsb1tlKytdPW4+PjYmNjN8MTI4LG9bZSsrXT1uJjYzfDEyOCk7cmV0dXJuIGUtcn19KTt2YXIgcnU9bWUoKEV5LHR1KT0+e1widXNlIHN0cmljdFwiO3R1LmV4cG9ydHM9TWQ7ZnVuY3Rpb24gTWQoYSx0LG8pe3ZhciBlPW98fDgxOTIscj1lPj4+MSxuPW51bGwscz1lO3JldHVybiBmdW5jdGlvbih1KXtpZih1PDF8fHU+cilyZXR1cm4gYSh1KTtzK3U+ZSYmKG49YShlKSxzPTApO3ZhciBsPXQuY2FsbChuLHMscys9dSk7cmV0dXJuIHMmNyYmKHM9KHN8NykrMSksbH19fSk7dmFyIG91PW1lKChEeSxudSk9PntcInVzZSBzdHJpY3RcIjtudS5leHBvcnRzPU1lO3ZhciBvbj1YdCgpO2Z1bmN0aW9uIE1lKGEsdCl7dGhpcy5sbz1hPj4+MCx0aGlzLmhpPXQ+Pj4wfXZhciBmcj1NZS56ZXJvPW5ldyBNZSgwLDApO2ZyLnRvTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuIDB9O2ZyLnp6RW5jb2RlPWZyLnp6RGVjb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2ZyLmxlbmd0aD1mdW5jdGlvbigpe3JldHVybiAxfTt2YXIgR2Q9TWUuemVyb0hhc2g9XCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtNZS5mcm9tTnVtYmVyPWZ1bmN0aW9uKHQpe2lmKHQ9PT0wKXJldHVybiBmcjt2YXIgbz10PDA7byYmKHQ9LXQpO3ZhciBlPXQ+Pj4wLHI9KHQtZSkvNDI5NDk2NzI5Nj4+PjA7cmV0dXJuIG8mJihyPX5yPj4+MCxlPX5lPj4+MCwrK2U+NDI5NDk2NzI5NSYmKGU9MCwrK3I+NDI5NDk2NzI5NSYmKHI9MCkpKSxuZXcgTWUoZSxyKX07TWUuZnJvbT1mdW5jdGlvbih0KXtpZih0eXBlb2YgdD09XCJudW1iZXJcIilyZXR1cm4gTWUuZnJvbU51bWJlcih0KTtpZihvbi5pc1N0cmluZyh0KSlpZihvbi5Mb25nKXQ9b24uTG9uZy5mcm9tU3RyaW5nKHQpO2Vsc2UgcmV0dXJuIE1lLmZyb21OdW1iZXIocGFyc2VJbnQodCwxMCkpO3JldHVybiB0Lmxvd3x8dC5oaWdoP25ldyBNZSh0Lmxvdz4+PjAsdC5oaWdoPj4+MCk6ZnJ9O01lLnByb3RvdHlwZS50b051bWJlcj1mdW5jdGlvbih0KXtpZighdCYmdGhpcy5oaT4+PjMxKXt2YXIgbz1+dGhpcy5sbysxPj4+MCxlPX50aGlzLmhpPj4+MDtyZXR1cm4gb3x8KGU9ZSsxPj4+MCksLShvK2UqNDI5NDk2NzI5Nil9cmV0dXJuIHRoaXMubG8rdGhpcy5oaSo0Mjk0OTY3Mjk2fTtNZS5wcm90b3R5cGUudG9Mb25nPWZ1bmN0aW9uKHQpe3JldHVybiBvbi5Mb25nP25ldyBvbi5Mb25nKHRoaXMubG98MCx0aGlzLmhpfDAsISF0KTp7bG93OnRoaXMubG98MCxoaWdoOnRoaXMuaGl8MCx1bnNpZ25lZDohIXR9fTt2YXIgWXQ9U3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0O01lLmZyb21IYXNoPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09R2Q/ZnI6bmV3IE1lKChZdC5jYWxsKHQsMCl8WXQuY2FsbCh0LDEpPDw4fFl0LmNhbGwodCwyKTw8MTZ8WXQuY2FsbCh0LDMpPDwyNCk+Pj4wLChZdC5jYWxsKHQsNCl8WXQuY2FsbCh0LDUpPDw4fFl0LmNhbGwodCw2KTw8MTZ8WXQuY2FsbCh0LDcpPDwyNCk+Pj4wKX07TWUucHJvdG90eXBlLnRvSGFzaD1mdW5jdGlvbigpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMubG8mMjU1LHRoaXMubG8+Pj44JjI1NSx0aGlzLmxvPj4+MTYmMjU1LHRoaXMubG8+Pj4yNCx0aGlzLmhpJjI1NSx0aGlzLmhpPj4+OCYyNTUsdGhpcy5oaT4+PjE2JjI1NSx0aGlzLmhpPj4+MjQpfTtNZS5wcm90b3R5cGUuenpFbmNvZGU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhpPj4zMTtyZXR1cm4gdGhpcy5oaT0oKHRoaXMuaGk8PDF8dGhpcy5sbz4+PjMxKV50KT4+PjAsdGhpcy5sbz0odGhpcy5sbzw8MV50KT4+PjAsdGhpc307TWUucHJvdG90eXBlLnp6RGVjb2RlPWZ1bmN0aW9uKCl7dmFyIHQ9LSh0aGlzLmxvJjEpO3JldHVybiB0aGlzLmxvPSgodGhpcy5sbz4+PjF8dGhpcy5oaTw8MzEpXnQpPj4+MCx0aGlzLmhpPSh0aGlzLmhpPj4+MV50KT4+PjAsdGhpc307TWUucHJvdG90eXBlLmxlbmd0aD1mdW5jdGlvbigpe3ZhciB0PXRoaXMubG8sbz0odGhpcy5sbz4+PjI4fHRoaXMuaGk8PDQpPj4+MCxlPXRoaXMuaGk+Pj4yNDtyZXR1cm4gZT09PTA/bz09PTA/dDwxNjM4ND90PDEyOD8xOjI6dDwyMDk3MTUyPzM6NDpvPDE2Mzg0P288MTI4PzU6NjpvPDIwOTcxNTI/Nzo4OmU8MTI4Pzk6MTB9fSk7dmFyIFh0PW1lKHJpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIEg9cmk7SC5hc1Byb21pc2U9UnMoKTtILmJhc2U2ND16cygpO0guRXZlbnRFbWl0dGVyPVdzKCk7SC5mbG9hdD1KcygpO0guaW5xdWlyZT1acygpO0gudXRmOD1ldSgpO0gucG9vbD1ydSgpO0guTG9uZ0JpdHM9b3UoKTtILmlzTm9kZT0hISh0eXBlb2YgZ2xvYmFsPFwidVwiJiZnbG9iYWwmJmdsb2JhbC5wcm9jZXNzJiZnbG9iYWwucHJvY2Vzcy52ZXJzaW9ucyYmZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMubm9kZSk7SC5nbG9iYWw9SC5pc05vZGUmJmdsb2JhbHx8dHlwZW9mIHdpbmRvdzxcInVcIiYmd2luZG93fHx0eXBlb2Ygc2VsZjxcInVcIiYmc2VsZnx8cmk7SC5lbXB0eUFycmF5PU9iamVjdC5mcmVlemU/T2JqZWN0LmZyZWV6ZShbXSk6W107SC5lbXB0eU9iamVjdD1PYmplY3QuZnJlZXplP09iamVjdC5mcmVlemUoe30pOnt9O0guaXNJbnRlZ2VyPU51bWJlci5pc0ludGVnZXJ8fGZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09XCJudW1iZXJcIiYmaXNGaW5pdGUodCkmJk1hdGguZmxvb3IodCk9PT10fTtILmlzU3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09XCJzdHJpbmdcInx8dCBpbnN0YW5jZW9mIFN0cmluZ307SC5pc09iamVjdD1mdW5jdGlvbih0KXtyZXR1cm4gdCYmdHlwZW9mIHQ9PVwib2JqZWN0XCJ9O0guaXNzZXQ9SC5pc1NldD1mdW5jdGlvbih0LG8pe3ZhciBlPXRbb107cmV0dXJuIGUhPW51bGwmJnQuaGFzT3duUHJvcGVydHkobyk/dHlwZW9mIGUhPVwib2JqZWN0XCJ8fChBcnJheS5pc0FycmF5KGUpP2UubGVuZ3RoOk9iamVjdC5rZXlzKGUpLmxlbmd0aCk+MDohMX07SC5CdWZmZXI9ZnVuY3Rpb24oKXt0cnl7dmFyIGE9SC5pbnF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtyZXR1cm4gYS5wcm90b3R5cGUudXRmOFdyaXRlP2E6bnVsbH1jYXRjaHtyZXR1cm4gbnVsbH19KCk7SC5fQnVmZmVyX2Zyb209bnVsbDtILl9CdWZmZXJfYWxsb2NVbnNhZmU9bnVsbDtILm5ld0J1ZmZlcj1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PVwibnVtYmVyXCI/SC5CdWZmZXI/SC5fQnVmZmVyX2FsbG9jVW5zYWZlKHQpOm5ldyBILkFycmF5KHQpOkguQnVmZmVyP0guX0J1ZmZlcl9mcm9tKHQpOnR5cGVvZiBVaW50OEFycmF5PlwidVwiP3Q6bmV3IFVpbnQ4QXJyYXkodCl9O0guQXJyYXk9dHlwZW9mIFVpbnQ4QXJyYXk8XCJ1XCI/VWludDhBcnJheTpBcnJheTtILkxvbmc9SC5nbG9iYWwuZGNvZGVJTyYmSC5nbG9iYWwuZGNvZGVJTy5Mb25nfHxILmdsb2JhbC5Mb25nfHxILmlucXVpcmUoXCJsb25nXCIpO0gua2V5MlJlPS9edHJ1ZXxmYWxzZXwwfDEkLztILmtleTMyUmU9L14tPyg/OjB8WzEtOV1bMC05XSopJC87SC5rZXk2NFJlPS9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLztILmxvbmdUb0hhc2g9ZnVuY3Rpb24odCl7cmV0dXJuIHQ/SC5Mb25nQml0cy5mcm9tKHQpLnRvSGFzaCgpOkguTG9uZ0JpdHMuemVyb0hhc2h9O0gubG9uZ0Zyb21IYXNoPWZ1bmN0aW9uKHQsbyl7dmFyIGU9SC5Mb25nQml0cy5mcm9tSGFzaCh0KTtyZXR1cm4gSC5Mb25nP0guTG9uZy5mcm9tQml0cyhlLmxvLGUuaGksbyk6ZS50b051bWJlcighIW8pfTtmdW5jdGlvbiBpdShhLHQsbyl7Zm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLHI9MDtyPGUubGVuZ3RoOysrcikoYVtlW3JdXT09PXZvaWQgMHx8IW8pJiYoYVtlW3JdXT10W2Vbcl1dKTtyZXR1cm4gYX1ILm1lcmdlPWl1O0gubGNGaXJzdD1mdW5jdGlvbih0KXtyZXR1cm4gdC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSt0LnN1YnN0cmluZygxKX07ZnVuY3Rpb24gYXUoYSl7ZnVuY3Rpb24gdChvLGUpe2lmKCEodGhpcyBpbnN0YW5jZW9mIHQpKXJldHVybiBuZXcgdChvLGUpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwibWVzc2FnZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gb319KSxFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT9FcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLHQpOk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwic3RhY2tcIix7dmFsdWU6bmV3IEVycm9yKCkuc3RhY2t8fFwiXCJ9KSxlJiZpdSh0aGlzLGUpfXJldHVybiB0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsd3JpdGFibGU6ITAsZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9LG5hbWU6e2dldDpmdW5jdGlvbigpe3JldHVybiBhfSxzZXQ6dm9pZCAwLGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSx0b1N0cmluZzp7dmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lK1wiOiBcIit0aGlzLm1lc3NhZ2V9LHdyaXRhYmxlOiEwLGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfX0pLHR9SC5uZXdFcnJvcj1hdTtILlByb3RvY29sRXJyb3I9YXUoXCJQcm90b2NvbEVycm9yXCIpO0gub25lT2ZHZXR0ZXI9ZnVuY3Rpb24odCl7Zm9yKHZhciBvPXt9LGU9MDtlPHQubGVuZ3RoOysrZSlvW3RbZV1dPTE7cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciByPU9iamVjdC5rZXlzKHRoaXMpLG49ci5sZW5ndGgtMTtuPi0xOy0tbilpZihvW3Jbbl1dPT09MSYmdGhpc1tyW25dXSE9PXZvaWQgMCYmdGhpc1tyW25dXSE9PW51bGwpcmV0dXJuIHJbbl19fTtILm9uZU9mU2V0dGVyPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihvKXtmb3IodmFyIGU9MDtlPHQubGVuZ3RoOysrZSl0W2VdIT09byYmZGVsZXRlIHRoaXNbdFtlXV19fTtILnRvSlNPTk9wdGlvbnM9e2xvbmdzOlN0cmluZyxlbnVtczpTdHJpbmcsYnl0ZXM6U3RyaW5nLGpzb246ITB9O0guX2NvbmZpZ3VyZT1mdW5jdGlvbigpe3ZhciBhPUguQnVmZmVyO2lmKCFhKXtILl9CdWZmZXJfZnJvbT1ILl9CdWZmZXJfYWxsb2NVbnNhZmU9bnVsbDtyZXR1cm59SC5fQnVmZmVyX2Zyb209YS5mcm9tIT09VWludDhBcnJheS5mcm9tJiZhLmZyb218fGZ1bmN0aW9uKG8sZSl7cmV0dXJuIG5ldyBhKG8sZSl9LEguX0J1ZmZlcl9hbGxvY1Vuc2FmZT1hLmFsbG9jVW5zYWZlfHxmdW5jdGlvbihvKXtyZXR1cm4gbmV3IGEobyl9fX0pO3ZhciBsaT1tZSgoRnksZnUpPT57XCJ1c2Ugc3RyaWN0XCI7ZnUuZXhwb3J0cz1zZTt2YXIgbHQ9WHQoKSxuaSxqbj1sdC5Mb25nQml0cyxzdT1sdC5iYXNlNjQsdXU9bHQudXRmODtmdW5jdGlvbiBhbihhLHQsbyl7dGhpcy5mbj1hLHRoaXMubGVuPXQsdGhpcy5uZXh0PXZvaWQgMCx0aGlzLnZhbD1vfWZ1bmN0aW9uIGlpKCl7fWZ1bmN0aW9uIFVkKGEpe3RoaXMuaGVhZD1hLmhlYWQsdGhpcy50YWlsPWEudGFpbCx0aGlzLmxlbj1hLmxlbix0aGlzLm5leHQ9YS5zdGF0ZXN9ZnVuY3Rpb24gc2UoKXt0aGlzLmxlbj0wLHRoaXMuaGVhZD1uZXcgYW4oaWksMCwwKSx0aGlzLnRhaWw9dGhpcy5oZWFkLHRoaXMuc3RhdGVzPW51bGx9dmFyIGx1PWZ1bmN0aW9uKCl7cmV0dXJuIGx0LkJ1ZmZlcj9mdW5jdGlvbigpe3JldHVybihzZS5jcmVhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG5pfSkoKX06ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHNlfX07c2UuY3JlYXRlPWx1KCk7c2UuYWxsb2M9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBsdC5BcnJheSh0KX07bHQuQXJyYXkhPT1BcnJheSYmKHNlLmFsbG9jPWx0LnBvb2woc2UuYWxsb2MsbHQuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5KSk7c2UucHJvdG90eXBlLl9wdXNoPWZ1bmN0aW9uKHQsbyxlKXtyZXR1cm4gdGhpcy50YWlsPXRoaXMudGFpbC5uZXh0PW5ldyBhbih0LG8sZSksdGhpcy5sZW4rPW8sdGhpc307ZnVuY3Rpb24gYWkoYSx0LG8pe3Rbb109YSYyNTV9ZnVuY3Rpb24gemQoYSx0LG8pe2Zvcig7YT4xMjc7KXRbbysrXT1hJjEyN3wxMjgsYT4+Pj03O3Rbb109YX1mdW5jdGlvbiBzaShhLHQpe3RoaXMubGVuPWEsdGhpcy5uZXh0PXZvaWQgMCx0aGlzLnZhbD10fXNpLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGFuLnByb3RvdHlwZSk7c2kucHJvdG90eXBlLmZuPXpkO3NlLnByb3RvdHlwZS51aW50MzI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubGVuKz0odGhpcy50YWlsPXRoaXMudGFpbC5uZXh0PW5ldyBzaSgodD10Pj4+MCk8MTI4PzE6dDwxNjM4ND8yOnQ8MjA5NzE1Mj8zOnQ8MjY4NDM1NDU2PzQ6NSx0KSkubGVuLHRoaXN9O3NlLnByb3RvdHlwZS5pbnQzMj1mdW5jdGlvbih0KXtyZXR1cm4gdDwwP3RoaXMuX3B1c2godWksMTAsam4uZnJvbU51bWJlcih0KSk6dGhpcy51aW50MzIodCl9O3NlLnByb3RvdHlwZS5zaW50MzI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudWludDMyKCh0PDwxXnQ+PjMxKT4+PjApfTtmdW5jdGlvbiB1aShhLHQsbyl7Zm9yKDthLmhpOyl0W28rK109YS5sbyYxMjd8MTI4LGEubG89KGEubG8+Pj43fGEuaGk8PDI1KT4+PjAsYS5oaT4+Pj03O2Zvcig7YS5sbz4xMjc7KXRbbysrXT1hLmxvJjEyN3wxMjgsYS5sbz1hLmxvPj4+Nzt0W28rK109YS5sb31zZS5wcm90b3R5cGUudWludDY0PWZ1bmN0aW9uKHQpe3ZhciBvPWpuLmZyb20odCk7cmV0dXJuIHRoaXMuX3B1c2godWksby5sZW5ndGgoKSxvKX07c2UucHJvdG90eXBlLmludDY0PXNlLnByb3RvdHlwZS51aW50NjQ7c2UucHJvdG90eXBlLnNpbnQ2ND1mdW5jdGlvbih0KXt2YXIgbz1qbi5mcm9tKHQpLnp6RW5jb2RlKCk7cmV0dXJuIHRoaXMuX3B1c2godWksby5sZW5ndGgoKSxvKX07c2UucHJvdG90eXBlLmJvb2w9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3B1c2goYWksMSx0PzE6MCl9O2Z1bmN0aW9uIG9pKGEsdCxvKXt0W29dPWEmMjU1LHRbbysxXT1hPj4+OCYyNTUsdFtvKzJdPWE+Pj4xNiYyNTUsdFtvKzNdPWE+Pj4yNH1zZS5wcm90b3R5cGUuZml4ZWQzMj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcHVzaChvaSw0LHQ+Pj4wKX07c2UucHJvdG90eXBlLnNmaXhlZDMyPXNlLnByb3RvdHlwZS5maXhlZDMyO3NlLnByb3RvdHlwZS5maXhlZDY0PWZ1bmN0aW9uKHQpe3ZhciBvPWpuLmZyb20odCk7cmV0dXJuIHRoaXMuX3B1c2gob2ksNCxvLmxvKS5fcHVzaChvaSw0LG8uaGkpfTtzZS5wcm90b3R5cGUuc2ZpeGVkNjQ9c2UucHJvdG90eXBlLmZpeGVkNjQ7c2UucHJvdG90eXBlLmZsb2F0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wdXNoKGx0LmZsb2F0LndyaXRlRmxvYXRMRSw0LHQpfTtzZS5wcm90b3R5cGUuZG91YmxlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wdXNoKGx0LmZsb2F0LndyaXRlRG91YmxlTEUsOCx0KX07dmFyIFZkPWx0LkFycmF5LnByb3RvdHlwZS5zZXQ/ZnVuY3Rpb24odCxvLGUpe28uc2V0KHQsZSl9OmZ1bmN0aW9uKHQsbyxlKXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoOysrcilvW2Urcl09dFtyXX07c2UucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKHQpe3ZhciBvPXQubGVuZ3RoPj4+MDtpZighbylyZXR1cm4gdGhpcy5fcHVzaChhaSwxLDApO2lmKGx0LmlzU3RyaW5nKHQpKXt2YXIgZT1zZS5hbGxvYyhvPXN1Lmxlbmd0aCh0KSk7c3UuZGVjb2RlKHQsZSwwKSx0PWV9cmV0dXJuIHRoaXMudWludDMyKG8pLl9wdXNoKFZkLG8sdCl9O3NlLnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24odCl7dmFyIG89dXUubGVuZ3RoKHQpO3JldHVybiBvP3RoaXMudWludDMyKG8pLl9wdXNoKHV1LndyaXRlLG8sdCk6dGhpcy5fcHVzaChhaSwxLDApfTtzZS5wcm90b3R5cGUuZm9yaz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlcz1uZXcgVWQodGhpcyksdGhpcy5oZWFkPXRoaXMudGFpbD1uZXcgYW4oaWksMCwwKSx0aGlzLmxlbj0wLHRoaXN9O3NlLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlcz8odGhpcy5oZWFkPXRoaXMuc3RhdGVzLmhlYWQsdGhpcy50YWlsPXRoaXMuc3RhdGVzLnRhaWwsdGhpcy5sZW49dGhpcy5zdGF0ZXMubGVuLHRoaXMuc3RhdGVzPXRoaXMuc3RhdGVzLm5leHQpOih0aGlzLmhlYWQ9dGhpcy50YWlsPW5ldyBhbihpaSwwLDApLHRoaXMubGVuPTApLHRoaXN9O3NlLnByb3RvdHlwZS5sZGVsaW09ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhlYWQsbz10aGlzLnRhaWwsZT10aGlzLmxlbjtyZXR1cm4gdGhpcy5yZXNldCgpLnVpbnQzMihlKSxlJiYodGhpcy50YWlsLm5leHQ9dC5uZXh0LHRoaXMudGFpbD1vLHRoaXMubGVuKz1lKSx0aGlzfTtzZS5wcm90b3R5cGUuZmluaXNoPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuaGVhZC5uZXh0LG89dGhpcy5jb25zdHJ1Y3Rvci5hbGxvYyh0aGlzLmxlbiksZT0wO3Q7KXQuZm4odC52YWwsbyxlKSxlKz10Lmxlbix0PXQubmV4dDtyZXR1cm4gb307c2UuX2NvbmZpZ3VyZT1mdW5jdGlvbihhKXtuaT1hLHNlLmNyZWF0ZT1sdSgpLG5pLl9jb25maWd1cmUoKX19KTt2YXIgZHU9bWUoKEN5LHB1KT0+e1widXNlIHN0cmljdFwiO3B1LmV4cG9ydHM9Q3Q7dmFyIGN1PWxpKCk7KEN0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGN1LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPUN0O3ZhciBLdD1YdCgpO2Z1bmN0aW9uIEN0KCl7Y3UuY2FsbCh0aGlzKX1DdC5fY29uZmlndXJlPWZ1bmN0aW9uKCl7Q3QuYWxsb2M9S3QuX0J1ZmZlcl9hbGxvY1Vuc2FmZSxDdC53cml0ZUJ5dGVzQnVmZmVyPUt0LkJ1ZmZlciYmS3QuQnVmZmVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkmJkt0LkJ1ZmZlci5wcm90b3R5cGUuc2V0Lm5hbWU9PT1cInNldFwiP2Z1bmN0aW9uKHQsbyxlKXtvLnNldCh0LGUpfTpmdW5jdGlvbih0LG8sZSl7aWYodC5jb3B5KXQuY29weShvLGUsMCx0Lmxlbmd0aCk7ZWxzZSBmb3IodmFyIHI9MDtyPHQubGVuZ3RoOylvW2UrK109dFtyKytdfX07Q3QucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKHQpe0t0LmlzU3RyaW5nKHQpJiYodD1LdC5fQnVmZmVyX2Zyb20odCxcImJhc2U2NFwiKSk7dmFyIG89dC5sZW5ndGg+Pj4wO3JldHVybiB0aGlzLnVpbnQzMihvKSxvJiZ0aGlzLl9wdXNoKEN0LndyaXRlQnl0ZXNCdWZmZXIsbyx0KSx0aGlzfTtmdW5jdGlvbiBXZChhLHQsbyl7YS5sZW5ndGg8NDA/S3QudXRmOC53cml0ZShhLHQsbyk6dC51dGY4V3JpdGU/dC51dGY4V3JpdGUoYSxvKTp0LndyaXRlKGEsbyl9Q3QucHJvdG90eXBlLnN0cmluZz1mdW5jdGlvbih0KXt2YXIgbz1LdC5CdWZmZXIuYnl0ZUxlbmd0aCh0KTtyZXR1cm4gdGhpcy51aW50MzIobyksbyYmdGhpcy5fcHVzaChXZCxvLHQpLHRoaXN9O0N0Ll9jb25maWd1cmUoKX0pO3ZhciBwaT1tZSgoJHkseXUpPT57XCJ1c2Ugc3RyaWN0XCI7eXUuZXhwb3J0cz1QZTt2YXIgJHQ9WHQoKSxjaSxidT0kdC5Mb25nQml0cyxIZD0kdC51dGY4O2Z1bmN0aW9uIF90KGEsdCl7cmV0dXJuIFJhbmdlRXJyb3IoXCJpbmRleCBvdXQgb2YgcmFuZ2U6IFwiK2EucG9zK1wiICsgXCIrKHR8fDEpK1wiID4gXCIrYS5sZW4pfWZ1bmN0aW9uIFBlKGEpe3RoaXMuYnVmPWEsdGhpcy5wb3M9MCx0aGlzLmxlbj1hLmxlbmd0aH12YXIgaHU9dHlwZW9mIFVpbnQ4QXJyYXk8XCJ1XCI/ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIG5ldyBQZSh0KTt0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpfTpmdW5jdGlvbih0KXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiBuZXcgUGUodCk7dGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKX0sZ3U9ZnVuY3Rpb24oKXtyZXR1cm4gJHQuQnVmZmVyP2Z1bmN0aW9uKG8pe3JldHVybihQZS5jcmVhdGU9ZnVuY3Rpb24ocil7cmV0dXJuICR0LkJ1ZmZlci5pc0J1ZmZlcihyKT9uZXcgY2kocik6aHUocil9KShvKX06aHV9O1BlLmNyZWF0ZT1ndSgpO1BlLnByb3RvdHlwZS5fc2xpY2U9JHQuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5fHwkdC5BcnJheS5wcm90b3R5cGUuc2xpY2U7UGUucHJvdG90eXBlLnVpbnQzMj1mdW5jdGlvbigpe3ZhciB0PTQyOTQ5NjcyOTU7cmV0dXJuIGZ1bmN0aW9uKCl7aWYodD0odGhpcy5idWZbdGhpcy5wb3NdJjEyNyk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOHx8KHQ9KHR8KHRoaXMuYnVmW3RoaXMucG9zXSYxMjcpPDw3KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXx8KHQ9KHR8KHRoaXMuYnVmW3RoaXMucG9zXSYxMjcpPDwxNCk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOCl8fCh0PSh0fCh0aGlzLmJ1Zlt0aGlzLnBvc10mMTI3KTw8MjEpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpfHwodD0odHwodGhpcy5idWZbdGhpcy5wb3NdJjE1KTw8MjgpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpKXJldHVybiB0O2lmKCh0aGlzLnBvcys9NSk+dGhpcy5sZW4pdGhyb3cgdGhpcy5wb3M9dGhpcy5sZW4sX3QodGhpcywxMCk7cmV0dXJuIHR9fSgpO1BlLnByb3RvdHlwZS5pbnQzMj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVpbnQzMigpfDB9O1BlLnByb3RvdHlwZS5zaW50MzI9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnVpbnQzMigpO3JldHVybiB0Pj4+MV4tKHQmMSl8MH07ZnVuY3Rpb24gZmkoKXt2YXIgYT1uZXcgYnUoMCwwKSx0PTA7aWYodGhpcy5sZW4tdGhpcy5wb3M+NCl7Zm9yKDt0PDQ7Kyt0KWlmKGEubG89KGEubG98KHRoaXMuYnVmW3RoaXMucG9zXSYxMjcpPDx0KjcpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGE7aWYoYS5sbz0oYS5sb3wodGhpcy5idWZbdGhpcy5wb3NdJjEyNyk8PDI4KT4+PjAsYS5oaT0oYS5oaXwodGhpcy5idWZbdGhpcy5wb3NdJjEyNyk+PjQpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGE7dD0wfWVsc2V7Zm9yKDt0PDM7Kyt0KXtpZih0aGlzLnBvcz49dGhpcy5sZW4pdGhyb3cgX3QodGhpcyk7aWYoYS5sbz0oYS5sb3wodGhpcy5idWZbdGhpcy5wb3NdJjEyNyk8PHQqNyk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gYX1yZXR1cm4gYS5sbz0oYS5sb3wodGhpcy5idWZbdGhpcy5wb3MrK10mMTI3KTw8dCo3KT4+PjAsYX1pZih0aGlzLmxlbi10aGlzLnBvcz40KXtmb3IoO3Q8NTsrK3QpaWYoYS5oaT0oYS5oaXwodGhpcy5idWZbdGhpcy5wb3NdJjEyNyk8PHQqNyszKT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBhfWVsc2UgZm9yKDt0PDU7Kyt0KXtpZih0aGlzLnBvcz49dGhpcy5sZW4pdGhyb3cgX3QodGhpcyk7aWYoYS5oaT0oYS5oaXwodGhpcy5idWZbdGhpcy5wb3NdJjEyNyk8PHQqNyszKT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBhfXRocm93IEVycm9yKFwiaW52YWxpZCB2YXJpbnQgZW5jb2RpbmdcIil9UGUucHJvdG90eXBlLmJvb2w9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51aW50MzIoKSE9PTB9O2Z1bmN0aW9uIFluKGEsdCl7cmV0dXJuKGFbdC00XXxhW3QtM108PDh8YVt0LTJdPDwxNnxhW3QtMV08PDI0KT4+PjB9UGUucHJvdG90eXBlLmZpeGVkMzI9ZnVuY3Rpb24oKXtpZih0aGlzLnBvcys0PnRoaXMubGVuKXRocm93IF90KHRoaXMsNCk7cmV0dXJuIFluKHRoaXMuYnVmLHRoaXMucG9zKz00KX07UGUucHJvdG90eXBlLnNmaXhlZDMyPWZ1bmN0aW9uKCl7aWYodGhpcy5wb3MrND50aGlzLmxlbil0aHJvdyBfdCh0aGlzLDQpO3JldHVybiBZbih0aGlzLmJ1Zix0aGlzLnBvcys9NCl8MH07ZnVuY3Rpb24gbXUoKXtpZih0aGlzLnBvcys4PnRoaXMubGVuKXRocm93IF90KHRoaXMsOCk7cmV0dXJuIG5ldyBidShZbih0aGlzLmJ1Zix0aGlzLnBvcys9NCksWW4odGhpcy5idWYsdGhpcy5wb3MrPTQpKX1QZS5wcm90b3R5cGUuZmxvYXQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBvcys0PnRoaXMubGVuKXRocm93IF90KHRoaXMsNCk7dmFyIHQ9JHQuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsdGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9NCx0fTtQZS5wcm90b3R5cGUuZG91YmxlPWZ1bmN0aW9uKCl7aWYodGhpcy5wb3MrOD50aGlzLmxlbil0aHJvdyBfdCh0aGlzLDQpO3ZhciB0PSR0LmZsb2F0LnJlYWREb3VibGVMRSh0aGlzLmJ1Zix0aGlzLnBvcyk7cmV0dXJuIHRoaXMucG9zKz04LHR9O1BlLnByb3RvdHlwZS5ieXRlcz1mdW5jdGlvbigpe3ZhciB0PXRoaXMudWludDMyKCksbz10aGlzLnBvcyxlPXRoaXMucG9zK3Q7aWYoZT50aGlzLmxlbil0aHJvdyBfdCh0aGlzLHQpO3JldHVybiB0aGlzLnBvcys9dCxBcnJheS5pc0FycmF5KHRoaXMuYnVmKT90aGlzLmJ1Zi5zbGljZShvLGUpOm89PT1lP25ldyB0aGlzLmJ1Zi5jb25zdHJ1Y3RvcigwKTp0aGlzLl9zbGljZS5jYWxsKHRoaXMuYnVmLG8sZSl9O1BlLnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmJ5dGVzKCk7cmV0dXJuIEhkLnJlYWQodCwwLHQubGVuZ3RoKX07UGUucHJvdG90eXBlLnNraXA9ZnVuY3Rpb24odCl7aWYodHlwZW9mIHQ9PVwibnVtYmVyXCIpe2lmKHRoaXMucG9zK3Q+dGhpcy5sZW4pdGhyb3cgX3QodGhpcyx0KTt0aGlzLnBvcys9dH1lbHNlIGRvIGlmKHRoaXMucG9zPj10aGlzLmxlbil0aHJvdyBfdCh0aGlzKTt3aGlsZSh0aGlzLmJ1Zlt0aGlzLnBvcysrXSYxMjgpO3JldHVybiB0aGlzfTtQZS5wcm90b3R5cGUuc2tpcFR5cGU9ZnVuY3Rpb24oYSl7c3dpdGNoKGEpe2Nhc2UgMDp0aGlzLnNraXAoKTticmVhaztjYXNlIDE6dGhpcy5za2lwKDgpO2JyZWFrO2Nhc2UgMjp0aGlzLnNraXAodGhpcy51aW50MzIoKSk7YnJlYWs7Y2FzZSAzOmZvcig7KGE9dGhpcy51aW50MzIoKSY3KSE9PTQ7KXRoaXMuc2tpcFR5cGUoYSk7YnJlYWs7Y2FzZSA1OnRoaXMuc2tpcCg0KTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIrYStcIiBhdCBvZmZzZXQgXCIrdGhpcy5wb3MpfXJldHVybiB0aGlzfTtQZS5fY29uZmlndXJlPWZ1bmN0aW9uKGEpe2NpPWEsUGUuY3JlYXRlPWd1KCksY2kuX2NvbmZpZ3VyZSgpO3ZhciB0PSR0Lkxvbmc/XCJ0b0xvbmdcIjpcInRvTnVtYmVyXCI7JHQubWVyZ2UoUGUucHJvdG90eXBlLHtpbnQ2NDpmdW5jdGlvbigpe3JldHVybiBmaS5jYWxsKHRoaXMpW3RdKCExKX0sdWludDY0OmZ1bmN0aW9uKCl7cmV0dXJuIGZpLmNhbGwodGhpcylbdF0oITApfSxzaW50NjQ6ZnVuY3Rpb24oKXtyZXR1cm4gZmkuY2FsbCh0aGlzKS56ekRlY29kZSgpW3RdKCExKX0sZml4ZWQ2NDpmdW5jdGlvbigpe3JldHVybiBtdS5jYWxsKHRoaXMpW3RdKCEwKX0sc2ZpeGVkNjQ6ZnVuY3Rpb24oKXtyZXR1cm4gbXUuY2FsbCh0aGlzKVt0XSghMSl9fSl9fSk7dmFyIHZ1PW1lKChreSx3dSk9PntcInVzZSBzdHJpY3RcIjt3dS5leHBvcnRzPWNyO3ZhciB4dT1waSgpOyhjci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh4dS5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1jcjt2YXIgVHU9WHQoKTtmdW5jdGlvbiBjcihhKXt4dS5jYWxsKHRoaXMsYSl9Y3IuX2NvbmZpZ3VyZT1mdW5jdGlvbigpe1R1LkJ1ZmZlciYmKGNyLnByb3RvdHlwZS5fc2xpY2U9VHUuQnVmZmVyLnByb3RvdHlwZS5zbGljZSl9O2NyLnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnVpbnQzMigpO3JldHVybiB0aGlzLmJ1Zi51dGY4U2xpY2U/dGhpcy5idWYudXRmOFNsaWNlKHRoaXMucG9zLHRoaXMucG9zPU1hdGgubWluKHRoaXMucG9zK3QsdGhpcy5sZW4pKTp0aGlzLmJ1Zi50b1N0cmluZyhcInV0Zi04XCIsdGhpcy5wb3MsdGhpcy5wb3M9TWF0aC5taW4odGhpcy5wb3MrdCx0aGlzLmxlbikpfTtjci5fY29uZmlndXJlKCl9KTt2YXIgT3U9bWUoKEJ5LF91KT0+e1widXNlIHN0cmljdFwiO191LmV4cG9ydHM9c247dmFyIGRpPVh0KCk7KHNuLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGRpLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1zbjtmdW5jdGlvbiBzbihhLHQsbyl7aWYodHlwZW9mIGEhPVwiZnVuY3Rpb25cIil0aHJvdyBUeXBlRXJyb3IoXCJycGNJbXBsIG11c3QgYmUgYSBmdW5jdGlvblwiKTtkaS5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSx0aGlzLnJwY0ltcGw9YSx0aGlzLnJlcXVlc3REZWxpbWl0ZWQ9ISF0LHRoaXMucmVzcG9uc2VEZWxpbWl0ZWQ9ISFvfXNuLnByb3RvdHlwZS5ycGNDYWxsPWZ1bmN0aW9uIGEodCxvLGUscixuKXtpZighcil0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0IG11c3QgYmUgc3BlY2lmaWVkXCIpO3ZhciBzPXRoaXM7aWYoIW4pcmV0dXJuIGRpLmFzUHJvbWlzZShhLHMsdCxvLGUscik7aWYoIXMucnBjSW1wbCl7c2V0VGltZW91dChmdW5jdGlvbigpe24oRXJyb3IoXCJhbHJlYWR5IGVuZGVkXCIpKX0sMCk7cmV0dXJufXRyeXtyZXR1cm4gcy5ycGNJbXBsKHQsb1tzLnJlcXVlc3REZWxpbWl0ZWQ/XCJlbmNvZGVEZWxpbWl0ZWRcIjpcImVuY29kZVwiXShyKS5maW5pc2goKSxmdW5jdGlvbih1LGwpe2lmKHUpcmV0dXJuIHMuZW1pdChcImVycm9yXCIsdSx0KSxuKHUpO2lmKGw9PT1udWxsKXtzLmVuZCghMCk7cmV0dXJufWlmKCEobCBpbnN0YW5jZW9mIGUpKXRyeXtsPWVbcy5yZXNwb25zZURlbGltaXRlZD9cImRlY29kZURlbGltaXRlZFwiOlwiZGVjb2RlXCJdKGwpfWNhdGNoKGYpe3JldHVybiBzLmVtaXQoXCJlcnJvclwiLGYsdCksbihmKX1yZXR1cm4gcy5lbWl0KFwiZGF0YVwiLGwsdCksbihudWxsLGwpfSl9Y2F0Y2goaSl7cy5lbWl0KFwiZXJyb3JcIixpLHQpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtuKGkpfSwwKTtyZXR1cm59fTtzbi5wcm90b3R5cGUuZW5kPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnJwY0ltcGwmJih0fHx0aGlzLnJwY0ltcGwobnVsbCxudWxsLG51bGwpLHRoaXMucnBjSW1wbD1udWxsLHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKSksdGhpc319KTt2YXIgU3U9bWUoSXU9PntcInVzZSBzdHJpY3RcIjt2YXIgcWQ9SXU7cWQuU2VydmljZT1PdSgpfSk7dmFyIFB1PW1lKChSeSxBdSk9PntcInVzZSBzdHJpY3RcIjtBdS5leHBvcnRzPXt9fSk7dmFyIEx1PW1lKER1PT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHJ0PUR1O3J0LmJ1aWxkPVwibWluaW1hbFwiO3J0LldyaXRlcj1saSgpO3J0LkJ1ZmZlcldyaXRlcj1kdSgpO3J0LlJlYWRlcj1waSgpO3J0LkJ1ZmZlclJlYWRlcj12dSgpO3J0LnV0aWw9WHQoKTtydC5ycGM9U3UoKTtydC5yb290cz1QdSgpO3J0LmNvbmZpZ3VyZT1FdTtmdW5jdGlvbiBFdSgpe3J0LnV0aWwuX2NvbmZpZ3VyZSgpLHJ0LldyaXRlci5fY29uZmlndXJlKHJ0LkJ1ZmZlcldyaXRlcikscnQuUmVhZGVyLl9jb25maWd1cmUocnQuQnVmZmVyUmVhZGVyKX1FdSgpfSk7dmFyIEN1PW1lKChHeSxGdSk9PntcInVzZSBzdHJpY3RcIjtGdS5leHBvcnRzPUx1KCl9KTt2YXIgJHI9bWUoKFV5LCR1KT0+e1widXNlIHN0cmljdFwiO3ZhciBnZT1DdSgpLE49Z2UuUmVhZGVyLEVlPWdlLldyaXRlcix5PWdlLnV0aWwsbT1nZS5yb290cy5kZWZhdWx0fHwoZ2Uucm9vdHMuZGVmYXVsdD17fSk7bS5vbm54PWZ1bmN0aW9uKCl7dmFyIGE9e307cmV0dXJuIGEuVmVyc2lvbj1mdW5jdGlvbigpe3ZhciB0PXt9LG89T2JqZWN0LmNyZWF0ZSh0KTtyZXR1cm4gb1t0WzBdPVwiX1NUQVJUX1ZFUlNJT05cIl09MCxvW3RbMV09XCJJUl9WRVJTSU9OXzIwMTdfMTBfMTBcIl09MSxvW3RbMl09XCJJUl9WRVJTSU9OXzIwMTdfMTBfMzBcIl09MixvW3RbM109XCJJUl9WRVJTSU9OXzIwMTdfMTFfM1wiXT0zLG9bdFs0XT1cIklSX1ZFUlNJT05fMjAxOV8xXzIyXCJdPTQsb1t0WzVdPVwiSVJfVkVSU0lPTl8yMDE5XzNfMThcIl09NSxvW3RbNl09XCJJUl9WRVJTSU9OXzIwMTlfOV8xOVwiXT02LG9bdFs3XT1cIklSX1ZFUlNJT05fMjAyMF81XzhcIl09NyxvW3RbOF09XCJJUl9WRVJTSU9OXzIwMjFfN18zMFwiXT04LG9bdFs5XT1cIklSX1ZFUlNJT05cIl09OSxvfSgpLGEuQXR0cmlidXRlUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KG8pe2lmKHRoaXMuZmxvYXRzPVtdLHRoaXMuaW50cz1bXSx0aGlzLnN0cmluZ3M9W10sdGhpcy50ZW5zb3JzPVtdLHRoaXMuZ3JhcGhzPVtdLHRoaXMuc3BhcnNlVGVuc29ycz1bXSx0aGlzLnR5cGVQcm90b3M9W10sbylmb3IodmFyIGU9T2JqZWN0LmtleXMobykscj0wO3I8ZS5sZW5ndGg7KytyKW9bZVtyXV0hPW51bGwmJih0aGlzW2Vbcl1dPW9bZVtyXV0pfXJldHVybiB0LnByb3RvdHlwZS5uYW1lPVwiXCIsdC5wcm90b3R5cGUucmVmQXR0ck5hbWU9XCJcIix0LnByb3RvdHlwZS5kb2NTdHJpbmc9XCJcIix0LnByb3RvdHlwZS50eXBlPTAsdC5wcm90b3R5cGUuZj0wLHQucHJvdG90eXBlLmk9eS5Mb25nP3kuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsdC5wcm90b3R5cGUucz15Lm5ld0J1ZmZlcihbXSksdC5wcm90b3R5cGUudD1udWxsLHQucHJvdG90eXBlLmc9bnVsbCx0LnByb3RvdHlwZS5zcGFyc2VUZW5zb3I9bnVsbCx0LnByb3RvdHlwZS50cD1udWxsLHQucHJvdG90eXBlLmZsb2F0cz15LmVtcHR5QXJyYXksdC5wcm90b3R5cGUuaW50cz15LmVtcHR5QXJyYXksdC5wcm90b3R5cGUuc3RyaW5ncz15LmVtcHR5QXJyYXksdC5wcm90b3R5cGUudGVuc29ycz15LmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZ3JhcGhzPXkuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5zcGFyc2VUZW5zb3JzPXkuZW1wdHlBcnJheSx0LnByb3RvdHlwZS50eXBlUHJvdG9zPXkuZW1wdHlBcnJheSx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKGUscil7aWYocnx8KHI9RWUuY3JlYXRlKCkpLGUubmFtZSE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcIm5hbWVcIikmJnIudWludDMyKDEwKS5zdHJpbmcoZS5uYW1lKSxlLmYhPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJmXCIpJiZyLnVpbnQzMigyMSkuZmxvYXQoZS5mKSxlLmkhPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJpXCIpJiZyLnVpbnQzMigyNCkuaW50NjQoZS5pKSxlLnMhPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJzXCIpJiZyLnVpbnQzMigzNCkuYnl0ZXMoZS5zKSxlLnQhPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJ0XCIpJiZtLm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKGUudCxyLnVpbnQzMig0MikuZm9yaygpKS5sZGVsaW0oKSxlLmchPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJnXCIpJiZtLm9ubnguR3JhcGhQcm90by5lbmNvZGUoZS5nLHIudWludDMyKDUwKS5mb3JrKCkpLmxkZWxpbSgpLGUuZmxvYXRzIT1udWxsJiZlLmZsb2F0cy5sZW5ndGgpe3IudWludDMyKDU4KS5mb3JrKCk7Zm9yKHZhciBuPTA7bjxlLmZsb2F0cy5sZW5ndGg7KytuKXIuZmxvYXQoZS5mbG9hdHNbbl0pO3IubGRlbGltKCl9aWYoZS5pbnRzIT1udWxsJiZlLmludHMubGVuZ3RoKXtyLnVpbnQzMig2NikuZm9yaygpO2Zvcih2YXIgbj0wO248ZS5pbnRzLmxlbmd0aDsrK24pci5pbnQ2NChlLmludHNbbl0pO3IubGRlbGltKCl9aWYoZS5zdHJpbmdzIT1udWxsJiZlLnN0cmluZ3MubGVuZ3RoKWZvcih2YXIgbj0wO248ZS5zdHJpbmdzLmxlbmd0aDsrK24pci51aW50MzIoNzQpLmJ5dGVzKGUuc3RyaW5nc1tuXSk7aWYoZS50ZW5zb3JzIT1udWxsJiZlLnRlbnNvcnMubGVuZ3RoKWZvcih2YXIgbj0wO248ZS50ZW5zb3JzLmxlbmd0aDsrK24pbS5vbm54LlRlbnNvclByb3RvLmVuY29kZShlLnRlbnNvcnNbbl0sci51aW50MzIoODIpLmZvcmsoKSkubGRlbGltKCk7aWYoZS5ncmFwaHMhPW51bGwmJmUuZ3JhcGhzLmxlbmd0aClmb3IodmFyIG49MDtuPGUuZ3JhcGhzLmxlbmd0aDsrK24pbS5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKGUuZ3JhcGhzW25dLHIudWludDMyKDkwKS5mb3JrKCkpLmxkZWxpbSgpO2lmKGUuZG9jU3RyaW5nIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiZG9jU3RyaW5nXCIpJiZyLnVpbnQzMigxMDYpLnN0cmluZyhlLmRvY1N0cmluZyksZS50cCE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcInRwXCIpJiZtLm9ubnguVHlwZVByb3RvLmVuY29kZShlLnRwLHIudWludDMyKDExNCkuZm9yaygpKS5sZGVsaW0oKSxlLnR5cGVQcm90b3MhPW51bGwmJmUudHlwZVByb3Rvcy5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLnR5cGVQcm90b3MubGVuZ3RoOysrbiltLm9ubnguVHlwZVByb3RvLmVuY29kZShlLnR5cGVQcm90b3Nbbl0sci51aW50MzIoMTIyKS5mb3JrKCkpLmxkZWxpbSgpO2lmKGUudHlwZSE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcInR5cGVcIikmJnIudWludDMyKDE2MCkuaW50MzIoZS50eXBlKSxlLnJlZkF0dHJOYW1lIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwicmVmQXR0ck5hbWVcIikmJnIudWludDMyKDE3MCkuc3RyaW5nKGUucmVmQXR0ck5hbWUpLGUuc3BhcnNlVGVuc29yIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwic3BhcnNlVGVuc29yXCIpJiZtLm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZW5jb2RlKGUuc3BhcnNlVGVuc29yLHIudWludDMyKDE3OCkuZm9yaygpKS5sZGVsaW0oKSxlLnNwYXJzZVRlbnNvcnMhPW51bGwmJmUuc3BhcnNlVGVuc29ycy5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLnNwYXJzZVRlbnNvcnMubGVuZ3RoOysrbiltLm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZW5jb2RlKGUuc3BhcnNlVGVuc29yc1tuXSxyLnVpbnQzMigxODYpLmZvcmsoKSkubGRlbGltKCk7cmV0dXJuIHJ9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUscil7cmV0dXJuIHRoaXMuZW5jb2RlKGUscikubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKGUscil7ZSBpbnN0YW5jZW9mIE58fChlPU4uY3JlYXRlKGUpKTtmb3IodmFyIG49cj09PXZvaWQgMD9lLmxlbjplLnBvcytyLHM9bmV3IG0ub25ueC5BdHRyaWJ1dGVQcm90bztlLnBvczxuOyl7dmFyIGk9ZS51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTp7cy5uYW1lPWUuc3RyaW5nKCk7YnJlYWt9Y2FzZSAyMTp7cy5yZWZBdHRyTmFtZT1lLnN0cmluZygpO2JyZWFrfWNhc2UgMTM6e3MuZG9jU3RyaW5nPWUuc3RyaW5nKCk7YnJlYWt9Y2FzZSAyMDp7cy50eXBlPWUuaW50MzIoKTticmVha31jYXNlIDI6e3MuZj1lLmZsb2F0KCk7YnJlYWt9Y2FzZSAzOntzLmk9ZS5pbnQ2NCgpO2JyZWFrfWNhc2UgNDp7cy5zPWUuYnl0ZXMoKTticmVha31jYXNlIDU6e3MudD1tLm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWt9Y2FzZSA2OntzLmc9bS5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWt9Y2FzZSAyMjp7cy5zcGFyc2VUZW5zb3I9bS5vbm54LlNwYXJzZVRlbnNvclByb3RvLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrfWNhc2UgMTQ6e3MudHA9bS5vbm54LlR5cGVQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVha31jYXNlIDc6e2lmKHMuZmxvYXRzJiZzLmZsb2F0cy5sZW5ndGh8fChzLmZsb2F0cz1bXSksKGkmNyk9PT0yKWZvcih2YXIgdT1lLnVpbnQzMigpK2UucG9zO2UucG9zPHU7KXMuZmxvYXRzLnB1c2goZS5mbG9hdCgpKTtlbHNlIHMuZmxvYXRzLnB1c2goZS5mbG9hdCgpKTticmVha31jYXNlIDg6e2lmKHMuaW50cyYmcy5pbnRzLmxlbmd0aHx8KHMuaW50cz1bXSksKGkmNyk9PT0yKWZvcih2YXIgdT1lLnVpbnQzMigpK2UucG9zO2UucG9zPHU7KXMuaW50cy5wdXNoKGUuaW50NjQoKSk7ZWxzZSBzLmludHMucHVzaChlLmludDY0KCkpO2JyZWFrfWNhc2UgOTp7cy5zdHJpbmdzJiZzLnN0cmluZ3MubGVuZ3RofHwocy5zdHJpbmdzPVtdKSxzLnN0cmluZ3MucHVzaChlLmJ5dGVzKCkpO2JyZWFrfWNhc2UgMTA6e3MudGVuc29ycyYmcy50ZW5zb3JzLmxlbmd0aHx8KHMudGVuc29ycz1bXSkscy50ZW5zb3JzLnB1c2gobS5vbm54LlRlbnNvclByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVha31jYXNlIDExOntzLmdyYXBocyYmcy5ncmFwaHMubGVuZ3RofHwocy5ncmFwaHM9W10pLHMuZ3JhcGhzLnB1c2gobS5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrfWNhc2UgMjM6e3Muc3BhcnNlVGVuc29ycyYmcy5zcGFyc2VUZW5zb3JzLmxlbmd0aHx8KHMuc3BhcnNlVGVuc29ycz1bXSkscy5zcGFyc2VUZW5zb3JzLnB1c2gobS5vbm54LlNwYXJzZVRlbnNvclByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVha31jYXNlIDE1OntzLnR5cGVQcm90b3MmJnMudHlwZVByb3Rvcy5sZW5ndGh8fChzLnR5cGVQcm90b3M9W10pLHMudHlwZVByb3Rvcy5wdXNoKG0ub25ueC5UeXBlUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrfWRlZmF1bHQ6ZS5za2lwVHlwZShpJjcpO2JyZWFrfX1yZXR1cm4gc30sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBOfHwoZT1uZXcgTihlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYodHlwZW9mIGUhPVwib2JqZWN0XCJ8fGU9PT1udWxsKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYoZS5uYW1lIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmIXkuaXNTdHJpbmcoZS5uYW1lKSlyZXR1cm5cIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKGUucmVmQXR0ck5hbWUhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJyZWZBdHRyTmFtZVwiKSYmIXkuaXNTdHJpbmcoZS5yZWZBdHRyTmFtZSkpcmV0dXJuXCJyZWZBdHRyTmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYoZS5kb2NTdHJpbmchPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJiF5LmlzU3RyaW5nKGUuZG9jU3RyaW5nKSlyZXR1cm5cImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7aWYoZS50eXBlIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSlzd2l0Y2goZS50eXBlKXtkZWZhdWx0OnJldHVyblwidHlwZTogZW51bSB2YWx1ZSBleHBlY3RlZFwiO2Nhc2UgMDpjYXNlIDE6Y2FzZSAyOmNhc2UgMzpjYXNlIDQ6Y2FzZSA1OmNhc2UgMTE6Y2FzZSAxMzpjYXNlIDY6Y2FzZSA3OmNhc2UgODpjYXNlIDk6Y2FzZSAxMDpjYXNlIDEyOmNhc2UgMTQ6YnJlYWt9aWYoZS5mIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiZlwiKSYmdHlwZW9mIGUuZiE9XCJudW1iZXJcIilyZXR1cm5cImY6IG51bWJlciBleHBlY3RlZFwiO2lmKGUuaSE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImlcIikmJiF5LmlzSW50ZWdlcihlLmkpJiYhKGUuaSYmeS5pc0ludGVnZXIoZS5pLmxvdykmJnkuaXNJbnRlZ2VyKGUuaS5oaWdoKSkpcmV0dXJuXCJpOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtpZihlLnMhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJzXCIpJiYhKGUucyYmdHlwZW9mIGUucy5sZW5ndGg9PVwibnVtYmVyXCJ8fHkuaXNTdHJpbmcoZS5zKSkpcmV0dXJuXCJzOiBidWZmZXIgZXhwZWN0ZWRcIjtpZihlLnQhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJ0XCIpKXt2YXIgcj1tLm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KGUudCk7aWYocilyZXR1cm5cInQuXCIrcn1pZihlLmchPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJnXCIpKXt2YXIgcj1tLm9ubnguR3JhcGhQcm90by52ZXJpZnkoZS5nKTtpZihyKXJldHVyblwiZy5cIityfWlmKGUuc3BhcnNlVGVuc29yIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwic3BhcnNlVGVuc29yXCIpKXt2YXIgcj1tLm9ubnguU3BhcnNlVGVuc29yUHJvdG8udmVyaWZ5KGUuc3BhcnNlVGVuc29yKTtpZihyKXJldHVyblwic3BhcnNlVGVuc29yLlwiK3J9aWYoZS50cCE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcInRwXCIpKXt2YXIgcj1tLm9ubnguVHlwZVByb3RvLnZlcmlmeShlLnRwKTtpZihyKXJldHVyblwidHAuXCIrcn1pZihlLmZsb2F0cyE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImZsb2F0c1wiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5mbG9hdHMpKXJldHVyblwiZmxvYXRzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgbj0wO248ZS5mbG9hdHMubGVuZ3RoOysrbilpZih0eXBlb2YgZS5mbG9hdHNbbl0hPVwibnVtYmVyXCIpcmV0dXJuXCJmbG9hdHM6IG51bWJlcltdIGV4cGVjdGVkXCJ9aWYoZS5pbnRzIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiaW50c1wiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5pbnRzKSlyZXR1cm5cImludHM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciBuPTA7bjxlLmludHMubGVuZ3RoOysrbilpZigheS5pc0ludGVnZXIoZS5pbnRzW25dKSYmIShlLmludHNbbl0mJnkuaXNJbnRlZ2VyKGUuaW50c1tuXS5sb3cpJiZ5LmlzSW50ZWdlcihlLmludHNbbl0uaGlnaCkpKXJldHVyblwiaW50czogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWRcIn1pZihlLnN0cmluZ3MhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJzdHJpbmdzXCIpKXtpZighQXJyYXkuaXNBcnJheShlLnN0cmluZ3MpKXJldHVyblwic3RyaW5nczogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIG49MDtuPGUuc3RyaW5ncy5sZW5ndGg7KytuKWlmKCEoZS5zdHJpbmdzW25dJiZ0eXBlb2YgZS5zdHJpbmdzW25dLmxlbmd0aD09XCJudW1iZXJcInx8eS5pc1N0cmluZyhlLnN0cmluZ3Nbbl0pKSlyZXR1cm5cInN0cmluZ3M6IGJ1ZmZlcltdIGV4cGVjdGVkXCJ9aWYoZS50ZW5zb3JzIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwidGVuc29yc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS50ZW5zb3JzKSlyZXR1cm5cInRlbnNvcnM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciBuPTA7bjxlLnRlbnNvcnMubGVuZ3RoOysrbil7dmFyIHI9bS5vbm54LlRlbnNvclByb3RvLnZlcmlmeShlLnRlbnNvcnNbbl0pO2lmKHIpcmV0dXJuXCJ0ZW5zb3JzLlwiK3J9fWlmKGUuZ3JhcGhzIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiZ3JhcGhzXCIpKXtpZighQXJyYXkuaXNBcnJheShlLmdyYXBocykpcmV0dXJuXCJncmFwaHM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciBuPTA7bjxlLmdyYXBocy5sZW5ndGg7KytuKXt2YXIgcj1tLm9ubnguR3JhcGhQcm90by52ZXJpZnkoZS5ncmFwaHNbbl0pO2lmKHIpcmV0dXJuXCJncmFwaHMuXCIrcn19aWYoZS5zcGFyc2VUZW5zb3JzIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwic3BhcnNlVGVuc29yc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5zcGFyc2VUZW5zb3JzKSlyZXR1cm5cInNwYXJzZVRlbnNvcnM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciBuPTA7bjxlLnNwYXJzZVRlbnNvcnMubGVuZ3RoOysrbil7dmFyIHI9bS5vbm54LlNwYXJzZVRlbnNvclByb3RvLnZlcmlmeShlLnNwYXJzZVRlbnNvcnNbbl0pO2lmKHIpcmV0dXJuXCJzcGFyc2VUZW5zb3JzLlwiK3J9fWlmKGUudHlwZVByb3RvcyE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVQcm90b3NcIikpe2lmKCFBcnJheS5pc0FycmF5KGUudHlwZVByb3RvcykpcmV0dXJuXCJ0eXBlUHJvdG9zOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgbj0wO248ZS50eXBlUHJvdG9zLmxlbmd0aDsrK24pe3ZhciByPW0ub25ueC5UeXBlUHJvdG8udmVyaWZ5KGUudHlwZVByb3Rvc1tuXSk7aWYocilyZXR1cm5cInR5cGVQcm90b3MuXCIrcn19cmV0dXJuIG51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgbS5vbm54LkF0dHJpYnV0ZVByb3RvKXJldHVybiBlO3ZhciByPW5ldyBtLm9ubnguQXR0cmlidXRlUHJvdG87c3dpdGNoKGUubmFtZSE9bnVsbCYmKHIubmFtZT1TdHJpbmcoZS5uYW1lKSksZS5yZWZBdHRyTmFtZSE9bnVsbCYmKHIucmVmQXR0ck5hbWU9U3RyaW5nKGUucmVmQXR0ck5hbWUpKSxlLmRvY1N0cmluZyE9bnVsbCYmKHIuZG9jU3RyaW5nPVN0cmluZyhlLmRvY1N0cmluZykpLGUudHlwZSl7ZGVmYXVsdDppZih0eXBlb2YgZS50eXBlPT1cIm51bWJlclwiKXtyLnR5cGU9ZS50eXBlO2JyZWFrfWJyZWFrO2Nhc2VcIlVOREVGSU5FRFwiOmNhc2UgMDpyLnR5cGU9MDticmVhaztjYXNlXCJGTE9BVFwiOmNhc2UgMTpyLnR5cGU9MTticmVhaztjYXNlXCJJTlRcIjpjYXNlIDI6ci50eXBlPTI7YnJlYWs7Y2FzZVwiU1RSSU5HXCI6Y2FzZSAzOnIudHlwZT0zO2JyZWFrO2Nhc2VcIlRFTlNPUlwiOmNhc2UgNDpyLnR5cGU9NDticmVhaztjYXNlXCJHUkFQSFwiOmNhc2UgNTpyLnR5cGU9NTticmVhaztjYXNlXCJTUEFSU0VfVEVOU09SXCI6Y2FzZSAxMTpyLnR5cGU9MTE7YnJlYWs7Y2FzZVwiVFlQRV9QUk9UT1wiOmNhc2UgMTM6ci50eXBlPTEzO2JyZWFrO2Nhc2VcIkZMT0FUU1wiOmNhc2UgNjpyLnR5cGU9NjticmVhaztjYXNlXCJJTlRTXCI6Y2FzZSA3OnIudHlwZT03O2JyZWFrO2Nhc2VcIlNUUklOR1NcIjpjYXNlIDg6ci50eXBlPTg7YnJlYWs7Y2FzZVwiVEVOU09SU1wiOmNhc2UgOTpyLnR5cGU9OTticmVhaztjYXNlXCJHUkFQSFNcIjpjYXNlIDEwOnIudHlwZT0xMDticmVhaztjYXNlXCJTUEFSU0VfVEVOU09SU1wiOmNhc2UgMTI6ci50eXBlPTEyO2JyZWFrO2Nhc2VcIlRZUEVfUFJPVE9TXCI6Y2FzZSAxNDpyLnR5cGU9MTQ7YnJlYWt9aWYoZS5mIT1udWxsJiYoci5mPU51bWJlcihlLmYpKSxlLmkhPW51bGwmJih5Lkxvbmc/KHIuaT15LkxvbmcuZnJvbVZhbHVlKGUuaSkpLnVuc2lnbmVkPSExOnR5cGVvZiBlLmk9PVwic3RyaW5nXCI/ci5pPXBhcnNlSW50KGUuaSwxMCk6dHlwZW9mIGUuaT09XCJudW1iZXJcIj9yLmk9ZS5pOnR5cGVvZiBlLmk9PVwib2JqZWN0XCImJihyLmk9bmV3IHkuTG9uZ0JpdHMoZS5pLmxvdz4+PjAsZS5pLmhpZ2g+Pj4wKS50b051bWJlcigpKSksZS5zIT1udWxsJiYodHlwZW9mIGUucz09XCJzdHJpbmdcIj95LmJhc2U2NC5kZWNvZGUoZS5zLHIucz15Lm5ld0J1ZmZlcih5LmJhc2U2NC5sZW5ndGgoZS5zKSksMCk6ZS5zLmxlbmd0aD49MCYmKHIucz1lLnMpKSxlLnQhPW51bGwpe2lmKHR5cGVvZiBlLnQhPVwib2JqZWN0XCIpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udDogb2JqZWN0IGV4cGVjdGVkXCIpO3IudD1tLm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChlLnQpfWlmKGUuZyE9bnVsbCl7aWYodHlwZW9mIGUuZyE9XCJvYmplY3RcIil0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5nOiBvYmplY3QgZXhwZWN0ZWRcIik7ci5nPW0ub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3QoZS5nKX1pZihlLnNwYXJzZVRlbnNvciE9bnVsbCl7aWYodHlwZW9mIGUuc3BhcnNlVGVuc29yIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnNwYXJzZVRlbnNvcjogb2JqZWN0IGV4cGVjdGVkXCIpO3Iuc3BhcnNlVGVuc29yPW0ub25ueC5TcGFyc2VUZW5zb3JQcm90by5mcm9tT2JqZWN0KGUuc3BhcnNlVGVuc29yKX1pZihlLnRwIT1udWxsKXtpZih0eXBlb2YgZS50cCE9XCJvYmplY3RcIil0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by50cDogb2JqZWN0IGV4cGVjdGVkXCIpO3IudHA9bS5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KGUudHApfWlmKGUuZmxvYXRzKXtpZighQXJyYXkuaXNBcnJheShlLmZsb2F0cykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uZmxvYXRzOiBhcnJheSBleHBlY3RlZFwiKTtyLmZsb2F0cz1bXTtmb3IodmFyIG49MDtuPGUuZmxvYXRzLmxlbmd0aDsrK24pci5mbG9hdHNbbl09TnVtYmVyKGUuZmxvYXRzW25dKX1pZihlLmludHMpe2lmKCFBcnJheS5pc0FycmF5KGUuaW50cykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uaW50czogYXJyYXkgZXhwZWN0ZWRcIik7ci5pbnRzPVtdO2Zvcih2YXIgbj0wO248ZS5pbnRzLmxlbmd0aDsrK24peS5Mb25nPyhyLmludHNbbl09eS5Mb25nLmZyb21WYWx1ZShlLmludHNbbl0pKS51bnNpZ25lZD0hMTp0eXBlb2YgZS5pbnRzW25dPT1cInN0cmluZ1wiP3IuaW50c1tuXT1wYXJzZUludChlLmludHNbbl0sMTApOnR5cGVvZiBlLmludHNbbl09PVwibnVtYmVyXCI/ci5pbnRzW25dPWUuaW50c1tuXTp0eXBlb2YgZS5pbnRzW25dPT1cIm9iamVjdFwiJiYoci5pbnRzW25dPW5ldyB5LkxvbmdCaXRzKGUuaW50c1tuXS5sb3c+Pj4wLGUuaW50c1tuXS5oaWdoPj4+MCkudG9OdW1iZXIoKSl9aWYoZS5zdHJpbmdzKXtpZighQXJyYXkuaXNBcnJheShlLnN0cmluZ3MpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnN0cmluZ3M6IGFycmF5IGV4cGVjdGVkXCIpO3Iuc3RyaW5ncz1bXTtmb3IodmFyIG49MDtuPGUuc3RyaW5ncy5sZW5ndGg7KytuKXR5cGVvZiBlLnN0cmluZ3Nbbl09PVwic3RyaW5nXCI/eS5iYXNlNjQuZGVjb2RlKGUuc3RyaW5nc1tuXSxyLnN0cmluZ3Nbbl09eS5uZXdCdWZmZXIoeS5iYXNlNjQubGVuZ3RoKGUuc3RyaW5nc1tuXSkpLDApOmUuc3RyaW5nc1tuXS5sZW5ndGg+PTAmJihyLnN0cmluZ3Nbbl09ZS5zdHJpbmdzW25dKX1pZihlLnRlbnNvcnMpe2lmKCFBcnJheS5pc0FycmF5KGUudGVuc29ycykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udGVuc29yczogYXJyYXkgZXhwZWN0ZWRcIik7ci50ZW5zb3JzPVtdO2Zvcih2YXIgbj0wO248ZS50ZW5zb3JzLmxlbmd0aDsrK24pe2lmKHR5cGVvZiBlLnRlbnNvcnNbbl0hPVwib2JqZWN0XCIpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udGVuc29yczogb2JqZWN0IGV4cGVjdGVkXCIpO3IudGVuc29yc1tuXT1tLm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChlLnRlbnNvcnNbbl0pfX1pZihlLmdyYXBocyl7aWYoIUFycmF5LmlzQXJyYXkoZS5ncmFwaHMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmdyYXBoczogYXJyYXkgZXhwZWN0ZWRcIik7ci5ncmFwaHM9W107Zm9yKHZhciBuPTA7bjxlLmdyYXBocy5sZW5ndGg7KytuKXtpZih0eXBlb2YgZS5ncmFwaHNbbl0hPVwib2JqZWN0XCIpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uZ3JhcGhzOiBvYmplY3QgZXhwZWN0ZWRcIik7ci5ncmFwaHNbbl09bS5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdChlLmdyYXBoc1tuXSl9fWlmKGUuc3BhcnNlVGVuc29ycyl7aWYoIUFycmF5LmlzQXJyYXkoZS5zcGFyc2VUZW5zb3JzKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5zcGFyc2VUZW5zb3JzOiBhcnJheSBleHBlY3RlZFwiKTtyLnNwYXJzZVRlbnNvcnM9W107Zm9yKHZhciBuPTA7bjxlLnNwYXJzZVRlbnNvcnMubGVuZ3RoOysrbil7aWYodHlwZW9mIGUuc3BhcnNlVGVuc29yc1tuXSE9XCJvYmplY3RcIil0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5zcGFyc2VUZW5zb3JzOiBvYmplY3QgZXhwZWN0ZWRcIik7ci5zcGFyc2VUZW5zb3JzW25dPW0ub25ueC5TcGFyc2VUZW5zb3JQcm90by5mcm9tT2JqZWN0KGUuc3BhcnNlVGVuc29yc1tuXSl9fWlmKGUudHlwZVByb3Rvcyl7aWYoIUFycmF5LmlzQXJyYXkoZS50eXBlUHJvdG9zKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by50eXBlUHJvdG9zOiBhcnJheSBleHBlY3RlZFwiKTtyLnR5cGVQcm90b3M9W107Zm9yKHZhciBuPTA7bjxlLnR5cGVQcm90b3MubGVuZ3RoOysrbil7aWYodHlwZW9mIGUudHlwZVByb3Rvc1tuXSE9XCJvYmplY3RcIil0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by50eXBlUHJvdG9zOiBvYmplY3QgZXhwZWN0ZWRcIik7ci50eXBlUHJvdG9zW25dPW0ub25ueC5UeXBlUHJvdG8uZnJvbU9iamVjdChlLnR5cGVQcm90b3Nbbl0pfX1yZXR1cm4gcn0sdC50b09iamVjdD1mdW5jdGlvbihlLHIpe3J8fChyPXt9KTt2YXIgbj17fTtpZigoci5hcnJheXN8fHIuZGVmYXVsdHMpJiYobi5mbG9hdHM9W10sbi5pbnRzPVtdLG4uc3RyaW5ncz1bXSxuLnRlbnNvcnM9W10sbi5ncmFwaHM9W10sbi50eXBlUHJvdG9zPVtdLG4uc3BhcnNlVGVuc29ycz1bXSksci5kZWZhdWx0cyl7aWYobi5uYW1lPVwiXCIsbi5mPTAseS5Mb25nKXt2YXIgcz1uZXcgeS5Mb25nKDAsMCwhMSk7bi5pPXIubG9uZ3M9PT1TdHJpbmc/cy50b1N0cmluZygpOnIubG9uZ3M9PT1OdW1iZXI/cy50b051bWJlcigpOnN9ZWxzZSBuLmk9ci5sb25ncz09PVN0cmluZz9cIjBcIjowO3IuYnl0ZXM9PT1TdHJpbmc/bi5zPVwiXCI6KG4ucz1bXSxyLmJ5dGVzIT09QXJyYXkmJihuLnM9eS5uZXdCdWZmZXIobi5zKSkpLG4udD1udWxsLG4uZz1udWxsLG4uZG9jU3RyaW5nPVwiXCIsbi50cD1udWxsLG4udHlwZT1yLmVudW1zPT09U3RyaW5nP1wiVU5ERUZJTkVEXCI6MCxuLnJlZkF0dHJOYW1lPVwiXCIsbi5zcGFyc2VUZW5zb3I9bnVsbH1pZihlLm5hbWUhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYobi5uYW1lPWUubmFtZSksZS5mIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiZlwiKSYmKG4uZj1yLmpzb24mJiFpc0Zpbml0ZShlLmYpP1N0cmluZyhlLmYpOmUuZiksZS5pIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiaVwiKSYmKHR5cGVvZiBlLmk9PVwibnVtYmVyXCI/bi5pPXIubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKGUuaSk6ZS5pOm4uaT1yLmxvbmdzPT09U3RyaW5nP3kuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlLmkpOnIubG9uZ3M9PT1OdW1iZXI/bmV3IHkuTG9uZ0JpdHMoZS5pLmxvdz4+PjAsZS5pLmhpZ2g+Pj4wKS50b051bWJlcigpOmUuaSksZS5zIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwic1wiKSYmKG4ucz1yLmJ5dGVzPT09U3RyaW5nP3kuYmFzZTY0LmVuY29kZShlLnMsMCxlLnMubGVuZ3RoKTpyLmJ5dGVzPT09QXJyYXk/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZS5zKTplLnMpLGUudCE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcInRcIikmJihuLnQ9bS5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KGUudCxyKSksZS5nIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiZ1wiKSYmKG4uZz1tLm9ubnguR3JhcGhQcm90by50b09iamVjdChlLmcscikpLGUuZmxvYXRzJiZlLmZsb2F0cy5sZW5ndGgpe24uZmxvYXRzPVtdO2Zvcih2YXIgaT0wO2k8ZS5mbG9hdHMubGVuZ3RoOysraSluLmZsb2F0c1tpXT1yLmpzb24mJiFpc0Zpbml0ZShlLmZsb2F0c1tpXSk/U3RyaW5nKGUuZmxvYXRzW2ldKTplLmZsb2F0c1tpXX1pZihlLmludHMmJmUuaW50cy5sZW5ndGgpe24uaW50cz1bXTtmb3IodmFyIGk9MDtpPGUuaW50cy5sZW5ndGg7KytpKXR5cGVvZiBlLmludHNbaV09PVwibnVtYmVyXCI/bi5pbnRzW2ldPXIubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKGUuaW50c1tpXSk6ZS5pbnRzW2ldOm4uaW50c1tpXT1yLmxvbmdzPT09U3RyaW5nP3kuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlLmludHNbaV0pOnIubG9uZ3M9PT1OdW1iZXI/bmV3IHkuTG9uZ0JpdHMoZS5pbnRzW2ldLmxvdz4+PjAsZS5pbnRzW2ldLmhpZ2g+Pj4wKS50b051bWJlcigpOmUuaW50c1tpXX1pZihlLnN0cmluZ3MmJmUuc3RyaW5ncy5sZW5ndGgpe24uc3RyaW5ncz1bXTtmb3IodmFyIGk9MDtpPGUuc3RyaW5ncy5sZW5ndGg7KytpKW4uc3RyaW5nc1tpXT1yLmJ5dGVzPT09U3RyaW5nP3kuYmFzZTY0LmVuY29kZShlLnN0cmluZ3NbaV0sMCxlLnN0cmluZ3NbaV0ubGVuZ3RoKTpyLmJ5dGVzPT09QXJyYXk/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZS5zdHJpbmdzW2ldKTplLnN0cmluZ3NbaV19aWYoZS50ZW5zb3JzJiZlLnRlbnNvcnMubGVuZ3RoKXtuLnRlbnNvcnM9W107Zm9yKHZhciBpPTA7aTxlLnRlbnNvcnMubGVuZ3RoOysraSluLnRlbnNvcnNbaV09bS5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KGUudGVuc29yc1tpXSxyKX1pZihlLmdyYXBocyYmZS5ncmFwaHMubGVuZ3RoKXtuLmdyYXBocz1bXTtmb3IodmFyIGk9MDtpPGUuZ3JhcGhzLmxlbmd0aDsrK2kpbi5ncmFwaHNbaV09bS5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QoZS5ncmFwaHNbaV0scil9aWYoZS5kb2NTdHJpbmchPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz1lLmRvY1N0cmluZyksZS50cCE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcInRwXCIpJiYobi50cD1tLm9ubnguVHlwZVByb3RvLnRvT2JqZWN0KGUudHAscikpLGUudHlwZVByb3RvcyYmZS50eXBlUHJvdG9zLmxlbmd0aCl7bi50eXBlUHJvdG9zPVtdO2Zvcih2YXIgaT0wO2k8ZS50eXBlUHJvdG9zLmxlbmd0aDsrK2kpbi50eXBlUHJvdG9zW2ldPW0ub25ueC5UeXBlUHJvdG8udG9PYmplY3QoZS50eXBlUHJvdG9zW2ldLHIpfWlmKGUudHlwZSE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikmJihuLnR5cGU9ci5lbnVtcz09PVN0cmluZz9tLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVtlLnR5cGVdPT09dm9pZCAwP2UudHlwZTptLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVtlLnR5cGVdOmUudHlwZSksZS5yZWZBdHRyTmFtZSE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcInJlZkF0dHJOYW1lXCIpJiYobi5yZWZBdHRyTmFtZT1lLnJlZkF0dHJOYW1lKSxlLnNwYXJzZVRlbnNvciE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcInNwYXJzZVRlbnNvclwiKSYmKG4uc3BhcnNlVGVuc29yPW0ub25ueC5TcGFyc2VUZW5zb3JQcm90by50b09iamVjdChlLnNwYXJzZVRlbnNvcixyKSksZS5zcGFyc2VUZW5zb3JzJiZlLnNwYXJzZVRlbnNvcnMubGVuZ3RoKXtuLnNwYXJzZVRlbnNvcnM9W107Zm9yKHZhciBpPTA7aTxlLnNwYXJzZVRlbnNvcnMubGVuZ3RoOysraSluLnNwYXJzZVRlbnNvcnNbaV09bS5vbm54LlNwYXJzZVRlbnNvclByb3RvLnRvT2JqZWN0KGUuc3BhcnNlVGVuc29yc1tpXSxyKX1yZXR1cm4gbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxnZS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0LmdldFR5cGVVcmw9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT12b2lkIDAmJihlPVwidHlwZS5nb29nbGVhcGlzLmNvbVwiKSxlK1wiL29ubnguQXR0cmlidXRlUHJvdG9cIn0sdC5BdHRyaWJ1dGVUeXBlPWZ1bmN0aW9uKCl7dmFyIG89e30sZT1PYmplY3QuY3JlYXRlKG8pO3JldHVybiBlW29bMF09XCJVTkRFRklORURcIl09MCxlW29bMV09XCJGTE9BVFwiXT0xLGVbb1syXT1cIklOVFwiXT0yLGVbb1szXT1cIlNUUklOR1wiXT0zLGVbb1s0XT1cIlRFTlNPUlwiXT00LGVbb1s1XT1cIkdSQVBIXCJdPTUsZVtvWzExXT1cIlNQQVJTRV9URU5TT1JcIl09MTEsZVtvWzEzXT1cIlRZUEVfUFJPVE9cIl09MTMsZVtvWzZdPVwiRkxPQVRTXCJdPTYsZVtvWzddPVwiSU5UU1wiXT03LGVbb1s4XT1cIlNUUklOR1NcIl09OCxlW29bOV09XCJURU5TT1JTXCJdPTksZVtvWzEwXT1cIkdSQVBIU1wiXT0xMCxlW29bMTJdPVwiU1BBUlNFX1RFTlNPUlNcIl09MTIsZVtvWzE0XT1cIlRZUEVfUFJPVE9TXCJdPTE0LGV9KCksdH0oKSxhLlZhbHVlSW5mb1Byb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChvKXtpZihvKWZvcih2YXIgZT1PYmplY3Qua2V5cyhvKSxyPTA7cjxlLmxlbmd0aDsrK3Ipb1tlW3JdXSE9bnVsbCYmKHRoaXNbZVtyXV09b1tlW3JdXSl9cmV0dXJuIHQucHJvdG90eXBlLm5hbWU9XCJcIix0LnByb3RvdHlwZS50eXBlPW51bGwsdC5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbihlLHIpe3JldHVybiByfHwocj1FZS5jcmVhdGUoKSksZS5uYW1lIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwibmFtZVwiKSYmci51aW50MzIoMTApLnN0cmluZyhlLm5hbWUpLGUudHlwZSE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcInR5cGVcIikmJm0ub25ueC5UeXBlUHJvdG8uZW5jb2RlKGUudHlwZSxyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKSxlLmRvY1N0cmluZyE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImRvY1N0cmluZ1wiKSYmci51aW50MzIoMjYpLnN0cmluZyhlLmRvY1N0cmluZykscn0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdGhpcy5lbmNvZGUoZSxyKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24oZSxyKXtlIGluc3RhbmNlb2YgTnx8KGU9Ti5jcmVhdGUoZSkpO2Zvcih2YXIgbj1yPT09dm9pZCAwP2UubGVuOmUucG9zK3Iscz1uZXcgbS5vbm54LlZhbHVlSW5mb1Byb3RvO2UucG9zPG47KXt2YXIgaT1lLnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOntzLm5hbWU9ZS5zdHJpbmcoKTticmVha31jYXNlIDI6e3MudHlwZT1tLm9ubnguVHlwZVByb3RvLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrfWNhc2UgMzp7cy5kb2NTdHJpbmc9ZS5zdHJpbmcoKTticmVha31kZWZhdWx0OmUuc2tpcFR5cGUoaSY3KTticmVha319cmV0dXJuIHN9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgTnx8KGU9bmV3IE4oZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKGUpe2lmKHR5cGVvZiBlIT1cIm9iamVjdFwifHxlPT09bnVsbClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKGUubmFtZSE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiF5LmlzU3RyaW5nKGUubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihlLnR5cGUhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKXt2YXIgcj1tLm9ubnguVHlwZVByb3RvLnZlcmlmeShlLnR5cGUpO2lmKHIpcmV0dXJuXCJ0eXBlLlwiK3J9cmV0dXJuIGUuZG9jU3RyaW5nIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYheS5pc1N0cmluZyhlLmRvY1N0cmluZyk/XCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgbS5vbm54LlZhbHVlSW5mb1Byb3RvKXJldHVybiBlO3ZhciByPW5ldyBtLm9ubnguVmFsdWVJbmZvUHJvdG87aWYoZS5uYW1lIT1udWxsJiYoci5uYW1lPVN0cmluZyhlLm5hbWUpKSxlLnR5cGUhPW51bGwpe2lmKHR5cGVvZiBlLnR5cGUhPVwib2JqZWN0XCIpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVmFsdWVJbmZvUHJvdG8udHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO3IudHlwZT1tLm9ubnguVHlwZVByb3RvLmZyb21PYmplY3QoZS50eXBlKX1yZXR1cm4gZS5kb2NTdHJpbmchPW51bGwmJihyLmRvY1N0cmluZz1TdHJpbmcoZS5kb2NTdHJpbmcpKSxyfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKGUscil7cnx8KHI9e30pO3ZhciBuPXt9O3JldHVybiByLmRlZmF1bHRzJiYobi5uYW1lPVwiXCIsbi50eXBlPW51bGwsbi5kb2NTdHJpbmc9XCJcIiksZS5uYW1lIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmKG4ubmFtZT1lLm5hbWUpLGUudHlwZSE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikmJihuLnR5cGU9bS5vbm54LlR5cGVQcm90by50b09iamVjdChlLnR5cGUscikpLGUuZG9jU3RyaW5nIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9ZS5kb2NTdHJpbmcpLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsZ2UudXRpbC50b0pTT05PcHRpb25zKX0sdC5nZXRUeXBlVXJsPWZ1bmN0aW9uKGUpe3JldHVybiBlPT09dm9pZCAwJiYoZT1cInR5cGUuZ29vZ2xlYXBpcy5jb21cIiksZStcIi9vbm54LlZhbHVlSW5mb1Byb3RvXCJ9LHR9KCksYS5Ob2RlUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KG8pe2lmKHRoaXMuaW5wdXQ9W10sdGhpcy5vdXRwdXQ9W10sdGhpcy5hdHRyaWJ1dGU9W10sbylmb3IodmFyIGU9T2JqZWN0LmtleXMobykscj0wO3I8ZS5sZW5ndGg7KytyKW9bZVtyXV0hPW51bGwmJih0aGlzW2Vbcl1dPW9bZVtyXV0pfXJldHVybiB0LnByb3RvdHlwZS5pbnB1dD15LmVtcHR5QXJyYXksdC5wcm90b3R5cGUub3V0cHV0PXkuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5uYW1lPVwiXCIsdC5wcm90b3R5cGUub3BUeXBlPVwiXCIsdC5wcm90b3R5cGUuZG9tYWluPVwiXCIsdC5wcm90b3R5cGUuYXR0cmlidXRlPXkuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5kb2NTdHJpbmc9XCJcIix0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKGUscil7aWYocnx8KHI9RWUuY3JlYXRlKCkpLGUuaW5wdXQhPW51bGwmJmUuaW5wdXQubGVuZ3RoKWZvcih2YXIgbj0wO248ZS5pbnB1dC5sZW5ndGg7KytuKXIudWludDMyKDEwKS5zdHJpbmcoZS5pbnB1dFtuXSk7aWYoZS5vdXRwdXQhPW51bGwmJmUub3V0cHV0Lmxlbmd0aClmb3IodmFyIG49MDtuPGUub3V0cHV0Lmxlbmd0aDsrK24pci51aW50MzIoMTgpLnN0cmluZyhlLm91dHB1dFtuXSk7aWYoZS5uYW1lIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwibmFtZVwiKSYmci51aW50MzIoMjYpLnN0cmluZyhlLm5hbWUpLGUub3BUeXBlIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwib3BUeXBlXCIpJiZyLnVpbnQzMigzNCkuc3RyaW5nKGUub3BUeXBlKSxlLmF0dHJpYnV0ZSE9bnVsbCYmZS5hdHRyaWJ1dGUubGVuZ3RoKWZvcih2YXIgbj0wO248ZS5hdHRyaWJ1dGUubGVuZ3RoOysrbiltLm9ubnguQXR0cmlidXRlUHJvdG8uZW5jb2RlKGUuYXR0cmlidXRlW25dLHIudWludDMyKDQyKS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiBlLmRvY1N0cmluZyE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImRvY1N0cmluZ1wiKSYmci51aW50MzIoNTApLnN0cmluZyhlLmRvY1N0cmluZyksZS5kb21haW4hPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJkb21haW5cIikmJnIudWludDMyKDU4KS5zdHJpbmcoZS5kb21haW4pLHJ9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUscil7cmV0dXJuIHRoaXMuZW5jb2RlKGUscikubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKGUscil7ZSBpbnN0YW5jZW9mIE58fChlPU4uY3JlYXRlKGUpKTtmb3IodmFyIG49cj09PXZvaWQgMD9lLmxlbjplLnBvcytyLHM9bmV3IG0ub25ueC5Ob2RlUHJvdG87ZS5wb3M8bjspe3ZhciBpPWUudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6e3MuaW5wdXQmJnMuaW5wdXQubGVuZ3RofHwocy5pbnB1dD1bXSkscy5pbnB1dC5wdXNoKGUuc3RyaW5nKCkpO2JyZWFrfWNhc2UgMjp7cy5vdXRwdXQmJnMub3V0cHV0Lmxlbmd0aHx8KHMub3V0cHV0PVtdKSxzLm91dHB1dC5wdXNoKGUuc3RyaW5nKCkpO2JyZWFrfWNhc2UgMzp7cy5uYW1lPWUuc3RyaW5nKCk7YnJlYWt9Y2FzZSA0OntzLm9wVHlwZT1lLnN0cmluZygpO2JyZWFrfWNhc2UgNzp7cy5kb21haW49ZS5zdHJpbmcoKTticmVha31jYXNlIDU6e3MuYXR0cmlidXRlJiZzLmF0dHJpYnV0ZS5sZW5ndGh8fChzLmF0dHJpYnV0ZT1bXSkscy5hdHRyaWJ1dGUucHVzaChtLm9ubnguQXR0cmlidXRlUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrfWNhc2UgNjp7cy5kb2NTdHJpbmc9ZS5zdHJpbmcoKTticmVha31kZWZhdWx0OmUuc2tpcFR5cGUoaSY3KTticmVha319cmV0dXJuIHN9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgTnx8KGU9bmV3IE4oZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKGUpe2lmKHR5cGVvZiBlIT1cIm9iamVjdFwifHxlPT09bnVsbClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKGUuaW5wdXQhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJpbnB1dFwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5pbnB1dCkpcmV0dXJuXCJpbnB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHI9MDtyPGUuaW5wdXQubGVuZ3RoOysrcilpZigheS5pc1N0cmluZyhlLmlucHV0W3JdKSlyZXR1cm5cImlucHV0OiBzdHJpbmdbXSBleHBlY3RlZFwifWlmKGUub3V0cHV0IT1udWxsJiZlLmhhc093blByb3BlcnR5KFwib3V0cHV0XCIpKXtpZighQXJyYXkuaXNBcnJheShlLm91dHB1dCkpcmV0dXJuXCJvdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciByPTA7cjxlLm91dHB1dC5sZW5ndGg7KytyKWlmKCF5LmlzU3RyaW5nKGUub3V0cHV0W3JdKSlyZXR1cm5cIm91dHB1dDogc3RyaW5nW10gZXhwZWN0ZWRcIn1pZihlLm5hbWUhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYheS5pc1N0cmluZyhlLm5hbWUpKXJldHVyblwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYoZS5vcFR5cGUhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJvcFR5cGVcIikmJiF5LmlzU3RyaW5nKGUub3BUeXBlKSlyZXR1cm5cIm9wVHlwZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYoZS5kb21haW4hPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJiF5LmlzU3RyaW5nKGUuZG9tYWluKSlyZXR1cm5cImRvbWFpbjogc3RyaW5nIGV4cGVjdGVkXCI7aWYoZS5hdHRyaWJ1dGUhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJhdHRyaWJ1dGVcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuYXR0cmlidXRlKSlyZXR1cm5cImF0dHJpYnV0ZTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHI9MDtyPGUuYXR0cmlidXRlLmxlbmd0aDsrK3Ipe3ZhciBuPW0ub25ueC5BdHRyaWJ1dGVQcm90by52ZXJpZnkoZS5hdHRyaWJ1dGVbcl0pO2lmKG4pcmV0dXJuXCJhdHRyaWJ1dGUuXCIrbn19cmV0dXJuIGUuZG9jU3RyaW5nIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYheS5pc1N0cmluZyhlLmRvY1N0cmluZyk/XCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgbS5vbm54Lk5vZGVQcm90bylyZXR1cm4gZTt2YXIgcj1uZXcgbS5vbm54Lk5vZGVQcm90bztpZihlLmlucHV0KXtpZighQXJyYXkuaXNBcnJheShlLmlucHV0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Ob2RlUHJvdG8uaW5wdXQ6IGFycmF5IGV4cGVjdGVkXCIpO3IuaW5wdXQ9W107Zm9yKHZhciBuPTA7bjxlLmlucHV0Lmxlbmd0aDsrK24pci5pbnB1dFtuXT1TdHJpbmcoZS5pbnB1dFtuXSl9aWYoZS5vdXRwdXQpe2lmKCFBcnJheS5pc0FycmF5KGUub3V0cHV0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Ob2RlUHJvdG8ub3V0cHV0OiBhcnJheSBleHBlY3RlZFwiKTtyLm91dHB1dD1bXTtmb3IodmFyIG49MDtuPGUub3V0cHV0Lmxlbmd0aDsrK24pci5vdXRwdXRbbl09U3RyaW5nKGUub3V0cHV0W25dKX1pZihlLm5hbWUhPW51bGwmJihyLm5hbWU9U3RyaW5nKGUubmFtZSkpLGUub3BUeXBlIT1udWxsJiYoci5vcFR5cGU9U3RyaW5nKGUub3BUeXBlKSksZS5kb21haW4hPW51bGwmJihyLmRvbWFpbj1TdHJpbmcoZS5kb21haW4pKSxlLmF0dHJpYnV0ZSl7aWYoIUFycmF5LmlzQXJyYXkoZS5hdHRyaWJ1dGUpKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk5vZGVQcm90by5hdHRyaWJ1dGU6IGFycmF5IGV4cGVjdGVkXCIpO3IuYXR0cmlidXRlPVtdO2Zvcih2YXIgbj0wO248ZS5hdHRyaWJ1dGUubGVuZ3RoOysrbil7aWYodHlwZW9mIGUuYXR0cmlidXRlW25dIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk5vZGVQcm90by5hdHRyaWJ1dGU6IG9iamVjdCBleHBlY3RlZFwiKTtyLmF0dHJpYnV0ZVtuXT1tLm9ubnguQXR0cmlidXRlUHJvdG8uZnJvbU9iamVjdChlLmF0dHJpYnV0ZVtuXSl9fXJldHVybiBlLmRvY1N0cmluZyE9bnVsbCYmKHIuZG9jU3RyaW5nPVN0cmluZyhlLmRvY1N0cmluZykpLHJ9LHQudG9PYmplY3Q9ZnVuY3Rpb24oZSxyKXtyfHwocj17fSk7dmFyIG49e307aWYoKHIuYXJyYXlzfHxyLmRlZmF1bHRzKSYmKG4uaW5wdXQ9W10sbi5vdXRwdXQ9W10sbi5hdHRyaWJ1dGU9W10pLHIuZGVmYXVsdHMmJihuLm5hbWU9XCJcIixuLm9wVHlwZT1cIlwiLG4uZG9jU3RyaW5nPVwiXCIsbi5kb21haW49XCJcIiksZS5pbnB1dCYmZS5pbnB1dC5sZW5ndGgpe24uaW5wdXQ9W107Zm9yKHZhciBzPTA7czxlLmlucHV0Lmxlbmd0aDsrK3Mpbi5pbnB1dFtzXT1lLmlucHV0W3NdfWlmKGUub3V0cHV0JiZlLm91dHB1dC5sZW5ndGgpe24ub3V0cHV0PVtdO2Zvcih2YXIgcz0wO3M8ZS5vdXRwdXQubGVuZ3RoOysrcyluLm91dHB1dFtzXT1lLm91dHB1dFtzXX1pZihlLm5hbWUhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYobi5uYW1lPWUubmFtZSksZS5vcFR5cGUhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJvcFR5cGVcIikmJihuLm9wVHlwZT1lLm9wVHlwZSksZS5hdHRyaWJ1dGUmJmUuYXR0cmlidXRlLmxlbmd0aCl7bi5hdHRyaWJ1dGU9W107Zm9yKHZhciBzPTA7czxlLmF0dHJpYnV0ZS5sZW5ndGg7KytzKW4uYXR0cmlidXRlW3NdPW0ub25ueC5BdHRyaWJ1dGVQcm90by50b09iamVjdChlLmF0dHJpYnV0ZVtzXSxyKX1yZXR1cm4gZS5kb2NTdHJpbmchPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz1lLmRvY1N0cmluZyksZS5kb21haW4hPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJihuLmRvbWFpbj1lLmRvbWFpbiksbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxnZS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0LmdldFR5cGVVcmw9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT12b2lkIDAmJihlPVwidHlwZS5nb29nbGVhcGlzLmNvbVwiKSxlK1wiL29ubnguTm9kZVByb3RvXCJ9LHR9KCksYS5UcmFpbmluZ0luZm9Qcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobyl7aWYodGhpcy5pbml0aWFsaXphdGlvbkJpbmRpbmc9W10sdGhpcy51cGRhdGVCaW5kaW5nPVtdLG8pZm9yKHZhciBlPU9iamVjdC5rZXlzKG8pLHI9MDtyPGUubGVuZ3RoOysrcilvW2Vbcl1dIT1udWxsJiYodGhpc1tlW3JdXT1vW2Vbcl1dKX1yZXR1cm4gdC5wcm90b3R5cGUuaW5pdGlhbGl6YXRpb249bnVsbCx0LnByb3RvdHlwZS5hbGdvcml0aG09bnVsbCx0LnByb3RvdHlwZS5pbml0aWFsaXphdGlvbkJpbmRpbmc9eS5lbXB0eUFycmF5LHQucHJvdG90eXBlLnVwZGF0ZUJpbmRpbmc9eS5lbXB0eUFycmF5LHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24oZSxyKXtpZihyfHwocj1FZS5jcmVhdGUoKSksZS5pbml0aWFsaXphdGlvbiE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImluaXRpYWxpemF0aW9uXCIpJiZtLm9ubnguR3JhcGhQcm90by5lbmNvZGUoZS5pbml0aWFsaXphdGlvbixyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKSxlLmFsZ29yaXRobSE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImFsZ29yaXRobVwiKSYmbS5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKGUuYWxnb3JpdGhtLHIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpLGUuaW5pdGlhbGl6YXRpb25CaW5kaW5nIT1udWxsJiZlLmluaXRpYWxpemF0aW9uQmluZGluZy5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLmluaXRpYWxpemF0aW9uQmluZGluZy5sZW5ndGg7KytuKW0ub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZShlLmluaXRpYWxpemF0aW9uQmluZGluZ1tuXSxyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtpZihlLnVwZGF0ZUJpbmRpbmchPW51bGwmJmUudXBkYXRlQmluZGluZy5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoOysrbiltLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUoZS51cGRhdGVCaW5kaW5nW25dLHIudWludDMyKDM0KS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiByfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbihlLHIpe3JldHVybiB0aGlzLmVuY29kZShlLHIpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbihlLHIpe2UgaW5zdGFuY2VvZiBOfHwoZT1OLmNyZWF0ZShlKSk7Zm9yKHZhciBuPXI9PT12b2lkIDA/ZS5sZW46ZS5wb3MrcixzPW5ldyBtLm9ubnguVHJhaW5pbmdJbmZvUHJvdG87ZS5wb3M8bjspe3ZhciBpPWUudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6e3MuaW5pdGlhbGl6YXRpb249bS5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWt9Y2FzZSAyOntzLmFsZ29yaXRobT1tLm9ubnguR3JhcGhQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVha31jYXNlIDM6e3MuaW5pdGlhbGl6YXRpb25CaW5kaW5nJiZzLmluaXRpYWxpemF0aW9uQmluZGluZy5sZW5ndGh8fChzLmluaXRpYWxpemF0aW9uQmluZGluZz1bXSkscy5pbml0aWFsaXphdGlvbkJpbmRpbmcucHVzaChtLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWt9Y2FzZSA0OntzLnVwZGF0ZUJpbmRpbmcmJnMudXBkYXRlQmluZGluZy5sZW5ndGh8fChzLnVwZGF0ZUJpbmRpbmc9W10pLHMudXBkYXRlQmluZGluZy5wdXNoKG0ub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVha31kZWZhdWx0OmUuc2tpcFR5cGUoaSY3KTticmVha319cmV0dXJuIHN9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgTnx8KGU9bmV3IE4oZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKGUpe2lmKHR5cGVvZiBlIT1cIm9iamVjdFwifHxlPT09bnVsbClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKGUuaW5pdGlhbGl6YXRpb24hPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJpbml0aWFsaXphdGlvblwiKSl7dmFyIHI9bS5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KGUuaW5pdGlhbGl6YXRpb24pO2lmKHIpcmV0dXJuXCJpbml0aWFsaXphdGlvbi5cIityfWlmKGUuYWxnb3JpdGhtIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiYWxnb3JpdGhtXCIpKXt2YXIgcj1tLm9ubnguR3JhcGhQcm90by52ZXJpZnkoZS5hbGdvcml0aG0pO2lmKHIpcmV0dXJuXCJhbGdvcml0aG0uXCIrcn1pZihlLmluaXRpYWxpemF0aW9uQmluZGluZyE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImluaXRpYWxpemF0aW9uQmluZGluZ1wiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5pbml0aWFsaXphdGlvbkJpbmRpbmcpKXJldHVyblwiaW5pdGlhbGl6YXRpb25CaW5kaW5nOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgbj0wO248ZS5pbml0aWFsaXphdGlvbkJpbmRpbmcubGVuZ3RoOysrbil7dmFyIHI9bS5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KGUuaW5pdGlhbGl6YXRpb25CaW5kaW5nW25dKTtpZihyKXJldHVyblwiaW5pdGlhbGl6YXRpb25CaW5kaW5nLlwiK3J9fWlmKGUudXBkYXRlQmluZGluZyE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcInVwZGF0ZUJpbmRpbmdcIikpe2lmKCFBcnJheS5pc0FycmF5KGUudXBkYXRlQmluZGluZykpcmV0dXJuXCJ1cGRhdGVCaW5kaW5nOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgbj0wO248ZS51cGRhdGVCaW5kaW5nLmxlbmd0aDsrK24pe3ZhciByPW0ub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShlLnVwZGF0ZUJpbmRpbmdbbl0pO2lmKHIpcmV0dXJuXCJ1cGRhdGVCaW5kaW5nLlwiK3J9fXJldHVybiBudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIG0ub25ueC5UcmFpbmluZ0luZm9Qcm90bylyZXR1cm4gZTt2YXIgcj1uZXcgbS5vbm54LlRyYWluaW5nSW5mb1Byb3RvO2lmKGUuaW5pdGlhbGl6YXRpb24hPW51bGwpe2lmKHR5cGVvZiBlLmluaXRpYWxpemF0aW9uIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRyYWluaW5nSW5mb1Byb3RvLmluaXRpYWxpemF0aW9uOiBvYmplY3QgZXhwZWN0ZWRcIik7ci5pbml0aWFsaXphdGlvbj1tLm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KGUuaW5pdGlhbGl6YXRpb24pfWlmKGUuYWxnb3JpdGhtIT1udWxsKXtpZih0eXBlb2YgZS5hbGdvcml0aG0hPVwib2JqZWN0XCIpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8uYWxnb3JpdGhtOiBvYmplY3QgZXhwZWN0ZWRcIik7ci5hbGdvcml0aG09bS5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdChlLmFsZ29yaXRobSl9aWYoZS5pbml0aWFsaXphdGlvbkJpbmRpbmcpe2lmKCFBcnJheS5pc0FycmF5KGUuaW5pdGlhbGl6YXRpb25CaW5kaW5nKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UcmFpbmluZ0luZm9Qcm90by5pbml0aWFsaXphdGlvbkJpbmRpbmc6IGFycmF5IGV4cGVjdGVkXCIpO3IuaW5pdGlhbGl6YXRpb25CaW5kaW5nPVtdO2Zvcih2YXIgbj0wO248ZS5pbml0aWFsaXphdGlvbkJpbmRpbmcubGVuZ3RoOysrbil7aWYodHlwZW9mIGUuaW5pdGlhbGl6YXRpb25CaW5kaW5nW25dIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRyYWluaW5nSW5mb1Byb3RvLmluaXRpYWxpemF0aW9uQmluZGluZzogb2JqZWN0IGV4cGVjdGVkXCIpO3IuaW5pdGlhbGl6YXRpb25CaW5kaW5nW25dPW0ub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3QoZS5pbml0aWFsaXphdGlvbkJpbmRpbmdbbl0pfX1pZihlLnVwZGF0ZUJpbmRpbmcpe2lmKCFBcnJheS5pc0FycmF5KGUudXBkYXRlQmluZGluZykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8udXBkYXRlQmluZGluZzogYXJyYXkgZXhwZWN0ZWRcIik7ci51cGRhdGVCaW5kaW5nPVtdO2Zvcih2YXIgbj0wO248ZS51cGRhdGVCaW5kaW5nLmxlbmd0aDsrK24pe2lmKHR5cGVvZiBlLnVwZGF0ZUJpbmRpbmdbbl0hPVwib2JqZWN0XCIpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8udXBkYXRlQmluZGluZzogb2JqZWN0IGV4cGVjdGVkXCIpO3IudXBkYXRlQmluZGluZ1tuXT1tLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KGUudXBkYXRlQmluZGluZ1tuXSl9fXJldHVybiByfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKGUscil7cnx8KHI9e30pO3ZhciBuPXt9O2lmKChyLmFycmF5c3x8ci5kZWZhdWx0cykmJihuLmluaXRpYWxpemF0aW9uQmluZGluZz1bXSxuLnVwZGF0ZUJpbmRpbmc9W10pLHIuZGVmYXVsdHMmJihuLmluaXRpYWxpemF0aW9uPW51bGwsbi5hbGdvcml0aG09bnVsbCksZS5pbml0aWFsaXphdGlvbiE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImluaXRpYWxpemF0aW9uXCIpJiYobi5pbml0aWFsaXphdGlvbj1tLm9ubnguR3JhcGhQcm90by50b09iamVjdChlLmluaXRpYWxpemF0aW9uLHIpKSxlLmFsZ29yaXRobSE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImFsZ29yaXRobVwiKSYmKG4uYWxnb3JpdGhtPW0ub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KGUuYWxnb3JpdGhtLHIpKSxlLmluaXRpYWxpemF0aW9uQmluZGluZyYmZS5pbml0aWFsaXphdGlvbkJpbmRpbmcubGVuZ3RoKXtuLmluaXRpYWxpemF0aW9uQmluZGluZz1bXTtmb3IodmFyIHM9MDtzPGUuaW5pdGlhbGl6YXRpb25CaW5kaW5nLmxlbmd0aDsrK3Mpbi5pbml0aWFsaXphdGlvbkJpbmRpbmdbc109bS5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QoZS5pbml0aWFsaXphdGlvbkJpbmRpbmdbc10scil9aWYoZS51cGRhdGVCaW5kaW5nJiZlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoKXtuLnVwZGF0ZUJpbmRpbmc9W107Zm9yKHZhciBzPTA7czxlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoOysrcyluLnVwZGF0ZUJpbmRpbmdbc109bS5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QoZS51cGRhdGVCaW5kaW5nW3NdLHIpfXJldHVybiBufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGdlLnV0aWwudG9KU09OT3B0aW9ucyl9LHQuZ2V0VHlwZVVybD1mdW5jdGlvbihlKXtyZXR1cm4gZT09PXZvaWQgMCYmKGU9XCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpLGUrXCIvb25ueC5UcmFpbmluZ0luZm9Qcm90b1wifSx0fSgpLGEuTW9kZWxQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobyl7aWYodGhpcy5vcHNldEltcG9ydD1bXSx0aGlzLm1ldGFkYXRhUHJvcHM9W10sdGhpcy50cmFpbmluZ0luZm89W10sdGhpcy5mdW5jdGlvbnM9W10sbylmb3IodmFyIGU9T2JqZWN0LmtleXMobykscj0wO3I8ZS5sZW5ndGg7KytyKW9bZVtyXV0hPW51bGwmJih0aGlzW2Vbcl1dPW9bZVtyXV0pfXJldHVybiB0LnByb3RvdHlwZS5pclZlcnNpb249eS5Mb25nP3kuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsdC5wcm90b3R5cGUub3BzZXRJbXBvcnQ9eS5lbXB0eUFycmF5LHQucHJvdG90eXBlLnByb2R1Y2VyTmFtZT1cIlwiLHQucHJvdG90eXBlLnByb2R1Y2VyVmVyc2lvbj1cIlwiLHQucHJvdG90eXBlLmRvbWFpbj1cIlwiLHQucHJvdG90eXBlLm1vZGVsVmVyc2lvbj15Lkxvbmc/eS5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCx0LnByb3RvdHlwZS5kb2NTdHJpbmc9XCJcIix0LnByb3RvdHlwZS5ncmFwaD1udWxsLHQucHJvdG90eXBlLm1ldGFkYXRhUHJvcHM9eS5lbXB0eUFycmF5LHQucHJvdG90eXBlLnRyYWluaW5nSW5mbz15LmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZnVuY3Rpb25zPXkuZW1wdHlBcnJheSx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKGUscil7aWYocnx8KHI9RWUuY3JlYXRlKCkpLGUuaXJWZXJzaW9uIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiaXJWZXJzaW9uXCIpJiZyLnVpbnQzMig4KS5pbnQ2NChlLmlyVmVyc2lvbiksZS5wcm9kdWNlck5hbWUhPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJwcm9kdWNlck5hbWVcIikmJnIudWludDMyKDE4KS5zdHJpbmcoZS5wcm9kdWNlck5hbWUpLGUucHJvZHVjZXJWZXJzaW9uIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwicHJvZHVjZXJWZXJzaW9uXCIpJiZyLnVpbnQzMigyNikuc3RyaW5nKGUucHJvZHVjZXJWZXJzaW9uKSxlLmRvbWFpbiE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImRvbWFpblwiKSYmci51aW50MzIoMzQpLnN0cmluZyhlLmRvbWFpbiksZS5tb2RlbFZlcnNpb24hPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJtb2RlbFZlcnNpb25cIikmJnIudWludDMyKDQwKS5pbnQ2NChlLm1vZGVsVmVyc2lvbiksZS5kb2NTdHJpbmchPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJkb2NTdHJpbmdcIikmJnIudWludDMyKDUwKS5zdHJpbmcoZS5kb2NTdHJpbmcpLGUuZ3JhcGghPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJncmFwaFwiKSYmbS5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKGUuZ3JhcGgsci51aW50MzIoNTgpLmZvcmsoKSkubGRlbGltKCksZS5vcHNldEltcG9ydCE9bnVsbCYmZS5vcHNldEltcG9ydC5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLm9wc2V0SW1wb3J0Lmxlbmd0aDsrK24pbS5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5lbmNvZGUoZS5vcHNldEltcG9ydFtuXSxyLnVpbnQzMig2NikuZm9yaygpKS5sZGVsaW0oKTtpZihlLm1ldGFkYXRhUHJvcHMhPW51bGwmJmUubWV0YWRhdGFQcm9wcy5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLm1ldGFkYXRhUHJvcHMubGVuZ3RoOysrbiltLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUoZS5tZXRhZGF0YVByb3BzW25dLHIudWludDMyKDExNCkuZm9yaygpKS5sZGVsaW0oKTtpZihlLnRyYWluaW5nSW5mbyE9bnVsbCYmZS50cmFpbmluZ0luZm8ubGVuZ3RoKWZvcih2YXIgbj0wO248ZS50cmFpbmluZ0luZm8ubGVuZ3RoOysrbiltLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8uZW5jb2RlKGUudHJhaW5pbmdJbmZvW25dLHIudWludDMyKDE2MikuZm9yaygpKS5sZGVsaW0oKTtpZihlLmZ1bmN0aW9ucyE9bnVsbCYmZS5mdW5jdGlvbnMubGVuZ3RoKWZvcih2YXIgbj0wO248ZS5mdW5jdGlvbnMubGVuZ3RoOysrbiltLm9ubnguRnVuY3Rpb25Qcm90by5lbmNvZGUoZS5mdW5jdGlvbnNbbl0sci51aW50MzIoMjAyKS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiByfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbihlLHIpe3JldHVybiB0aGlzLmVuY29kZShlLHIpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbihlLHIpe2UgaW5zdGFuY2VvZiBOfHwoZT1OLmNyZWF0ZShlKSk7Zm9yKHZhciBuPXI9PT12b2lkIDA/ZS5sZW46ZS5wb3MrcixzPW5ldyBtLm9ubnguTW9kZWxQcm90bztlLnBvczxuOyl7dmFyIGk9ZS51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTp7cy5pclZlcnNpb249ZS5pbnQ2NCgpO2JyZWFrfWNhc2UgODp7cy5vcHNldEltcG9ydCYmcy5vcHNldEltcG9ydC5sZW5ndGh8fChzLm9wc2V0SW1wb3J0PVtdKSxzLm9wc2V0SW1wb3J0LnB1c2gobS5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWt9Y2FzZSAyOntzLnByb2R1Y2VyTmFtZT1lLnN0cmluZygpO2JyZWFrfWNhc2UgMzp7cy5wcm9kdWNlclZlcnNpb249ZS5zdHJpbmcoKTticmVha31jYXNlIDQ6e3MuZG9tYWluPWUuc3RyaW5nKCk7YnJlYWt9Y2FzZSA1OntzLm1vZGVsVmVyc2lvbj1lLmludDY0KCk7YnJlYWt9Y2FzZSA2OntzLmRvY1N0cmluZz1lLnN0cmluZygpO2JyZWFrfWNhc2UgNzp7cy5ncmFwaD1tLm9ubnguR3JhcGhQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVha31jYXNlIDE0OntzLm1ldGFkYXRhUHJvcHMmJnMubWV0YWRhdGFQcm9wcy5sZW5ndGh8fChzLm1ldGFkYXRhUHJvcHM9W10pLHMubWV0YWRhdGFQcm9wcy5wdXNoKG0ub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVha31jYXNlIDIwOntzLnRyYWluaW5nSW5mbyYmcy50cmFpbmluZ0luZm8ubGVuZ3RofHwocy50cmFpbmluZ0luZm89W10pLHMudHJhaW5pbmdJbmZvLnB1c2gobS5vbm54LlRyYWluaW5nSW5mb1Byb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVha31jYXNlIDI1OntzLmZ1bmN0aW9ucyYmcy5mdW5jdGlvbnMubGVuZ3RofHwocy5mdW5jdGlvbnM9W10pLHMuZnVuY3Rpb25zLnB1c2gobS5vbm54LkZ1bmN0aW9uUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrfWRlZmF1bHQ6ZS5za2lwVHlwZShpJjcpO2JyZWFrfX1yZXR1cm4gc30sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBOfHwoZT1uZXcgTihlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYodHlwZW9mIGUhPVwib2JqZWN0XCJ8fGU9PT1udWxsKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYoZS5pclZlcnNpb24hPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJpclZlcnNpb25cIikmJiF5LmlzSW50ZWdlcihlLmlyVmVyc2lvbikmJiEoZS5pclZlcnNpb24mJnkuaXNJbnRlZ2VyKGUuaXJWZXJzaW9uLmxvdykmJnkuaXNJbnRlZ2VyKGUuaXJWZXJzaW9uLmhpZ2gpKSlyZXR1cm5cImlyVmVyc2lvbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7aWYoZS5vcHNldEltcG9ydCE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcIm9wc2V0SW1wb3J0XCIpKXtpZighQXJyYXkuaXNBcnJheShlLm9wc2V0SW1wb3J0KSlyZXR1cm5cIm9wc2V0SW1wb3J0OiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgcj0wO3I8ZS5vcHNldEltcG9ydC5sZW5ndGg7KytyKXt2YXIgbj1tLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLnZlcmlmeShlLm9wc2V0SW1wb3J0W3JdKTtpZihuKXJldHVyblwib3BzZXRJbXBvcnQuXCIrbn19aWYoZS5wcm9kdWNlck5hbWUhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlck5hbWVcIikmJiF5LmlzU3RyaW5nKGUucHJvZHVjZXJOYW1lKSlyZXR1cm5cInByb2R1Y2VyTmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYoZS5wcm9kdWNlclZlcnNpb24hPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlclZlcnNpb25cIikmJiF5LmlzU3RyaW5nKGUucHJvZHVjZXJWZXJzaW9uKSlyZXR1cm5cInByb2R1Y2VyVmVyc2lvbjogc3RyaW5nIGV4cGVjdGVkXCI7aWYoZS5kb21haW4hPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJiF5LmlzU3RyaW5nKGUuZG9tYWluKSlyZXR1cm5cImRvbWFpbjogc3RyaW5nIGV4cGVjdGVkXCI7aWYoZS5tb2RlbFZlcnNpb24hPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJtb2RlbFZlcnNpb25cIikmJiF5LmlzSW50ZWdlcihlLm1vZGVsVmVyc2lvbikmJiEoZS5tb2RlbFZlcnNpb24mJnkuaXNJbnRlZ2VyKGUubW9kZWxWZXJzaW9uLmxvdykmJnkuaXNJbnRlZ2VyKGUubW9kZWxWZXJzaW9uLmhpZ2gpKSlyZXR1cm5cIm1vZGVsVmVyc2lvbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7aWYoZS5kb2NTdHJpbmchPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJiF5LmlzU3RyaW5nKGUuZG9jU3RyaW5nKSlyZXR1cm5cImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7aWYoZS5ncmFwaCE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImdyYXBoXCIpKXt2YXIgbj1tLm9ubnguR3JhcGhQcm90by52ZXJpZnkoZS5ncmFwaCk7aWYobilyZXR1cm5cImdyYXBoLlwiK259aWYoZS5tZXRhZGF0YVByb3BzIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwibWV0YWRhdGFQcm9wc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5tZXRhZGF0YVByb3BzKSlyZXR1cm5cIm1ldGFkYXRhUHJvcHM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciByPTA7cjxlLm1ldGFkYXRhUHJvcHMubGVuZ3RoOysrcil7dmFyIG49bS5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KGUubWV0YWRhdGFQcm9wc1tyXSk7aWYobilyZXR1cm5cIm1ldGFkYXRhUHJvcHMuXCIrbn19aWYoZS50cmFpbmluZ0luZm8hPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJ0cmFpbmluZ0luZm9cIikpe2lmKCFBcnJheS5pc0FycmF5KGUudHJhaW5pbmdJbmZvKSlyZXR1cm5cInRyYWluaW5nSW5mbzogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHI9MDtyPGUudHJhaW5pbmdJbmZvLmxlbmd0aDsrK3Ipe3ZhciBuPW0ub25ueC5UcmFpbmluZ0luZm9Qcm90by52ZXJpZnkoZS50cmFpbmluZ0luZm9bcl0pO2lmKG4pcmV0dXJuXCJ0cmFpbmluZ0luZm8uXCIrbn19aWYoZS5mdW5jdGlvbnMhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJmdW5jdGlvbnNcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuZnVuY3Rpb25zKSlyZXR1cm5cImZ1bmN0aW9uczogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHI9MDtyPGUuZnVuY3Rpb25zLmxlbmd0aDsrK3Ipe3ZhciBuPW0ub25ueC5GdW5jdGlvblByb3RvLnZlcmlmeShlLmZ1bmN0aW9uc1tyXSk7aWYobilyZXR1cm5cImZ1bmN0aW9ucy5cIitufX1yZXR1cm4gbnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBtLm9ubnguTW9kZWxQcm90bylyZXR1cm4gZTt2YXIgcj1uZXcgbS5vbm54Lk1vZGVsUHJvdG87aWYoZS5pclZlcnNpb24hPW51bGwmJih5Lkxvbmc/KHIuaXJWZXJzaW9uPXkuTG9uZy5mcm9tVmFsdWUoZS5pclZlcnNpb24pKS51bnNpZ25lZD0hMTp0eXBlb2YgZS5pclZlcnNpb249PVwic3RyaW5nXCI/ci5pclZlcnNpb249cGFyc2VJbnQoZS5pclZlcnNpb24sMTApOnR5cGVvZiBlLmlyVmVyc2lvbj09XCJudW1iZXJcIj9yLmlyVmVyc2lvbj1lLmlyVmVyc2lvbjp0eXBlb2YgZS5pclZlcnNpb249PVwib2JqZWN0XCImJihyLmlyVmVyc2lvbj1uZXcgeS5Mb25nQml0cyhlLmlyVmVyc2lvbi5sb3c+Pj4wLGUuaXJWZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpKSksZS5vcHNldEltcG9ydCl7aWYoIUFycmF5LmlzQXJyYXkoZS5vcHNldEltcG9ydCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIik7ci5vcHNldEltcG9ydD1bXTtmb3IodmFyIG49MDtuPGUub3BzZXRJbXBvcnQubGVuZ3RoOysrbil7aWYodHlwZW9mIGUub3BzZXRJbXBvcnRbbl0hPVwib2JqZWN0XCIpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogb2JqZWN0IGV4cGVjdGVkXCIpO3Iub3BzZXRJbXBvcnRbbl09bS5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5mcm9tT2JqZWN0KGUub3BzZXRJbXBvcnRbbl0pfX1pZihlLnByb2R1Y2VyTmFtZSE9bnVsbCYmKHIucHJvZHVjZXJOYW1lPVN0cmluZyhlLnByb2R1Y2VyTmFtZSkpLGUucHJvZHVjZXJWZXJzaW9uIT1udWxsJiYoci5wcm9kdWNlclZlcnNpb249U3RyaW5nKGUucHJvZHVjZXJWZXJzaW9uKSksZS5kb21haW4hPW51bGwmJihyLmRvbWFpbj1TdHJpbmcoZS5kb21haW4pKSxlLm1vZGVsVmVyc2lvbiE9bnVsbCYmKHkuTG9uZz8oci5tb2RlbFZlcnNpb249eS5Mb25nLmZyb21WYWx1ZShlLm1vZGVsVmVyc2lvbikpLnVuc2lnbmVkPSExOnR5cGVvZiBlLm1vZGVsVmVyc2lvbj09XCJzdHJpbmdcIj9yLm1vZGVsVmVyc2lvbj1wYXJzZUludChlLm1vZGVsVmVyc2lvbiwxMCk6dHlwZW9mIGUubW9kZWxWZXJzaW9uPT1cIm51bWJlclwiP3IubW9kZWxWZXJzaW9uPWUubW9kZWxWZXJzaW9uOnR5cGVvZiBlLm1vZGVsVmVyc2lvbj09XCJvYmplY3RcIiYmKHIubW9kZWxWZXJzaW9uPW5ldyB5LkxvbmdCaXRzKGUubW9kZWxWZXJzaW9uLmxvdz4+PjAsZS5tb2RlbFZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCkpKSxlLmRvY1N0cmluZyE9bnVsbCYmKHIuZG9jU3RyaW5nPVN0cmluZyhlLmRvY1N0cmluZykpLGUuZ3JhcGghPW51bGwpe2lmKHR5cGVvZiBlLmdyYXBoIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8uZ3JhcGg6IG9iamVjdCBleHBlY3RlZFwiKTtyLmdyYXBoPW0ub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3QoZS5ncmFwaCl9aWYoZS5tZXRhZGF0YVByb3BzKXtpZighQXJyYXkuaXNBcnJheShlLm1ldGFkYXRhUHJvcHMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8ubWV0YWRhdGFQcm9wczogYXJyYXkgZXhwZWN0ZWRcIik7ci5tZXRhZGF0YVByb3BzPVtdO2Zvcih2YXIgbj0wO248ZS5tZXRhZGF0YVByb3BzLmxlbmd0aDsrK24pe2lmKHR5cGVvZiBlLm1ldGFkYXRhUHJvcHNbbl0hPVwib2JqZWN0XCIpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5tZXRhZGF0YVByb3BzOiBvYmplY3QgZXhwZWN0ZWRcIik7ci5tZXRhZGF0YVByb3BzW25dPW0ub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3QoZS5tZXRhZGF0YVByb3BzW25dKX19aWYoZS50cmFpbmluZ0luZm8pe2lmKCFBcnJheS5pc0FycmF5KGUudHJhaW5pbmdJbmZvKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLnRyYWluaW5nSW5mbzogYXJyYXkgZXhwZWN0ZWRcIik7ci50cmFpbmluZ0luZm89W107Zm9yKHZhciBuPTA7bjxlLnRyYWluaW5nSW5mby5sZW5ndGg7KytuKXtpZih0eXBlb2YgZS50cmFpbmluZ0luZm9bbl0hPVwib2JqZWN0XCIpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by50cmFpbmluZ0luZm86IG9iamVjdCBleHBlY3RlZFwiKTtyLnRyYWluaW5nSW5mb1tuXT1tLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8uZnJvbU9iamVjdChlLnRyYWluaW5nSW5mb1tuXSl9fWlmKGUuZnVuY3Rpb25zKXtpZighQXJyYXkuaXNBcnJheShlLmZ1bmN0aW9ucykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5mdW5jdGlvbnM6IGFycmF5IGV4cGVjdGVkXCIpO3IuZnVuY3Rpb25zPVtdO2Zvcih2YXIgbj0wO248ZS5mdW5jdGlvbnMubGVuZ3RoOysrbil7aWYodHlwZW9mIGUuZnVuY3Rpb25zW25dIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8uZnVuY3Rpb25zOiBvYmplY3QgZXhwZWN0ZWRcIik7ci5mdW5jdGlvbnNbbl09bS5vbm54LkZ1bmN0aW9uUHJvdG8uZnJvbU9iamVjdChlLmZ1bmN0aW9uc1tuXSl9fXJldHVybiByfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKGUscil7cnx8KHI9e30pO3ZhciBuPXt9O2lmKChyLmFycmF5c3x8ci5kZWZhdWx0cykmJihuLm9wc2V0SW1wb3J0PVtdLG4ubWV0YWRhdGFQcm9wcz1bXSxuLnRyYWluaW5nSW5mbz1bXSxuLmZ1bmN0aW9ucz1bXSksci5kZWZhdWx0cyl7aWYoeS5Mb25nKXt2YXIgcz1uZXcgeS5Mb25nKDAsMCwhMSk7bi5pclZlcnNpb249ci5sb25ncz09PVN0cmluZz9zLnRvU3RyaW5nKCk6ci5sb25ncz09PU51bWJlcj9zLnRvTnVtYmVyKCk6c31lbHNlIG4uaXJWZXJzaW9uPXIubG9uZ3M9PT1TdHJpbmc/XCIwXCI6MDtpZihuLnByb2R1Y2VyTmFtZT1cIlwiLG4ucHJvZHVjZXJWZXJzaW9uPVwiXCIsbi5kb21haW49XCJcIix5Lkxvbmcpe3ZhciBzPW5ldyB5LkxvbmcoMCwwLCExKTtuLm1vZGVsVmVyc2lvbj1yLmxvbmdzPT09U3RyaW5nP3MudG9TdHJpbmcoKTpyLmxvbmdzPT09TnVtYmVyP3MudG9OdW1iZXIoKTpzfWVsc2Ugbi5tb2RlbFZlcnNpb249ci5sb25ncz09PVN0cmluZz9cIjBcIjowO24uZG9jU3RyaW5nPVwiXCIsbi5ncmFwaD1udWxsfWlmKGUuaXJWZXJzaW9uIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiaXJWZXJzaW9uXCIpJiYodHlwZW9mIGUuaXJWZXJzaW9uPT1cIm51bWJlclwiP24uaXJWZXJzaW9uPXIubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKGUuaXJWZXJzaW9uKTplLmlyVmVyc2lvbjpuLmlyVmVyc2lvbj1yLmxvbmdzPT09U3RyaW5nP3kuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlLmlyVmVyc2lvbik6ci5sb25ncz09PU51bWJlcj9uZXcgeS5Mb25nQml0cyhlLmlyVmVyc2lvbi5sb3c+Pj4wLGUuaXJWZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpOmUuaXJWZXJzaW9uKSxlLnByb2R1Y2VyTmFtZSE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyTmFtZVwiKSYmKG4ucHJvZHVjZXJOYW1lPWUucHJvZHVjZXJOYW1lKSxlLnByb2R1Y2VyVmVyc2lvbiE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyVmVyc2lvblwiKSYmKG4ucHJvZHVjZXJWZXJzaW9uPWUucHJvZHVjZXJWZXJzaW9uKSxlLmRvbWFpbiE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmKG4uZG9tYWluPWUuZG9tYWluKSxlLm1vZGVsVmVyc2lvbiE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcIm1vZGVsVmVyc2lvblwiKSYmKHR5cGVvZiBlLm1vZGVsVmVyc2lvbj09XCJudW1iZXJcIj9uLm1vZGVsVmVyc2lvbj1yLmxvbmdzPT09U3RyaW5nP1N0cmluZyhlLm1vZGVsVmVyc2lvbik6ZS5tb2RlbFZlcnNpb246bi5tb2RlbFZlcnNpb249ci5sb25ncz09PVN0cmluZz95LkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZS5tb2RlbFZlcnNpb24pOnIubG9uZ3M9PT1OdW1iZXI/bmV3IHkuTG9uZ0JpdHMoZS5tb2RlbFZlcnNpb24ubG93Pj4+MCxlLm1vZGVsVmVyc2lvbi5oaWdoPj4+MCkudG9OdW1iZXIoKTplLm1vZGVsVmVyc2lvbiksZS5kb2NTdHJpbmchPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz1lLmRvY1N0cmluZyksZS5ncmFwaCE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImdyYXBoXCIpJiYobi5ncmFwaD1tLm9ubnguR3JhcGhQcm90by50b09iamVjdChlLmdyYXBoLHIpKSxlLm9wc2V0SW1wb3J0JiZlLm9wc2V0SW1wb3J0Lmxlbmd0aCl7bi5vcHNldEltcG9ydD1bXTtmb3IodmFyIGk9MDtpPGUub3BzZXRJbXBvcnQubGVuZ3RoOysraSluLm9wc2V0SW1wb3J0W2ldPW0ub25ueC5PcGVyYXRvclNldElkUHJvdG8udG9PYmplY3QoZS5vcHNldEltcG9ydFtpXSxyKX1pZihlLm1ldGFkYXRhUHJvcHMmJmUubWV0YWRhdGFQcm9wcy5sZW5ndGgpe24ubWV0YWRhdGFQcm9wcz1bXTtmb3IodmFyIGk9MDtpPGUubWV0YWRhdGFQcm9wcy5sZW5ndGg7KytpKW4ubWV0YWRhdGFQcm9wc1tpXT1tLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdChlLm1ldGFkYXRhUHJvcHNbaV0scil9aWYoZS50cmFpbmluZ0luZm8mJmUudHJhaW5pbmdJbmZvLmxlbmd0aCl7bi50cmFpbmluZ0luZm89W107Zm9yKHZhciBpPTA7aTxlLnRyYWluaW5nSW5mby5sZW5ndGg7KytpKW4udHJhaW5pbmdJbmZvW2ldPW0ub25ueC5UcmFpbmluZ0luZm9Qcm90by50b09iamVjdChlLnRyYWluaW5nSW5mb1tpXSxyKX1pZihlLmZ1bmN0aW9ucyYmZS5mdW5jdGlvbnMubGVuZ3RoKXtuLmZ1bmN0aW9ucz1bXTtmb3IodmFyIGk9MDtpPGUuZnVuY3Rpb25zLmxlbmd0aDsrK2kpbi5mdW5jdGlvbnNbaV09bS5vbm54LkZ1bmN0aW9uUHJvdG8udG9PYmplY3QoZS5mdW5jdGlvbnNbaV0scil9cmV0dXJuIG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsZ2UudXRpbC50b0pTT05PcHRpb25zKX0sdC5nZXRUeXBlVXJsPWZ1bmN0aW9uKGUpe3JldHVybiBlPT09dm9pZCAwJiYoZT1cInR5cGUuZ29vZ2xlYXBpcy5jb21cIiksZStcIi9vbm54Lk1vZGVsUHJvdG9cIn0sdH0oKSxhLlN0cmluZ1N0cmluZ0VudHJ5UHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KG8pe2lmKG8pZm9yKHZhciBlPU9iamVjdC5rZXlzKG8pLHI9MDtyPGUubGVuZ3RoOysrcilvW2Vbcl1dIT1udWxsJiYodGhpc1tlW3JdXT1vW2Vbcl1dKX1yZXR1cm4gdC5wcm90b3R5cGUua2V5PVwiXCIsdC5wcm90b3R5cGUudmFsdWU9XCJcIix0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKGUscil7cmV0dXJuIHJ8fChyPUVlLmNyZWF0ZSgpKSxlLmtleSE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImtleVwiKSYmci51aW50MzIoMTApLnN0cmluZyhlLmtleSksZS52YWx1ZSE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcInZhbHVlXCIpJiZyLnVpbnQzMigxOCkuc3RyaW5nKGUudmFsdWUpLHJ9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUscil7cmV0dXJuIHRoaXMuZW5jb2RlKGUscikubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKGUscil7ZSBpbnN0YW5jZW9mIE58fChlPU4uY3JlYXRlKGUpKTtmb3IodmFyIG49cj09PXZvaWQgMD9lLmxlbjplLnBvcytyLHM9bmV3IG0ub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvO2UucG9zPG47KXt2YXIgaT1lLnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOntzLmtleT1lLnN0cmluZygpO2JyZWFrfWNhc2UgMjp7cy52YWx1ZT1lLnN0cmluZygpO2JyZWFrfWRlZmF1bHQ6ZS5za2lwVHlwZShpJjcpO2JyZWFrfX1yZXR1cm4gc30sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBOfHwoZT1uZXcgTihlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlIT1cIm9iamVjdFwifHxlPT09bnVsbD9cIm9iamVjdCBleHBlY3RlZFwiOmUua2V5IT1udWxsJiZlLmhhc093blByb3BlcnR5KFwia2V5XCIpJiYheS5pc1N0cmluZyhlLmtleSk/XCJrZXk6IHN0cmluZyBleHBlY3RlZFwiOmUudmFsdWUhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSYmIXkuaXNTdHJpbmcoZS52YWx1ZSk/XCJ2YWx1ZTogc3RyaW5nIGV4cGVjdGVkXCI6bnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBtLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90bylyZXR1cm4gZTt2YXIgcj1uZXcgbS5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG87cmV0dXJuIGUua2V5IT1udWxsJiYoci5rZXk9U3RyaW5nKGUua2V5KSksZS52YWx1ZSE9bnVsbCYmKHIudmFsdWU9U3RyaW5nKGUudmFsdWUpKSxyfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKGUscil7cnx8KHI9e30pO3ZhciBuPXt9O3JldHVybiByLmRlZmF1bHRzJiYobi5rZXk9XCJcIixuLnZhbHVlPVwiXCIpLGUua2V5IT1udWxsJiZlLmhhc093blByb3BlcnR5KFwia2V5XCIpJiYobi5rZXk9ZS5rZXkpLGUudmFsdWUhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSYmKG4udmFsdWU9ZS52YWx1ZSksbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxnZS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0LmdldFR5cGVVcmw9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT12b2lkIDAmJihlPVwidHlwZS5nb29nbGVhcGlzLmNvbVwiKSxlK1wiL29ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1wifSx0fSgpLGEuVGVuc29yQW5ub3RhdGlvbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobyl7aWYodGhpcy5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPVtdLG8pZm9yKHZhciBlPU9iamVjdC5rZXlzKG8pLHI9MDtyPGUubGVuZ3RoOysrcilvW2Vbcl1dIT1udWxsJiYodGhpc1tlW3JdXT1vW2Vbcl1dKX1yZXR1cm4gdC5wcm90b3R5cGUudGVuc29yTmFtZT1cIlwiLHQucHJvdG90eXBlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9eS5lbXB0eUFycmF5LHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24oZSxyKXtpZihyfHwocj1FZS5jcmVhdGUoKSksZS50ZW5zb3JOYW1lIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwidGVuc29yTmFtZVwiKSYmci51aW50MzIoMTApLnN0cmluZyhlLnRlbnNvck5hbWUpLGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyE9bnVsbCYmZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aClmb3IodmFyIG49MDtuPGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7KytuKW0ub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZShlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbbl0sci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7cmV0dXJuIHJ9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUscil7cmV0dXJuIHRoaXMuZW5jb2RlKGUscikubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKGUscil7ZSBpbnN0YW5jZW9mIE58fChlPU4uY3JlYXRlKGUpKTtmb3IodmFyIG49cj09PXZvaWQgMD9lLmxlbjplLnBvcytyLHM9bmV3IG0ub25ueC5UZW5zb3JBbm5vdGF0aW9uO2UucG9zPG47KXt2YXIgaT1lLnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOntzLnRlbnNvck5hbWU9ZS5zdHJpbmcoKTticmVha31jYXNlIDI6e3MucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmcy5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aHx8KHMucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1bXSkscy5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLnB1c2gobS5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrfWRlZmF1bHQ6ZS5za2lwVHlwZShpJjcpO2JyZWFrfX1yZXR1cm4gc30sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBOfHwoZT1uZXcgTihlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYodHlwZW9mIGUhPVwib2JqZWN0XCJ8fGU9PT1udWxsKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYoZS50ZW5zb3JOYW1lIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwidGVuc29yTmFtZVwiKSYmIXkuaXNTdHJpbmcoZS50ZW5zb3JOYW1lKSlyZXR1cm5cInRlbnNvck5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNcIikpe2lmKCFBcnJheS5pc0FycmF5KGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcykpcmV0dXJuXCJxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgcj0wO3I8ZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK3Ipe3ZhciBuPW0ub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbcl0pO2lmKG4pcmV0dXJuXCJxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLlwiK259fXJldHVybiBudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIG0ub25ueC5UZW5zb3JBbm5vdGF0aW9uKXJldHVybiBlO3ZhciByPW5ldyBtLm9ubnguVGVuc29yQW5ub3RhdGlvbjtpZihlLnRlbnNvck5hbWUhPW51bGwmJihyLnRlbnNvck5hbWU9U3RyaW5nKGUudGVuc29yTmFtZSkpLGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyl7aWYoIUFycmF5LmlzQXJyYXkoZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JBbm5vdGF0aW9uLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM6IGFycmF5IGV4cGVjdGVkXCIpO3IucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1bXTtmb3IodmFyIG49MDtuPGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7KytuKXtpZih0eXBlb2YgZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW25dIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvckFubm90YXRpb24ucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lczogb2JqZWN0IGV4cGVjdGVkXCIpO3IucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXT1tLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXSl9fXJldHVybiByfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKGUscil7cnx8KHI9e30pO3ZhciBuPXt9O2lmKChyLmFycmF5c3x8ci5kZWZhdWx0cykmJihuLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9W10pLHIuZGVmYXVsdHMmJihuLnRlbnNvck5hbWU9XCJcIiksZS50ZW5zb3JOYW1lIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwidGVuc29yTmFtZVwiKSYmKG4udGVuc29yTmFtZT1lLnRlbnNvck5hbWUpLGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aCl7bi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPVtdO2Zvcih2YXIgcz0wO3M8ZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK3Mpbi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW3NdPW0ub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tzXSxyKX1yZXR1cm4gbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxnZS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0LmdldFR5cGVVcmw9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT12b2lkIDAmJihlPVwidHlwZS5nb29nbGVhcGlzLmNvbVwiKSxlK1wiL29ubnguVGVuc29yQW5ub3RhdGlvblwifSx0fSgpLGEuR3JhcGhQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobyl7aWYodGhpcy5ub2RlPVtdLHRoaXMuaW5pdGlhbGl6ZXI9W10sdGhpcy5zcGFyc2VJbml0aWFsaXplcj1bXSx0aGlzLmlucHV0PVtdLHRoaXMub3V0cHV0PVtdLHRoaXMudmFsdWVJbmZvPVtdLHRoaXMucXVhbnRpemF0aW9uQW5ub3RhdGlvbj1bXSxvKWZvcih2YXIgZT1PYmplY3Qua2V5cyhvKSxyPTA7cjxlLmxlbmd0aDsrK3Ipb1tlW3JdXSE9bnVsbCYmKHRoaXNbZVtyXV09b1tlW3JdXSl9cmV0dXJuIHQucHJvdG90eXBlLm5vZGU9eS5lbXB0eUFycmF5LHQucHJvdG90eXBlLm5hbWU9XCJcIix0LnByb3RvdHlwZS5pbml0aWFsaXplcj15LmVtcHR5QXJyYXksdC5wcm90b3R5cGUuc3BhcnNlSW5pdGlhbGl6ZXI9eS5lbXB0eUFycmF5LHQucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLHQucHJvdG90eXBlLmlucHV0PXkuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5vdXRwdXQ9eS5lbXB0eUFycmF5LHQucHJvdG90eXBlLnZhbHVlSW5mbz15LmVtcHR5QXJyYXksdC5wcm90b3R5cGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbj15LmVtcHR5QXJyYXksdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbihlLHIpe2lmKHJ8fChyPUVlLmNyZWF0ZSgpKSxlLm5vZGUhPW51bGwmJmUubm9kZS5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLm5vZGUubGVuZ3RoOysrbiltLm9ubnguTm9kZVByb3RvLmVuY29kZShlLm5vZGVbbl0sci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7aWYoZS5uYW1lIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwibmFtZVwiKSYmci51aW50MzIoMTgpLnN0cmluZyhlLm5hbWUpLGUuaW5pdGlhbGl6ZXIhPW51bGwmJmUuaW5pdGlhbGl6ZXIubGVuZ3RoKWZvcih2YXIgbj0wO248ZS5pbml0aWFsaXplci5sZW5ndGg7KytuKW0ub25ueC5UZW5zb3JQcm90by5lbmNvZGUoZS5pbml0aWFsaXplcltuXSxyLnVpbnQzMig0MikuZm9yaygpKS5sZGVsaW0oKTtpZihlLmRvY1N0cmluZyE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImRvY1N0cmluZ1wiKSYmci51aW50MzIoODIpLnN0cmluZyhlLmRvY1N0cmluZyksZS5pbnB1dCE9bnVsbCYmZS5pbnB1dC5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLmlucHV0Lmxlbmd0aDsrK24pbS5vbm54LlZhbHVlSW5mb1Byb3RvLmVuY29kZShlLmlucHV0W25dLHIudWludDMyKDkwKS5mb3JrKCkpLmxkZWxpbSgpO2lmKGUub3V0cHV0IT1udWxsJiZlLm91dHB1dC5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLm91dHB1dC5sZW5ndGg7KytuKW0ub25ueC5WYWx1ZUluZm9Qcm90by5lbmNvZGUoZS5vdXRwdXRbbl0sci51aW50MzIoOTgpLmZvcmsoKSkubGRlbGltKCk7aWYoZS52YWx1ZUluZm8hPW51bGwmJmUudmFsdWVJbmZvLmxlbmd0aClmb3IodmFyIG49MDtuPGUudmFsdWVJbmZvLmxlbmd0aDsrK24pbS5vbm54LlZhbHVlSW5mb1Byb3RvLmVuY29kZShlLnZhbHVlSW5mb1tuXSxyLnVpbnQzMigxMDYpLmZvcmsoKSkubGRlbGltKCk7aWYoZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uIT1udWxsJiZlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoKWZvcih2YXIgbj0wO248ZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsrK24pbS5vbm54LlRlbnNvckFubm90YXRpb24uZW5jb2RlKGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbltuXSxyLnVpbnQzMigxMTQpLmZvcmsoKSkubGRlbGltKCk7aWYoZS5zcGFyc2VJbml0aWFsaXplciE9bnVsbCYmZS5zcGFyc2VJbml0aWFsaXplci5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLnNwYXJzZUluaXRpYWxpemVyLmxlbmd0aDsrK24pbS5vbm54LlNwYXJzZVRlbnNvclByb3RvLmVuY29kZShlLnNwYXJzZUluaXRpYWxpemVyW25dLHIudWludDMyKDEyMikuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gcn0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdGhpcy5lbmNvZGUoZSxyKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24oZSxyKXtlIGluc3RhbmNlb2YgTnx8KGU9Ti5jcmVhdGUoZSkpO2Zvcih2YXIgbj1yPT09dm9pZCAwP2UubGVuOmUucG9zK3Iscz1uZXcgbS5vbm54LkdyYXBoUHJvdG87ZS5wb3M8bjspe3ZhciBpPWUudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6e3Mubm9kZSYmcy5ub2RlLmxlbmd0aHx8KHMubm9kZT1bXSkscy5ub2RlLnB1c2gobS5vbm54Lk5vZGVQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWt9Y2FzZSAyOntzLm5hbWU9ZS5zdHJpbmcoKTticmVha31jYXNlIDU6e3MuaW5pdGlhbGl6ZXImJnMuaW5pdGlhbGl6ZXIubGVuZ3RofHwocy5pbml0aWFsaXplcj1bXSkscy5pbml0aWFsaXplci5wdXNoKG0ub25ueC5UZW5zb3JQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWt9Y2FzZSAxNTp7cy5zcGFyc2VJbml0aWFsaXplciYmcy5zcGFyc2VJbml0aWFsaXplci5sZW5ndGh8fChzLnNwYXJzZUluaXRpYWxpemVyPVtdKSxzLnNwYXJzZUluaXRpYWxpemVyLnB1c2gobS5vbm54LlNwYXJzZVRlbnNvclByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVha31jYXNlIDEwOntzLmRvY1N0cmluZz1lLnN0cmluZygpO2JyZWFrfWNhc2UgMTE6e3MuaW5wdXQmJnMuaW5wdXQubGVuZ3RofHwocy5pbnB1dD1bXSkscy5pbnB1dC5wdXNoKG0ub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWt9Y2FzZSAxMjp7cy5vdXRwdXQmJnMub3V0cHV0Lmxlbmd0aHx8KHMub3V0cHV0PVtdKSxzLm91dHB1dC5wdXNoKG0ub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWt9Y2FzZSAxMzp7cy52YWx1ZUluZm8mJnMudmFsdWVJbmZvLmxlbmd0aHx8KHMudmFsdWVJbmZvPVtdKSxzLnZhbHVlSW5mby5wdXNoKG0ub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWt9Y2FzZSAxNDp7cy5xdWFudGl6YXRpb25Bbm5vdGF0aW9uJiZzLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RofHwocy5xdWFudGl6YXRpb25Bbm5vdGF0aW9uPVtdKSxzLnF1YW50aXphdGlvbkFubm90YXRpb24ucHVzaChtLm9ubnguVGVuc29yQW5ub3RhdGlvbi5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWt9ZGVmYXVsdDplLnNraXBUeXBlKGkmNyk7YnJlYWt9fXJldHVybiBzfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIE58fChlPW5ldyBOKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbihlKXtpZih0eXBlb2YgZSE9XCJvYmplY3RcInx8ZT09PW51bGwpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihlLm5vZGUhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJub2RlXCIpKXtpZighQXJyYXkuaXNBcnJheShlLm5vZGUpKXJldHVyblwibm9kZTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHI9MDtyPGUubm9kZS5sZW5ndGg7KytyKXt2YXIgbj1tLm9ubnguTm9kZVByb3RvLnZlcmlmeShlLm5vZGVbcl0pO2lmKG4pcmV0dXJuXCJub2RlLlwiK259fWlmKGUubmFtZSE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiF5LmlzU3RyaW5nKGUubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihlLmluaXRpYWxpemVyIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiaW5pdGlhbGl6ZXJcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuaW5pdGlhbGl6ZXIpKXJldHVyblwiaW5pdGlhbGl6ZXI6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciByPTA7cjxlLmluaXRpYWxpemVyLmxlbmd0aDsrK3Ipe3ZhciBuPW0ub25ueC5UZW5zb3JQcm90by52ZXJpZnkoZS5pbml0aWFsaXplcltyXSk7aWYobilyZXR1cm5cImluaXRpYWxpemVyLlwiK259fWlmKGUuc3BhcnNlSW5pdGlhbGl6ZXIhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJzcGFyc2VJbml0aWFsaXplclwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5zcGFyc2VJbml0aWFsaXplcikpcmV0dXJuXCJzcGFyc2VJbml0aWFsaXplcjogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHI9MDtyPGUuc3BhcnNlSW5pdGlhbGl6ZXIubGVuZ3RoOysrcil7dmFyIG49bS5vbm54LlNwYXJzZVRlbnNvclByb3RvLnZlcmlmeShlLnNwYXJzZUluaXRpYWxpemVyW3JdKTtpZihuKXJldHVyblwic3BhcnNlSW5pdGlhbGl6ZXIuXCIrbn19aWYoZS5kb2NTdHJpbmchPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJiF5LmlzU3RyaW5nKGUuZG9jU3RyaW5nKSlyZXR1cm5cImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7aWYoZS5pbnB1dCE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImlucHV0XCIpKXtpZighQXJyYXkuaXNBcnJheShlLmlucHV0KSlyZXR1cm5cImlucHV0OiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgcj0wO3I8ZS5pbnB1dC5sZW5ndGg7KytyKXt2YXIgbj1tLm9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5KGUuaW5wdXRbcl0pO2lmKG4pcmV0dXJuXCJpbnB1dC5cIitufX1pZihlLm91dHB1dCE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcIm91dHB1dFwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5vdXRwdXQpKXJldHVyblwib3V0cHV0OiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgcj0wO3I8ZS5vdXRwdXQubGVuZ3RoOysrcil7dmFyIG49bS5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeShlLm91dHB1dFtyXSk7aWYobilyZXR1cm5cIm91dHB1dC5cIitufX1pZihlLnZhbHVlSW5mbyE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlSW5mb1wiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS52YWx1ZUluZm8pKXJldHVyblwidmFsdWVJbmZvOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgcj0wO3I8ZS52YWx1ZUluZm8ubGVuZ3RoOysrcil7dmFyIG49bS5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeShlLnZhbHVlSW5mb1tyXSk7aWYobilyZXR1cm5cInZhbHVlSW5mby5cIitufX1pZihlLnF1YW50aXphdGlvbkFubm90YXRpb24hPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJxdWFudGl6YXRpb25Bbm5vdGF0aW9uXCIpKXtpZighQXJyYXkuaXNBcnJheShlLnF1YW50aXphdGlvbkFubm90YXRpb24pKXJldHVyblwicXVhbnRpemF0aW9uQW5ub3RhdGlvbjogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHI9MDtyPGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGg7KytyKXt2YXIgbj1tLm9ubnguVGVuc29yQW5ub3RhdGlvbi52ZXJpZnkoZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW3JdKTtpZihuKXJldHVyblwicXVhbnRpemF0aW9uQW5ub3RhdGlvbi5cIitufX1yZXR1cm4gbnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBtLm9ubnguR3JhcGhQcm90bylyZXR1cm4gZTt2YXIgcj1uZXcgbS5vbm54LkdyYXBoUHJvdG87aWYoZS5ub2RlKXtpZighQXJyYXkuaXNBcnJheShlLm5vZGUpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ubm9kZTogYXJyYXkgZXhwZWN0ZWRcIik7ci5ub2RlPVtdO2Zvcih2YXIgbj0wO248ZS5ub2RlLmxlbmd0aDsrK24pe2lmKHR5cGVvZiBlLm5vZGVbbl0hPVwib2JqZWN0XCIpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5ub2RlOiBvYmplY3QgZXhwZWN0ZWRcIik7ci5ub2RlW25dPW0ub25ueC5Ob2RlUHJvdG8uZnJvbU9iamVjdChlLm5vZGVbbl0pfX1pZihlLm5hbWUhPW51bGwmJihyLm5hbWU9U3RyaW5nKGUubmFtZSkpLGUuaW5pdGlhbGl6ZXIpe2lmKCFBcnJheS5pc0FycmF5KGUuaW5pdGlhbGl6ZXIpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5pdGlhbGl6ZXI6IGFycmF5IGV4cGVjdGVkXCIpO3IuaW5pdGlhbGl6ZXI9W107Zm9yKHZhciBuPTA7bjxlLmluaXRpYWxpemVyLmxlbmd0aDsrK24pe2lmKHR5cGVvZiBlLmluaXRpYWxpemVyW25dIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5pdGlhbGl6ZXI6IG9iamVjdCBleHBlY3RlZFwiKTtyLmluaXRpYWxpemVyW25dPW0ub25ueC5UZW5zb3JQcm90by5mcm9tT2JqZWN0KGUuaW5pdGlhbGl6ZXJbbl0pfX1pZihlLnNwYXJzZUluaXRpYWxpemVyKXtpZighQXJyYXkuaXNBcnJheShlLnNwYXJzZUluaXRpYWxpemVyKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnNwYXJzZUluaXRpYWxpemVyOiBhcnJheSBleHBlY3RlZFwiKTtyLnNwYXJzZUluaXRpYWxpemVyPVtdO2Zvcih2YXIgbj0wO248ZS5zcGFyc2VJbml0aWFsaXplci5sZW5ndGg7KytuKXtpZih0eXBlb2YgZS5zcGFyc2VJbml0aWFsaXplcltuXSE9XCJvYmplY3RcIil0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnNwYXJzZUluaXRpYWxpemVyOiBvYmplY3QgZXhwZWN0ZWRcIik7ci5zcGFyc2VJbml0aWFsaXplcltuXT1tLm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZnJvbU9iamVjdChlLnNwYXJzZUluaXRpYWxpemVyW25dKX19aWYoZS5kb2NTdHJpbmchPW51bGwmJihyLmRvY1N0cmluZz1TdHJpbmcoZS5kb2NTdHJpbmcpKSxlLmlucHV0KXtpZighQXJyYXkuaXNBcnJheShlLmlucHV0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLmlucHV0OiBhcnJheSBleHBlY3RlZFwiKTtyLmlucHV0PVtdO2Zvcih2YXIgbj0wO248ZS5pbnB1dC5sZW5ndGg7KytuKXtpZih0eXBlb2YgZS5pbnB1dFtuXSE9XCJvYmplY3RcIil0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLmlucHV0OiBvYmplY3QgZXhwZWN0ZWRcIik7ci5pbnB1dFtuXT1tLm9ubnguVmFsdWVJbmZvUHJvdG8uZnJvbU9iamVjdChlLmlucHV0W25dKX19aWYoZS5vdXRwdXQpe2lmKCFBcnJheS5pc0FycmF5KGUub3V0cHV0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIik7ci5vdXRwdXQ9W107Zm9yKHZhciBuPTA7bjxlLm91dHB1dC5sZW5ndGg7KytuKXtpZih0eXBlb2YgZS5vdXRwdXRbbl0hPVwib2JqZWN0XCIpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5vdXRwdXQ6IG9iamVjdCBleHBlY3RlZFwiKTtyLm91dHB1dFtuXT1tLm9ubnguVmFsdWVJbmZvUHJvdG8uZnJvbU9iamVjdChlLm91dHB1dFtuXSl9fWlmKGUudmFsdWVJbmZvKXtpZighQXJyYXkuaXNBcnJheShlLnZhbHVlSW5mbykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by52YWx1ZUluZm86IGFycmF5IGV4cGVjdGVkXCIpO3IudmFsdWVJbmZvPVtdO2Zvcih2YXIgbj0wO248ZS52YWx1ZUluZm8ubGVuZ3RoOysrbil7aWYodHlwZW9mIGUudmFsdWVJbmZvW25dIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8udmFsdWVJbmZvOiBvYmplY3QgZXhwZWN0ZWRcIik7ci52YWx1ZUluZm9bbl09bS5vbm54LlZhbHVlSW5mb1Byb3RvLmZyb21PYmplY3QoZS52YWx1ZUluZm9bbl0pfX1pZihlLnF1YW50aXphdGlvbkFubm90YXRpb24pe2lmKCFBcnJheS5pc0FycmF5KGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbikpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5xdWFudGl6YXRpb25Bbm5vdGF0aW9uOiBhcnJheSBleHBlY3RlZFwiKTtyLnF1YW50aXphdGlvbkFubm90YXRpb249W107Zm9yKHZhciBuPTA7bjxlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOysrbil7aWYodHlwZW9mIGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbltuXSE9XCJvYmplY3RcIil0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnF1YW50aXphdGlvbkFubm90YXRpb246IG9iamVjdCBleHBlY3RlZFwiKTtyLnF1YW50aXphdGlvbkFubm90YXRpb25bbl09bS5vbm54LlRlbnNvckFubm90YXRpb24uZnJvbU9iamVjdChlLnF1YW50aXphdGlvbkFubm90YXRpb25bbl0pfX1yZXR1cm4gcn0sdC50b09iamVjdD1mdW5jdGlvbihlLHIpe3J8fChyPXt9KTt2YXIgbj17fTtpZigoci5hcnJheXN8fHIuZGVmYXVsdHMpJiYobi5ub2RlPVtdLG4uaW5pdGlhbGl6ZXI9W10sbi5pbnB1dD1bXSxuLm91dHB1dD1bXSxuLnZhbHVlSW5mbz1bXSxuLnF1YW50aXphdGlvbkFubm90YXRpb249W10sbi5zcGFyc2VJbml0aWFsaXplcj1bXSksci5kZWZhdWx0cyYmKG4ubmFtZT1cIlwiLG4uZG9jU3RyaW5nPVwiXCIpLGUubm9kZSYmZS5ub2RlLmxlbmd0aCl7bi5ub2RlPVtdO2Zvcih2YXIgcz0wO3M8ZS5ub2RlLmxlbmd0aDsrK3Mpbi5ub2RlW3NdPW0ub25ueC5Ob2RlUHJvdG8udG9PYmplY3QoZS5ub2RlW3NdLHIpfWlmKGUubmFtZSE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJihuLm5hbWU9ZS5uYW1lKSxlLmluaXRpYWxpemVyJiZlLmluaXRpYWxpemVyLmxlbmd0aCl7bi5pbml0aWFsaXplcj1bXTtmb3IodmFyIHM9MDtzPGUuaW5pdGlhbGl6ZXIubGVuZ3RoOysrcyluLmluaXRpYWxpemVyW3NdPW0ub25ueC5UZW5zb3JQcm90by50b09iamVjdChlLmluaXRpYWxpemVyW3NdLHIpfWlmKGUuZG9jU3RyaW5nIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9ZS5kb2NTdHJpbmcpLGUuaW5wdXQmJmUuaW5wdXQubGVuZ3RoKXtuLmlucHV0PVtdO2Zvcih2YXIgcz0wO3M8ZS5pbnB1dC5sZW5ndGg7KytzKW4uaW5wdXRbc109bS5vbm54LlZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0KGUuaW5wdXRbc10scil9aWYoZS5vdXRwdXQmJmUub3V0cHV0Lmxlbmd0aCl7bi5vdXRwdXQ9W107Zm9yKHZhciBzPTA7czxlLm91dHB1dC5sZW5ndGg7KytzKW4ub3V0cHV0W3NdPW0ub25ueC5WYWx1ZUluZm9Qcm90by50b09iamVjdChlLm91dHB1dFtzXSxyKX1pZihlLnZhbHVlSW5mbyYmZS52YWx1ZUluZm8ubGVuZ3RoKXtuLnZhbHVlSW5mbz1bXTtmb3IodmFyIHM9MDtzPGUudmFsdWVJbmZvLmxlbmd0aDsrK3Mpbi52YWx1ZUluZm9bc109bS5vbm54LlZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0KGUudmFsdWVJbmZvW3NdLHIpfWlmKGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbiYmZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aCl7bi5xdWFudGl6YXRpb25Bbm5vdGF0aW9uPVtdO2Zvcih2YXIgcz0wO3M8ZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsrK3Mpbi5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW3NdPW0ub25ueC5UZW5zb3JBbm5vdGF0aW9uLnRvT2JqZWN0KGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbltzXSxyKX1pZihlLnNwYXJzZUluaXRpYWxpemVyJiZlLnNwYXJzZUluaXRpYWxpemVyLmxlbmd0aCl7bi5zcGFyc2VJbml0aWFsaXplcj1bXTtmb3IodmFyIHM9MDtzPGUuc3BhcnNlSW5pdGlhbGl6ZXIubGVuZ3RoOysrcyluLnNwYXJzZUluaXRpYWxpemVyW3NdPW0ub25ueC5TcGFyc2VUZW5zb3JQcm90by50b09iamVjdChlLnNwYXJzZUluaXRpYWxpemVyW3NdLHIpfXJldHVybiBufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGdlLnV0aWwudG9KU09OT3B0aW9ucyl9LHQuZ2V0VHlwZVVybD1mdW5jdGlvbihlKXtyZXR1cm4gZT09PXZvaWQgMCYmKGU9XCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpLGUrXCIvb25ueC5HcmFwaFByb3RvXCJ9LHR9KCksYS5UZW5zb3JQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobyl7aWYodGhpcy5kaW1zPVtdLHRoaXMuZmxvYXREYXRhPVtdLHRoaXMuaW50MzJEYXRhPVtdLHRoaXMuc3RyaW5nRGF0YT1bXSx0aGlzLmludDY0RGF0YT1bXSx0aGlzLmV4dGVybmFsRGF0YT1bXSx0aGlzLmRvdWJsZURhdGE9W10sdGhpcy51aW50NjREYXRhPVtdLG8pZm9yKHZhciBlPU9iamVjdC5rZXlzKG8pLHI9MDtyPGUubGVuZ3RoOysrcilvW2Vbcl1dIT1udWxsJiYodGhpc1tlW3JdXT1vW2Vbcl1dKX1yZXR1cm4gdC5wcm90b3R5cGUuZGltcz15LmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZGF0YVR5cGU9MCx0LnByb3RvdHlwZS5zZWdtZW50PW51bGwsdC5wcm90b3R5cGUuZmxvYXREYXRhPXkuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5pbnQzMkRhdGE9eS5lbXB0eUFycmF5LHQucHJvdG90eXBlLnN0cmluZ0RhdGE9eS5lbXB0eUFycmF5LHQucHJvdG90eXBlLmludDY0RGF0YT15LmVtcHR5QXJyYXksdC5wcm90b3R5cGUubmFtZT1cIlwiLHQucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLHQucHJvdG90eXBlLnJhd0RhdGE9eS5uZXdCdWZmZXIoW10pLHQucHJvdG90eXBlLmV4dGVybmFsRGF0YT15LmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZGF0YUxvY2F0aW9uPTAsdC5wcm90b3R5cGUuZG91YmxlRGF0YT15LmVtcHR5QXJyYXksdC5wcm90b3R5cGUudWludDY0RGF0YT15LmVtcHR5QXJyYXksdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbihlLHIpe2lmKHJ8fChyPUVlLmNyZWF0ZSgpKSxlLmRpbXMhPW51bGwmJmUuZGltcy5sZW5ndGgpe3IudWludDMyKDEwKS5mb3JrKCk7Zm9yKHZhciBuPTA7bjxlLmRpbXMubGVuZ3RoOysrbilyLmludDY0KGUuZGltc1tuXSk7ci5sZGVsaW0oKX1pZihlLmRhdGFUeXBlIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiZGF0YVR5cGVcIikmJnIudWludDMyKDE2KS5pbnQzMihlLmRhdGFUeXBlKSxlLnNlZ21lbnQhPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJzZWdtZW50XCIpJiZtLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC5lbmNvZGUoZS5zZWdtZW50LHIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpLGUuZmxvYXREYXRhIT1udWxsJiZlLmZsb2F0RGF0YS5sZW5ndGgpe3IudWludDMyKDM0KS5mb3JrKCk7Zm9yKHZhciBuPTA7bjxlLmZsb2F0RGF0YS5sZW5ndGg7KytuKXIuZmxvYXQoZS5mbG9hdERhdGFbbl0pO3IubGRlbGltKCl9aWYoZS5pbnQzMkRhdGEhPW51bGwmJmUuaW50MzJEYXRhLmxlbmd0aCl7ci51aW50MzIoNDIpLmZvcmsoKTtmb3IodmFyIG49MDtuPGUuaW50MzJEYXRhLmxlbmd0aDsrK24pci5pbnQzMihlLmludDMyRGF0YVtuXSk7ci5sZGVsaW0oKX1pZihlLnN0cmluZ0RhdGEhPW51bGwmJmUuc3RyaW5nRGF0YS5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLnN0cmluZ0RhdGEubGVuZ3RoOysrbilyLnVpbnQzMig1MCkuYnl0ZXMoZS5zdHJpbmdEYXRhW25dKTtpZihlLmludDY0RGF0YSE9bnVsbCYmZS5pbnQ2NERhdGEubGVuZ3RoKXtyLnVpbnQzMig1OCkuZm9yaygpO2Zvcih2YXIgbj0wO248ZS5pbnQ2NERhdGEubGVuZ3RoOysrbilyLmludDY0KGUuaW50NjREYXRhW25dKTtyLmxkZWxpbSgpfWlmKGUubmFtZSE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcIm5hbWVcIikmJnIudWludDMyKDY2KS5zdHJpbmcoZS5uYW1lKSxlLnJhd0RhdGEhPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJyYXdEYXRhXCIpJiZyLnVpbnQzMig3NCkuYnl0ZXMoZS5yYXdEYXRhKSxlLmRvdWJsZURhdGEhPW51bGwmJmUuZG91YmxlRGF0YS5sZW5ndGgpe3IudWludDMyKDgyKS5mb3JrKCk7Zm9yKHZhciBuPTA7bjxlLmRvdWJsZURhdGEubGVuZ3RoOysrbilyLmRvdWJsZShlLmRvdWJsZURhdGFbbl0pO3IubGRlbGltKCl9aWYoZS51aW50NjREYXRhIT1udWxsJiZlLnVpbnQ2NERhdGEubGVuZ3RoKXtyLnVpbnQzMig5MCkuZm9yaygpO2Zvcih2YXIgbj0wO248ZS51aW50NjREYXRhLmxlbmd0aDsrK24pci51aW50NjQoZS51aW50NjREYXRhW25dKTtyLmxkZWxpbSgpfWlmKGUuZG9jU3RyaW5nIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiZG9jU3RyaW5nXCIpJiZyLnVpbnQzMig5OCkuc3RyaW5nKGUuZG9jU3RyaW5nKSxlLmV4dGVybmFsRGF0YSE9bnVsbCYmZS5leHRlcm5hbERhdGEubGVuZ3RoKWZvcih2YXIgbj0wO248ZS5leHRlcm5hbERhdGEubGVuZ3RoOysrbiltLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUoZS5leHRlcm5hbERhdGFbbl0sci51aW50MzIoMTA2KS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiBlLmRhdGFMb2NhdGlvbiE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImRhdGFMb2NhdGlvblwiKSYmci51aW50MzIoMTEyKS5pbnQzMihlLmRhdGFMb2NhdGlvbikscn0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdGhpcy5lbmNvZGUoZSxyKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24oZSxyKXtlIGluc3RhbmNlb2YgTnx8KGU9Ti5jcmVhdGUoZSkpO2Zvcih2YXIgbj1yPT09dm9pZCAwP2UubGVuOmUucG9zK3Iscz1uZXcgbS5vbm54LlRlbnNvclByb3RvO2UucG9zPG47KXt2YXIgaT1lLnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOntpZihzLmRpbXMmJnMuZGltcy5sZW5ndGh8fChzLmRpbXM9W10pLChpJjcpPT09Milmb3IodmFyIHU9ZS51aW50MzIoKStlLnBvcztlLnBvczx1OylzLmRpbXMucHVzaChlLmludDY0KCkpO2Vsc2Ugcy5kaW1zLnB1c2goZS5pbnQ2NCgpKTticmVha31jYXNlIDI6e3MuZGF0YVR5cGU9ZS5pbnQzMigpO2JyZWFrfWNhc2UgMzp7cy5zZWdtZW50PW0ub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrfWNhc2UgNDp7aWYocy5mbG9hdERhdGEmJnMuZmxvYXREYXRhLmxlbmd0aHx8KHMuZmxvYXREYXRhPVtdKSwoaSY3KT09PTIpZm9yKHZhciB1PWUudWludDMyKCkrZS5wb3M7ZS5wb3M8dTspcy5mbG9hdERhdGEucHVzaChlLmZsb2F0KCkpO2Vsc2Ugcy5mbG9hdERhdGEucHVzaChlLmZsb2F0KCkpO2JyZWFrfWNhc2UgNTp7aWYocy5pbnQzMkRhdGEmJnMuaW50MzJEYXRhLmxlbmd0aHx8KHMuaW50MzJEYXRhPVtdKSwoaSY3KT09PTIpZm9yKHZhciB1PWUudWludDMyKCkrZS5wb3M7ZS5wb3M8dTspcy5pbnQzMkRhdGEucHVzaChlLmludDMyKCkpO2Vsc2Ugcy5pbnQzMkRhdGEucHVzaChlLmludDMyKCkpO2JyZWFrfWNhc2UgNjp7cy5zdHJpbmdEYXRhJiZzLnN0cmluZ0RhdGEubGVuZ3RofHwocy5zdHJpbmdEYXRhPVtdKSxzLnN0cmluZ0RhdGEucHVzaChlLmJ5dGVzKCkpO2JyZWFrfWNhc2UgNzp7aWYocy5pbnQ2NERhdGEmJnMuaW50NjREYXRhLmxlbmd0aHx8KHMuaW50NjREYXRhPVtdKSwoaSY3KT09PTIpZm9yKHZhciB1PWUudWludDMyKCkrZS5wb3M7ZS5wb3M8dTspcy5pbnQ2NERhdGEucHVzaChlLmludDY0KCkpO2Vsc2Ugcy5pbnQ2NERhdGEucHVzaChlLmludDY0KCkpO2JyZWFrfWNhc2UgODp7cy5uYW1lPWUuc3RyaW5nKCk7YnJlYWt9Y2FzZSAxMjp7cy5kb2NTdHJpbmc9ZS5zdHJpbmcoKTticmVha31jYXNlIDk6e3MucmF3RGF0YT1lLmJ5dGVzKCk7YnJlYWt9Y2FzZSAxMzp7cy5leHRlcm5hbERhdGEmJnMuZXh0ZXJuYWxEYXRhLmxlbmd0aHx8KHMuZXh0ZXJuYWxEYXRhPVtdKSxzLmV4dGVybmFsRGF0YS5wdXNoKG0ub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVha31jYXNlIDE0OntzLmRhdGFMb2NhdGlvbj1lLmludDMyKCk7YnJlYWt9Y2FzZSAxMDp7aWYocy5kb3VibGVEYXRhJiZzLmRvdWJsZURhdGEubGVuZ3RofHwocy5kb3VibGVEYXRhPVtdKSwoaSY3KT09PTIpZm9yKHZhciB1PWUudWludDMyKCkrZS5wb3M7ZS5wb3M8dTspcy5kb3VibGVEYXRhLnB1c2goZS5kb3VibGUoKSk7ZWxzZSBzLmRvdWJsZURhdGEucHVzaChlLmRvdWJsZSgpKTticmVha31jYXNlIDExOntpZihzLnVpbnQ2NERhdGEmJnMudWludDY0RGF0YS5sZW5ndGh8fChzLnVpbnQ2NERhdGE9W10pLChpJjcpPT09Milmb3IodmFyIHU9ZS51aW50MzIoKStlLnBvcztlLnBvczx1OylzLnVpbnQ2NERhdGEucHVzaChlLnVpbnQ2NCgpKTtlbHNlIHMudWludDY0RGF0YS5wdXNoKGUudWludDY0KCkpO2JyZWFrfWRlZmF1bHQ6ZS5za2lwVHlwZShpJjcpO2JyZWFrfX1yZXR1cm4gc30sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBOfHwoZT1uZXcgTihlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYodHlwZW9mIGUhPVwib2JqZWN0XCJ8fGU9PT1udWxsKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYoZS5kaW1zIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiZGltc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5kaW1zKSlyZXR1cm5cImRpbXM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciByPTA7cjxlLmRpbXMubGVuZ3RoOysrcilpZigheS5pc0ludGVnZXIoZS5kaW1zW3JdKSYmIShlLmRpbXNbcl0mJnkuaXNJbnRlZ2VyKGUuZGltc1tyXS5sb3cpJiZ5LmlzSW50ZWdlcihlLmRpbXNbcl0uaGlnaCkpKXJldHVyblwiZGltczogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWRcIn1pZihlLmRhdGFUeXBlIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiZGF0YVR5cGVcIikmJiF5LmlzSW50ZWdlcihlLmRhdGFUeXBlKSlyZXR1cm5cImRhdGFUeXBlOiBpbnRlZ2VyIGV4cGVjdGVkXCI7aWYoZS5zZWdtZW50IT1udWxsJiZlLmhhc093blByb3BlcnR5KFwic2VnbWVudFwiKSl7dmFyIG49bS5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQudmVyaWZ5KGUuc2VnbWVudCk7aWYobilyZXR1cm5cInNlZ21lbnQuXCIrbn1pZihlLmZsb2F0RGF0YSE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImZsb2F0RGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5mbG9hdERhdGEpKXJldHVyblwiZmxvYXREYXRhOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgcj0wO3I8ZS5mbG9hdERhdGEubGVuZ3RoOysrcilpZih0eXBlb2YgZS5mbG9hdERhdGFbcl0hPVwibnVtYmVyXCIpcmV0dXJuXCJmbG9hdERhdGE6IG51bWJlcltdIGV4cGVjdGVkXCJ9aWYoZS5pbnQzMkRhdGEhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJpbnQzMkRhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuaW50MzJEYXRhKSlyZXR1cm5cImludDMyRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHI9MDtyPGUuaW50MzJEYXRhLmxlbmd0aDsrK3IpaWYoIXkuaXNJbnRlZ2VyKGUuaW50MzJEYXRhW3JdKSlyZXR1cm5cImludDMyRGF0YTogaW50ZWdlcltdIGV4cGVjdGVkXCJ9aWYoZS5zdHJpbmdEYXRhIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwic3RyaW5nRGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5zdHJpbmdEYXRhKSlyZXR1cm5cInN0cmluZ0RhdGE6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciByPTA7cjxlLnN0cmluZ0RhdGEubGVuZ3RoOysrcilpZighKGUuc3RyaW5nRGF0YVtyXSYmdHlwZW9mIGUuc3RyaW5nRGF0YVtyXS5sZW5ndGg9PVwibnVtYmVyXCJ8fHkuaXNTdHJpbmcoZS5zdHJpbmdEYXRhW3JdKSkpcmV0dXJuXCJzdHJpbmdEYXRhOiBidWZmZXJbXSBleHBlY3RlZFwifWlmKGUuaW50NjREYXRhIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiaW50NjREYXRhXCIpKXtpZighQXJyYXkuaXNBcnJheShlLmludDY0RGF0YSkpcmV0dXJuXCJpbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciByPTA7cjxlLmludDY0RGF0YS5sZW5ndGg7KytyKWlmKCF5LmlzSW50ZWdlcihlLmludDY0RGF0YVtyXSkmJiEoZS5pbnQ2NERhdGFbcl0mJnkuaXNJbnRlZ2VyKGUuaW50NjREYXRhW3JdLmxvdykmJnkuaXNJbnRlZ2VyKGUuaW50NjREYXRhW3JdLmhpZ2gpKSlyZXR1cm5cImludDY0RGF0YTogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWRcIn1pZihlLm5hbWUhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYheS5pc1N0cmluZyhlLm5hbWUpKXJldHVyblwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYoZS5kb2NTdHJpbmchPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJiF5LmlzU3RyaW5nKGUuZG9jU3RyaW5nKSlyZXR1cm5cImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7aWYoZS5yYXdEYXRhIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwicmF3RGF0YVwiKSYmIShlLnJhd0RhdGEmJnR5cGVvZiBlLnJhd0RhdGEubGVuZ3RoPT1cIm51bWJlclwifHx5LmlzU3RyaW5nKGUucmF3RGF0YSkpKXJldHVyblwicmF3RGF0YTogYnVmZmVyIGV4cGVjdGVkXCI7aWYoZS5leHRlcm5hbERhdGEhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJleHRlcm5hbERhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuZXh0ZXJuYWxEYXRhKSlyZXR1cm5cImV4dGVybmFsRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHI9MDtyPGUuZXh0ZXJuYWxEYXRhLmxlbmd0aDsrK3Ipe3ZhciBuPW0ub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShlLmV4dGVybmFsRGF0YVtyXSk7aWYobilyZXR1cm5cImV4dGVybmFsRGF0YS5cIitufX1pZihlLmRhdGFMb2NhdGlvbiE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFMb2NhdGlvblwiKSlzd2l0Y2goZS5kYXRhTG9jYXRpb24pe2RlZmF1bHQ6cmV0dXJuXCJkYXRhTG9jYXRpb246IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtjYXNlIDA6Y2FzZSAxOmJyZWFrfWlmKGUuZG91YmxlRGF0YSE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImRvdWJsZURhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuZG91YmxlRGF0YSkpcmV0dXJuXCJkb3VibGVEYXRhOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgcj0wO3I8ZS5kb3VibGVEYXRhLmxlbmd0aDsrK3IpaWYodHlwZW9mIGUuZG91YmxlRGF0YVtyXSE9XCJudW1iZXJcIilyZXR1cm5cImRvdWJsZURhdGE6IG51bWJlcltdIGV4cGVjdGVkXCJ9aWYoZS51aW50NjREYXRhIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwidWludDY0RGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS51aW50NjREYXRhKSlyZXR1cm5cInVpbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciByPTA7cjxlLnVpbnQ2NERhdGEubGVuZ3RoOysrcilpZigheS5pc0ludGVnZXIoZS51aW50NjREYXRhW3JdKSYmIShlLnVpbnQ2NERhdGFbcl0mJnkuaXNJbnRlZ2VyKGUudWludDY0RGF0YVtyXS5sb3cpJiZ5LmlzSW50ZWdlcihlLnVpbnQ2NERhdGFbcl0uaGlnaCkpKXJldHVyblwidWludDY0RGF0YTogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWRcIn1yZXR1cm4gbnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBtLm9ubnguVGVuc29yUHJvdG8pcmV0dXJuIGU7dmFyIHI9bmV3IG0ub25ueC5UZW5zb3JQcm90bztpZihlLmRpbXMpe2lmKCFBcnJheS5pc0FycmF5KGUuZGltcykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZGltczogYXJyYXkgZXhwZWN0ZWRcIik7ci5kaW1zPVtdO2Zvcih2YXIgbj0wO248ZS5kaW1zLmxlbmd0aDsrK24peS5Mb25nPyhyLmRpbXNbbl09eS5Mb25nLmZyb21WYWx1ZShlLmRpbXNbbl0pKS51bnNpZ25lZD0hMTp0eXBlb2YgZS5kaW1zW25dPT1cInN0cmluZ1wiP3IuZGltc1tuXT1wYXJzZUludChlLmRpbXNbbl0sMTApOnR5cGVvZiBlLmRpbXNbbl09PVwibnVtYmVyXCI/ci5kaW1zW25dPWUuZGltc1tuXTp0eXBlb2YgZS5kaW1zW25dPT1cIm9iamVjdFwiJiYoci5kaW1zW25dPW5ldyB5LkxvbmdCaXRzKGUuZGltc1tuXS5sb3c+Pj4wLGUuZGltc1tuXS5oaWdoPj4+MCkudG9OdW1iZXIoKSl9aWYoZS5kYXRhVHlwZSE9bnVsbCYmKHIuZGF0YVR5cGU9ZS5kYXRhVHlwZXwwKSxlLnNlZ21lbnQhPW51bGwpe2lmKHR5cGVvZiBlLnNlZ21lbnQhPVwib2JqZWN0XCIpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uc2VnbWVudDogb2JqZWN0IGV4cGVjdGVkXCIpO3Iuc2VnbWVudD1tLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC5mcm9tT2JqZWN0KGUuc2VnbWVudCl9aWYoZS5mbG9hdERhdGEpe2lmKCFBcnJheS5pc0FycmF5KGUuZmxvYXREYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5mbG9hdERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO3IuZmxvYXREYXRhPVtdO2Zvcih2YXIgbj0wO248ZS5mbG9hdERhdGEubGVuZ3RoOysrbilyLmZsb2F0RGF0YVtuXT1OdW1iZXIoZS5mbG9hdERhdGFbbl0pfWlmKGUuaW50MzJEYXRhKXtpZighQXJyYXkuaXNBcnJheShlLmludDMyRGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uaW50MzJEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtyLmludDMyRGF0YT1bXTtmb3IodmFyIG49MDtuPGUuaW50MzJEYXRhLmxlbmd0aDsrK24pci5pbnQzMkRhdGFbbl09ZS5pbnQzMkRhdGFbbl18MH1pZihlLnN0cmluZ0RhdGEpe2lmKCFBcnJheS5pc0FycmF5KGUuc3RyaW5nRGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uc3RyaW5nRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7ci5zdHJpbmdEYXRhPVtdO2Zvcih2YXIgbj0wO248ZS5zdHJpbmdEYXRhLmxlbmd0aDsrK24pdHlwZW9mIGUuc3RyaW5nRGF0YVtuXT09XCJzdHJpbmdcIj95LmJhc2U2NC5kZWNvZGUoZS5zdHJpbmdEYXRhW25dLHIuc3RyaW5nRGF0YVtuXT15Lm5ld0J1ZmZlcih5LmJhc2U2NC5sZW5ndGgoZS5zdHJpbmdEYXRhW25dKSksMCk6ZS5zdHJpbmdEYXRhW25dLmxlbmd0aD49MCYmKHIuc3RyaW5nRGF0YVtuXT1lLnN0cmluZ0RhdGFbbl0pfWlmKGUuaW50NjREYXRhKXtpZighQXJyYXkuaXNBcnJheShlLmludDY0RGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uaW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiKTtyLmludDY0RGF0YT1bXTtmb3IodmFyIG49MDtuPGUuaW50NjREYXRhLmxlbmd0aDsrK24peS5Mb25nPyhyLmludDY0RGF0YVtuXT15LkxvbmcuZnJvbVZhbHVlKGUuaW50NjREYXRhW25dKSkudW5zaWduZWQ9ITE6dHlwZW9mIGUuaW50NjREYXRhW25dPT1cInN0cmluZ1wiP3IuaW50NjREYXRhW25dPXBhcnNlSW50KGUuaW50NjREYXRhW25dLDEwKTp0eXBlb2YgZS5pbnQ2NERhdGFbbl09PVwibnVtYmVyXCI/ci5pbnQ2NERhdGFbbl09ZS5pbnQ2NERhdGFbbl06dHlwZW9mIGUuaW50NjREYXRhW25dPT1cIm9iamVjdFwiJiYoci5pbnQ2NERhdGFbbl09bmV3IHkuTG9uZ0JpdHMoZS5pbnQ2NERhdGFbbl0ubG93Pj4+MCxlLmludDY0RGF0YVtuXS5oaWdoPj4+MCkudG9OdW1iZXIoKSl9aWYoZS5uYW1lIT1udWxsJiYoci5uYW1lPVN0cmluZyhlLm5hbWUpKSxlLmRvY1N0cmluZyE9bnVsbCYmKHIuZG9jU3RyaW5nPVN0cmluZyhlLmRvY1N0cmluZykpLGUucmF3RGF0YSE9bnVsbCYmKHR5cGVvZiBlLnJhd0RhdGE9PVwic3RyaW5nXCI/eS5iYXNlNjQuZGVjb2RlKGUucmF3RGF0YSxyLnJhd0RhdGE9eS5uZXdCdWZmZXIoeS5iYXNlNjQubGVuZ3RoKGUucmF3RGF0YSkpLDApOmUucmF3RGF0YS5sZW5ndGg+PTAmJihyLnJhd0RhdGE9ZS5yYXdEYXRhKSksZS5leHRlcm5hbERhdGEpe2lmKCFBcnJheS5pc0FycmF5KGUuZXh0ZXJuYWxEYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5leHRlcm5hbERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO3IuZXh0ZXJuYWxEYXRhPVtdO2Zvcih2YXIgbj0wO248ZS5leHRlcm5hbERhdGEubGVuZ3RoOysrbil7aWYodHlwZW9mIGUuZXh0ZXJuYWxEYXRhW25dIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmV4dGVybmFsRGF0YTogb2JqZWN0IGV4cGVjdGVkXCIpO3IuZXh0ZXJuYWxEYXRhW25dPW0ub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3QoZS5leHRlcm5hbERhdGFbbl0pfX1zd2l0Y2goZS5kYXRhTG9jYXRpb24pe2RlZmF1bHQ6aWYodHlwZW9mIGUuZGF0YUxvY2F0aW9uPT1cIm51bWJlclwiKXtyLmRhdGFMb2NhdGlvbj1lLmRhdGFMb2NhdGlvbjticmVha31icmVhaztjYXNlXCJERUZBVUxUXCI6Y2FzZSAwOnIuZGF0YUxvY2F0aW9uPTA7YnJlYWs7Y2FzZVwiRVhURVJOQUxcIjpjYXNlIDE6ci5kYXRhTG9jYXRpb249MTticmVha31pZihlLmRvdWJsZURhdGEpe2lmKCFBcnJheS5pc0FycmF5KGUuZG91YmxlRGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZG91YmxlRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7ci5kb3VibGVEYXRhPVtdO2Zvcih2YXIgbj0wO248ZS5kb3VibGVEYXRhLmxlbmd0aDsrK24pci5kb3VibGVEYXRhW25dPU51bWJlcihlLmRvdWJsZURhdGFbbl0pfWlmKGUudWludDY0RGF0YSl7aWYoIUFycmF5LmlzQXJyYXkoZS51aW50NjREYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by51aW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiKTtyLnVpbnQ2NERhdGE9W107Zm9yKHZhciBuPTA7bjxlLnVpbnQ2NERhdGEubGVuZ3RoOysrbil5Lkxvbmc/KHIudWludDY0RGF0YVtuXT15LkxvbmcuZnJvbVZhbHVlKGUudWludDY0RGF0YVtuXSkpLnVuc2lnbmVkPSEwOnR5cGVvZiBlLnVpbnQ2NERhdGFbbl09PVwic3RyaW5nXCI/ci51aW50NjREYXRhW25dPXBhcnNlSW50KGUudWludDY0RGF0YVtuXSwxMCk6dHlwZW9mIGUudWludDY0RGF0YVtuXT09XCJudW1iZXJcIj9yLnVpbnQ2NERhdGFbbl09ZS51aW50NjREYXRhW25dOnR5cGVvZiBlLnVpbnQ2NERhdGFbbl09PVwib2JqZWN0XCImJihyLnVpbnQ2NERhdGFbbl09bmV3IHkuTG9uZ0JpdHMoZS51aW50NjREYXRhW25dLmxvdz4+PjAsZS51aW50NjREYXRhW25dLmhpZ2g+Pj4wKS50b051bWJlcighMCkpfXJldHVybiByfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKGUscil7cnx8KHI9e30pO3ZhciBuPXt9O2lmKChyLmFycmF5c3x8ci5kZWZhdWx0cykmJihuLmRpbXM9W10sbi5mbG9hdERhdGE9W10sbi5pbnQzMkRhdGE9W10sbi5zdHJpbmdEYXRhPVtdLG4uaW50NjREYXRhPVtdLG4uZG91YmxlRGF0YT1bXSxuLnVpbnQ2NERhdGE9W10sbi5leHRlcm5hbERhdGE9W10pLHIuZGVmYXVsdHMmJihuLmRhdGFUeXBlPTAsbi5zZWdtZW50PW51bGwsbi5uYW1lPVwiXCIsci5ieXRlcz09PVN0cmluZz9uLnJhd0RhdGE9XCJcIjoobi5yYXdEYXRhPVtdLHIuYnl0ZXMhPT1BcnJheSYmKG4ucmF3RGF0YT15Lm5ld0J1ZmZlcihuLnJhd0RhdGEpKSksbi5kb2NTdHJpbmc9XCJcIixuLmRhdGFMb2NhdGlvbj1yLmVudW1zPT09U3RyaW5nP1wiREVGQVVMVFwiOjApLGUuZGltcyYmZS5kaW1zLmxlbmd0aCl7bi5kaW1zPVtdO2Zvcih2YXIgcz0wO3M8ZS5kaW1zLmxlbmd0aDsrK3MpdHlwZW9mIGUuZGltc1tzXT09XCJudW1iZXJcIj9uLmRpbXNbc109ci5sb25ncz09PVN0cmluZz9TdHJpbmcoZS5kaW1zW3NdKTplLmRpbXNbc106bi5kaW1zW3NdPXIubG9uZ3M9PT1TdHJpbmc/eS5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUuZGltc1tzXSk6ci5sb25ncz09PU51bWJlcj9uZXcgeS5Mb25nQml0cyhlLmRpbXNbc10ubG93Pj4+MCxlLmRpbXNbc10uaGlnaD4+PjApLnRvTnVtYmVyKCk6ZS5kaW1zW3NdfWlmKGUuZGF0YVR5cGUhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJkYXRhVHlwZVwiKSYmKG4uZGF0YVR5cGU9ZS5kYXRhVHlwZSksZS5zZWdtZW50IT1udWxsJiZlLmhhc093blByb3BlcnR5KFwic2VnbWVudFwiKSYmKG4uc2VnbWVudD1tLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC50b09iamVjdChlLnNlZ21lbnQscikpLGUuZmxvYXREYXRhJiZlLmZsb2F0RGF0YS5sZW5ndGgpe24uZmxvYXREYXRhPVtdO2Zvcih2YXIgcz0wO3M8ZS5mbG9hdERhdGEubGVuZ3RoOysrcyluLmZsb2F0RGF0YVtzXT1yLmpzb24mJiFpc0Zpbml0ZShlLmZsb2F0RGF0YVtzXSk/U3RyaW5nKGUuZmxvYXREYXRhW3NdKTplLmZsb2F0RGF0YVtzXX1pZihlLmludDMyRGF0YSYmZS5pbnQzMkRhdGEubGVuZ3RoKXtuLmludDMyRGF0YT1bXTtmb3IodmFyIHM9MDtzPGUuaW50MzJEYXRhLmxlbmd0aDsrK3Mpbi5pbnQzMkRhdGFbc109ZS5pbnQzMkRhdGFbc119aWYoZS5zdHJpbmdEYXRhJiZlLnN0cmluZ0RhdGEubGVuZ3RoKXtuLnN0cmluZ0RhdGE9W107Zm9yKHZhciBzPTA7czxlLnN0cmluZ0RhdGEubGVuZ3RoOysrcyluLnN0cmluZ0RhdGFbc109ci5ieXRlcz09PVN0cmluZz95LmJhc2U2NC5lbmNvZGUoZS5zdHJpbmdEYXRhW3NdLDAsZS5zdHJpbmdEYXRhW3NdLmxlbmd0aCk6ci5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUuc3RyaW5nRGF0YVtzXSk6ZS5zdHJpbmdEYXRhW3NdfWlmKGUuaW50NjREYXRhJiZlLmludDY0RGF0YS5sZW5ndGgpe24uaW50NjREYXRhPVtdO2Zvcih2YXIgcz0wO3M8ZS5pbnQ2NERhdGEubGVuZ3RoOysrcyl0eXBlb2YgZS5pbnQ2NERhdGFbc109PVwibnVtYmVyXCI/bi5pbnQ2NERhdGFbc109ci5sb25ncz09PVN0cmluZz9TdHJpbmcoZS5pbnQ2NERhdGFbc10pOmUuaW50NjREYXRhW3NdOm4uaW50NjREYXRhW3NdPXIubG9uZ3M9PT1TdHJpbmc/eS5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUuaW50NjREYXRhW3NdKTpyLmxvbmdzPT09TnVtYmVyP25ldyB5LkxvbmdCaXRzKGUuaW50NjREYXRhW3NdLmxvdz4+PjAsZS5pbnQ2NERhdGFbc10uaGlnaD4+PjApLnRvTnVtYmVyKCk6ZS5pbnQ2NERhdGFbc119aWYoZS5uYW1lIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmKG4ubmFtZT1lLm5hbWUpLGUucmF3RGF0YSE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcInJhd0RhdGFcIikmJihuLnJhd0RhdGE9ci5ieXRlcz09PVN0cmluZz95LmJhc2U2NC5lbmNvZGUoZS5yYXdEYXRhLDAsZS5yYXdEYXRhLmxlbmd0aCk6ci5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUucmF3RGF0YSk6ZS5yYXdEYXRhKSxlLmRvdWJsZURhdGEmJmUuZG91YmxlRGF0YS5sZW5ndGgpe24uZG91YmxlRGF0YT1bXTtmb3IodmFyIHM9MDtzPGUuZG91YmxlRGF0YS5sZW5ndGg7KytzKW4uZG91YmxlRGF0YVtzXT1yLmpzb24mJiFpc0Zpbml0ZShlLmRvdWJsZURhdGFbc10pP1N0cmluZyhlLmRvdWJsZURhdGFbc10pOmUuZG91YmxlRGF0YVtzXX1pZihlLnVpbnQ2NERhdGEmJmUudWludDY0RGF0YS5sZW5ndGgpe24udWludDY0RGF0YT1bXTtmb3IodmFyIHM9MDtzPGUudWludDY0RGF0YS5sZW5ndGg7KytzKXR5cGVvZiBlLnVpbnQ2NERhdGFbc109PVwibnVtYmVyXCI/bi51aW50NjREYXRhW3NdPXIubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKGUudWludDY0RGF0YVtzXSk6ZS51aW50NjREYXRhW3NdOm4udWludDY0RGF0YVtzXT1yLmxvbmdzPT09U3RyaW5nP3kuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlLnVpbnQ2NERhdGFbc10pOnIubG9uZ3M9PT1OdW1iZXI/bmV3IHkuTG9uZ0JpdHMoZS51aW50NjREYXRhW3NdLmxvdz4+PjAsZS51aW50NjREYXRhW3NdLmhpZ2g+Pj4wKS50b051bWJlcighMCk6ZS51aW50NjREYXRhW3NdfWlmKGUuZG9jU3RyaW5nIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9ZS5kb2NTdHJpbmcpLGUuZXh0ZXJuYWxEYXRhJiZlLmV4dGVybmFsRGF0YS5sZW5ndGgpe24uZXh0ZXJuYWxEYXRhPVtdO2Zvcih2YXIgcz0wO3M8ZS5leHRlcm5hbERhdGEubGVuZ3RoOysrcyluLmV4dGVybmFsRGF0YVtzXT1tLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdChlLmV4dGVybmFsRGF0YVtzXSxyKX1yZXR1cm4gZS5kYXRhTG9jYXRpb24hPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJkYXRhTG9jYXRpb25cIikmJihuLmRhdGFMb2NhdGlvbj1yLmVudW1zPT09U3RyaW5nP20ub25ueC5UZW5zb3JQcm90by5EYXRhTG9jYXRpb25bZS5kYXRhTG9jYXRpb25dPT09dm9pZCAwP2UuZGF0YUxvY2F0aW9uOm0ub25ueC5UZW5zb3JQcm90by5EYXRhTG9jYXRpb25bZS5kYXRhTG9jYXRpb25dOmUuZGF0YUxvY2F0aW9uKSxufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGdlLnV0aWwudG9KU09OT3B0aW9ucyl9LHQuZ2V0VHlwZVVybD1mdW5jdGlvbihlKXtyZXR1cm4gZT09PXZvaWQgMCYmKGU9XCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpLGUrXCIvb25ueC5UZW5zb3JQcm90b1wifSx0LkRhdGFUeXBlPWZ1bmN0aW9uKCl7dmFyIG89e30sZT1PYmplY3QuY3JlYXRlKG8pO3JldHVybiBlW29bMF09XCJVTkRFRklORURcIl09MCxlW29bMV09XCJGTE9BVFwiXT0xLGVbb1syXT1cIlVJTlQ4XCJdPTIsZVtvWzNdPVwiSU5UOFwiXT0zLGVbb1s0XT1cIlVJTlQxNlwiXT00LGVbb1s1XT1cIklOVDE2XCJdPTUsZVtvWzZdPVwiSU5UMzJcIl09NixlW29bN109XCJJTlQ2NFwiXT03LGVbb1s4XT1cIlNUUklOR1wiXT04LGVbb1s5XT1cIkJPT0xcIl09OSxlW29bMTBdPVwiRkxPQVQxNlwiXT0xMCxlW29bMTFdPVwiRE9VQkxFXCJdPTExLGVbb1sxMl09XCJVSU5UMzJcIl09MTIsZVtvWzEzXT1cIlVJTlQ2NFwiXT0xMyxlW29bMTRdPVwiQ09NUExFWDY0XCJdPTE0LGVbb1sxNV09XCJDT01QTEVYMTI4XCJdPTE1LGVbb1sxNl09XCJCRkxPQVQxNlwiXT0xNixlW29bMTddPVwiRkxPQVQ4RTRNM0ZOXCJdPTE3LGVbb1sxOF09XCJGTE9BVDhFNE0zRk5VWlwiXT0xOCxlW29bMTldPVwiRkxPQVQ4RTVNMlwiXT0xOSxlW29bMjBdPVwiRkxPQVQ4RTVNMkZOVVpcIl09MjAsZX0oKSx0LlNlZ21lbnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBvKGUpe2lmKGUpZm9yKHZhciByPU9iamVjdC5rZXlzKGUpLG49MDtuPHIubGVuZ3RoOysrbillW3Jbbl1dIT1udWxsJiYodGhpc1tyW25dXT1lW3Jbbl1dKX1yZXR1cm4gby5wcm90b3R5cGUuYmVnaW49eS5Mb25nP3kuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsby5wcm90b3R5cGUuZW5kPXkuTG9uZz95LkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLG8uY3JlYXRlPWZ1bmN0aW9uKHIpe3JldHVybiBuZXcgbyhyKX0sby5lbmNvZGU9ZnVuY3Rpb24ocixuKXtyZXR1cm4gbnx8KG49RWUuY3JlYXRlKCkpLHIuYmVnaW4hPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsXCJiZWdpblwiKSYmbi51aW50MzIoOCkuaW50NjQoci5iZWdpbiksci5lbmQhPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsXCJlbmRcIikmJm4udWludDMyKDE2KS5pbnQ2NChyLmVuZCksbn0sby5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24ocixuKXtyZXR1cm4gdGhpcy5lbmNvZGUocixuKS5sZGVsaW0oKX0sby5kZWNvZGU9ZnVuY3Rpb24ocixuKXtyIGluc3RhbmNlb2YgTnx8KHI9Ti5jcmVhdGUocikpO2Zvcih2YXIgcz1uPT09dm9pZCAwP3IubGVuOnIucG9zK24saT1uZXcgbS5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQ7ci5wb3M8czspe3ZhciB1PXIudWludDMyKCk7c3dpdGNoKHU+Pj4zKXtjYXNlIDE6e2kuYmVnaW49ci5pbnQ2NCgpO2JyZWFrfWNhc2UgMjp7aS5lbmQ9ci5pbnQ2NCgpO2JyZWFrfWRlZmF1bHQ6ci5za2lwVHlwZSh1JjcpO2JyZWFrfX1yZXR1cm4gaX0sby5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24ocil7cmV0dXJuIHIgaW5zdGFuY2VvZiBOfHwocj1uZXcgTihyKSksdGhpcy5kZWNvZGUocixyLnVpbnQzMigpKX0sby52ZXJpZnk9ZnVuY3Rpb24ocil7cmV0dXJuIHR5cGVvZiByIT1cIm9iamVjdFwifHxyPT09bnVsbD9cIm9iamVjdCBleHBlY3RlZFwiOnIuYmVnaW4hPW51bGwmJnIuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSYmIXkuaXNJbnRlZ2VyKHIuYmVnaW4pJiYhKHIuYmVnaW4mJnkuaXNJbnRlZ2VyKHIuYmVnaW4ubG93KSYmeS5pc0ludGVnZXIoci5iZWdpbi5oaWdoKSk/XCJiZWdpbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI6ci5lbmQhPW51bGwmJnIuaGFzT3duUHJvcGVydHkoXCJlbmRcIikmJiF5LmlzSW50ZWdlcihyLmVuZCkmJiEoci5lbmQmJnkuaXNJbnRlZ2VyKHIuZW5kLmxvdykmJnkuaXNJbnRlZ2VyKHIuZW5kLmhpZ2gpKT9cImVuZDogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI6bnVsbH0sby5mcm9tT2JqZWN0PWZ1bmN0aW9uKHIpe2lmKHIgaW5zdGFuY2VvZiBtLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudClyZXR1cm4gcjt2YXIgbj1uZXcgbS5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQ7cmV0dXJuIHIuYmVnaW4hPW51bGwmJih5Lkxvbmc/KG4uYmVnaW49eS5Mb25nLmZyb21WYWx1ZShyLmJlZ2luKSkudW5zaWduZWQ9ITE6dHlwZW9mIHIuYmVnaW49PVwic3RyaW5nXCI/bi5iZWdpbj1wYXJzZUludChyLmJlZ2luLDEwKTp0eXBlb2Ygci5iZWdpbj09XCJudW1iZXJcIj9uLmJlZ2luPXIuYmVnaW46dHlwZW9mIHIuYmVnaW49PVwib2JqZWN0XCImJihuLmJlZ2luPW5ldyB5LkxvbmdCaXRzKHIuYmVnaW4ubG93Pj4+MCxyLmJlZ2luLmhpZ2g+Pj4wKS50b051bWJlcigpKSksci5lbmQhPW51bGwmJih5Lkxvbmc/KG4uZW5kPXkuTG9uZy5mcm9tVmFsdWUoci5lbmQpKS51bnNpZ25lZD0hMTp0eXBlb2Ygci5lbmQ9PVwic3RyaW5nXCI/bi5lbmQ9cGFyc2VJbnQoci5lbmQsMTApOnR5cGVvZiByLmVuZD09XCJudW1iZXJcIj9uLmVuZD1yLmVuZDp0eXBlb2Ygci5lbmQ9PVwib2JqZWN0XCImJihuLmVuZD1uZXcgeS5Mb25nQml0cyhyLmVuZC5sb3c+Pj4wLHIuZW5kLmhpZ2g+Pj4wKS50b051bWJlcigpKSksbn0sby50b09iamVjdD1mdW5jdGlvbihyLG4pe258fChuPXt9KTt2YXIgcz17fTtpZihuLmRlZmF1bHRzKXtpZih5Lkxvbmcpe3ZhciBpPW5ldyB5LkxvbmcoMCwwLCExKTtzLmJlZ2luPW4ubG9uZ3M9PT1TdHJpbmc/aS50b1N0cmluZygpOm4ubG9uZ3M9PT1OdW1iZXI/aS50b051bWJlcigpOml9ZWxzZSBzLmJlZ2luPW4ubG9uZ3M9PT1TdHJpbmc/XCIwXCI6MDtpZih5Lkxvbmcpe3ZhciBpPW5ldyB5LkxvbmcoMCwwLCExKTtzLmVuZD1uLmxvbmdzPT09U3RyaW5nP2kudG9TdHJpbmcoKTpuLmxvbmdzPT09TnVtYmVyP2kudG9OdW1iZXIoKTppfWVsc2Ugcy5lbmQ9bi5sb25ncz09PVN0cmluZz9cIjBcIjowfXJldHVybiByLmJlZ2luIT1udWxsJiZyLmhhc093blByb3BlcnR5KFwiYmVnaW5cIikmJih0eXBlb2Ygci5iZWdpbj09XCJudW1iZXJcIj9zLmJlZ2luPW4ubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHIuYmVnaW4pOnIuYmVnaW46cy5iZWdpbj1uLmxvbmdzPT09U3RyaW5nP3kuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyLmJlZ2luKTpuLmxvbmdzPT09TnVtYmVyP25ldyB5LkxvbmdCaXRzKHIuYmVnaW4ubG93Pj4+MCxyLmJlZ2luLmhpZ2g+Pj4wKS50b051bWJlcigpOnIuYmVnaW4pLHIuZW5kIT1udWxsJiZyLmhhc093blByb3BlcnR5KFwiZW5kXCIpJiYodHlwZW9mIHIuZW5kPT1cIm51bWJlclwiP3MuZW5kPW4ubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHIuZW5kKTpyLmVuZDpzLmVuZD1uLmxvbmdzPT09U3RyaW5nP3kuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyLmVuZCk6bi5sb25ncz09PU51bWJlcj9uZXcgeS5Mb25nQml0cyhyLmVuZC5sb3c+Pj4wLHIuZW5kLmhpZ2g+Pj4wKS50b051bWJlcigpOnIuZW5kKSxzfSxvLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGdlLnV0aWwudG9KU09OT3B0aW9ucyl9LG8uZ2V0VHlwZVVybD1mdW5jdGlvbihyKXtyZXR1cm4gcj09PXZvaWQgMCYmKHI9XCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpLHIrXCIvb25ueC5UZW5zb3JQcm90by5TZWdtZW50XCJ9LG99KCksdC5EYXRhTG9jYXRpb249ZnVuY3Rpb24oKXt2YXIgbz17fSxlPU9iamVjdC5jcmVhdGUobyk7cmV0dXJuIGVbb1swXT1cIkRFRkFVTFRcIl09MCxlW29bMV09XCJFWFRFUk5BTFwiXT0xLGV9KCksdH0oKSxhLlNwYXJzZVRlbnNvclByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChvKXtpZih0aGlzLmRpbXM9W10sbylmb3IodmFyIGU9T2JqZWN0LmtleXMobykscj0wO3I8ZS5sZW5ndGg7KytyKW9bZVtyXV0hPW51bGwmJih0aGlzW2Vbcl1dPW9bZVtyXV0pfXJldHVybiB0LnByb3RvdHlwZS52YWx1ZXM9bnVsbCx0LnByb3RvdHlwZS5pbmRpY2VzPW51bGwsdC5wcm90b3R5cGUuZGltcz15LmVtcHR5QXJyYXksdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbihlLHIpe2lmKHJ8fChyPUVlLmNyZWF0ZSgpKSxlLnZhbHVlcyE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcInZhbHVlc1wiKSYmbS5vbm54LlRlbnNvclByb3RvLmVuY29kZShlLnZhbHVlcyxyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKSxlLmluZGljZXMhPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJpbmRpY2VzXCIpJiZtLm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKGUuaW5kaWNlcyxyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKSxlLmRpbXMhPW51bGwmJmUuZGltcy5sZW5ndGgpe3IudWludDMyKDI2KS5mb3JrKCk7Zm9yKHZhciBuPTA7bjxlLmRpbXMubGVuZ3RoOysrbilyLmludDY0KGUuZGltc1tuXSk7ci5sZGVsaW0oKX1yZXR1cm4gcn0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdGhpcy5lbmNvZGUoZSxyKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24oZSxyKXtlIGluc3RhbmNlb2YgTnx8KGU9Ti5jcmVhdGUoZSkpO2Zvcih2YXIgbj1yPT09dm9pZCAwP2UubGVuOmUucG9zK3Iscz1uZXcgbS5vbm54LlNwYXJzZVRlbnNvclByb3RvO2UucG9zPG47KXt2YXIgaT1lLnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOntzLnZhbHVlcz1tLm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWt9Y2FzZSAyOntzLmluZGljZXM9bS5vbm54LlRlbnNvclByb3RvLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrfWNhc2UgMzp7aWYocy5kaW1zJiZzLmRpbXMubGVuZ3RofHwocy5kaW1zPVtdKSwoaSY3KT09PTIpZm9yKHZhciB1PWUudWludDMyKCkrZS5wb3M7ZS5wb3M8dTspcy5kaW1zLnB1c2goZS5pbnQ2NCgpKTtlbHNlIHMuZGltcy5wdXNoKGUuaW50NjQoKSk7YnJlYWt9ZGVmYXVsdDplLnNraXBUeXBlKGkmNyk7YnJlYWt9fXJldHVybiBzfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIE58fChlPW5ldyBOKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbihlKXtpZih0eXBlb2YgZSE9XCJvYmplY3RcInx8ZT09PW51bGwpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihlLnZhbHVlcyE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlc1wiKSl7dmFyIHI9bS5vbm54LlRlbnNvclByb3RvLnZlcmlmeShlLnZhbHVlcyk7aWYocilyZXR1cm5cInZhbHVlcy5cIityfWlmKGUuaW5kaWNlcyE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImluZGljZXNcIikpe3ZhciByPW0ub25ueC5UZW5zb3JQcm90by52ZXJpZnkoZS5pbmRpY2VzKTtpZihyKXJldHVyblwiaW5kaWNlcy5cIityfWlmKGUuZGltcyE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImRpbXNcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuZGltcykpcmV0dXJuXCJkaW1zOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgbj0wO248ZS5kaW1zLmxlbmd0aDsrK24paWYoIXkuaXNJbnRlZ2VyKGUuZGltc1tuXSkmJiEoZS5kaW1zW25dJiZ5LmlzSW50ZWdlcihlLmRpbXNbbl0ubG93KSYmeS5pc0ludGVnZXIoZS5kaW1zW25dLmhpZ2gpKSlyZXR1cm5cImRpbXM6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCJ9cmV0dXJuIG51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgbS5vbm54LlNwYXJzZVRlbnNvclByb3RvKXJldHVybiBlO3ZhciByPW5ldyBtLm9ubnguU3BhcnNlVGVuc29yUHJvdG87aWYoZS52YWx1ZXMhPW51bGwpe2lmKHR5cGVvZiBlLnZhbHVlcyE9XCJvYmplY3RcIil0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5TcGFyc2VUZW5zb3JQcm90by52YWx1ZXM6IG9iamVjdCBleHBlY3RlZFwiKTtyLnZhbHVlcz1tLm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChlLnZhbHVlcyl9aWYoZS5pbmRpY2VzIT1udWxsKXtpZih0eXBlb2YgZS5pbmRpY2VzIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlNwYXJzZVRlbnNvclByb3RvLmluZGljZXM6IG9iamVjdCBleHBlY3RlZFwiKTtyLmluZGljZXM9bS5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3QoZS5pbmRpY2VzKX1pZihlLmRpbXMpe2lmKCFBcnJheS5pc0FycmF5KGUuZGltcykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZGltczogYXJyYXkgZXhwZWN0ZWRcIik7ci5kaW1zPVtdO2Zvcih2YXIgbj0wO248ZS5kaW1zLmxlbmd0aDsrK24peS5Mb25nPyhyLmRpbXNbbl09eS5Mb25nLmZyb21WYWx1ZShlLmRpbXNbbl0pKS51bnNpZ25lZD0hMTp0eXBlb2YgZS5kaW1zW25dPT1cInN0cmluZ1wiP3IuZGltc1tuXT1wYXJzZUludChlLmRpbXNbbl0sMTApOnR5cGVvZiBlLmRpbXNbbl09PVwibnVtYmVyXCI/ci5kaW1zW25dPWUuZGltc1tuXTp0eXBlb2YgZS5kaW1zW25dPT1cIm9iamVjdFwiJiYoci5kaW1zW25dPW5ldyB5LkxvbmdCaXRzKGUuZGltc1tuXS5sb3c+Pj4wLGUuZGltc1tuXS5oaWdoPj4+MCkudG9OdW1iZXIoKSl9cmV0dXJuIHJ9LHQudG9PYmplY3Q9ZnVuY3Rpb24oZSxyKXtyfHwocj17fSk7dmFyIG49e307aWYoKHIuYXJyYXlzfHxyLmRlZmF1bHRzKSYmKG4uZGltcz1bXSksci5kZWZhdWx0cyYmKG4udmFsdWVzPW51bGwsbi5pbmRpY2VzPW51bGwpLGUudmFsdWVzIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwidmFsdWVzXCIpJiYobi52YWx1ZXM9bS5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KGUudmFsdWVzLHIpKSxlLmluZGljZXMhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJpbmRpY2VzXCIpJiYobi5pbmRpY2VzPW0ub25ueC5UZW5zb3JQcm90by50b09iamVjdChlLmluZGljZXMscikpLGUuZGltcyYmZS5kaW1zLmxlbmd0aCl7bi5kaW1zPVtdO2Zvcih2YXIgcz0wO3M8ZS5kaW1zLmxlbmd0aDsrK3MpdHlwZW9mIGUuZGltc1tzXT09XCJudW1iZXJcIj9uLmRpbXNbc109ci5sb25ncz09PVN0cmluZz9TdHJpbmcoZS5kaW1zW3NdKTplLmRpbXNbc106bi5kaW1zW3NdPXIubG9uZ3M9PT1TdHJpbmc/eS5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUuZGltc1tzXSk6ci5sb25ncz09PU51bWJlcj9uZXcgeS5Mb25nQml0cyhlLmRpbXNbc10ubG93Pj4+MCxlLmRpbXNbc10uaGlnaD4+PjApLnRvTnVtYmVyKCk6ZS5kaW1zW3NdfXJldHVybiBufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGdlLnV0aWwudG9KU09OT3B0aW9ucyl9LHQuZ2V0VHlwZVVybD1mdW5jdGlvbihlKXtyZXR1cm4gZT09PXZvaWQgMCYmKGU9XCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpLGUrXCIvb25ueC5TcGFyc2VUZW5zb3JQcm90b1wifSx0fSgpLGEuVGVuc29yU2hhcGVQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobyl7aWYodGhpcy5kaW09W10sbylmb3IodmFyIGU9T2JqZWN0LmtleXMobykscj0wO3I8ZS5sZW5ndGg7KytyKW9bZVtyXV0hPW51bGwmJih0aGlzW2Vbcl1dPW9bZVtyXV0pfXJldHVybiB0LnByb3RvdHlwZS5kaW09eS5lbXB0eUFycmF5LHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24oZSxyKXtpZihyfHwocj1FZS5jcmVhdGUoKSksZS5kaW0hPW51bGwmJmUuZGltLmxlbmd0aClmb3IodmFyIG49MDtuPGUuZGltLmxlbmd0aDsrK24pbS5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLmVuY29kZShlLmRpbVtuXSxyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gcn0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdGhpcy5lbmNvZGUoZSxyKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24oZSxyKXtlIGluc3RhbmNlb2YgTnx8KGU9Ti5jcmVhdGUoZSkpO2Zvcih2YXIgbj1yPT09dm9pZCAwP2UubGVuOmUucG9zK3Iscz1uZXcgbS5vbm54LlRlbnNvclNoYXBlUHJvdG87ZS5wb3M8bjspe3ZhciBpPWUudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6e3MuZGltJiZzLmRpbS5sZW5ndGh8fChzLmRpbT1bXSkscy5kaW0ucHVzaChtLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrfWRlZmF1bHQ6ZS5za2lwVHlwZShpJjcpO2JyZWFrfX1yZXR1cm4gc30sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBOfHwoZT1uZXcgTihlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYodHlwZW9mIGUhPVwib2JqZWN0XCJ8fGU9PT1udWxsKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYoZS5kaW0hPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJkaW1cIikpe2lmKCFBcnJheS5pc0FycmF5KGUuZGltKSlyZXR1cm5cImRpbTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHI9MDtyPGUuZGltLmxlbmd0aDsrK3Ipe3ZhciBuPW0ub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi52ZXJpZnkoZS5kaW1bcl0pO2lmKG4pcmV0dXJuXCJkaW0uXCIrbn19cmV0dXJuIG51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgbS5vbm54LlRlbnNvclNoYXBlUHJvdG8pcmV0dXJuIGU7dmFyIHI9bmV3IG0ub25ueC5UZW5zb3JTaGFwZVByb3RvO2lmKGUuZGltKXtpZighQXJyYXkuaXNBcnJheShlLmRpbSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yU2hhcGVQcm90by5kaW06IGFycmF5IGV4cGVjdGVkXCIpO3IuZGltPVtdO2Zvcih2YXIgbj0wO248ZS5kaW0ubGVuZ3RoOysrbil7aWYodHlwZW9mIGUuZGltW25dIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclNoYXBlUHJvdG8uZGltOiBvYmplY3QgZXhwZWN0ZWRcIik7ci5kaW1bbl09bS5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLmZyb21PYmplY3QoZS5kaW1bbl0pfX1yZXR1cm4gcn0sdC50b09iamVjdD1mdW5jdGlvbihlLHIpe3J8fChyPXt9KTt2YXIgbj17fTtpZigoci5hcnJheXN8fHIuZGVmYXVsdHMpJiYobi5kaW09W10pLGUuZGltJiZlLmRpbS5sZW5ndGgpe24uZGltPVtdO2Zvcih2YXIgcz0wO3M8ZS5kaW0ubGVuZ3RoOysrcyluLmRpbVtzXT1tLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24udG9PYmplY3QoZS5kaW1bc10scil9cmV0dXJuIG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsZ2UudXRpbC50b0pTT05PcHRpb25zKX0sdC5nZXRUeXBlVXJsPWZ1bmN0aW9uKGUpe3JldHVybiBlPT09dm9pZCAwJiYoZT1cInR5cGUuZ29vZ2xlYXBpcy5jb21cIiksZStcIi9vbm54LlRlbnNvclNoYXBlUHJvdG9cIn0sdC5EaW1lbnNpb249ZnVuY3Rpb24oKXtmdW5jdGlvbiBvKHIpe2lmKHIpZm9yKHZhciBuPU9iamVjdC5rZXlzKHIpLHM9MDtzPG4ubGVuZ3RoOysrcylyW25bc11dIT1udWxsJiYodGhpc1tuW3NdXT1yW25bc11dKX1vLnByb3RvdHlwZS5kaW1WYWx1ZT1udWxsLG8ucHJvdG90eXBlLmRpbVBhcmFtPW51bGwsby5wcm90b3R5cGUuZGVub3RhdGlvbj1cIlwiO3ZhciBlO3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoby5wcm90b3R5cGUsXCJ2YWx1ZVwiLHtnZXQ6eS5vbmVPZkdldHRlcihlPVtcImRpbVZhbHVlXCIsXCJkaW1QYXJhbVwiXSksc2V0Onkub25lT2ZTZXR0ZXIoZSl9KSxvLmNyZWF0ZT1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IG8obil9LG8uZW5jb2RlPWZ1bmN0aW9uKG4scyl7cmV0dXJuIHN8fChzPUVlLmNyZWF0ZSgpKSxuLmRpbVZhbHVlIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChuLFwiZGltVmFsdWVcIikmJnMudWludDMyKDgpLmludDY0KG4uZGltVmFsdWUpLG4uZGltUGFyYW0hPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sXCJkaW1QYXJhbVwiKSYmcy51aW50MzIoMTgpLnN0cmluZyhuLmRpbVBhcmFtKSxuLmRlbm90YXRpb24hPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sXCJkZW5vdGF0aW9uXCIpJiZzLnVpbnQzMigyNikuc3RyaW5nKG4uZGVub3RhdGlvbiksc30sby5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24obixzKXtyZXR1cm4gdGhpcy5lbmNvZGUobixzKS5sZGVsaW0oKX0sby5kZWNvZGU9ZnVuY3Rpb24obixzKXtuIGluc3RhbmNlb2YgTnx8KG49Ti5jcmVhdGUobikpO2Zvcih2YXIgaT1zPT09dm9pZCAwP24ubGVuOm4ucG9zK3MsdT1uZXcgbS5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uO24ucG9zPGk7KXt2YXIgbD1uLnVpbnQzMigpO3N3aXRjaChsPj4+Myl7Y2FzZSAxOnt1LmRpbVZhbHVlPW4uaW50NjQoKTticmVha31jYXNlIDI6e3UuZGltUGFyYW09bi5zdHJpbmcoKTticmVha31jYXNlIDM6e3UuZGVub3RhdGlvbj1uLnN0cmluZygpO2JyZWFrfWRlZmF1bHQ6bi5za2lwVHlwZShsJjcpO2JyZWFrfX1yZXR1cm4gdX0sby5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24obil7cmV0dXJuIG4gaW5zdGFuY2VvZiBOfHwobj1uZXcgTihuKSksdGhpcy5kZWNvZGUobixuLnVpbnQzMigpKX0sby52ZXJpZnk9ZnVuY3Rpb24obil7aWYodHlwZW9mIG4hPVwib2JqZWN0XCJ8fG49PT1udWxsKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7dmFyIHM9e307aWYobi5kaW1WYWx1ZSE9bnVsbCYmbi5oYXNPd25Qcm9wZXJ0eShcImRpbVZhbHVlXCIpJiYocy52YWx1ZT0xLCF5LmlzSW50ZWdlcihuLmRpbVZhbHVlKSYmIShuLmRpbVZhbHVlJiZ5LmlzSW50ZWdlcihuLmRpbVZhbHVlLmxvdykmJnkuaXNJbnRlZ2VyKG4uZGltVmFsdWUuaGlnaCkpKSlyZXR1cm5cImRpbVZhbHVlOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtpZihuLmRpbVBhcmFtIT1udWxsJiZuLmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikpe2lmKHMudmFsdWU9PT0xKXJldHVyblwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO2lmKHMudmFsdWU9MSwheS5pc1N0cmluZyhuLmRpbVBhcmFtKSlyZXR1cm5cImRpbVBhcmFtOiBzdHJpbmcgZXhwZWN0ZWRcIn1yZXR1cm4gbi5kZW5vdGF0aW9uIT1udWxsJiZuLmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmIXkuaXNTdHJpbmcobi5kZW5vdGF0aW9uKT9cImRlbm90YXRpb246IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LG8uZnJvbU9iamVjdD1mdW5jdGlvbihuKXtpZihuIGluc3RhbmNlb2YgbS5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uKXJldHVybiBuO3ZhciBzPW5ldyBtLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb247cmV0dXJuIG4uZGltVmFsdWUhPW51bGwmJih5Lkxvbmc/KHMuZGltVmFsdWU9eS5Mb25nLmZyb21WYWx1ZShuLmRpbVZhbHVlKSkudW5zaWduZWQ9ITE6dHlwZW9mIG4uZGltVmFsdWU9PVwic3RyaW5nXCI/cy5kaW1WYWx1ZT1wYXJzZUludChuLmRpbVZhbHVlLDEwKTp0eXBlb2Ygbi5kaW1WYWx1ZT09XCJudW1iZXJcIj9zLmRpbVZhbHVlPW4uZGltVmFsdWU6dHlwZW9mIG4uZGltVmFsdWU9PVwib2JqZWN0XCImJihzLmRpbVZhbHVlPW5ldyB5LkxvbmdCaXRzKG4uZGltVmFsdWUubG93Pj4+MCxuLmRpbVZhbHVlLmhpZ2g+Pj4wKS50b051bWJlcigpKSksbi5kaW1QYXJhbSE9bnVsbCYmKHMuZGltUGFyYW09U3RyaW5nKG4uZGltUGFyYW0pKSxuLmRlbm90YXRpb24hPW51bGwmJihzLmRlbm90YXRpb249U3RyaW5nKG4uZGVub3RhdGlvbikpLHN9LG8udG9PYmplY3Q9ZnVuY3Rpb24obixzKXtzfHwocz17fSk7dmFyIGk9e307cmV0dXJuIHMuZGVmYXVsdHMmJihpLmRlbm90YXRpb249XCJcIiksbi5kaW1WYWx1ZSE9bnVsbCYmbi5oYXNPd25Qcm9wZXJ0eShcImRpbVZhbHVlXCIpJiYodHlwZW9mIG4uZGltVmFsdWU9PVwibnVtYmVyXCI/aS5kaW1WYWx1ZT1zLmxvbmdzPT09U3RyaW5nP1N0cmluZyhuLmRpbVZhbHVlKTpuLmRpbVZhbHVlOmkuZGltVmFsdWU9cy5sb25ncz09PVN0cmluZz95LkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobi5kaW1WYWx1ZSk6cy5sb25ncz09PU51bWJlcj9uZXcgeS5Mb25nQml0cyhuLmRpbVZhbHVlLmxvdz4+PjAsbi5kaW1WYWx1ZS5oaWdoPj4+MCkudG9OdW1iZXIoKTpuLmRpbVZhbHVlLHMub25lb2ZzJiYoaS52YWx1ZT1cImRpbVZhbHVlXCIpKSxuLmRpbVBhcmFtIT1udWxsJiZuLmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikmJihpLmRpbVBhcmFtPW4uZGltUGFyYW0scy5vbmVvZnMmJihpLnZhbHVlPVwiZGltUGFyYW1cIikpLG4uZGVub3RhdGlvbiE9bnVsbCYmbi5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikmJihpLmRlbm90YXRpb249bi5kZW5vdGF0aW9uKSxpfSxvLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGdlLnV0aWwudG9KU09OT3B0aW9ucyl9LG8uZ2V0VHlwZVVybD1mdW5jdGlvbihuKXtyZXR1cm4gbj09PXZvaWQgMCYmKG49XCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpLG4rXCIvb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblwifSxvfSgpLHR9KCksYS5UeXBlUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe2lmKGUpZm9yKHZhciByPU9iamVjdC5rZXlzKGUpLG49MDtuPHIubGVuZ3RoOysrbillW3Jbbl1dIT1udWxsJiYodGhpc1tyW25dXT1lW3Jbbl1dKX10LnByb3RvdHlwZS50ZW5zb3JUeXBlPW51bGwsdC5wcm90b3R5cGUuc2VxdWVuY2VUeXBlPW51bGwsdC5wcm90b3R5cGUubWFwVHlwZT1udWxsLHQucHJvdG90eXBlLm9wdGlvbmFsVHlwZT1udWxsLHQucHJvdG90eXBlLnNwYXJzZVRlbnNvclR5cGU9bnVsbCx0LnByb3RvdHlwZS5kZW5vdGF0aW9uPVwiXCI7dmFyIG87cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInZhbHVlXCIse2dldDp5Lm9uZU9mR2V0dGVyKG89W1widGVuc29yVHlwZVwiLFwic2VxdWVuY2VUeXBlXCIsXCJtYXBUeXBlXCIsXCJvcHRpb25hbFR5cGVcIixcInNwYXJzZVRlbnNvclR5cGVcIl0pLHNldDp5Lm9uZU9mU2V0dGVyKG8pfSksdC5jcmVhdGU9ZnVuY3Rpb24ocil7cmV0dXJuIG5ldyB0KHIpfSx0LmVuY29kZT1mdW5jdGlvbihyLG4pe3JldHVybiBufHwobj1FZS5jcmVhdGUoKSksci50ZW5zb3JUeXBlIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyLFwidGVuc29yVHlwZVwiKSYmbS5vbm54LlR5cGVQcm90by5UZW5zb3IuZW5jb2RlKHIudGVuc29yVHlwZSxuLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKSxyLnNlcXVlbmNlVHlwZSE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocixcInNlcXVlbmNlVHlwZVwiKSYmbS5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5lbmNvZGUoci5zZXF1ZW5jZVR5cGUsbi51aW50MzIoMzQpLmZvcmsoKSkubGRlbGltKCksci5tYXBUeXBlIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyLFwibWFwVHlwZVwiKSYmbS5vbm54LlR5cGVQcm90by5NYXAuZW5jb2RlKHIubWFwVHlwZSxuLnVpbnQzMig0MikuZm9yaygpKS5sZGVsaW0oKSxyLmRlbm90YXRpb24hPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsXCJkZW5vdGF0aW9uXCIpJiZuLnVpbnQzMig1MCkuc3RyaW5nKHIuZGVub3RhdGlvbiksci5zcGFyc2VUZW5zb3JUeXBlIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyLFwic3BhcnNlVGVuc29yVHlwZVwiKSYmbS5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IuZW5jb2RlKHIuc3BhcnNlVGVuc29yVHlwZSxuLnVpbnQzMig2NikuZm9yaygpKS5sZGVsaW0oKSxyLm9wdGlvbmFsVHlwZSE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocixcIm9wdGlvbmFsVHlwZVwiKSYmbS5vbm54LlR5cGVQcm90by5PcHRpb25hbC5lbmNvZGUoci5vcHRpb25hbFR5cGUsbi51aW50MzIoNzQpLmZvcmsoKSkubGRlbGltKCksbn0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24ocixuKXtyZXR1cm4gdGhpcy5lbmNvZGUocixuKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24ocixuKXtyIGluc3RhbmNlb2YgTnx8KHI9Ti5jcmVhdGUocikpO2Zvcih2YXIgcz1uPT09dm9pZCAwP3IubGVuOnIucG9zK24saT1uZXcgbS5vbm54LlR5cGVQcm90bztyLnBvczxzOyl7dmFyIHU9ci51aW50MzIoKTtzd2l0Y2godT4+PjMpe2Nhc2UgMTp7aS50ZW5zb3JUeXBlPW0ub25ueC5UeXBlUHJvdG8uVGVuc29yLmRlY29kZShyLHIudWludDMyKCkpO2JyZWFrfWNhc2UgNDp7aS5zZXF1ZW5jZVR5cGU9bS5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5kZWNvZGUocixyLnVpbnQzMigpKTticmVha31jYXNlIDU6e2kubWFwVHlwZT1tLm9ubnguVHlwZVByb3RvLk1hcC5kZWNvZGUocixyLnVpbnQzMigpKTticmVha31jYXNlIDk6e2kub3B0aW9uYWxUeXBlPW0ub25ueC5UeXBlUHJvdG8uT3B0aW9uYWwuZGVjb2RlKHIsci51aW50MzIoKSk7YnJlYWt9Y2FzZSA4OntpLnNwYXJzZVRlbnNvclR5cGU9bS5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IuZGVjb2RlKHIsci51aW50MzIoKSk7YnJlYWt9Y2FzZSA2OntpLmRlbm90YXRpb249ci5zdHJpbmcoKTticmVha31kZWZhdWx0OnIuc2tpcFR5cGUodSY3KTticmVha319cmV0dXJuIGl9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHIpe3JldHVybiByIGluc3RhbmNlb2YgTnx8KHI9bmV3IE4ocikpLHRoaXMuZGVjb2RlKHIsci51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHIpe2lmKHR5cGVvZiByIT1cIm9iamVjdFwifHxyPT09bnVsbClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO3ZhciBuPXt9O2lmKHIudGVuc29yVHlwZSE9bnVsbCYmci5oYXNPd25Qcm9wZXJ0eShcInRlbnNvclR5cGVcIikpe24udmFsdWU9MTt7dmFyIHM9bS5vbm54LlR5cGVQcm90by5UZW5zb3IudmVyaWZ5KHIudGVuc29yVHlwZSk7aWYocylyZXR1cm5cInRlbnNvclR5cGUuXCIrc319aWYoci5zZXF1ZW5jZVR5cGUhPW51bGwmJnIuaGFzT3duUHJvcGVydHkoXCJzZXF1ZW5jZVR5cGVcIikpe2lmKG4udmFsdWU9PT0xKXJldHVyblwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO24udmFsdWU9MTt7dmFyIHM9bS5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS52ZXJpZnkoci5zZXF1ZW5jZVR5cGUpO2lmKHMpcmV0dXJuXCJzZXF1ZW5jZVR5cGUuXCIrc319aWYoci5tYXBUeXBlIT1udWxsJiZyLmhhc093blByb3BlcnR5KFwibWFwVHlwZVwiKSl7aWYobi52YWx1ZT09PTEpcmV0dXJuXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7bi52YWx1ZT0xO3t2YXIgcz1tLm9ubnguVHlwZVByb3RvLk1hcC52ZXJpZnkoci5tYXBUeXBlKTtpZihzKXJldHVyblwibWFwVHlwZS5cIitzfX1pZihyLm9wdGlvbmFsVHlwZSE9bnVsbCYmci5oYXNPd25Qcm9wZXJ0eShcIm9wdGlvbmFsVHlwZVwiKSl7aWYobi52YWx1ZT09PTEpcmV0dXJuXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7bi52YWx1ZT0xO3t2YXIgcz1tLm9ubnguVHlwZVByb3RvLk9wdGlvbmFsLnZlcmlmeShyLm9wdGlvbmFsVHlwZSk7aWYocylyZXR1cm5cIm9wdGlvbmFsVHlwZS5cIitzfX1pZihyLnNwYXJzZVRlbnNvclR5cGUhPW51bGwmJnIuaGFzT3duUHJvcGVydHkoXCJzcGFyc2VUZW5zb3JUeXBlXCIpKXtpZihuLnZhbHVlPT09MSlyZXR1cm5cInZhbHVlOiBtdWx0aXBsZSB2YWx1ZXNcIjtuLnZhbHVlPTE7e3ZhciBzPW0ub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLnZlcmlmeShyLnNwYXJzZVRlbnNvclR5cGUpO2lmKHMpcmV0dXJuXCJzcGFyc2VUZW5zb3JUeXBlLlwiK3N9fXJldHVybiByLmRlbm90YXRpb24hPW51bGwmJnIuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpJiYheS5pc1N0cmluZyhyLmRlbm90YXRpb24pP1wiZGVub3RhdGlvbjogc3RyaW5nIGV4cGVjdGVkXCI6bnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHIpe2lmKHIgaW5zdGFuY2VvZiBtLm9ubnguVHlwZVByb3RvKXJldHVybiByO3ZhciBuPW5ldyBtLm9ubnguVHlwZVByb3RvO2lmKHIudGVuc29yVHlwZSE9bnVsbCl7aWYodHlwZW9mIHIudGVuc29yVHlwZSE9XCJvYmplY3RcIil0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8udGVuc29yVHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO24udGVuc29yVHlwZT1tLm9ubnguVHlwZVByb3RvLlRlbnNvci5mcm9tT2JqZWN0KHIudGVuc29yVHlwZSl9aWYoci5zZXF1ZW5jZVR5cGUhPW51bGwpe2lmKHR5cGVvZiByLnNlcXVlbmNlVHlwZSE9XCJvYmplY3RcIil0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8uc2VxdWVuY2VUeXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7bi5zZXF1ZW5jZVR5cGU9bS5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5mcm9tT2JqZWN0KHIuc2VxdWVuY2VUeXBlKX1pZihyLm1hcFR5cGUhPW51bGwpe2lmKHR5cGVvZiByLm1hcFR5cGUhPVwib2JqZWN0XCIpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLm1hcFR5cGU6IG9iamVjdCBleHBlY3RlZFwiKTtuLm1hcFR5cGU9bS5vbm54LlR5cGVQcm90by5NYXAuZnJvbU9iamVjdChyLm1hcFR5cGUpfWlmKHIub3B0aW9uYWxUeXBlIT1udWxsKXtpZih0eXBlb2Ygci5vcHRpb25hbFR5cGUhPVwib2JqZWN0XCIpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLm9wdGlvbmFsVHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO24ub3B0aW9uYWxUeXBlPW0ub25ueC5UeXBlUHJvdG8uT3B0aW9uYWwuZnJvbU9iamVjdChyLm9wdGlvbmFsVHlwZSl9aWYoci5zcGFyc2VUZW5zb3JUeXBlIT1udWxsKXtpZih0eXBlb2Ygci5zcGFyc2VUZW5zb3JUeXBlIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by5zcGFyc2VUZW5zb3JUeXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7bi5zcGFyc2VUZW5zb3JUeXBlPW0ub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLmZyb21PYmplY3Qoci5zcGFyc2VUZW5zb3JUeXBlKX1yZXR1cm4gci5kZW5vdGF0aW9uIT1udWxsJiYobi5kZW5vdGF0aW9uPVN0cmluZyhyLmRlbm90YXRpb24pKSxufSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHIsbil7bnx8KG49e30pO3ZhciBzPXt9O3JldHVybiBuLmRlZmF1bHRzJiYocy5kZW5vdGF0aW9uPVwiXCIpLHIudGVuc29yVHlwZSE9bnVsbCYmci5oYXNPd25Qcm9wZXJ0eShcInRlbnNvclR5cGVcIikmJihzLnRlbnNvclR5cGU9bS5vbm54LlR5cGVQcm90by5UZW5zb3IudG9PYmplY3Qoci50ZW5zb3JUeXBlLG4pLG4ub25lb2ZzJiYocy52YWx1ZT1cInRlbnNvclR5cGVcIikpLHIuc2VxdWVuY2VUeXBlIT1udWxsJiZyLmhhc093blByb3BlcnR5KFwic2VxdWVuY2VUeXBlXCIpJiYocy5zZXF1ZW5jZVR5cGU9bS5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS50b09iamVjdChyLnNlcXVlbmNlVHlwZSxuKSxuLm9uZW9mcyYmKHMudmFsdWU9XCJzZXF1ZW5jZVR5cGVcIikpLHIubWFwVHlwZSE9bnVsbCYmci5oYXNPd25Qcm9wZXJ0eShcIm1hcFR5cGVcIikmJihzLm1hcFR5cGU9bS5vbm54LlR5cGVQcm90by5NYXAudG9PYmplY3Qoci5tYXBUeXBlLG4pLG4ub25lb2ZzJiYocy52YWx1ZT1cIm1hcFR5cGVcIikpLHIuZGVub3RhdGlvbiE9bnVsbCYmci5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikmJihzLmRlbm90YXRpb249ci5kZW5vdGF0aW9uKSxyLnNwYXJzZVRlbnNvclR5cGUhPW51bGwmJnIuaGFzT3duUHJvcGVydHkoXCJzcGFyc2VUZW5zb3JUeXBlXCIpJiYocy5zcGFyc2VUZW5zb3JUeXBlPW0ub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLnRvT2JqZWN0KHIuc3BhcnNlVGVuc29yVHlwZSxuKSxuLm9uZW9mcyYmKHMudmFsdWU9XCJzcGFyc2VUZW5zb3JUeXBlXCIpKSxyLm9wdGlvbmFsVHlwZSE9bnVsbCYmci5oYXNPd25Qcm9wZXJ0eShcIm9wdGlvbmFsVHlwZVwiKSYmKHMub3B0aW9uYWxUeXBlPW0ub25ueC5UeXBlUHJvdG8uT3B0aW9uYWwudG9PYmplY3Qoci5vcHRpb25hbFR5cGUsbiksbi5vbmVvZnMmJihzLnZhbHVlPVwib3B0aW9uYWxUeXBlXCIpKSxzfSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGdlLnV0aWwudG9KU09OT3B0aW9ucyl9LHQuZ2V0VHlwZVVybD1mdW5jdGlvbihyKXtyZXR1cm4gcj09PXZvaWQgMCYmKHI9XCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpLHIrXCIvb25ueC5UeXBlUHJvdG9cIn0sdC5UZW5zb3I9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHIpe2lmKHIpZm9yKHZhciBuPU9iamVjdC5rZXlzKHIpLHM9MDtzPG4ubGVuZ3RoOysrcylyW25bc11dIT1udWxsJiYodGhpc1tuW3NdXT1yW25bc11dKX1yZXR1cm4gZS5wcm90b3R5cGUuZWxlbVR5cGU9MCxlLnByb3RvdHlwZS5zaGFwZT1udWxsLGUuY3JlYXRlPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgZShuKX0sZS5lbmNvZGU9ZnVuY3Rpb24obixzKXtyZXR1cm4gc3x8KHM9RWUuY3JlYXRlKCkpLG4uZWxlbVR5cGUhPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sXCJlbGVtVHlwZVwiKSYmcy51aW50MzIoOCkuaW50MzIobi5lbGVtVHlwZSksbi5zaGFwZSE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobixcInNoYXBlXCIpJiZtLm9ubnguVGVuc29yU2hhcGVQcm90by5lbmNvZGUobi5zaGFwZSxzLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKSxzfSxlLmVuY29kZURlbGltaXRlZD1mdW5jdGlvbihuLHMpe3JldHVybiB0aGlzLmVuY29kZShuLHMpLmxkZWxpbSgpfSxlLmRlY29kZT1mdW5jdGlvbihuLHMpe24gaW5zdGFuY2VvZiBOfHwobj1OLmNyZWF0ZShuKSk7Zm9yKHZhciBpPXM9PT12b2lkIDA/bi5sZW46bi5wb3Mrcyx1PW5ldyBtLm9ubnguVHlwZVByb3RvLlRlbnNvcjtuLnBvczxpOyl7dmFyIGw9bi51aW50MzIoKTtzd2l0Y2gobD4+PjMpe2Nhc2UgMTp7dS5lbGVtVHlwZT1uLmludDMyKCk7YnJlYWt9Y2FzZSAyOnt1LnNoYXBlPW0ub25ueC5UZW5zb3JTaGFwZVByb3RvLmRlY29kZShuLG4udWludDMyKCkpO2JyZWFrfWRlZmF1bHQ6bi5za2lwVHlwZShsJjcpO2JyZWFrfX1yZXR1cm4gdX0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24obil7cmV0dXJuIG4gaW5zdGFuY2VvZiBOfHwobj1uZXcgTihuKSksdGhpcy5kZWNvZGUobixuLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24obil7aWYodHlwZW9mIG4hPVwib2JqZWN0XCJ8fG49PT1udWxsKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobi5lbGVtVHlwZSE9bnVsbCYmbi5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpJiYheS5pc0ludGVnZXIobi5lbGVtVHlwZSkpcmV0dXJuXCJlbGVtVHlwZTogaW50ZWdlciBleHBlY3RlZFwiO2lmKG4uc2hhcGUhPW51bGwmJm4uaGFzT3duUHJvcGVydHkoXCJzaGFwZVwiKSl7dmFyIHM9bS5vbm54LlRlbnNvclNoYXBlUHJvdG8udmVyaWZ5KG4uc2hhcGUpO2lmKHMpcmV0dXJuXCJzaGFwZS5cIitzfXJldHVybiBudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24obil7aWYobiBpbnN0YW5jZW9mIG0ub25ueC5UeXBlUHJvdG8uVGVuc29yKXJldHVybiBuO3ZhciBzPW5ldyBtLm9ubnguVHlwZVByb3RvLlRlbnNvcjtpZihuLmVsZW1UeXBlIT1udWxsJiYocy5lbGVtVHlwZT1uLmVsZW1UeXBlfDApLG4uc2hhcGUhPW51bGwpe2lmKHR5cGVvZiBuLnNoYXBlIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by5UZW5zb3Iuc2hhcGU6IG9iamVjdCBleHBlY3RlZFwiKTtzLnNoYXBlPW0ub25ueC5UZW5zb3JTaGFwZVByb3RvLmZyb21PYmplY3Qobi5zaGFwZSl9cmV0dXJuIHN9LGUudG9PYmplY3Q9ZnVuY3Rpb24obixzKXtzfHwocz17fSk7dmFyIGk9e307cmV0dXJuIHMuZGVmYXVsdHMmJihpLmVsZW1UeXBlPTAsaS5zaGFwZT1udWxsKSxuLmVsZW1UeXBlIT1udWxsJiZuLmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikmJihpLmVsZW1UeXBlPW4uZWxlbVR5cGUpLG4uc2hhcGUhPW51bGwmJm4uaGFzT3duUHJvcGVydHkoXCJzaGFwZVwiKSYmKGkuc2hhcGU9bS5vbm54LlRlbnNvclNoYXBlUHJvdG8udG9PYmplY3Qobi5zaGFwZSxzKSksaX0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxnZS51dGlsLnRvSlNPTk9wdGlvbnMpfSxlLmdldFR5cGVVcmw9ZnVuY3Rpb24obil7cmV0dXJuIG49PT12b2lkIDAmJihuPVwidHlwZS5nb29nbGVhcGlzLmNvbVwiKSxuK1wiL29ubnguVHlwZVByb3RvLlRlbnNvclwifSxlfSgpLHQuU2VxdWVuY2U9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHIpe2lmKHIpZm9yKHZhciBuPU9iamVjdC5rZXlzKHIpLHM9MDtzPG4ubGVuZ3RoOysrcylyW25bc11dIT1udWxsJiYodGhpc1tuW3NdXT1yW25bc11dKX1yZXR1cm4gZS5wcm90b3R5cGUuZWxlbVR5cGU9bnVsbCxlLmNyZWF0ZT1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IGUobil9LGUuZW5jb2RlPWZ1bmN0aW9uKG4scyl7cmV0dXJuIHN8fChzPUVlLmNyZWF0ZSgpKSxuLmVsZW1UeXBlIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChuLFwiZWxlbVR5cGVcIikmJm0ub25ueC5UeXBlUHJvdG8uZW5jb2RlKG4uZWxlbVR5cGUscy51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCksc30sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24obixzKXtyZXR1cm4gdGhpcy5lbmNvZGUobixzKS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24obixzKXtuIGluc3RhbmNlb2YgTnx8KG49Ti5jcmVhdGUobikpO2Zvcih2YXIgaT1zPT09dm9pZCAwP24ubGVuOm4ucG9zK3MsdT1uZXcgbS5vbm54LlR5cGVQcm90by5TZXF1ZW5jZTtuLnBvczxpOyl7dmFyIGw9bi51aW50MzIoKTtzd2l0Y2gobD4+PjMpe2Nhc2UgMTp7dS5lbGVtVHlwZT1tLm9ubnguVHlwZVByb3RvLmRlY29kZShuLG4udWludDMyKCkpO2JyZWFrfWRlZmF1bHQ6bi5za2lwVHlwZShsJjcpO2JyZWFrfX1yZXR1cm4gdX0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24obil7cmV0dXJuIG4gaW5zdGFuY2VvZiBOfHwobj1uZXcgTihuKSksdGhpcy5kZWNvZGUobixuLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24obil7aWYodHlwZW9mIG4hPVwib2JqZWN0XCJ8fG49PT1udWxsKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobi5lbGVtVHlwZSE9bnVsbCYmbi5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpKXt2YXIgcz1tLm9ubnguVHlwZVByb3RvLnZlcmlmeShuLmVsZW1UeXBlKTtpZihzKXJldHVyblwiZWxlbVR5cGUuXCIrc31yZXR1cm4gbnVsbH0sZS5mcm9tT2JqZWN0PWZ1bmN0aW9uKG4pe2lmKG4gaW5zdGFuY2VvZiBtLm9ubnguVHlwZVByb3RvLlNlcXVlbmNlKXJldHVybiBuO3ZhciBzPW5ldyBtLm9ubnguVHlwZVByb3RvLlNlcXVlbmNlO2lmKG4uZWxlbVR5cGUhPW51bGwpe2lmKHR5cGVvZiBuLmVsZW1UeXBlIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5lbGVtVHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO3MuZWxlbVR5cGU9bS5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KG4uZWxlbVR5cGUpfXJldHVybiBzfSxlLnRvT2JqZWN0PWZ1bmN0aW9uKG4scyl7c3x8KHM9e30pO3ZhciBpPXt9O3JldHVybiBzLmRlZmF1bHRzJiYoaS5lbGVtVHlwZT1udWxsKSxuLmVsZW1UeXBlIT1udWxsJiZuLmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikmJihpLmVsZW1UeXBlPW0ub25ueC5UeXBlUHJvdG8udG9PYmplY3Qobi5lbGVtVHlwZSxzKSksaX0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxnZS51dGlsLnRvSlNPTk9wdGlvbnMpfSxlLmdldFR5cGVVcmw9ZnVuY3Rpb24obil7cmV0dXJuIG49PT12b2lkIDAmJihuPVwidHlwZS5nb29nbGVhcGlzLmNvbVwiKSxuK1wiL29ubnguVHlwZVByb3RvLlNlcXVlbmNlXCJ9LGV9KCksdC5NYXA9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHIpe2lmKHIpZm9yKHZhciBuPU9iamVjdC5rZXlzKHIpLHM9MDtzPG4ubGVuZ3RoOysrcylyW25bc11dIT1udWxsJiYodGhpc1tuW3NdXT1yW25bc11dKX1yZXR1cm4gZS5wcm90b3R5cGUua2V5VHlwZT0wLGUucHJvdG90eXBlLnZhbHVlVHlwZT1udWxsLGUuY3JlYXRlPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgZShuKX0sZS5lbmNvZGU9ZnVuY3Rpb24obixzKXtyZXR1cm4gc3x8KHM9RWUuY3JlYXRlKCkpLG4ua2V5VHlwZSE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobixcImtleVR5cGVcIikmJnMudWludDMyKDgpLmludDMyKG4ua2V5VHlwZSksbi52YWx1ZVR5cGUhPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sXCJ2YWx1ZVR5cGVcIikmJm0ub25ueC5UeXBlUHJvdG8uZW5jb2RlKG4udmFsdWVUeXBlLHMudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpLHN9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKG4scyl7cmV0dXJuIHRoaXMuZW5jb2RlKG4scykubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKG4scyl7biBpbnN0YW5jZW9mIE58fChuPU4uY3JlYXRlKG4pKTtmb3IodmFyIGk9cz09PXZvaWQgMD9uLmxlbjpuLnBvcytzLHU9bmV3IG0ub25ueC5UeXBlUHJvdG8uTWFwO24ucG9zPGk7KXt2YXIgbD1uLnVpbnQzMigpO3N3aXRjaChsPj4+Myl7Y2FzZSAxOnt1LmtleVR5cGU9bi5pbnQzMigpO2JyZWFrfWNhc2UgMjp7dS52YWx1ZVR5cGU9bS5vbm54LlR5cGVQcm90by5kZWNvZGUobixuLnVpbnQzMigpKTticmVha31kZWZhdWx0Om4uc2tpcFR5cGUobCY3KTticmVha319cmV0dXJuIHV9LGUuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKG4pe3JldHVybiBuIGluc3RhbmNlb2YgTnx8KG49bmV3IE4obikpLHRoaXMuZGVjb2RlKG4sbi51aW50MzIoKSl9LGUudmVyaWZ5PWZ1bmN0aW9uKG4pe2lmKHR5cGVvZiBuIT1cIm9iamVjdFwifHxuPT09bnVsbClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG4ua2V5VHlwZSE9bnVsbCYmbi5oYXNPd25Qcm9wZXJ0eShcImtleVR5cGVcIikmJiF5LmlzSW50ZWdlcihuLmtleVR5cGUpKXJldHVyblwia2V5VHlwZTogaW50ZWdlciBleHBlY3RlZFwiO2lmKG4udmFsdWVUeXBlIT1udWxsJiZuLmhhc093blByb3BlcnR5KFwidmFsdWVUeXBlXCIpKXt2YXIgcz1tLm9ubnguVHlwZVByb3RvLnZlcmlmeShuLnZhbHVlVHlwZSk7aWYocylyZXR1cm5cInZhbHVlVHlwZS5cIitzfXJldHVybiBudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24obil7aWYobiBpbnN0YW5jZW9mIG0ub25ueC5UeXBlUHJvdG8uTWFwKXJldHVybiBuO3ZhciBzPW5ldyBtLm9ubnguVHlwZVByb3RvLk1hcDtpZihuLmtleVR5cGUhPW51bGwmJihzLmtleVR5cGU9bi5rZXlUeXBlfDApLG4udmFsdWVUeXBlIT1udWxsKXtpZih0eXBlb2Ygbi52YWx1ZVR5cGUhPVwib2JqZWN0XCIpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLk1hcC52YWx1ZVR5cGU6IG9iamVjdCBleHBlY3RlZFwiKTtzLnZhbHVlVHlwZT1tLm9ubnguVHlwZVByb3RvLmZyb21PYmplY3Qobi52YWx1ZVR5cGUpfXJldHVybiBzfSxlLnRvT2JqZWN0PWZ1bmN0aW9uKG4scyl7c3x8KHM9e30pO3ZhciBpPXt9O3JldHVybiBzLmRlZmF1bHRzJiYoaS5rZXlUeXBlPTAsaS52YWx1ZVR5cGU9bnVsbCksbi5rZXlUeXBlIT1udWxsJiZuLmhhc093blByb3BlcnR5KFwia2V5VHlwZVwiKSYmKGkua2V5VHlwZT1uLmtleVR5cGUpLG4udmFsdWVUeXBlIT1udWxsJiZuLmhhc093blByb3BlcnR5KFwidmFsdWVUeXBlXCIpJiYoaS52YWx1ZVR5cGU9bS5vbm54LlR5cGVQcm90by50b09iamVjdChuLnZhbHVlVHlwZSxzKSksaX0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxnZS51dGlsLnRvSlNPTk9wdGlvbnMpfSxlLmdldFR5cGVVcmw9ZnVuY3Rpb24obil7cmV0dXJuIG49PT12b2lkIDAmJihuPVwidHlwZS5nb29nbGVhcGlzLmNvbVwiKSxuK1wiL29ubnguVHlwZVByb3RvLk1hcFwifSxlfSgpLHQuT3B0aW9uYWw9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHIpe2lmKHIpZm9yKHZhciBuPU9iamVjdC5rZXlzKHIpLHM9MDtzPG4ubGVuZ3RoOysrcylyW25bc11dIT1udWxsJiYodGhpc1tuW3NdXT1yW25bc11dKX1yZXR1cm4gZS5wcm90b3R5cGUuZWxlbVR5cGU9bnVsbCxlLmNyZWF0ZT1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IGUobil9LGUuZW5jb2RlPWZ1bmN0aW9uKG4scyl7cmV0dXJuIHN8fChzPUVlLmNyZWF0ZSgpKSxuLmVsZW1UeXBlIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChuLFwiZWxlbVR5cGVcIikmJm0ub25ueC5UeXBlUHJvdG8uZW5jb2RlKG4uZWxlbVR5cGUscy51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCksc30sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24obixzKXtyZXR1cm4gdGhpcy5lbmNvZGUobixzKS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24obixzKXtuIGluc3RhbmNlb2YgTnx8KG49Ti5jcmVhdGUobikpO2Zvcih2YXIgaT1zPT09dm9pZCAwP24ubGVuOm4ucG9zK3MsdT1uZXcgbS5vbm54LlR5cGVQcm90by5PcHRpb25hbDtuLnBvczxpOyl7dmFyIGw9bi51aW50MzIoKTtzd2l0Y2gobD4+PjMpe2Nhc2UgMTp7dS5lbGVtVHlwZT1tLm9ubnguVHlwZVByb3RvLmRlY29kZShuLG4udWludDMyKCkpO2JyZWFrfWRlZmF1bHQ6bi5za2lwVHlwZShsJjcpO2JyZWFrfX1yZXR1cm4gdX0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24obil7cmV0dXJuIG4gaW5zdGFuY2VvZiBOfHwobj1uZXcgTihuKSksdGhpcy5kZWNvZGUobixuLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24obil7aWYodHlwZW9mIG4hPVwib2JqZWN0XCJ8fG49PT1udWxsKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobi5lbGVtVHlwZSE9bnVsbCYmbi5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpKXt2YXIgcz1tLm9ubnguVHlwZVByb3RvLnZlcmlmeShuLmVsZW1UeXBlKTtpZihzKXJldHVyblwiZWxlbVR5cGUuXCIrc31yZXR1cm4gbnVsbH0sZS5mcm9tT2JqZWN0PWZ1bmN0aW9uKG4pe2lmKG4gaW5zdGFuY2VvZiBtLm9ubnguVHlwZVByb3RvLk9wdGlvbmFsKXJldHVybiBuO3ZhciBzPW5ldyBtLm9ubnguVHlwZVByb3RvLk9wdGlvbmFsO2lmKG4uZWxlbVR5cGUhPW51bGwpe2lmKHR5cGVvZiBuLmVsZW1UeXBlIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by5PcHRpb25hbC5lbGVtVHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO3MuZWxlbVR5cGU9bS5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KG4uZWxlbVR5cGUpfXJldHVybiBzfSxlLnRvT2JqZWN0PWZ1bmN0aW9uKG4scyl7c3x8KHM9e30pO3ZhciBpPXt9O3JldHVybiBzLmRlZmF1bHRzJiYoaS5lbGVtVHlwZT1udWxsKSxuLmVsZW1UeXBlIT1udWxsJiZuLmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikmJihpLmVsZW1UeXBlPW0ub25ueC5UeXBlUHJvdG8udG9PYmplY3Qobi5lbGVtVHlwZSxzKSksaX0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxnZS51dGlsLnRvSlNPTk9wdGlvbnMpfSxlLmdldFR5cGVVcmw9ZnVuY3Rpb24obil7cmV0dXJuIG49PT12b2lkIDAmJihuPVwidHlwZS5nb29nbGVhcGlzLmNvbVwiKSxuK1wiL29ubnguVHlwZVByb3RvLk9wdGlvbmFsXCJ9LGV9KCksdC5TcGFyc2VUZW5zb3I9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHIpe2lmKHIpZm9yKHZhciBuPU9iamVjdC5rZXlzKHIpLHM9MDtzPG4ubGVuZ3RoOysrcylyW25bc11dIT1udWxsJiYodGhpc1tuW3NdXT1yW25bc11dKX1yZXR1cm4gZS5wcm90b3R5cGUuZWxlbVR5cGU9MCxlLnByb3RvdHlwZS5zaGFwZT1udWxsLGUuY3JlYXRlPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgZShuKX0sZS5lbmNvZGU9ZnVuY3Rpb24obixzKXtyZXR1cm4gc3x8KHM9RWUuY3JlYXRlKCkpLG4uZWxlbVR5cGUhPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sXCJlbGVtVHlwZVwiKSYmcy51aW50MzIoOCkuaW50MzIobi5lbGVtVHlwZSksbi5zaGFwZSE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobixcInNoYXBlXCIpJiZtLm9ubnguVGVuc29yU2hhcGVQcm90by5lbmNvZGUobi5zaGFwZSxzLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKSxzfSxlLmVuY29kZURlbGltaXRlZD1mdW5jdGlvbihuLHMpe3JldHVybiB0aGlzLmVuY29kZShuLHMpLmxkZWxpbSgpfSxlLmRlY29kZT1mdW5jdGlvbihuLHMpe24gaW5zdGFuY2VvZiBOfHwobj1OLmNyZWF0ZShuKSk7Zm9yKHZhciBpPXM9PT12b2lkIDA/bi5sZW46bi5wb3Mrcyx1PW5ldyBtLm9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvcjtuLnBvczxpOyl7dmFyIGw9bi51aW50MzIoKTtzd2l0Y2gobD4+PjMpe2Nhc2UgMTp7dS5lbGVtVHlwZT1uLmludDMyKCk7YnJlYWt9Y2FzZSAyOnt1LnNoYXBlPW0ub25ueC5UZW5zb3JTaGFwZVByb3RvLmRlY29kZShuLG4udWludDMyKCkpO2JyZWFrfWRlZmF1bHQ6bi5za2lwVHlwZShsJjcpO2JyZWFrfX1yZXR1cm4gdX0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24obil7cmV0dXJuIG4gaW5zdGFuY2VvZiBOfHwobj1uZXcgTihuKSksdGhpcy5kZWNvZGUobixuLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24obil7aWYodHlwZW9mIG4hPVwib2JqZWN0XCJ8fG49PT1udWxsKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobi5lbGVtVHlwZSE9bnVsbCYmbi5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpJiYheS5pc0ludGVnZXIobi5lbGVtVHlwZSkpcmV0dXJuXCJlbGVtVHlwZTogaW50ZWdlciBleHBlY3RlZFwiO2lmKG4uc2hhcGUhPW51bGwmJm4uaGFzT3duUHJvcGVydHkoXCJzaGFwZVwiKSl7dmFyIHM9bS5vbm54LlRlbnNvclNoYXBlUHJvdG8udmVyaWZ5KG4uc2hhcGUpO2lmKHMpcmV0dXJuXCJzaGFwZS5cIitzfXJldHVybiBudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24obil7aWYobiBpbnN0YW5jZW9mIG0ub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yKXJldHVybiBuO3ZhciBzPW5ldyBtLm9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvcjtpZihuLmVsZW1UeXBlIT1udWxsJiYocy5lbGVtVHlwZT1uLmVsZW1UeXBlfDApLG4uc2hhcGUhPW51bGwpe2lmKHR5cGVvZiBuLnNoYXBlIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3Iuc2hhcGU6IG9iamVjdCBleHBlY3RlZFwiKTtzLnNoYXBlPW0ub25ueC5UZW5zb3JTaGFwZVByb3RvLmZyb21PYmplY3Qobi5zaGFwZSl9cmV0dXJuIHN9LGUudG9PYmplY3Q9ZnVuY3Rpb24obixzKXtzfHwocz17fSk7dmFyIGk9e307cmV0dXJuIHMuZGVmYXVsdHMmJihpLmVsZW1UeXBlPTAsaS5zaGFwZT1udWxsKSxuLmVsZW1UeXBlIT1udWxsJiZuLmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikmJihpLmVsZW1UeXBlPW4uZWxlbVR5cGUpLG4uc2hhcGUhPW51bGwmJm4uaGFzT3duUHJvcGVydHkoXCJzaGFwZVwiKSYmKGkuc2hhcGU9bS5vbm54LlRlbnNvclNoYXBlUHJvdG8udG9PYmplY3Qobi5zaGFwZSxzKSksaX0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxnZS51dGlsLnRvSlNPTk9wdGlvbnMpfSxlLmdldFR5cGVVcmw9ZnVuY3Rpb24obil7cmV0dXJuIG49PT12b2lkIDAmJihuPVwidHlwZS5nb29nbGVhcGlzLmNvbVwiKSxuK1wiL29ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclwifSxlfSgpLHR9KCksYS5PcGVyYXRvclNldElkUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KG8pe2lmKG8pZm9yKHZhciBlPU9iamVjdC5rZXlzKG8pLHI9MDtyPGUubGVuZ3RoOysrcilvW2Vbcl1dIT1udWxsJiYodGhpc1tlW3JdXT1vW2Vbcl1dKX1yZXR1cm4gdC5wcm90b3R5cGUuZG9tYWluPVwiXCIsdC5wcm90b3R5cGUudmVyc2lvbj15Lkxvbmc/eS5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKGUscil7cmV0dXJuIHJ8fChyPUVlLmNyZWF0ZSgpKSxlLmRvbWFpbiE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImRvbWFpblwiKSYmci51aW50MzIoMTApLnN0cmluZyhlLmRvbWFpbiksZS52ZXJzaW9uIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwidmVyc2lvblwiKSYmci51aW50MzIoMTYpLmludDY0KGUudmVyc2lvbikscn0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdGhpcy5lbmNvZGUoZSxyKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24oZSxyKXtlIGluc3RhbmNlb2YgTnx8KGU9Ti5jcmVhdGUoZSkpO2Zvcih2YXIgbj1yPT09dm9pZCAwP2UubGVuOmUucG9zK3Iscz1uZXcgbS5vbm54Lk9wZXJhdG9yU2V0SWRQcm90bztlLnBvczxuOyl7dmFyIGk9ZS51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTp7cy5kb21haW49ZS5zdHJpbmcoKTticmVha31jYXNlIDI6e3MudmVyc2lvbj1lLmludDY0KCk7YnJlYWt9ZGVmYXVsdDplLnNraXBUeXBlKGkmNyk7YnJlYWt9fXJldHVybiBzfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIE58fChlPW5ldyBOKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGUhPVwib2JqZWN0XCJ8fGU9PT1udWxsP1wib2JqZWN0IGV4cGVjdGVkXCI6ZS5kb21haW4hPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJiF5LmlzU3RyaW5nKGUuZG9tYWluKT9cImRvbWFpbjogc3RyaW5nIGV4cGVjdGVkXCI6ZS52ZXJzaW9uIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwidmVyc2lvblwiKSYmIXkuaXNJbnRlZ2VyKGUudmVyc2lvbikmJiEoZS52ZXJzaW9uJiZ5LmlzSW50ZWdlcihlLnZlcnNpb24ubG93KSYmeS5pc0ludGVnZXIoZS52ZXJzaW9uLmhpZ2gpKT9cInZlcnNpb246IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgbS5vbm54Lk9wZXJhdG9yU2V0SWRQcm90bylyZXR1cm4gZTt2YXIgcj1uZXcgbS5vbm54Lk9wZXJhdG9yU2V0SWRQcm90bztyZXR1cm4gZS5kb21haW4hPW51bGwmJihyLmRvbWFpbj1TdHJpbmcoZS5kb21haW4pKSxlLnZlcnNpb24hPW51bGwmJih5Lkxvbmc/KHIudmVyc2lvbj15LkxvbmcuZnJvbVZhbHVlKGUudmVyc2lvbikpLnVuc2lnbmVkPSExOnR5cGVvZiBlLnZlcnNpb249PVwic3RyaW5nXCI/ci52ZXJzaW9uPXBhcnNlSW50KGUudmVyc2lvbiwxMCk6dHlwZW9mIGUudmVyc2lvbj09XCJudW1iZXJcIj9yLnZlcnNpb249ZS52ZXJzaW9uOnR5cGVvZiBlLnZlcnNpb249PVwib2JqZWN0XCImJihyLnZlcnNpb249bmV3IHkuTG9uZ0JpdHMoZS52ZXJzaW9uLmxvdz4+PjAsZS52ZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpKSkscn0sdC50b09iamVjdD1mdW5jdGlvbihlLHIpe3J8fChyPXt9KTt2YXIgbj17fTtpZihyLmRlZmF1bHRzKWlmKG4uZG9tYWluPVwiXCIseS5Mb25nKXt2YXIgcz1uZXcgeS5Mb25nKDAsMCwhMSk7bi52ZXJzaW9uPXIubG9uZ3M9PT1TdHJpbmc/cy50b1N0cmluZygpOnIubG9uZ3M9PT1OdW1iZXI/cy50b051bWJlcigpOnN9ZWxzZSBuLnZlcnNpb249ci5sb25ncz09PVN0cmluZz9cIjBcIjowO3JldHVybiBlLmRvbWFpbiE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmKG4uZG9tYWluPWUuZG9tYWluKSxlLnZlcnNpb24hPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJ2ZXJzaW9uXCIpJiYodHlwZW9mIGUudmVyc2lvbj09XCJudW1iZXJcIj9uLnZlcnNpb249ci5sb25ncz09PVN0cmluZz9TdHJpbmcoZS52ZXJzaW9uKTplLnZlcnNpb246bi52ZXJzaW9uPXIubG9uZ3M9PT1TdHJpbmc/eS5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUudmVyc2lvbik6ci5sb25ncz09PU51bWJlcj9uZXcgeS5Mb25nQml0cyhlLnZlcnNpb24ubG93Pj4+MCxlLnZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCk6ZS52ZXJzaW9uKSxufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGdlLnV0aWwudG9KU09OT3B0aW9ucyl9LHQuZ2V0VHlwZVVybD1mdW5jdGlvbihlKXtyZXR1cm4gZT09PXZvaWQgMCYmKGU9XCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpLGUrXCIvb25ueC5PcGVyYXRvclNldElkUHJvdG9cIn0sdH0oKSxhLk9wZXJhdG9yU3RhdHVzPWZ1bmN0aW9uKCl7dmFyIHQ9e30sbz1PYmplY3QuY3JlYXRlKHQpO3JldHVybiBvW3RbMF09XCJFWFBFUklNRU5UQUxcIl09MCxvW3RbMV09XCJTVEFCTEVcIl09MSxvfSgpLGEuRnVuY3Rpb25Qcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobyl7aWYodGhpcy5pbnB1dD1bXSx0aGlzLm91dHB1dD1bXSx0aGlzLmF0dHJpYnV0ZT1bXSx0aGlzLmF0dHJpYnV0ZVByb3RvPVtdLHRoaXMubm9kZT1bXSx0aGlzLm9wc2V0SW1wb3J0PVtdLG8pZm9yKHZhciBlPU9iamVjdC5rZXlzKG8pLHI9MDtyPGUubGVuZ3RoOysrcilvW2Vbcl1dIT1udWxsJiYodGhpc1tlW3JdXT1vW2Vbcl1dKX1yZXR1cm4gdC5wcm90b3R5cGUubmFtZT1cIlwiLHQucHJvdG90eXBlLmlucHV0PXkuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5vdXRwdXQ9eS5lbXB0eUFycmF5LHQucHJvdG90eXBlLmF0dHJpYnV0ZT15LmVtcHR5QXJyYXksdC5wcm90b3R5cGUuYXR0cmlidXRlUHJvdG89eS5lbXB0eUFycmF5LHQucHJvdG90eXBlLm5vZGU9eS5lbXB0eUFycmF5LHQucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLHQucHJvdG90eXBlLm9wc2V0SW1wb3J0PXkuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5kb21haW49XCJcIix0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKGUscil7aWYocnx8KHI9RWUuY3JlYXRlKCkpLGUubmFtZSE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcIm5hbWVcIikmJnIudWludDMyKDEwKS5zdHJpbmcoZS5uYW1lKSxlLmlucHV0IT1udWxsJiZlLmlucHV0Lmxlbmd0aClmb3IodmFyIG49MDtuPGUuaW5wdXQubGVuZ3RoOysrbilyLnVpbnQzMigzNCkuc3RyaW5nKGUuaW5wdXRbbl0pO2lmKGUub3V0cHV0IT1udWxsJiZlLm91dHB1dC5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLm91dHB1dC5sZW5ndGg7KytuKXIudWludDMyKDQyKS5zdHJpbmcoZS5vdXRwdXRbbl0pO2lmKGUuYXR0cmlidXRlIT1udWxsJiZlLmF0dHJpYnV0ZS5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLmF0dHJpYnV0ZS5sZW5ndGg7KytuKXIudWludDMyKDUwKS5zdHJpbmcoZS5hdHRyaWJ1dGVbbl0pO2lmKGUubm9kZSE9bnVsbCYmZS5ub2RlLmxlbmd0aClmb3IodmFyIG49MDtuPGUubm9kZS5sZW5ndGg7KytuKW0ub25ueC5Ob2RlUHJvdG8uZW5jb2RlKGUubm9kZVtuXSxyLnVpbnQzMig1OCkuZm9yaygpKS5sZGVsaW0oKTtpZihlLmRvY1N0cmluZyE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImRvY1N0cmluZ1wiKSYmci51aW50MzIoNjYpLnN0cmluZyhlLmRvY1N0cmluZyksZS5vcHNldEltcG9ydCE9bnVsbCYmZS5vcHNldEltcG9ydC5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLm9wc2V0SW1wb3J0Lmxlbmd0aDsrK24pbS5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5lbmNvZGUoZS5vcHNldEltcG9ydFtuXSxyLnVpbnQzMig3NCkuZm9yaygpKS5sZGVsaW0oKTtpZihlLmRvbWFpbiE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImRvbWFpblwiKSYmci51aW50MzIoODIpLnN0cmluZyhlLmRvbWFpbiksZS5hdHRyaWJ1dGVQcm90byE9bnVsbCYmZS5hdHRyaWJ1dGVQcm90by5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLmF0dHJpYnV0ZVByb3RvLmxlbmd0aDsrK24pbS5vbm54LkF0dHJpYnV0ZVByb3RvLmVuY29kZShlLmF0dHJpYnV0ZVByb3RvW25dLHIudWludDMyKDkwKS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiByfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbihlLHIpe3JldHVybiB0aGlzLmVuY29kZShlLHIpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbihlLHIpe2UgaW5zdGFuY2VvZiBOfHwoZT1OLmNyZWF0ZShlKSk7Zm9yKHZhciBuPXI9PT12b2lkIDA/ZS5sZW46ZS5wb3MrcixzPW5ldyBtLm9ubnguRnVuY3Rpb25Qcm90bztlLnBvczxuOyl7dmFyIGk9ZS51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTp7cy5uYW1lPWUuc3RyaW5nKCk7YnJlYWt9Y2FzZSA0OntzLmlucHV0JiZzLmlucHV0Lmxlbmd0aHx8KHMuaW5wdXQ9W10pLHMuaW5wdXQucHVzaChlLnN0cmluZygpKTticmVha31jYXNlIDU6e3Mub3V0cHV0JiZzLm91dHB1dC5sZW5ndGh8fChzLm91dHB1dD1bXSkscy5vdXRwdXQucHVzaChlLnN0cmluZygpKTticmVha31jYXNlIDY6e3MuYXR0cmlidXRlJiZzLmF0dHJpYnV0ZS5sZW5ndGh8fChzLmF0dHJpYnV0ZT1bXSkscy5hdHRyaWJ1dGUucHVzaChlLnN0cmluZygpKTticmVha31jYXNlIDExOntzLmF0dHJpYnV0ZVByb3RvJiZzLmF0dHJpYnV0ZVByb3RvLmxlbmd0aHx8KHMuYXR0cmlidXRlUHJvdG89W10pLHMuYXR0cmlidXRlUHJvdG8ucHVzaChtLm9ubnguQXR0cmlidXRlUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrfWNhc2UgNzp7cy5ub2RlJiZzLm5vZGUubGVuZ3RofHwocy5ub2RlPVtdKSxzLm5vZGUucHVzaChtLm9ubnguTm9kZVByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVha31jYXNlIDg6e3MuZG9jU3RyaW5nPWUuc3RyaW5nKCk7YnJlYWt9Y2FzZSA5OntzLm9wc2V0SW1wb3J0JiZzLm9wc2V0SW1wb3J0Lmxlbmd0aHx8KHMub3BzZXRJbXBvcnQ9W10pLHMub3BzZXRJbXBvcnQucHVzaChtLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVha31jYXNlIDEwOntzLmRvbWFpbj1lLnN0cmluZygpO2JyZWFrfWRlZmF1bHQ6ZS5za2lwVHlwZShpJjcpO2JyZWFrfX1yZXR1cm4gc30sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBOfHwoZT1uZXcgTihlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYodHlwZW9mIGUhPVwib2JqZWN0XCJ8fGU9PT1udWxsKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYoZS5uYW1lIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmIXkuaXNTdHJpbmcoZS5uYW1lKSlyZXR1cm5cIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKGUuaW5wdXQhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJpbnB1dFwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5pbnB1dCkpcmV0dXJuXCJpbnB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHI9MDtyPGUuaW5wdXQubGVuZ3RoOysrcilpZigheS5pc1N0cmluZyhlLmlucHV0W3JdKSlyZXR1cm5cImlucHV0OiBzdHJpbmdbXSBleHBlY3RlZFwifWlmKGUub3V0cHV0IT1udWxsJiZlLmhhc093blByb3BlcnR5KFwib3V0cHV0XCIpKXtpZighQXJyYXkuaXNBcnJheShlLm91dHB1dCkpcmV0dXJuXCJvdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciByPTA7cjxlLm91dHB1dC5sZW5ndGg7KytyKWlmKCF5LmlzU3RyaW5nKGUub3V0cHV0W3JdKSlyZXR1cm5cIm91dHB1dDogc3RyaW5nW10gZXhwZWN0ZWRcIn1pZihlLmF0dHJpYnV0ZSE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImF0dHJpYnV0ZVwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5hdHRyaWJ1dGUpKXJldHVyblwiYXR0cmlidXRlOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgcj0wO3I8ZS5hdHRyaWJ1dGUubGVuZ3RoOysrcilpZigheS5pc1N0cmluZyhlLmF0dHJpYnV0ZVtyXSkpcmV0dXJuXCJhdHRyaWJ1dGU6IHN0cmluZ1tdIGV4cGVjdGVkXCJ9aWYoZS5hdHRyaWJ1dGVQcm90byE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImF0dHJpYnV0ZVByb3RvXCIpKXtpZighQXJyYXkuaXNBcnJheShlLmF0dHJpYnV0ZVByb3RvKSlyZXR1cm5cImF0dHJpYnV0ZVByb3RvOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgcj0wO3I8ZS5hdHRyaWJ1dGVQcm90by5sZW5ndGg7KytyKXt2YXIgbj1tLm9ubnguQXR0cmlidXRlUHJvdG8udmVyaWZ5KGUuYXR0cmlidXRlUHJvdG9bcl0pO2lmKG4pcmV0dXJuXCJhdHRyaWJ1dGVQcm90by5cIitufX1pZihlLm5vZGUhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJub2RlXCIpKXtpZighQXJyYXkuaXNBcnJheShlLm5vZGUpKXJldHVyblwibm9kZTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHI9MDtyPGUubm9kZS5sZW5ndGg7KytyKXt2YXIgbj1tLm9ubnguTm9kZVByb3RvLnZlcmlmeShlLm5vZGVbcl0pO2lmKG4pcmV0dXJuXCJub2RlLlwiK259fWlmKGUuZG9jU3RyaW5nIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYheS5pc1N0cmluZyhlLmRvY1N0cmluZykpcmV0dXJuXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO2lmKGUub3BzZXRJbXBvcnQhPW51bGwmJmUuaGFzT3duUHJvcGVydHkoXCJvcHNldEltcG9ydFwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5vcHNldEltcG9ydCkpcmV0dXJuXCJvcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHI9MDtyPGUub3BzZXRJbXBvcnQubGVuZ3RoOysrcil7dmFyIG49bS5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by52ZXJpZnkoZS5vcHNldEltcG9ydFtyXSk7aWYobilyZXR1cm5cIm9wc2V0SW1wb3J0LlwiK259fXJldHVybiBlLmRvbWFpbiE9bnVsbCYmZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmIXkuaXNTdHJpbmcoZS5kb21haW4pP1wiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIG0ub25ueC5GdW5jdGlvblByb3RvKXJldHVybiBlO3ZhciByPW5ldyBtLm9ubnguRnVuY3Rpb25Qcm90bztpZihlLm5hbWUhPW51bGwmJihyLm5hbWU9U3RyaW5nKGUubmFtZSkpLGUuaW5wdXQpe2lmKCFBcnJheS5pc0FycmF5KGUuaW5wdXQpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkZ1bmN0aW9uUHJvdG8uaW5wdXQ6IGFycmF5IGV4cGVjdGVkXCIpO3IuaW5wdXQ9W107Zm9yKHZhciBuPTA7bjxlLmlucHV0Lmxlbmd0aDsrK24pci5pbnB1dFtuXT1TdHJpbmcoZS5pbnB1dFtuXSl9aWYoZS5vdXRwdXQpe2lmKCFBcnJheS5pc0FycmF5KGUub3V0cHV0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIik7ci5vdXRwdXQ9W107Zm9yKHZhciBuPTA7bjxlLm91dHB1dC5sZW5ndGg7KytuKXIub3V0cHV0W25dPVN0cmluZyhlLm91dHB1dFtuXSl9aWYoZS5hdHRyaWJ1dGUpe2lmKCFBcnJheS5pc0FycmF5KGUuYXR0cmlidXRlKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLmF0dHJpYnV0ZTogYXJyYXkgZXhwZWN0ZWRcIik7ci5hdHRyaWJ1dGU9W107Zm9yKHZhciBuPTA7bjxlLmF0dHJpYnV0ZS5sZW5ndGg7KytuKXIuYXR0cmlidXRlW25dPVN0cmluZyhlLmF0dHJpYnV0ZVtuXSl9aWYoZS5hdHRyaWJ1dGVQcm90byl7aWYoIUFycmF5LmlzQXJyYXkoZS5hdHRyaWJ1dGVQcm90bykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguRnVuY3Rpb25Qcm90by5hdHRyaWJ1dGVQcm90bzogYXJyYXkgZXhwZWN0ZWRcIik7ci5hdHRyaWJ1dGVQcm90bz1bXTtmb3IodmFyIG49MDtuPGUuYXR0cmlidXRlUHJvdG8ubGVuZ3RoOysrbil7aWYodHlwZW9mIGUuYXR0cmlidXRlUHJvdG9bbl0hPVwib2JqZWN0XCIpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguRnVuY3Rpb25Qcm90by5hdHRyaWJ1dGVQcm90bzogb2JqZWN0IGV4cGVjdGVkXCIpO3IuYXR0cmlidXRlUHJvdG9bbl09bS5vbm54LkF0dHJpYnV0ZVByb3RvLmZyb21PYmplY3QoZS5hdHRyaWJ1dGVQcm90b1tuXSl9fWlmKGUubm9kZSl7aWYoIUFycmF5LmlzQXJyYXkoZS5ub2RlKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLm5vZGU6IGFycmF5IGV4cGVjdGVkXCIpO3Iubm9kZT1bXTtmb3IodmFyIG49MDtuPGUubm9kZS5sZW5ndGg7KytuKXtpZih0eXBlb2YgZS5ub2RlW25dIT1cIm9iamVjdFwiKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkZ1bmN0aW9uUHJvdG8ubm9kZTogb2JqZWN0IGV4cGVjdGVkXCIpO3Iubm9kZVtuXT1tLm9ubnguTm9kZVByb3RvLmZyb21PYmplY3QoZS5ub2RlW25dKX19aWYoZS5kb2NTdHJpbmchPW51bGwmJihyLmRvY1N0cmluZz1TdHJpbmcoZS5kb2NTdHJpbmcpKSxlLm9wc2V0SW1wb3J0KXtpZighQXJyYXkuaXNBcnJheShlLm9wc2V0SW1wb3J0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLm9wc2V0SW1wb3J0OiBhcnJheSBleHBlY3RlZFwiKTtyLm9wc2V0SW1wb3J0PVtdO2Zvcih2YXIgbj0wO248ZS5vcHNldEltcG9ydC5sZW5ndGg7KytuKXtpZih0eXBlb2YgZS5vcHNldEltcG9ydFtuXSE9XCJvYmplY3RcIil0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLm9wc2V0SW1wb3J0OiBvYmplY3QgZXhwZWN0ZWRcIik7ci5vcHNldEltcG9ydFtuXT1tLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmZyb21PYmplY3QoZS5vcHNldEltcG9ydFtuXSl9fXJldHVybiBlLmRvbWFpbiE9bnVsbCYmKHIuZG9tYWluPVN0cmluZyhlLmRvbWFpbikpLHJ9LHQudG9PYmplY3Q9ZnVuY3Rpb24oZSxyKXtyfHwocj17fSk7dmFyIG49e307aWYoKHIuYXJyYXlzfHxyLmRlZmF1bHRzKSYmKG4uaW5wdXQ9W10sbi5vdXRwdXQ9W10sbi5hdHRyaWJ1dGU9W10sbi5ub2RlPVtdLG4ub3BzZXRJbXBvcnQ9W10sbi5hdHRyaWJ1dGVQcm90bz1bXSksci5kZWZhdWx0cyYmKG4ubmFtZT1cIlwiLG4uZG9jU3RyaW5nPVwiXCIsbi5kb21haW49XCJcIiksZS5uYW1lIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmKG4ubmFtZT1lLm5hbWUpLGUuaW5wdXQmJmUuaW5wdXQubGVuZ3RoKXtuLmlucHV0PVtdO2Zvcih2YXIgcz0wO3M8ZS5pbnB1dC5sZW5ndGg7KytzKW4uaW5wdXRbc109ZS5pbnB1dFtzXX1pZihlLm91dHB1dCYmZS5vdXRwdXQubGVuZ3RoKXtuLm91dHB1dD1bXTtmb3IodmFyIHM9MDtzPGUub3V0cHV0Lmxlbmd0aDsrK3Mpbi5vdXRwdXRbc109ZS5vdXRwdXRbc119aWYoZS5hdHRyaWJ1dGUmJmUuYXR0cmlidXRlLmxlbmd0aCl7bi5hdHRyaWJ1dGU9W107Zm9yKHZhciBzPTA7czxlLmF0dHJpYnV0ZS5sZW5ndGg7KytzKW4uYXR0cmlidXRlW3NdPWUuYXR0cmlidXRlW3NdfWlmKGUubm9kZSYmZS5ub2RlLmxlbmd0aCl7bi5ub2RlPVtdO2Zvcih2YXIgcz0wO3M8ZS5ub2RlLmxlbmd0aDsrK3Mpbi5ub2RlW3NdPW0ub25ueC5Ob2RlUHJvdG8udG9PYmplY3QoZS5ub2RlW3NdLHIpfWlmKGUuZG9jU3RyaW5nIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9ZS5kb2NTdHJpbmcpLGUub3BzZXRJbXBvcnQmJmUub3BzZXRJbXBvcnQubGVuZ3RoKXtuLm9wc2V0SW1wb3J0PVtdO2Zvcih2YXIgcz0wO3M8ZS5vcHNldEltcG9ydC5sZW5ndGg7KytzKW4ub3BzZXRJbXBvcnRbc109bS5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by50b09iamVjdChlLm9wc2V0SW1wb3J0W3NdLHIpfWlmKGUuZG9tYWluIT1udWxsJiZlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYobi5kb21haW49ZS5kb21haW4pLGUuYXR0cmlidXRlUHJvdG8mJmUuYXR0cmlidXRlUHJvdG8ubGVuZ3RoKXtuLmF0dHJpYnV0ZVByb3RvPVtdO2Zvcih2YXIgcz0wO3M8ZS5hdHRyaWJ1dGVQcm90by5sZW5ndGg7KytzKW4uYXR0cmlidXRlUHJvdG9bc109bS5vbm54LkF0dHJpYnV0ZVByb3RvLnRvT2JqZWN0KGUuYXR0cmlidXRlUHJvdG9bc10scil9cmV0dXJuIG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsZ2UudXRpbC50b0pTT05PcHRpb25zKX0sdC5nZXRUeXBlVXJsPWZ1bmN0aW9uKGUpe3JldHVybiBlPT09dm9pZCAwJiYoZT1cInR5cGUuZ29vZ2xlYXBpcy5jb21cIiksZStcIi9vbm54LkZ1bmN0aW9uUHJvdG9cIn0sdH0oKSxhfSgpOyR1LmV4cG9ydHM9bX0pO2Z1bmN0aW9uIGtyKGEsdCl7aWYoIWEpdGhyb3cgbmV3IEVycm9yKHR5cGVvZiB0PT1cInN0cmluZ1wiP3Q6dCgpKX1mdW5jdGlvbiBsbihhKXtyZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGEpfXZhciB5ZSxwcixoaSxLZSxYbixWZSxudCxVLHVuLGRyLGhyLG1yLGZlPUUoKCk9PntcInVzZSBzdHJpY3RcIjtXbigpO2VpKCk7eWU9RXIoJHIoKSk7YnIoKTtwcj1jbGFzc3tzdGF0aWMgYXJyYXlzRXF1YWwodCxvKXtpZih0Lmxlbmd0aCE9PW8ubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKHRbZV0hPT1vW2VdKXJldHVybiExO3JldHVybiEwfX0saGk9Y2xhc3N7c3RhdGljIHByZXByb2Nlc3NJbnB1dFNoYXBlcyh0LG8pe2xldCBlPXQubGVuZ3RoPT09MT9bMSx0WzBdXTp0LHI9by5sZW5ndGg9PT0xP1tvWzBdLDFdOm87cmV0dXJuW2Uscl19c3RhdGljIHBvc3Rwcm9jZXNzT3V0cHV0U2hhcGUodCxvLGUpe289PT0xJiZ0LnNwbGljZSh0Lmxlbmd0aC0yLDEpLGU9PT0xJiZ0LnBvcCgpfXN0YXRpYyBjYWxjTWF0TXVsU2hhcGUodCxvKXtyZXR1cm4gdFsxXSE9PW9bMF0/dm9pZCAwOlt0WzBdLG9bMV1dfX0sS2U9Y2xhc3MgYXtzdGF0aWMgY2FsY1NoYXBlKHQsbyxlPSExKXtsZXQgcj10Lmxlbmd0aCxuPW8ubGVuZ3RoO2lmKHI9PT0wKXJldHVybiBvO2lmKG49PT0wKXJldHVybiB0O2xldCBzPU1hdGgubWF4KHQubGVuZ3RoLG8ubGVuZ3RoKSxpPW5ldyBBcnJheShzKTtpZihlKXtpZihyPDJ8fG48MilyZXR1cm47bGV0IHU9aGkuY2FsY01hdE11bFNoYXBlKFt0W3ItMl0sdFtyLTFdXSxbb1tuLTJdLG9bbi0xXV0pO2lmKHU9PT12b2lkIDApcmV0dXJuO1tpW3MtMl0saVtzLTFdXT11fWZvcihsZXQgdT1lPzM6MTt1PD1zO3UrKyl7bGV0IGw9ci11PDA/MTp0W3ItdV0sZj1uLXU8MD8xOm9bbi11XTtpZihsIT09ZiYmbD4xJiZmPjEpcmV0dXJuO2lbcy11XT1NYXRoLm1heChsLGYpfXJldHVybiBpfXN0YXRpYyBpbmRleCh0LG8pe2xldCBlPW5ldyBBcnJheShvLmxlbmd0aCk7cmV0dXJuIGEuZmlsbEluZGV4KHQsbyxlKSxlfXN0YXRpYyBmaWxsSW5kZXgodCxvLGUpe2xldCByPXQubGVuZ3RoLW8ubGVuZ3RoO2ZvcihsZXQgbj0wO248by5sZW5ndGg7bisrKWVbbl09dFtyK25dJW9bbl19c3RhdGljIGNhbGModCxvLGUscixuKXtsZXQgcz1hLmNhbGNTaGFwZSh0LmRpbXMsby5kaW1zKTtpZihzKXtpZihyJiYhVS5hcmVFcXVhbChzLHQuZGltcykpcmV0dXJuO2xldCBpPVUuc2l6ZShzKSx1PXI/dDpuZXcgQ2UocyxufHx0LnR5cGUpO2lmKHMubGVuZ3RoPT09MCl1LnNldChbXSxlKHQuZ2V0KFtdKSxvLmdldChbXSkpKTtlbHNle2xldCBsPW5ldyBBcnJheShzLmxlbmd0aCksZj1uZXcgQXJyYXkodC5kaW1zLmxlbmd0aCkscD1uZXcgQXJyYXkoby5kaW1zLmxlbmd0aCksZD0wLFQ9MCx2PSExLHc9ITE7dC5kaW1zLmxlbmd0aD09PTAmJihkPXQuZ2V0KFtdKSx2PSEwKSxvLmRpbXMubGVuZ3RoPT09MCYmKFQ9by5nZXQoW10pLHc9ITApO2xldCBJO2ZvcihsZXQgTD0wO0w8aTtMKyspe0k9TDtmb3IobGV0IEY9cy5sZW5ndGgtMTtGPj0wO0YtLSlsW0ZdPUklc1tGXSxJPU1hdGguZmxvb3IoSS9zW0ZdKTt2fHwoYS5maWxsSW5kZXgobCx0LmRpbXMsZiksZD10LmdldChmKSksd3x8KGEuZmlsbEluZGV4KGwsby5kaW1zLHApLFQ9by5nZXQocCkpLHUuc2V0KGwsZShkLFQpKX19cmV0dXJuIHV9fXN0YXRpYyBpc1ZhbGlkQnJvYWRjYXN0KHQsbyl7bGV0IGU9dC5sZW5ndGgscj1vLmxlbmd0aDtpZihlPnIpcmV0dXJuITE7Zm9yKGxldCBuPTE7bjw9ZTtuKyspaWYodFtlLW5dIT09MSYmdFtlLW5dIT09b1tyLW5dKXJldHVybiExO3JldHVybiEwfXN0YXRpYyBnZXRCcm9hZGNhc3REaW1zKHQsbyl7bGV0IGU9dC5sZW5ndGgscj1bXTtmb3IobGV0IG49MDtuPGU7bisrKXtsZXQgcz1lLTEtbixpPXRbc118fDE7KG9bby5sZW5ndGgtMS1uXXx8MSk+MSYmaT09PTEmJnIudW5zaGlmdChzKX1yZXR1cm4gcn19LFhuPWNsYXNze3N0YXRpYyBnZXRTaGFwZU9mR2VtbVJlc3VsdCh0LG8sZSxyLG4pe2lmKHQubGVuZ3RoIT09Mnx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcInNoYXBlIG5lZWQgdG8gYmUgb2Ygc2l6ZSAyXCIpO2xldCBzLGksdTtvPyhzPXRbMV0saT10WzBdKToocz10WzBdLGk9dFsxXSk7bGV0IGw9LTE7aWYocj8odT1lWzBdLGw9MSk6KHU9ZVsxXSxsPTApLGVbbF0hPT1pKXRocm93IG5ldyBFcnJvcihcImRpbWVuc2lvbiBtaXNtYXRjaFwiKTtpZihzPD0wfHx1PD0wfHxpPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2hhcGUgc3BlY2lmaWVkXCIpO2lmKG4mJiFLZS5pc1ZhbGlkQnJvYWRjYXN0KG4sW3MsdV0pKXRocm93IG5ldyBFcnJvcihcImdlbW06IGludmFsaWQgYmlhcyBzaGFwZSBmb3IgYnJvYWRjYXN0XCIpO3JldHVybltzLHUsaV19fSxWZT1jbGFzcyBhe3N0YXRpYyB0ZW5zb3JEYXRhVHlwZUZyb21Qcm90byh0KXtzd2l0Y2godCl7Y2FzZSB5ZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6cmV0dXJuXCJpbnQ4XCI7Y2FzZSB5ZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OnJldHVyblwidWludDhcIjtjYXNlIHllLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDpyZXR1cm5cImJvb2xcIjtjYXNlIHllLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgeWUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6cmV0dXJuXCJ1aW50MTZcIjtjYXNlIHllLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgeWUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIHllLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6cmV0dXJuXCJmbG9hdDMyXCI7Y2FzZSB5ZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpyZXR1cm5cImZsb2F0NjRcIjtjYXNlIHllLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuU1RSSU5HOnJldHVyblwic3RyaW5nXCI7Y2FzZSB5ZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0OnJldHVyblwiaW50MzJcIjtjYXNlIHllLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0OnJldHVyblwidWludDMyXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt5ZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3RdfWApfX1zdGF0aWMgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0odCl7c3dpdGNoKHQpe2Nhc2VcImludDhcIjpyZXR1cm4geWUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4O2Nhc2VcInVpbnQ4XCI6cmV0dXJuIHllLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg7Y2FzZVwiYm9vbFwiOnJldHVybiB5ZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w7Y2FzZVwiaW50MTZcIjpyZXR1cm4geWUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjtjYXNlXCJ1aW50MTZcIjpyZXR1cm4geWUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY7Y2FzZVwiaW50MzJcIjpyZXR1cm4geWUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4geWUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiB5ZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4geWUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIHllLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuU1RSSU5HO2Nhc2VcImludDY0XCI6cmV0dXJuIHllLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ7Y2FzZVwidWludDY0XCI6cmV0dXJuIHllLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH1gKX19c3RhdGljIHRlbnNvckRpbXNGcm9tUHJvdG8odCl7cmV0dXJuIHQubWFwKG89Pld0LmlzTG9uZyhvKT9vLnRvTnVtYmVyKCk6byl9c3RhdGljIHRlbnNvclZhbHVlVHlwZUZyb21Qcm90byh0KXtyZXR1cm57dGVuc29yVHlwZTphLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKHQuZWxlbVR5cGUpLHNoYXBlOntkaW1zOmEudGVuc29yRGltc0Zyb21Qcm90byh0LnNoYXBlLmRpbS5tYXAobz0+by5kaW1WYWx1ZSkpfX19c3RhdGljIHRlbnNvckRpbXNGcm9tT1JURm9ybWF0KHQpe2xldCBvPVtdO2ZvcihsZXQgZT0wO2U8dC5kaW1zTGVuZ3RoKCk7ZSsrKW8ucHVzaChudC5sb25nVG9OdW1iZXIodC5kaW1zKGUpKSk7cmV0dXJuIG99c3RhdGljIHRlbnNvckF0dHJpYnV0ZXNGcm9tT1JURm9ybWF0KHQpe2xldCBvPVtdO2ZvcihsZXQgZT0wO2U8dC5hdHRyaWJ1dGVzTGVuZ3RoKCk7ZSsrKW8ucHVzaCh0LmF0dHJpYnV0ZXMoZSkpO3JldHVybiBvfX0sbnQ9Y2xhc3N7c3RhdGljIGxvbmdUb051bWJlcih0LG8pe3JldHVybiBXdC5pc0xvbmcodCk/dC50b051bWJlcigpOnQgaW5zdGFuY2VvZiBPLkxvbmc/V3QuZnJvbVZhbHVlKHtsb3c6dC5sb3csaGlnaDp0LmhpZ2gsdW5zaWduZWQ6bz8/ITF9KS50b051bWJlcigpOnR9c3RhdGljIGlzTG9uZyh0KXtyZXR1cm4gV3QuaXNMb25nKHQpfHx0IGluc3RhbmNlb2YgTy5Mb25nfX0sVT1jbGFzcyBhe3N0YXRpYyBzaXplKHQpe3JldHVybiBhLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCwwLHQubGVuZ3RoKX1zdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24odCxvKXtpZihvPDB8fG8+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke299IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGEuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LG8sdC5sZW5ndGgpfXN0YXRpYyBzaXplVG9EaW1lbnNpb24odCxvKXtpZihvPDB8fG8+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke299IGZvciBzaXplVG9EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke3QubGVuZ3RofSBkaW1lbnNpb25zLmApO3JldHVybiBhLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCwwLG8pfXN0YXRpYyBnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsbyxlKXtsZXQgcj0xO2ZvcihsZXQgbj1vO248ZTtuKyspe2lmKHRbbl08PTApdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGdldCB2YWxpZCBzaXplIGZyb20gc3BlY2lmaWVkIGRpbWVuc2lvbiByYW5nZS4gTW9zdCBsaWtlbHkgdGhlIHJhbmdlIGNvbnRhaW5zIDAgb3IgbmVnYXRpdmUgdmFsdWVzIGluIHRoZW0uXCIpO3IqPXRbbl19cmV0dXJuIHJ9c3RhdGljIGNvbXB1dGVTdHJpZGVzKHQpe2xldCBvPXQubGVuZ3RoO2lmKG89PT0wKXJldHVybltdO2lmKG89PT0xKXJldHVyblsxXTtsZXQgZT1uZXcgQXJyYXkobyk7ZVtvLTFdPTEsZVtvLTJdPXRbby0xXTtmb3IobGV0IHI9by0zO3I+PTA7LS1yKWVbcl09ZVtyKzFdKnRbcisxXTtyZXR1cm4gZX1zdGF0aWMgdHJhbnNwb3NlKHQpe3JldHVybiB0LnNsaWNlKCkucmV2ZXJzZSgpfXN0YXRpYyBpbmRpY2VzVG9PZmZzZXQodCxvLGUpe2U9PT12b2lkIDAmJihlPXQubGVuZ3RoKTtsZXQgcj0wO2ZvcihsZXQgbj0wO248ZTsrK24pcis9b1tuXSp0W25dO3JldHVybiByfXN0YXRpYyBvZmZzZXRUb0luZGljZXModCxvKXtsZXQgZT1vLmxlbmd0aDtpZihlPT09MClyZXR1cm5bXTtpZihlPT09MSlyZXR1cm5bdCpvWzBdXTtsZXQgcj1uZXcgQXJyYXkoby5sZW5ndGgpO2ZvcihsZXQgbj0wO248ci5sZW5ndGgtMTsrK24pcltuXT1NYXRoLmZsb29yKHQvb1tuXSksdC09cltuXSpvW25dO3JldHVybiByW3IubGVuZ3RoLTFdPXQscn1zdGF0aWMgbm9ybWFsaXplQXhpcyh0LG8pe2lmKHQ8LW8mJnQ+PW8pdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYXhpcyBmb3IgdGhpcyBvcGVyYXRpb24uXCIpO3JldHVybiB0PDA/dCtvOnR9c3RhdGljIG5vcm1hbGl6ZUF4ZXModCxvKXtyZXR1cm4gdC5tYXAoZT0+dGhpcy5ub3JtYWxpemVBeGlzKGUsbykpfXN0YXRpYyBpbmNyZW1lbnRJbmRleCh0LG8sZSl7aWYoby5sZW5ndGg9PT0wfHx0Lmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggaW5jcmVtZW50aW5nIHVuc3VwcG9ydGVkIGZvciBzY2FsYXIgVGVuc29yXCIpO2lmKGU9PT12b2lkIDApZT1vLmxlbmd0aDtlbHNlIGlmKGU8PTB8fGU+by5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IGF4aXMgdG8gaW5jcmVtZW50IG9uXCIpO2ZvcihsZXQgcj1lLTE7cj49MCYmKHRbcl0rKywhKHRbcl08b1tyXSkpOy0tcil0W3JdPTB9c3RhdGljIGNhbGN1bGF0ZVJlc2hhcGVkRGltcyh0LG8pe2lmKG8ubGVuZ3RoPT09MCl7aWYodC5sZW5ndGg9PT0wfHxhLnNpemUodCk9PT0xKXJldHVybltdO3Rocm93IG5ldyBFcnJvcihcImNhbm5vdCByZXNoYXBlIHRvIGEgc2NhbGFyIFRlbnNvclwiKX1sZXQgZT1vLmxlbmd0aCxyPW5ldyBBcnJheShlKSxuPS0xLHM9MTtmb3IobGV0IHU9MDt1PGU7dSsrKXtpZihvW3VdPC0xKXRocm93IG5ldyBFcnJvcihcImEgZGltZW5zaW9uIGluIHNoYXBlIGhpbnRzIGNhbm5vdCBiZSBsZXNzIHRoYW4gLTFcIik7aWYob1t1XT09PS0xKXtpZihuIT09LTEpdGhyb3cgbmV3IEVycm9yKFwiYXQgbW9zdCBvbmUgZGltZW5zaW9uIGluIHNoYXBlIGhpbnRzIGNhbiBiZSAtMVwiKTtuPXV9ZWxzZXtpZihvW3VdPT09MCl7aWYodT49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGhlIGRpbWVuc2lvbiB3aXRoIHZhbHVlIHplcm8gZXhjZWVkcyB0aGUgZGltZW5zaW9uIHNpemUgb2YgdGhlIGlucHV0IHRlbnNvclwiKTtyW3VdPXRbdV19ZWxzZSByW3VdPW9bdV07cyo9clt1XX19bGV0IGk9YS5zaXplKHQpO2lmKG4hPT0tMSl7aWYoaSVzIT09MCl0aHJvdyBuZXcgRXJyb3IoYHRoZSBpbnB1dCB0ZW5zb3IgY2Fubm90IGJlIHJlc2hhcGVkIHRvIHRoZSByZXF1ZXN0ZWQgc2hhcGUuIElucHV0IHNoYXBlOiBbJHt0fV0gT3V0cHV0IHNoYXBlOiBbJHtvfV1gKTtyW25dPWkvc31lbHNlIGlmKHMhPT1pKXRocm93IG5ldyBFcnJvcihcInJlc2hhcGVkRGltcyBhbmQgb3JpZ2luYWxEaW1zIGRvbid0IGhhdmUgbWF0Y2hpbmcgc2l6ZXNcIik7cmV0dXJuIHJ9c3RhdGljIHNvcnRCYXNlZE9uUGVybSh0LG8pe3JldHVybiBvP28ubWFwKGU9PnRbZV0pOnQuc2xpY2UoKS5yZXZlcnNlKCl9c3RhdGljIHBhZFNoYXBlKHQsbyl7bGV0IGU9dC5sZW5ndGg7cmV0dXJuIHQubWFwKChyLG4pPT5yK29bbl0rb1tuK2VdKX1zdGF0aWMgYXJlRXF1YWwodCxvKXtyZXR1cm4gdC5sZW5ndGghPT1vLmxlbmd0aD8hMTp0LmV2ZXJ5KChlLHIpPT5lPT09b1tyXSl9c3RhdGljIHZhbGlkYXRlRGltc0FuZENhbGNTaXplKHQpe2lmKHQubGVuZ3RoPjYpdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9ubHkgcmFuayAwIHRvIDYgaXMgc3VwcG9ydGVkIGZvciB0ZW5zb3Igc2hhcGUuXCIpO2xldCBvPTE7Zm9yKGxldCBlIG9mIHQpe2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2hhcGU6ICR7ZX0gaXMgbm90IGFuIGludGVnZXJgKTtpZihlPDB8fGU+MjE0NzQ4MzY0Nyl0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNoYXBlOiBsZW5ndGggJHtlfSBpcyBub3QgYWxsb3dlZGApO28qPWV9cmV0dXJuIG99c3RhdGljIGZsYXR0ZW5TaGFwZSh0LG8pe288MCYmKG8rPXQubGVuZ3RoKTtsZXQgZT10LnJlZHVjZSgocyxpKT0+cyppLDEpLHI9dC5zbGljZShvKS5yZWR1Y2UoKHMsaSk9PnMqaSwxKTtyZXR1cm5bZS9yLHJdfXN0YXRpYyBzcXVlZXplU2hhcGUodCxvKXtsZXQgZT1uZXcgQXJyYXk7bz1hLm5vcm1hbGl6ZUF4ZXMobyx0Lmxlbmd0aCk7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspe2xldCBuPW8uaW5kZXhPZihyKT49MDtpZihuJiZ0W3JdIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJzcXVlZXplIGFuIGF4aXMgb2Ygc2l6ZSBkaWZmZXJlbnQgdGhhbiAxXCIpOyhvLmxlbmd0aD09PTAmJnRbcl0+MXx8by5sZW5ndGg+MCYmIW4pJiZlLnB1c2godFtyXSl9cmV0dXJuIGV9c3RhdGljIHVuc3F1ZWV6ZVNoYXBlKHQsbyl7bGV0IGU9bmV3IEFycmF5KHQubGVuZ3RoK28ubGVuZ3RoKTtlLmZpbGwoMCk7Zm9yKGxldCBuPTA7bjxvLmxlbmd0aDtuKyspe2xldCBzPWEubm9ybWFsaXplQXhpcyhvW25dLGUubGVuZ3RoKTtpZihzPj1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCInYXhlcycgaGFzIGFuIG91dCBvZiByYW5nZSBheGlzXCIpO2lmKGVbc10hPT0wKXRocm93IG5ldyBFcnJvcihcIidheGVzJyBoYXMgYSBkdXBsaWNhdGUgYXhpc1wiKTtlW3NdPTF9bGV0IHI9MDtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyllW25dPT09MCYmKGVbbl09dFtyKytdKTtpZihyIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGhlIHVuc3F1ZWV6ZWQgZGltZW5zaW9uIGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZFwiKTtyZXR1cm4gZX19LHVuPWNsYXNzIGF7c3RhdGljIHNwbGl0U2hhcGUodCxvLGUscil7aWYoZS5sZW5ndGg9PT0wKXtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJuZWVkIHRvIGtub3cgbnVtYmVyIG9mIG91dHB1dHMgd2hlbiB0aGUgJ3NwbGl0JyBhdHRyaWJ1dGUgaXMgbm90IHNwZWNpZmllZFwiKTthLmRldGVybWluZVNwbGl0KHRbb10scixlKX1sZXQgbj1bXSxzPVswXTtmb3IobGV0IGk9MDtpPGUubGVuZ3RoOysraSl7aSE9PTAmJnMucHVzaChzW2ktMV0rZVtpLTFdKTtsZXQgdT10LnNsaWNlKCk7dVtvXT1lW2ldLG4ucHVzaCh1KX1yZXR1cm5bbixzXX1zdGF0aWMgZGV0ZXJtaW5lU3BsaXQodCxvLGUpe2lmKHQlbyE9PTApdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHNwbGl0IHRlbnNvciB0byBlcXVhbCBzaXplZCBwYXJ0c1wiKTtmb3IobGV0IHI9MDtyPG87KytyKWUucHVzaCh0L28pfX0sZHI9Y2xhc3MgYXtzdGF0aWMgYWRqdXN0UG9vbEF0dHJpYnV0ZXModCxvLGUscixuLHMpe2lmKCF0JiZlLmxlbmd0aCE9PW8ubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9uc1wiKTtpZih0KWZvcihsZXQgaT0wO2k8by5sZW5ndGgtMjtpKyspaT49ZS5sZW5ndGg/ZS5wdXNoKG9baSsyXSk6ZVtpXT1vW2krMl07Zm9yKGxldCBpPTA7aTxlLmxlbmd0aDtpKyspaWYoaTxyLmxlbmd0aCl7aWYocltpXTwwKXRocm93IG5ldyBFcnJvcihcInN0cmlkZXMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugci5wdXNoKDEpO2ZvcihsZXQgaT0wO2k8ZS5sZW5ndGg7aSsrKWlmKGk8bi5sZW5ndGgpe2lmKG5baV08MCl0aHJvdyBuZXcgRXJyb3IoXCJkaWxhdGlvbnMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugbi5wdXNoKDEpO2ZvcihsZXQgaT0wO2k8ZS5sZW5ndGgqMjtpKyspaWYoaTxzLmxlbmd0aCl7aWYoc1tpXTwwKXRocm93IG5ldyBFcnJvcihcInBhZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBzLnB1c2goMCk7Zm9yKGxldCBpPTA7aTxlLmxlbmd0aDtpKyspe2lmKGVbaV08PTApdGhyb3cgbmV3IEVycm9yKFwia2VybmVsIHNoYXBlcyBuZWVkIHRvIGJlIGdyZWF0ZXIgdGhhbiAwXCIpO2lmKHNbaV0+PWVbaV18fHNbaStlLmxlbmd0aF0+PWVbaV0pdGhyb3cgbmV3IEVycm9yKFwicGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbFwiKX19c3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0LG8sZSxyLG4scyl7aWYocyl7aWYobi5sZW5ndGghPT0yKih0Lmxlbmd0aC0yKSl0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2YgcGFkcyBzaG91bGQgYmUgdHdpY2UgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYoby5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzdHJpZGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZihyLmxlbmd0aCE9PXQubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2ZvcihsZXQgaT0wO2k8dC5sZW5ndGgtMjtpKyspYS5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0W2krMl0sb1tpXSxlW2ldLHJbaV0sbixpLGkrdC5sZW5ndGgtMixzKX19c3RhdGljIGNvbXB1dGVQb29sT3V0cHV0U2hhcGUodCxvLGUscixuLHMsaSl7aWYoby5sZW5ndGg8PTApdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hhcGUgbXVzdCBiZSBvZiBzaXplIGdyZWF0ZXIgdGhhbiAwXCIpO2xldCB1PVtvWzBdLG9bMV1dO3JldHVybiBhLmNvbXB1dGVTaGFwZUhlbHBlcih0LG8sdSxlLHIsbixzLGkpLHV9c3RhdGljIGNvbXB1dGVDb252T3V0cHV0U2hhcGUodCxvLGUscixuLHMsaSl7aWYodC5sZW5ndGg8PTB8fG8ubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXNcIik7bGV0IHU9W3RbMF0sb1swXV07cmV0dXJuIGEuY29tcHV0ZVNoYXBlSGVscGVyKCExLHQsdSxlLHIsbixzLGkpLHV9c3RhdGljIGNvbXB1dGVTaGFwZUhlbHBlcih0LG8sZSxyLG4scyxpLHUpe2lmKHQpZm9yKGxldCBsPTA7bDxvLmxlbmd0aC0yO2wrKyllLnB1c2goMSk7ZWxzZSBmb3IobGV0IGw9MDtsPG8ubGVuZ3RoLTI7bCsrKWUucHVzaChhLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKG9bbCsyXSxyW2xdLG5bbF0sc1tsXSxpLGwsbCtvLmxlbmd0aC0yLHUpKX1zdGF0aWMgYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodCxvLGUscixuLHMsaSx1KXtsZXQgbD1lKihyLTEpKzE7aWYodSYmdSE9PVwiTk9UU0VUXCIpc3dpdGNoKHUpe2Nhc2VcIlZBTElEXCI6cmV0dXJuIG5bc109MCxuW2ldPTAsTWF0aC5mbG9vcigodC1sKS9vKzEpO2Nhc2VcIlNBTUVfTE9XRVJcIjpjYXNlXCJTQU1FX1VQUEVSXCI6aWYoZSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRGlsYXRpb24gbm90IHN1cHBvcnRlZCBmb3IgU0FNRV9VUFBFUiBvciBTQU1FX0xPV0VSXCIpO3tsZXQgcD0oKHQrby0xKS9vLTEpKm8rci10O3JldHVybiBuW3NdPU1hdGguZmxvb3IodT09PVwiU0FNRV9MT1dFUlwiPyhwKzEpLzI6cC8yKSxuW2ldPXAtbltzXSxNYXRoLmZsb29yKCh0K3AtcikvbysxKX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIEF1dG9QYWQgdHlwZVwiKX1lbHNlIHJldHVybiBNYXRoLmZsb29yKCh0K25bc10rbltpXS1sKS9vKzEpfX0saHI9LTM0MDI4MjM0NjYzODUyODg2ZTIyLG1yPTM0MDI4MjM0NjYzODUyODg2ZTIyfSk7ZnVuY3Rpb24gamQoYSl7c3dpdGNoKGEpe2Nhc2VcImJvb2xcIjpjYXNlXCJpbnQ4XCI6Y2FzZVwidWludDhcIjpyZXR1cm4gMTtjYXNlXCJpbnQxNlwiOmNhc2VcInVpbnQxNlwiOnJldHVybiAyO2Nhc2VcImludDMyXCI6Y2FzZVwidWludDMyXCI6Y2FzZVwiZmxvYXQzMlwiOnJldHVybiA0O2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gODtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGNhbGN1bGF0ZSBzaXplb2YoKSBvbiB0eXBlICR7YX1gKX19ZnVuY3Rpb24ga3UoYSl7c3dpdGNoKGEpe2Nhc2UgcmUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpjYXNlIHJlLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpjYXNlIHJlLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDpyZXR1cm4gMTtjYXNlIHJlLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OmNhc2UgcmUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpyZXR1cm4gMjtjYXNlIHJlLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6Y2FzZSByZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOmNhc2UgcmUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6cmV0dXJuIDQ7Y2FzZSByZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0OmNhc2UgcmUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6Y2FzZSByZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm4gODtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGNhbGN1bGF0ZSBzaXplb2YoKSBvbiB0eXBlICR7cmUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVthXX1gKX19ZnVuY3Rpb24gWWQoYSx0KXtyZXR1cm4gbmV3KFJ1KHQpKShhKX1mdW5jdGlvbiBSdShhKXtzd2l0Y2goYSl7Y2FzZVwiYm9vbFwiOmNhc2VcInVpbnQ4XCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gSW50MTZBcnJheTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gSW50MzJBcnJheTtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gVWludDMyQXJyYXk7Y2FzZVwiaW50NjRcIjpyZXR1cm4gQmlnSW50NjRBcnJheTtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIEZsb2F0NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVuc3BlY2lmaWVkIGVycm9yXCIpfX1mdW5jdGlvbiBiaShhLHQpe2lmKHQ9PT1yZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0fHx0PT09bWkuVGVuc29yRGF0YVR5cGUuSU5UNjQpe2lmKGEuZ3JlYXRlclRoYW5PckVxdWFsKDIxNDc0ODM2NDgpfHxhLmxlc3NUaGFuKC0yMTQ3NDgzNjQ4KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW50NjQgaXMgbm90IHN1cHBvcnRlZFwiKX1lbHNlIGlmKHQ9PT1yZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMnx8dD09PW1pLlRlbnNvckRhdGFUeXBlLlVJTlQzMnx8dD09PXJlLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0fHx0PT09bWkuVGVuc29yRGF0YVR5cGUuVUlOVDY0KXtpZihhLmdyZWF0ZXJUaGFuT3JFcXVhbCg0Mjk0OTY3Mjk2KXx8YS5sZXNzVGhhbigwKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwidWludDY0IGlzIG5vdCBzdXBwb3J0ZWRcIil9ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBub3QgYSBMT05HIHR5cGU6ICR7cmUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVt0XX1gKTtyZXR1cm4gYS50b051bWJlcigpfWZ1bmN0aW9uIEJ1KGEsdCxvKXtzd2l0Y2godCl7Y2FzZSByZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6Y2FzZSByZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OnJldHVybiBhLmdldFVpbnQ4KG8pO2Nhc2UgcmUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OnJldHVybiBhLmdldEludDgobyk7Y2FzZSByZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpyZXR1cm4gYS5nZXRVaW50MTYobywhMCk7Y2FzZSByZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2OnJldHVybiBhLmdldEludDE2KG8sITApO2Nhc2UgcmUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpyZXR1cm4gYS5nZXRGbG9hdDMyKG8sITApO2Nhc2UgcmUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpyZXR1cm4gYS5nZXRJbnQzMihvLCEwKTtjYXNlIHJlLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOnJldHVybiBhLmdldFVpbnQzMihvLCEwKTtjYXNlIHJlLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6cmV0dXJuIGJpKFd0LmZyb21CaXRzKGEuZ2V0VWludDMyKG8sITApLGEuZ2V0VWludDMyKG8rNCwhMCksITEpLHQpO2Nhc2UgcmUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6cmV0dXJuIGEuZ2V0RmxvYXQ2NChvLCEwKTtjYXNlIHJlLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0OnJldHVybiBiaShXdC5mcm9tQml0cyhhLmdldFVpbnQzMihvLCEwKSxhLmdldFVpbnQzMihvKzQsITApLCEwKSx0KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlYWQgZnJvbSBEYXRhVmlldyBmb3IgdHlwZSAke3JlLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVbdF19YCl9fXZhciBOdSxyZSxtaSxDZSxicj1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7TnU9RXIoU3MoKSk7ZWkoKTtubigpO3JlPUVyKCRyKCkpO2ZlKCk7bWk9Vy5leHBlcmltZW50YWwuZmJzLENlPWNsYXNzIGF7Y29uc3RydWN0b3IodCxvLGUscixuLHM9TnUuR3VpZC5jcmVhdGUoKSl7dGhpcy5kaW1zPXQ7dGhpcy50eXBlPW87dGhpcy5kYXRhUHJvdmlkZXI9ZTt0aGlzLmFzeW5jRGF0YVByb3ZpZGVyPXI7dGhpcy5jYWNoZT1uO3RoaXMuZGF0YUlkPXM7dGhpcy5zaXplPVUudmFsaWRhdGVEaW1zQW5kQ2FsY1NpemUodCk7bGV0IGk9dGhpcy5zaXplLHU9ZT09PXZvaWQgMCYmcj09PXZvaWQgMCYmbj09PXZvaWQgMDtpZihuIT09dm9pZCAwJiZuLmxlbmd0aCE9PWkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnB1dCBkaW1zIGRvZXNuJ3QgbWF0Y2ggZGF0YSBsZW5ndGguXCIpO2lmKG89PT1cInN0cmluZ1wiKXtpZihuIT09dm9pZCAwJiYoIUFycmF5LmlzQXJyYXkobil8fCFuLmV2ZXJ5KGw9PnR5cGVvZiBsPT1cInN0cmluZ1wiKSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhY2hlIHNob3VsZCBiZSBhIHN0cmluZyBhcnJheVwiKTt1JiYodGhpcy5jYWNoZT1uZXcgQXJyYXkoaSkpfWVsc2V7aWYobiE9PXZvaWQgMCl7bGV0IGw9UnUobyk7aWYoIShuIGluc3RhbmNlb2YgbCkpdGhyb3cgbmV3IFR5cGVFcnJvcihgY2FjaGUgc2hvdWxkIGJlIHR5cGUgJHtsLm5hbWV9YCl9aWYodSl7bGV0IGw9bmV3IEFycmF5QnVmZmVyKGkqamQobykpO3RoaXMuY2FjaGU9WWQobCxvKX19fWdldCBkYXRhKCl7aWYodGhpcy5jYWNoZT09PXZvaWQgMCl7bGV0IHQ9dGhpcy5kYXRhUHJvdmlkZXIodGhpcy5kYXRhSWQpO2lmKHQubGVuZ3RoIT09dGhpcy5zaXplKXRocm93IG5ldyBFcnJvcihcIkxlbmd0aCBvZiBkYXRhIHByb3ZpZGVkIGJ5IHRoZSBEYXRhIFByb3ZpZGVyIGlzIGluY29uc2lzdGVudCB3aXRoIHRoZSBkaW1zIG9mIHRoaXMgVGVuc29yLlwiKTt0aGlzLmNhY2hlPXR9cmV0dXJuIHRoaXMuY2FjaGV9Z2V0IHN0cmluZ0RhdGEoKXtpZih0aGlzLnR5cGUhPT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJkYXRhIHR5cGUgaXMgbm90IHN0cmluZ1wiKTtyZXR1cm4gdGhpcy5kYXRhfWdldCBpbnRlZ2VyRGF0YSgpe3N3aXRjaCh0aGlzLnR5cGUpe2Nhc2VcInVpbnQ4XCI6Y2FzZVwiaW50OFwiOmNhc2VcInVpbnQxNlwiOmNhc2VcImludDE2XCI6Y2FzZVwiaW50MzJcIjpjYXNlXCJ1aW50MzJcIjpjYXNlXCJib29sXCI6cmV0dXJuIHRoaXMuZGF0YTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoXCJkYXRhIHR5cGUgaXMgbm90IGludGVnZXIgKHVpbnQ4LCBpbnQ4LCB1aW50MTYsIGludDE2LCBpbnQzMiwgdWludDMyLCBib29sKVwiKX19Z2V0IGZsb2F0RGF0YSgpe3N3aXRjaCh0aGlzLnR5cGUpe2Nhc2VcImZsb2F0MzJcIjpjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIHRoaXMuZGF0YTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoXCJkYXRhIHR5cGUgaXMgbm90IGZsb2F0IChmbG9hdDMyLCBmbG9hdDY0KVwiKX19Z2V0IG51bWJlckRhdGEoKXtpZih0aGlzLnR5cGUhPT1cInN0cmluZ1wiKXJldHVybiB0aGlzLmRhdGE7dGhyb3cgbmV3IFR5cGVFcnJvcihcInR5cGUgY2Fubm90IGJlIG5vbi1udW1iZXIgKHN0cmluZylcIil9Z2V0KHQpe3JldHVybiB0aGlzLmRhdGFbVS5pbmRpY2VzVG9PZmZzZXQodCx0aGlzLnN0cmlkZXMpXX1zZXQodCxvKXt0aGlzLmRhdGFbVS5pbmRpY2VzVG9PZmZzZXQodCx0aGlzLnN0cmlkZXMpXT1vfWFzeW5jIGdldERhdGEoKXtyZXR1cm4gdGhpcy5jYWNoZT09PXZvaWQgMCYmKHRoaXMuY2FjaGU9YXdhaXQgdGhpcy5hc3luY0RhdGFQcm92aWRlcih0aGlzLmRhdGFJZCkpLHRoaXMuY2FjaGV9Z2V0IHN0cmlkZXMoKXtyZXR1cm4gdGhpcy5fc3RyaWRlc3x8KHRoaXMuX3N0cmlkZXM9VS5jb21wdXRlU3RyaWRlcyh0aGlzLmRpbXMpKSx0aGlzLl9zdHJpZGVzfXN0YXRpYyBmcm9tUHJvdG8odCl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNvbnN0cnVjdCBWYWx1ZSBmcm9tIGFuIGVtcHR5IHRlbnNvclwiKTtsZXQgbz1WZS50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byh0LmRhdGFUeXBlKSxlPVZlLnRlbnNvckRpbXNGcm9tUHJvdG8odC5kaW1zKSxyPW5ldyBhKGUsbyk7aWYobz09PVwic3RyaW5nXCIpdC5zdHJpbmdEYXRhLmZvckVhY2goKG4scyk9PntyLmRhdGFbc109bG4obil9KTtlbHNlIGlmKHQucmF3RGF0YSYmdHlwZW9mIHQucmF3RGF0YS5ieXRlTGVuZ3RoPT1cIm51bWJlclwiJiZ0LnJhd0RhdGEuYnl0ZUxlbmd0aD4wKXtsZXQgbj1yLmRhdGEscz1uZXcgRGF0YVZpZXcodC5yYXdEYXRhLmJ1ZmZlcix0LnJhd0RhdGEuYnl0ZU9mZnNldCx0LnJhd0RhdGEuYnl0ZUxlbmd0aCksaT1rdSh0LmRhdGFUeXBlKSx1PXQucmF3RGF0YS5ieXRlTGVuZ3RoL2k7aWYodC5yYXdEYXRhLmJ5dGVMZW5ndGglaSE9PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBidWZmZXIgbGVuZ3RoXCIpO2lmKG4ubGVuZ3RoIT09dSl0aHJvdyBuZXcgRXJyb3IoXCJidWZmZXIgbGVuZ3RoIG1pc21hdGNoXCIpO2ZvcihsZXQgbD0wO2w8dTtsKyspe2xldCBmPUJ1KHMsdC5kYXRhVHlwZSxsKmkpO25bbF09Zn19ZWxzZXtsZXQgbjtzd2l0Y2godC5kYXRhVHlwZSl7Y2FzZSByZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUOm49dC5mbG9hdERhdGE7YnJlYWs7Y2FzZSByZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOmNhc2UgcmUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpjYXNlIHJlLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OmNhc2UgcmUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OmNhc2UgcmUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpjYXNlIHJlLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDpuPXQuaW50MzJEYXRhO2JyZWFrO2Nhc2UgcmUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDpuPXQuaW50NjREYXRhO2JyZWFrO2Nhc2UgcmUub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6bj10LmRvdWJsZURhdGE7YnJlYWs7Y2FzZSByZS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjpjYXNlIHJlLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0Om49dC51aW50NjREYXRhO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwidW5zcGVjaWZpYyBlcnJvclwiKX1pZihuPT1udWxsKXRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBwb3B1bGF0ZSBkYXRhIGZyb20gYSB0ZW5zb3Jwcm90byB2YWx1ZVwiKTtsZXQgcz1yLmRhdGE7aWYocy5sZW5ndGghPT1uLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBsZW5ndGggbWlzbWF0Y2hcIik7Zm9yKGxldCBpPTA7aTxuLmxlbmd0aDtpKyspe2xldCB1PW5baV07V3QuaXNMb25nKHUpP3NbaV09YmkodSx0LmRhdGFUeXBlKTpzW2ldPXV9fXJldHVybiByfXN0YXRpYyBmcm9tRGF0YSh0LG8sZSl7cmV0dXJuIG5ldyBhKG8sZSx2b2lkIDAsdm9pZCAwLHQpfXN0YXRpYyBmcm9tT3J0VGVuc29yKHQpe2lmKCF0KXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBjb25zdHJ1Y3QgVmFsdWUgZnJvbSBhbiBlbXB0eSB0ZW5zb3JcIik7bGV0IG89VmUudGVuc29yRGltc0Zyb21PUlRGb3JtYXQodCksZT1WZS50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byh0LmRhdGFUeXBlKCkpLHI9bmV3IGEobyxlKTtpZihlPT09XCJzdHJpbmdcIilmb3IobGV0IG49MDtuPHQuc3RyaW5nRGF0YUxlbmd0aCgpO24rKylyLmRhdGFbbl09dC5zdHJpbmdEYXRhKG4pO2Vsc2UgaWYodC5yYXdEYXRhQXJyYXkoKSYmdHlwZW9mIHQucmF3RGF0YUxlbmd0aCgpPT1cIm51bWJlclwiJiZ0LnJhd0RhdGFMZW5ndGgoKT4wKXtsZXQgbj1yLmRhdGEscz1uZXcgRGF0YVZpZXcodC5yYXdEYXRhQXJyYXkoKS5idWZmZXIsdC5yYXdEYXRhQXJyYXkoKS5ieXRlT2Zmc2V0LHQucmF3RGF0YUxlbmd0aCgpKSxpPWt1KHQuZGF0YVR5cGUoKSksdT10LnJhd0RhdGFMZW5ndGgoKS9pO2lmKHQucmF3RGF0YUxlbmd0aCgpJWkhPT0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYnVmZmVyIGxlbmd0aFwiKTtpZihuLmxlbmd0aCE9PXUpdGhyb3cgbmV3IEVycm9yKFwiYnVmZmVyIGxlbmd0aCBtaXNtYXRjaFwiKTtmb3IobGV0IGw9MDtsPHU7bCsrKXtsZXQgZj1CdShzLHQuZGF0YVR5cGUoKSxsKmkpO25bbF09Zn19cmV0dXJuIHJ9fX0pO2Z1bmN0aW9uIHEoYSl7cmV0dXJuIGE9PT0xP1hkOktkfWZ1bmN0aW9uIE11KGEpe2xldCB0PXEoYSk7cmV0dXJuYCR7dC52ZXJzaW9ufVxuICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICAgJHt0LmF0dHJpYnV0ZX0gdmVjMyBwb3NpdGlvbjtcbiAgICAgICR7dC5hdHRyaWJ1dGV9IHZlYzIgdGV4dHVyZUNvb3JkO1xuXG4gICAgICAke3QudmFyeWluZ1ZlcnRleH0gdmVjMiBUZXhDb29yZHM7XG5cbiAgICAgIHZvaWQgbWFpbigpXG4gICAgICB7XG4gICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAxLjApO1xuICAgICAgICAgIFRleENvb3JkcyA9IHRleHR1cmVDb29yZDtcbiAgICAgIH1gfWZ1bmN0aW9uIEd1KGEpe2xldCB0PXEoYSk7cmV0dXJuYCR7dC52ZXJzaW9ufVxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICBwcmVjaXNpb24gaGlnaHAgaW50O1xuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG4gICAgJHt0LnZhcnlpbmdGcmFnfSB2ZWMyIFRleENvb3JkcztcbiAgICAke3Qub3V0cHV0RGVjbGFyYXRpb259XG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcblxuICAgIC8vIEN1c3RvbSB2ZWN0b3IgdHlwZXMgdG8gaGFuZGxlIGhpZ2hlciBkaW1lbmFsaXRpZXMuXG4gICAgc3RydWN0IGl2ZWM1XG4gICAge1xuICAgICAgaW50IHg7XG4gICAgICBpbnQgeTtcbiAgICAgIGludCB6O1xuICAgICAgaW50IHc7XG4gICAgICBpbnQgdTtcbiAgICB9O1xuXG4gICAgc3RydWN0IGl2ZWM2XG4gICAge1xuICAgICAgaW50IHg7XG4gICAgICBpbnQgeTtcbiAgICAgIGludCB6O1xuICAgICAgaW50IHc7XG4gICAgICBpbnQgdTtcbiAgICAgIGludCB2O1xuICAgIH07XG5cbiAgICBpbnQgaW1vZChpbnQgeCwgaW50IHkpIHtcbiAgICAgIHJldHVybiB4IC0geSAqICh4IC8geSk7XG4gICAgfVxuXG4gICAgYH1mdW5jdGlvbiBVdShhLHQpe2xldCBvPXEoYSk7cmV0dXJuYFxuICB2b2lkIG1haW4oKSB7XG4gICAgaW50IGluZGljZXNbJHt0fV07XG4gICAgdG9WZWMoVGV4Q29vcmRzLCBpbmRpY2VzKTtcbiAgICB2ZWM0IHJlc3VsdCA9IHZlYzQocHJvY2VzcyhpbmRpY2VzKSk7XG4gICAgJHtvLm91dHB1dH0gPSByZXN1bHQ7XG4gIH1cbiAgYH12YXIgWGQsS2QseGU9RSgoKT0+e1widXNlIHN0cmljdFwiO1hkPXt2ZXJzaW9uOlwiXCIsYXR0cmlidXRlOlwiYXR0cmlidXRlXCIsdmFyeWluZ1ZlcnRleDpcInZhcnlpbmdcIix2YXJ5aW5nRnJhZzpcInZhcnlpbmdcIix0ZXh0dXJlMkQ6XCJ0ZXh0dXJlMkRcIixvdXRwdXQ6XCJnbF9GcmFnQ29sb3JcIixvdXRwdXREZWNsYXJhdGlvbjpcIlwifSxLZD17dmVyc2lvbjpcIiN2ZXJzaW9uIDMwMCBlc1wiLGF0dHJpYnV0ZTpcImluXCIsdmFyeWluZ1ZlcnRleDpcIm91dFwiLHZhcnlpbmdGcmFnOlwiaW5cIix0ZXh0dXJlMkQ6XCJ0ZXh0dXJlXCIsb3V0cHV0Olwib3V0cHV0Q29sb3JcIixvdXRwdXREZWNsYXJhdGlvbjpcIm91dCB2ZWM0IG91dHB1dENvbG9yO1wifX0pO3ZhciBhZT1FKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTthc3luYyBmdW5jdGlvbiBnaShhLHQ9ZT0+MCxvKXtyZXR1cm4gbmV3IFByb21pc2UoKGUscik9PntsZXQgbj0wLHM9KCk9PntpZihhKCkpe2UoKTtyZXR1cm59bisrO2xldCBpPXQobik7aWYobyE9bnVsbCYmbj49byl7cigpO3JldHVybn1zZXRUaW1lb3V0KHMsaSl9O3MoKX0pfWZ1bmN0aW9uIEtuKGEpe3JldHVybiBrcih0eXBlb2YgYTxcInVcIiYmYS5sZW5ndGghPT0wLCgpPT5cImVtcHR5IHN0cmluZyBmb3VuZCBmb3Igc2FtcGxlciBuYW1lXCIpLFwiZ2V0XCIrYS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSthLnNsaWNlKDEpfWZ1bmN0aW9uIHp1KGEpe3JldHVybiBrcih0eXBlb2YgYTxcInVcIiYmYS5sZW5ndGghPT0wLCgpPT5cImVtcHR5IHN0cmluZyBmb3VuZCBmb3Igc2FtcGxlciBuYW1lXCIpLFwiZ2V0XCIrYS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSthLnNsaWNlKDEpK1wiQXRPdXRDb29yZHNcIn1mdW5jdGlvbiBCcihhLHQpe2xldCBvPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYSkpO3JldHVybiBvPXQsb31mdW5jdGlvbiBOcihhLHQpe3JldHVybiB0Lm1hcChvPT5hW29dKS5qb2luKFwiLCBcIil9ZnVuY3Rpb24gSmUoYSl7aWYoYTw9MSlyZXR1cm5cImludFwiO2lmKGE9PT0yKXJldHVyblwiaXZlYzJcIjtpZihhPT09MylyZXR1cm5cIml2ZWMzXCI7aWYoYT09PTQpcmV0dXJuXCJpdmVjNFwiO2lmKGE9PT01KXJldHVyblwiaXZlYzVcIjtpZihhPT09NilyZXR1cm5cIml2ZWM2XCI7dGhyb3cgRXJyb3IoYEdQVSBmb3IgcmFuayAke2F9IGlzIG5vdCB5ZXQgc3VwcG9ydGVkYCl9ZnVuY3Rpb24gT3QoYT02KXtyZXR1cm5bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdLnNsaWNlKDAsYSl9dmFyIGt0PUUoKCk9PntcInVzZSBzdHJpY3RcIjtmZSgpfSk7ZnVuY3Rpb24gSmQoYSx0KXtyZXR1cm4gT3QodCkubWFwKG89PmAke2F9LiR7b31gKX1mdW5jdGlvbiBScihhLHQpe3JldHVybiB0PT09MT9bYV06SmQoYSx0KX1mdW5jdGlvbiBCdCgpe3JldHVybmBcbiAgICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgaW50IGRpbSkge1xuICAgICAgaW50IG1vZENvb3JkID0gaW1vZChkaW0sIDIpO1xuICAgICAgcmV0dXJuIG1vZENvb3JkID09IDAgPyBmcmFnLnIgOiBmcmFnLmc7XG4gICAgfVxuXG4gICAgZmxvYXQgZ2V0Q2hhbm5lbCh2ZWM0IGZyYWcsIHZlYzIgaW5uZXJEaW1zKSB7XG4gICAgICB2ZWMyIG1vZENvb3JkID0gbW9kKGlubmVyRGltcywgMi4pO1xuICAgICAgcmV0dXJuIG1vZENvb3JkLnggPT0gMC4gP1xuICAgICAgICAobW9kQ29vcmQueSA9PSAwLiA/IGZyYWcuciA6IGZyYWcuZykgOlxuICAgICAgICAobW9kQ29vcmQueSA9PSAwLiA/IGZyYWcuYiA6IGZyYWcuYSk7XG4gICAgfVxuICBgfXZhciBncj1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7a3QoKX0pO2Z1bmN0aW9uIFFkKGEsdCxvKXtpZihhPT09MClyZXR1cm5cImZhbHNlXCI7aWYoYT09PTEpcmV0dXJuYHJjID4gJHt0WzBdfWA7bGV0IGU9XCJcIjtmb3IobGV0IHI9YS0yO3I8YTtyKyspZSs9YCR7b1tyXX0gPj0gJHt0W3ItYSsyXX1gLHI8YS0xJiYoZSs9XCJ8fFwiKTtyZXR1cm4gZX1mdW5jdGlvbiBlaChhLHQpe2xldCBvPWEubGVuZ3RoO2lmKG89PT0wKXJldHVyblwiZ2V0QSgpLCAwLCAwLCAwXCI7aWYobz09PTEpcmV0dXJuYGdldEEocmMpLFxuICAgICAgICAgICAgcmMgKyAxID49ICR7YVswXX0gPyAwLiA6IGdldEEocmMgKyAxKSxcbiAgICAgICAgICAgIDAsIDBgO2xldCBlPVwiciwgY1wiLHI9XCJyLCBjcDFcIixuPVwicnAxLCBjXCIscz1cInJwMSwgY3AxXCIsaT1cIlwiO2lmKG8+Milmb3IobGV0IHU9MDt1PG8tMjsrK3UpaT1pK2Ake3RbdV19LGA7cmV0dXJuYGdldEEoJHtpfSR7ZX0pLFxuICAgICAgICAgIHJFZGdlID8gMC4gOiBnZXRBKCR7aX0ke259KSxcbiAgICAgICAgICBjRWRnZSA/IDAuIDogZ2V0QSgke2l9JHtyfSksXG4gICAgICAgICAgckVkZ2UgfHwgY0VkZ2UgPyAwLiA6IGdldEEoJHtpfSR7c30pYH1mdW5jdGlvbiB0aChhLHQsbyxlKXtyZXR1cm4gYT09PTB8fGE9PT0xP1wiXCI6YFxuICAgIGludCByID0gJHt0W2EtMl19O1xuICAgIGludCBjID0gJHt0W2EtMV19O1xuICAgIGludCBycDEgPSAke3RbYS0yXX0gKyAxO1xuICAgIGludCBjcDEgPSAke3RbYS0xXX0gKyAxO1xuICAgIGJvb2wgckVkZ2UgPSBycDEgPj0gJHtlfTtcbiAgICBib29sIGNFZGdlID0gY3AxID49ICR7b307XG4gICAgYH12YXIgVnUsWmQsV3UsSHU9RSgoKT0+e1widXNlIHN0cmljdFwiO3hlKCk7YWUoKTtrdCgpO2dyKCk7VnU9e25hbWU6XCJwYWNrXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6WzFdfSxaZD0oYSx0KT0+e2xldCBvPXEoYS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLGU9dC5kaW1zLHI9ZS5sZW5ndGgsbj10LmRpbXMubGVuZ3RoLHM9SmUobiksaT1ScihcInJjXCIsbiksdT10aChuLGksZVtlLmxlbmd0aC0yXSxlW2UubGVuZ3RoLTFdKSxsO3I9PT0wP2w9WzEsMV06cj09PTE/bD1bZVswXSwxXTpsPVtlW24tMV0sZVtuLTJdXTtsZXQgZj1RZChuLGwsaSkscD1laChlLGkpLGQ9YFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgJHtzfSByYyA9IGdldE91dHB1dENvb3JkcygpO1xuXG4gICAgICAgICAgaWYoJHtmfSkge1xuICAgICAgICAgICAgJHtvLm91dHB1dH0gPSB2ZWM0KDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAke3V9XG5cbiAgICAgICAgICAgICR7by5vdXRwdXR9ID0gdmVjNCgke3B9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGA7cmV0dXJuey4uLlZ1LGhhc01haW46ITAsb3V0cHV0OntkaW1zOnQuZGltcyx0eXBlOnQudHlwZSx0ZXh0dXJlVHlwZToyfSxzaGFkZXJTb3VyY2U6ZH19LFd1PShhLHQpPT4oey4uLlZ1LGdldDooKT0+WmQoYSx0KX0pfSk7ZnVuY3Rpb24geWkoYSl7aWYoYS5sZW5ndGg9PT0wKXJldHVyblsxLDEsMV07bGV0IHQ9MTtmb3IobGV0IG89MDtvPGEubGVuZ3RoLTI7KytvKXQqPWFbb107cmV0dXJuW3QsYS5sZW5ndGg+MT9hW2EubGVuZ3RoLTJdOjEsYVthLmxlbmd0aC0xXV19ZnVuY3Rpb24ganUoYSx0KXtsZXQgbz0hMTtyZXR1cm4gYS5sZW5ndGg9PT0wfHx0Lmxlbmd0aD09PTA/bz0hMDphLmxlbmd0aDwyfHx0Lmxlbmd0aDwyP289YVthLmxlbmd0aC0xXT09PXRbdC5sZW5ndGgtMV06bz1hW2EubGVuZ3RoLTFdPT09dFt0Lmxlbmd0aC0xXSYmYVthLmxlbmd0aC0yXT09PXRbdC5sZW5ndGgtMl0sb31mdW5jdGlvbiBvaChhKXtsZXQgdD1VLmNvbXB1dGVTdHJpZGVzKGEpLG89W1wiYlwiLFwiclwiLFwiY1wiXSxlPVwiaW5kZXhcIjtyZXR1cm5gXG4gICAgaXZlYzMgaW5wdXRDb29yZHNGcm9tUmVzaGFwZWRPdXRDb29yZHMoaW50IGluZGV4KSB7XG4gICAgICAke3QubWFwKChuLHMpPT57bGV0IGk9YGludCAke29bc119ID0gJHtlfSAvICR7bn1gLHU9cz09PXQubGVuZ3RoLTE/YGludCAke29bcysxXX0gPSAke2V9IC0gJHtvW3NdfSAqICR7bn1gOmBpbmRleCAtPSAke29bc119ICogJHtufWA7cmV0dXJuYCR7aX07ICR7dX07YH0pLmpvaW4oXCJcIil9XG4gICAgICByZXR1cm4gaXZlYzMoYiwgciwgYyk7XG4gICAgfVxuICBgfWZ1bmN0aW9uIGloKGEpe2xldCB0PVUuY29tcHV0ZVN0cmlkZXMoYSk7cmV0dXJuYFxuICBpbnQgZ2V0RmxhdHRlbmVkSW5kZXgoaXZlYzMgY29vcmRzKSB7XG4gICAgLy8gcmV2ZXJzZSB5LCB6IG9yZGVyXG4gICAgcmV0dXJuIGNvb3Jkcy54ICogJHt0WzBdfSArIGNvb3Jkcy56ICogJHt0WzFdfSArIGNvb3Jkcy55O1xuICB9XG5gfXZhciByaCxuaCxxdSxZdT1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZmUoKTt4ZSgpO2FlKCk7Z3IoKTtyaD1hPT4oe25hbWU6XCJSZXNoYXBlIChwYWNrZWQpXCIsaW5wdXRUeXBlczpbMl0saW5wdXROYW1lczpbXCJBXCJdLGNhY2hlSGludDpgJHthfWB9KSxuaD0oYSx0LG8sZSk9PntsZXQgcj10LmRpbXMsbj1lLHM9XCJcIjtmb3IobGV0IGw9MDtsPDQ7bCsrKXtsZXQgZj1cIlwiO3N3aXRjaChsKXtjYXNlIDA6Zj1cIm91dHB1dENvb3JkcyA9IHJjO1wiO2JyZWFrO2Nhc2UgMTpmPVwib3V0cHV0Q29vcmRzID0gaXZlYzMocmMueCwgcmMueSsxLCByYy56KTtcIjticmVhaztjYXNlIDI6Zj1cIm91dHB1dENvb3JkcyA9IGl2ZWMzKHJjLngsIHJjLnksIHJjLnorMSk7XCI7YnJlYWs7Y2FzZSAzOmY9XCJvdXRwdXRDb29yZHMgPSBpdmVjMyhyYy54LCByYy55KzEsIHJjLnorMSk7XCI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3J9cys9YFxuICAgICAgICAke2Z9XG4gICAgICAgICR7bD4wP1wiaWYob3V0cHV0Q29vcmRzLnkgPCByb3dzICYmIG91dHB1dENvb3Jkcy56IDwgY29scyl7XCI6XCJcIn1cbiAgICAgICAgICBpbnQgZmxhdHRlbmVkSW5kZXggPSBnZXRGbGF0dGVuZWRJbmRleChvdXRwdXRDb29yZHMpO1xuXG4gICAgICAgICAgaXZlYzMgaW5wdXRSQyA9IGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGZsYXR0ZW5lZEluZGV4KTtcbiAgICAgICAgICB2ZWMyIGlubmVyRGltcyA9IHZlYzIoZmxvYXQoaW5wdXRSQy55KSxmbG9hdChpbnB1dFJDLnopKTtcblxuICAgICAgICAgIHJlc3VsdFske2x9XSA9IGdldENoYW5uZWwoZ2V0QShpbnB1dFJDLngsIGlucHV0UkMueSwgaW5wdXRSQy56KSwgaW5uZXJEaW1zKTtcblxuICAgICAgICAke2w+MD9cIn1cIjpcIlwifVxuICAgICAgYH1sZXQgaT1xKGEuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx1PWBcbiAgICAgICR7b2gocil9XG4gICAgICAke2loKG4pfVxuICAgICAgJHtCdCgpfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMzIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG5cbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuMCk7XG5cbiAgICAgICAgaXZlYzMgb3V0cHV0Q29vcmRzO1xuICAgICAgICBpbnQgcm93cyA9ICR7blsyXX07XG4gICAgICAgIGludCBjb2xzID0gJHtuWzFdfTtcblxuICAgICAgICAke3N9XG4gICAgICAgICR7aS5vdXRwdXR9ID0gcmVzdWx0O1xuICAgICAgfVxuICAgIGA7cmV0dXJuey4uLm8sb3V0cHV0OntkaW1zOm4sdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6Mn0sc2hhZGVyU291cmNlOnUsaGFzTWFpbjohMH19LHF1PShhLHQsbyk9PntsZXQgZT1yaChvKTtyZXR1cm57Li4uZSxnZXQ6KCk9Pm5oKGEsdCxlLG8pfX19KTt2YXIgVGksWHU9RSgoKT0+e1widXNlIHN0cmljdFwiO3hlKCk7YWUoKTtUaT0oYSx0KT0+e2xldCBvPXQuc2hhcGUsZT1xKGEuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxyPWBcbiAgICBjb25zdCBmbG9hdCBGTE9BVF9NQVggPSAxLjcwMTQxMTg0ZTM4O1xuICAgIGNvbnN0IGZsb2F0IEZMT0FUX01JTiA9IDEuMTc1NDk0MzVlLTM4O1xuXG4gICAgYm9vbCBpc05hTihmbG9hdCB2YWwpIHtcbiAgICAgIHJldHVybiAodmFsIDwgMS4wIHx8IDAuMCA8IHZhbCB8fCB2YWwgPT0gMC4wKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9XG5cbiAgICBoaWdocCB2ZWM0IGVuY29kZUFzVWludDgoaGlnaHAgZmxvYXQgdikge1xuICAgICAgaWYgKGlzTmFOKHYpKSB7XG4gICAgICAgIHJldHVybiB2ZWM0KDI1NSwgMjU1LCAyNTUsIDI1NSk7XG4gICAgICB9XG5cbiAgICAgIGhpZ2hwIGZsb2F0IGF2ID0gYWJzKHYpO1xuXG4gICAgICBpZihhdiA8IEZMT0FUX01JTikge1xuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgfSBlbHNlIGlmKHYgPiBGTE9BVF9NQVgpIHtcbiAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsIDEyOC4wLCAxMjcuMCkgLyAyNTUuMDtcbiAgICAgIH0gZWxzZSBpZih2IDwgLUZMT0FUX01BWCkge1xuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgIDEyOC4wLCAyNTUuMCkgLyAyNTUuMDtcbiAgICAgIH1cblxuICAgICAgaGlnaHAgdmVjNCBjID0gdmVjNCgwLDAsMCwwKTtcblxuICAgICAgaGlnaHAgZmxvYXQgZSA9IGZsb29yKGxvZzIoYXYpKTtcbiAgICAgIGhpZ2hwIGZsb2F0IG0gPSBleHAyKGZyYWN0KGxvZzIoYXYpKSkgLSAxLjA7XG5cbiAgICAgIGNbMl0gPSBmbG9vcigxMjguMCAqIG0pO1xuICAgICAgbSAtPSBjWzJdIC8gMTI4LjA7XG4gICAgICBjWzFdID0gZmxvb3IoMzI3NjguMCAqIG0pO1xuICAgICAgbSAtPSBjWzFdIC8gMzI3NjguMDtcbiAgICAgIGNbMF0gPSBmbG9vcig4Mzg4NjA4LjAgKiBtKTtcblxuICAgICAgaGlnaHAgZmxvYXQgZWJpYXMgPSBlICsgMTI3LjA7XG4gICAgICBjWzNdID0gZmxvb3IoZWJpYXMgLyAyLjApO1xuICAgICAgZWJpYXMgLT0gY1szXSAqIDIuMDtcbiAgICAgIGNbMl0gKz0gZmxvb3IoZWJpYXMpICogMTI4LjA7XG5cbiAgICAgIGNbM10gKz0gMTI4LjAgKiBzdGVwKDAuMCwgLXYpO1xuXG4gICAgICByZXR1cm4gYyAvIDI1NS4wO1xuICAgIH1cblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIGZsb2F0IHZhbHVlID0gJHtlLnRleHR1cmUyRH0oWCxUZXhDb29yZHMpLnI7XG4gICAgICAke2Uub3V0cHV0fSA9IGVuY29kZUFzVWludDgodmFsdWUpO1xuICAgIH1gLG49e25hbWU6XCJVaW50OEVuY29kZVwiLGlucHV0VHlwZXM6WzBdLGlucHV0TmFtZXM6W1wiWFwiXSxvdXRwdXQ6e2RpbXM6byx0eXBlOnQudGVuc29yLnR5cGUsdGV4dHVyZVR5cGU6M30sc2hhZGVyU291cmNlOnIsaGFzTWFpbjohMH07cmV0dXJuIGEuZXhlY3V0ZVByb2dyYW0obixbdC50ZW5zb3JdKX19KTtmdW5jdGlvbiBzaChhLHQpe2lmKGE9PT0xKXJldHVyblwicmNcIjtsZXQgbz1cIlwiO2ZvcihsZXQgZT0wO2U8YTtlKyspbys9dFtlXSxlPGEtMSYmKG8rPVwiLFwiKTtyZXR1cm4gb312YXIgS3UsYWgsSnUsWnU9RSgoKT0+e1widXNlIHN0cmljdFwiO3hlKCk7YWUoKTtrdCgpO2dyKCk7S3U9e25hbWU6XCJ1bnBhY2tcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbMl19LGFoPShhLHQpPT57bGV0IG89dC5kaW1zLmxlbmd0aCxlPVJyKFwicmNcIixvKSxyPWUuc2xpY2UoLTIpLG49SmUobykscz1CdCgpLHU9dC5kaW1zLmxlbmd0aD09PTA/XCJcIjpzaChvLGUpLGw9bzw9MT9cInJjXCI6YHZlYzIoJHtyLmpvaW4oXCIsXCIpfSlgLGY9cShhLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbikscD1gXG4gICAgJHtzfVxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICR7bn0gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcblxuICAgICAgIC8vIFNhbXBsZSB0aGUgdGV4dHVyZSB3aXRoIHRoZSBjb29yZHMgdG8gZ2V0IHRoZSByZ2JhIGNoYW5uZWwgdmFsdWUuXG4gICAgICAgdmVjNCBwYWNrZWRJbnB1dCA9IGdldEEoJHt1fSk7XG5cbiAgICAgICAke2Yub3V0cHV0fSA9IHZlYzQoZ2V0Q2hhbm5lbChwYWNrZWRJbnB1dCwgJHtsfSksIDAsIDAsIDApO1xuICAgICB9XG4gICBgO3JldHVybnsuLi5LdSxoYXNNYWluOiEwLG91dHB1dDp7ZGltczp0LmRpbXMsdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6MH0sc2hhZGVyU291cmNlOnB9fSxKdT0oYSx0KT0+KHsuLi5LdSxnZXQ6KCk9PmFoKGEsdCl9KX0pO3ZhciBKbixmbixabixjbj1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YXQoKTtKbj1jbGFzc3tjb25zdHJ1Y3Rvcih0LG89MSl7aWYobz09PTEpdGhpcy5pbnRlcm5hbEZvcm1hdD10LlIzMkYsdGhpcy5mb3JtYXQ9dC5SRUQsdGhpcy50ZXh0dXJlVHlwZT10LkZMT0FULHRoaXMuY2hhbm5lbFNpemU9bztlbHNlIGlmKG89PT00KXRoaXMuaW50ZXJuYWxGb3JtYXQ9dC5SR0JBMzJGLHRoaXMuZm9ybWF0PXQuUkdCQSx0aGlzLnRleHR1cmVUeXBlPXQuRkxPQVQsdGhpcy5jaGFubmVsU2l6ZT1vO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHtvfWApfWVuY29kZSh0LG8pe2xldCBlLHI7cmV0dXJuIHQuY29uc3RydWN0b3IhPT1GbG9hdDMyQXJyYXkmJihjZS53YXJuaW5nKFwiRW5jb2RlclwiLFwiZGF0YSB3YXMgbm90IG9mIHR5cGUgRmxvYXQzMjsgY3JlYXRpbmcgbmV3IEZsb2F0MzJBcnJheVwiKSxyPW5ldyBGbG9hdDMyQXJyYXkodCkpLG8qdGhpcy5jaGFubmVsU2l6ZT50Lmxlbmd0aD8oY2Uud2FybmluZyhcIkVuY29kZXJcIixcIlNvdXJjZSBkYXRhIHRvbyBzbWFsbC4gQWxsb2NhdGluZyBsYXJnZXIgYXJyYXlcIikscj10LGU9dGhpcy5hbGxvY2F0ZShvKnRoaXMuY2hhbm5lbFNpemUpLHIuZm9yRWFjaCgobixzKT0+ZVtzXT1uKSk6KHI9dCxlPXIpLGV9YWxsb2NhdGUodCl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodCo0KX1kZWNvZGUodCxvKXtyZXR1cm4gdGhpcy5jaGFubmVsU2l6ZT09PTE/dC5maWx0ZXIoKHIsbik9Pm4lND09PTApLnN1YmFycmF5KDAsbyk6dC5zdWJhcnJheSgwLG8pfX0sZm49Y2xhc3N7Y29uc3RydWN0b3IodCxvPTEsZSl7aWYobyE9PTEmJm8hPT00KXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7b31gKTt0aGlzLmludGVybmFsRm9ybWF0PXQuUkdCQSx0aGlzLmZvcm1hdD10LlJHQkEsdGhpcy5jaGFubmVsU2l6ZT1vLHRoaXMudGV4dHVyZVR5cGU9ZXx8dC5GTE9BVH1lbmNvZGUodCxvKXtsZXQgZT10O3JldHVybiB0aGlzLmNoYW5uZWxTaXplPT09MSYmKGNlLnZlcmJvc2UoXCJFbmNvZGVyXCIsXCJFeHBsb2RpbmcgaW50byBhIGxhcmdlciBhcnJheVwiKSxlPXRoaXMuYWxsb2NhdGUobyksdC5mb3JFYWNoKChyLG4pPT5lW24qNF09cikpLGV9YWxsb2NhdGUodCl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodCo0KX1kZWNvZGUodCxvKXtyZXR1cm4gdGhpcy5jaGFubmVsU2l6ZT09PTE/dC5maWx0ZXIoKHIsbik9Pm4lND09PTApLnN1YmFycmF5KDAsbyk6dC5zdWJhcnJheSgwLG8pfX0sWm49Y2xhc3N7Y29uc3RydWN0b3IodCxvPTEpe3RoaXMuY2hhbm5lbFNpemU9NDtpZihvPT09MSl0aGlzLmludGVybmFsRm9ybWF0PXQuQUxQSEEsdGhpcy5mb3JtYXQ9dC5BTFBIQSx0aGlzLnRleHR1cmVUeXBlPXQuVU5TSUdORURfQllURSx0aGlzLmNoYW5uZWxTaXplPW87ZWxzZSBpZihvPT09NCl0aGlzLmludGVybmFsRm9ybWF0PXQuUkdCQSx0aGlzLmZvcm1hdD10LlJHQkEsdGhpcy50ZXh0dXJlVHlwZT10LlVOU0lHTkVEX0JZVEUsdGhpcy5jaGFubmVsU2l6ZT1vO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHtvfWApfWVuY29kZSh0LG8pe3JldHVybiBuZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlTGVuZ3RoKX1hbGxvY2F0ZSh0KXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodCp0aGlzLmNoYW5uZWxTaXplKX1kZWNvZGUodCxvKXtpZih0IGluc3RhbmNlb2YgVWludDhBcnJheSlyZXR1cm4gdC5zdWJhcnJheSgwLG8pO3Rocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcnJheSB0eXBlOiAke3QuY29uc3RydWN0b3J9YCl9fX0pO3ZhciBwbixRdSx4aSxlbD1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZmUoKTthZSgpO3BuPShhLHQsbyk9PntsZXQgZT1vPT09MHx8bz09PTE/MTo0LHI9bz09PTIsbj1vPT09MXx8bz09PTIscz1vPT09ND90Lmxlbmd0aC0xOnZvaWQgMCxpPW89PT00P3QubWFwKCh1LGwpPT5sPT09dC5sZW5ndGgtMT91KjQ6dSk6dm9pZCAwO3JldHVybiB4aShhLHQsZSxpLHtpc1BhY2tlZDpyLHJldmVyc2VXSDpuLGJyZWFrQXhpczpzfSl9LFF1PShhLHQsbyk9PntsZXQgZT1wbihhLHQsbyk7cmV0dXJuW2Uud2lkdGgsZS5oZWlnaHRdfSx4aT0oYSx0LG89MSxlLHIpPT57bGV0IG49ISEociYmci5pc1BhY2tlZCksW3MsaV09YS5jb21wdXRlVGV4dHVyZVdIKG4mJmV8fHQsciksdT10Lmxlbmd0aCxsPXQuc2xpY2UoMCk7aWYodT09PTAmJihsPVsxXSksbz09PTEpZT10O2Vsc2UgaWYobil7aWYobyE9PTQpdGhyb3cgbmV3IEVycm9yKFwiYSBwYWNrZWQgdGV4dHVyZSBtdXN0IGJlIDQtY2hhbm5lbFwiKTtlPXQsdT4wJiYobFt1LTFdPU1hdGguY2VpbChsW3UtMV0vMikpLHU+MSYmKGxbdS0yXT1NYXRoLmNlaWwobFt1LTJdLzIpKX1lbHNlIGlmKCFlKXRocm93IG5ldyBFcnJvcihcIlVucGFja2VkIHNoYXBlIGlzIG5lZWRlZCB3aGVuIHVzaW5nIGNoYW5uZWxzID4gMVwiKTtyZXR1cm57d2lkdGg6cyxoZWlnaHQ6aSxjaGFubmVsczpvLGlzUGFja2VkOm4sc2hhcGU6bCxzdHJpZGVzOlUuY29tcHV0ZVN0cmlkZXMobCksdW5wYWNrZWRTaGFwZTplLHJldmVyc2VkV0g6ciYmci5yZXZlcnNlV0h9fX0pO3ZhciBsaCxRbixybD1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YXQoKTticigpO2ZlKCk7SHUoKTtZdSgpO1h1KCk7WnUoKTtjbigpO2VsKCk7YWUoKTtsaD0oYSx0KT0+e2xldCBvPXQubWFwKHI9PmAke3IudW5wYWNrZWRTaGFwZS5qb2luKFwiLFwiKX07JHtyLndpZHRofXgke3IuaGVpZ2h0fWApLmpvaW4oXCJfXCIpLGU9YS5uYW1lO3JldHVybiBhLmNhY2hlSGludCYmKGUrPVwiW1wiK2EuY2FjaGVIaW50K1wiXVwiKSxlKz1cIjpcIitvLGV9LFFuPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuc2Vzc2lvbj10O3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwLHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXB9Y2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KHQsbyl7cmV0dXJuIFF1KHRoaXMuc2Vzc2lvbi5sYXlvdXRTdHJhdGVneSx0LG8pfWV4ZWN1dGVQcm9ncmFtKHQsbyl7aWYoby5sZW5ndGg8dC5pbnB1dE5hbWVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYElucHV0IHNpemUgbXVzdG4ndCBiZSBsZXNzIHRoYW4gJHt0LmlucHV0TmFtZXMubGVuZ3RofS5gKTtpZih0LmlucHV0TmFtZXMubGVuZ3RoIT09dC5pbnB1dFR5cGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBuYW1lcyBzaXplIGRvZXMgbm90IG1hdGNoIGlucHV0IHR5cGVzXCIpO2xldCBlPVtdO2ZvcihsZXQgbD0wO2w8dC5pbnB1dE5hbWVzLmxlbmd0aDsrK2wpZVtsXT10aGlzLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEob1tsXSx0LmlucHV0VHlwZXNbbF0pO2xldCByPWxoKHQsZSksbj10aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3Qocikscz1uP24ucHJvZ3JhbUluZm86dHlwZW9mIHQuZ2V0PT1cImZ1bmN0aW9uXCI/dC5nZXQoKTp0LGk9cG4odGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LHMub3V0cHV0LmRpbXMscy5vdXRwdXQudGV4dHVyZVR5cGUpLHU9dGhpcy5jcmVhdGVUZXh0dXJlRGF0YShpLHMub3V0cHV0LnR5cGUpO3JldHVybiBufHwobj10aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuYnVpbGQocyxlLHUpLHRoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5zZXRBcnRpZmFjdChyLG4pKSx0aGlzLnJ1blByb2dyYW0obixlLHUpLHV9cnVuKHQsbyl7cmV0dXJuIHRoaXMuZXhlY3V0ZVByb2dyYW0odCxvKS50ZW5zb3J9cnVuUHJvZ3JhbSh0LG8sZSl7Zm9yKGxldCByPTA7cjxvLmxlbmd0aDsrK3IpaWYoISFvW3JdLmlzUGFja2VkIT0odC5wcm9ncmFtSW5mby5pbnB1dFR5cGVzW3JdPT09MikpdGhyb3cgbmV3IEVycm9yKGBpbnB1dFske3J9XSBwcm9wZXJ0eSBwYWNrZWQgaW5jb25zaXN0ZW50YCk7aWYoISFlLmlzUGFja2VkIT0odC5wcm9ncmFtSW5mby5vdXRwdXQudGV4dHVyZVR5cGU9PT0yKSl0aHJvdyBuZXcgRXJyb3IoXCJvdXRwdXQgcHJvcGVydHkgcGFja2VkIGluY29uc2lzdGVudFwiKTt0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIucnVuKHQsbyxlKX1nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQsbyl7bGV0IGU9dGhpcy5nZXRUZXh0dXJlRGF0YSh0LmRhdGFJZCxvPT09Mik7aWYoIWUmJihlPXRoaXMuZ2V0VGV4dHVyZURhdGEodC5kYXRhSWQsbyE9PTIpLGUpKXJldHVybiBvPT09Mj90aGlzLnBhY2soZSk6dGhpcy51bnBhY2soZSk7aWYoIWUpe2xldCByPXBuKHRoaXMuc2Vzc2lvbi5sYXlvdXRTdHJhdGVneSx0LmRpbXMsbyk7aWYobz09PTQpe2xldCBpPXQuZGltcztpZihpLmxlbmd0aD09PTQpe2xldCB1PVtpWzBdLE1hdGguY2VpbChpWzFdKmlbMl0qaVszXS80KV0sbD1wbih0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksdSxvKSxmPXQubnVtYmVyRGF0YTtpZihpWzFdKmlbMl0qaVszXSU0IT09MCl7bGV0IHA9aVswXSxkPWlbMV0qaVsyXSppWzNdLFQ9TWF0aC5jZWlsKGQqMS80KSo0LHY9cCpUO2Y9bmV3IEZsb2F0MzJBcnJheSh2KTtmb3IobGV0IHc9MDt3PHA7Kyt3KXtsZXQgST13KmQsTD13KlQrdyUxKmQ7Zi5zZXQodC5udW1iZXJEYXRhLnN1YmFycmF5KEksSStkKSxMKX19cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGEobCx0LnR5cGUsZix0LDEpfX1pZihvPT09Mil7bGV0IG49eGkodGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LHQuZGltcywxLFtdLHtyZXZlcnNlV0g6ITB9KSxzPXRoaXMuY3JlYXRlVGV4dHVyZURhdGEobix0LnR5cGUsdC5udW1iZXJEYXRhLHQsMSk7ZT10aGlzLnBhY2socyl9ZWxzZSBlPXRoaXMuY3JlYXRlVGV4dHVyZURhdGEocix0LnR5cGUsdC5udW1iZXJEYXRhLHQsMSl9cmV0dXJuIGV9Y3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0QmluZFRlbnNvcih0LG8sZSxyKXtyZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YSh0LG8sZSxyLDEpfWNyZWF0ZVRleHR1cmVEYXRhKHQsbyxlLHIsbil7Y2UudmVyYm9zZShcIkluZmVyZW5jZUhhbmRsZXJcIixgQ3JlYXRpbmcgVGV4dHVyZURhdGE6IGxheW91dDpbJHtKU09OLnN0cmluZ2lmeSh0KX1dYCk7bGV0IHM9dGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLmNyZWF0ZVRleHR1cmVGcm9tTGF5b3V0KG8sdCxlLG4pO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUodCxvLHMscil9cmVzaGFwZVVucGFja2VkKHQsbyl7bGV0IGU9dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQsMCkscj17Y2hhbm5lbHM6ZS5jaGFubmVscyxoZWlnaHQ6ZS5oZWlnaHQsd2lkdGg6ZS53aWR0aCxzaGFwZTpvLmxlbmd0aCE9PTA/bzpbMV0sc3RyaWRlczpVLmNvbXB1dGVTdHJpZGVzKG8pLHVucGFja2VkU2hhcGU6b307cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZShyLHQudHlwZSxlLnRleHR1cmUpLnRlbnNvcn1yZXNoYXBlUGFja2VkKHQsbyl7bGV0IGU9dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQsMik7aWYoanUodC5kaW1zLG8pKXtsZXQgbD17Y2hhbm5lbHM6ZS5jaGFubmVscyxoZWlnaHQ6ZS5oZWlnaHQsd2lkdGg6ZS53aWR0aCxzaGFwZTpvLmxlbmd0aCE9PTA/bzpbMV0sc3RyaWRlczpVLmNvbXB1dGVTdHJpZGVzKG8pLHVucGFja2VkU2hhcGU6byxpc1BhY2tlZDohMH07cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZShsLHQudHlwZSxlLnRleHR1cmUpLnRlbnNvcn1sZXQgcj15aSh0LmRpbXMpLG49eWkobykscz10aGlzLnJlc2hhcGVQYWNrZWQodCxyKSxpPXRoaXMucnVuKHF1KHRoaXMscyxuKSxbc10pO3JldHVybiB0aGlzLnJlc2hhcGVQYWNrZWQoaSxvKX1jYXN0KHQsbyl7bGV0IGU9dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQsMCk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZShlLG8sZS50ZXh0dXJlKS50ZW5zb3J9Y3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZSh0LG8sZSxyLG4pe2xldCBzPXsuLi50LHRlbnNvcjpyfHxuZXcgQ2UodC51bnBhY2tlZFNoYXBlLG8saT0+dGhpcy5yZWFkVGV4dHVyZShzKSxhc3luYyBpPT50aGlzLnJlYWRUZXh0dXJlQXN5bmMocyksdm9pZCAwLG4pLHRleHR1cmU6ZX07cmV0dXJuIHRoaXMuc2V0VGV4dHVyZURhdGEocy50ZW5zb3IuZGF0YUlkLHMsdC5pc1BhY2tlZCksc31nZXRUZXh0dXJlRGF0YSh0LG89ITEpe3JldHVybiB0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0KT90aGlzLnNlc3Npb24uZ2V0VGV4dHVyZURhdGEodCxvKTpvP3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQodCk6dGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHQpfXNldFRleHR1cmVEYXRhKHQsbyxlPSExKXt0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0KT90aGlzLnNlc3Npb24uc2V0VGV4dHVyZURhdGEodCxvLGUpOihlP3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZTp0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSkuc2V0KHQsbyl9aXNUZXh0dXJlTGF5b3V0Q2FjaGVkKHQsbz0hMSl7cmV0dXJuISF0aGlzLmdldFRleHR1cmVEYXRhKHQuZGF0YUlkLG8pfWRpc3Bvc2UoKXt0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIuY2xlYXJBY3RpdmVUZXh0dXJlcygpLHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKHQ9PnRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZSh0KSksdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXAsdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCh0PT50aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodCkpLHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXB9cmVhZFRleHR1cmUodCl7cmV0dXJuIHQuaXNQYWNrZWQ/dGhpcy5yZWFkVGV4dHVyZSh0aGlzLnVucGFjayh0KSk6dGhpcy5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LmlzRmxvYXQzMkRvd25sb2FkU3VwcG9ydGVkP3RoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVGV4dHVyZSh0LHQudGVuc29yLnR5cGUsdC5jaGFubmVscyk6dGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlYWRVaW50OFRleHR1cmVBc0Zsb2F0KFRpKHRoaXMsdCkpfWFzeW5jIHJlYWRUZXh0dXJlQXN5bmModCl7cmV0dXJuIHQuaXNQYWNrZWQ/dGhpcy5yZWFkVGV4dHVyZUFzeW5jKHRoaXMudW5wYWNrKHQpKTp0aGlzLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQuaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQ/dGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlYWRUZXh0dXJlQXN5bmModCx0LnRlbnNvci50eXBlLHQuY2hhbm5lbHMpOnRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdChUaSh0aGlzLHQpKX1wYWNrKHQpe3JldHVybiB0aGlzLmV4ZWN1dGVQcm9ncmFtKFd1KHRoaXMsdC50ZW5zb3IpLFt0LnRlbnNvcl0pfXVucGFjayh0KXtyZXR1cm4gdGhpcy5leGVjdXRlUHJvZ3JhbShKdSh0aGlzLHQudGVuc29yKSxbdC50ZW5zb3JdKX19fSk7dmFyIHdpLGVlLEdlPUUoKCk9PntcInVzZSBzdHJpY3RcIjt3aT1jbGFzc3tjb25zdHJ1Y3Rvcih0KXtPYmplY3QuYXNzaWduKHRoaXMsdCl9Z2V0IGNhY2hlS2V5KCl7cmV0dXJuIHRoaXMua2V5fHwodGhpcy5rZXk9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuc29ydCgpLm1hcCh0PT5gJHt0aGlzW3RdfWApLmpvaW4oXCI7XCIpKSx0aGlzLmtleX19LGVlPWE9Pm5ldyB3aShhKX0pO3ZhciBubCxvbCxpbCxmaCxjaCxhbD1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7R2UoKTt4ZSgpO2FlKCk7bmw9e25hbWU6XCJCYXRjaE5vcm1hbGl6YXRpb25cIixpbnB1dE5hbWVzOltcIkFcIixcIlNjYWxlXCIsXCJCXCIsXCJNZWFuXCIsXCJWYXJpYW5jZVwiXSxpbnB1dFR5cGVzOlswLDAsMCwwLDBdfSxvbD0oYSx0LG8pPT4oY2godCksW2EucnVuKHsuLi5ubCxjYWNoZUhpbnQ6by5jYWNoZUtleSxnZXQ6KCk9PmZoKGEsdCxvKX0sdCldKSxpbD1hPT57bGV0IHQ9YS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiZXBzaWxvblwiLDFlLTUpLG89YS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibW9tZW50dW1cIiwuOSksZT1hLmF0dHJpYnV0ZXMuZ2V0SW50KFwic3BhdGlhbFwiLDEpO3JldHVybiBlZSh7ZXBzaWxvbjp0LG1vbWVudHVtOm8sc3BhdGlhbDplfSl9LGZoPShhLHQsbyk9PntsZXQgZT1xKGEuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxyPXRbMF0uZGltcy5sZW5ndGgsW24sc109YS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQodFsxXS5kaW1zLDApLGk9YFxuICBmbG9hdCBwcm9jZXNzKGludFske3J9XSBpbmRpY2VzKSB7XG4gICAgdmVjMiBwb3NpdGlvbiA9IG9mZnNldFRvQ29vcmRzKGluZGljZXNbMV0sICR7bn0sICR7c30pO1xuICAgIGZsb2F0IHNjYWxlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7ZS50ZXh0dXJlMkR9KFNjYWxlLCBwb3NpdGlvbikpO1xuICAgIGZsb2F0IG1lYW4gPSBnZXRDb2xvckFzRmxvYXQoJHtlLnRleHR1cmUyRH0oTWVhbiwgcG9zaXRpb24pKTtcbiAgICBmbG9hdCB2YXJpYW5jZSA9IGdldENvbG9yQXNGbG9hdCgke2UudGV4dHVyZTJEfShWYXJpYW5jZSwgcG9zaXRpb24pKTtcbiAgICBmbG9hdCBiID0gZ2V0Q29sb3JBc0Zsb2F0KCR7ZS50ZXh0dXJlMkR9KEIsIHBvc2l0aW9uKSk7XG5cbiAgICByZXR1cm4gc2NhbGUgKiAoIChfQShpbmRpY2VzKSAtIG1lYW4pIC8gc3FydCh2YXJpYW5jZSArIGZsb2F0KCR7by5lcHNpbG9ufSkpICkgKyBiO1xuICB9YDtyZXR1cm57Li4ubmwsb3V0cHV0OntkaW1zOnRbMF0uZGltcyx0eXBlOnRbMF0udHlwZSx0ZXh0dXJlVHlwZTowfSxzaGFkZXJTb3VyY2U6aX19LGNoPWE9PntpZighYXx8YS5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcihcIkJhdGNoTm9ybWFsaXphdGlvbiByZXF1aXJlcyA1IGlucHV0cy5cIik7bGV0IHQ9YVswXSxvPWFbMV0sZT1hWzJdLHI9YVszXSxuPWFbNF07aWYodC5kaW1zLmxlbmd0aDwzfHxvLmRpbXMubGVuZ3RoIT09MXx8ZS5kaW1zLmxlbmd0aCE9PTF8fHIuZGltcy5sZW5ndGghPT0xfHxuLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHNoYXBlLlwiKTtpZihvLmRpbXNbMF0hPT10LmRpbXNbMV18fGUuZGltc1swXSE9PXQuZGltc1sxXXx8ci5kaW1zWzBdIT09dC5kaW1zWzFdfHxuLmRpbXNbMF0hPT10LmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYodC50eXBlIT09XCJmbG9hdDMyXCImJnQudHlwZSE9PVwiZmxvYXQ2NFwifHxvLnR5cGUhPT1cImZsb2F0MzJcIiYmby50eXBlIT09XCJmbG9hdDY0XCJ8fGUudHlwZSE9PVwiZmxvYXQzMlwiJiZlLnR5cGUhPT1cImZsb2F0NjRcInx8ci50eXBlIT09XCJmbG9hdDMyXCImJnIudHlwZSE9PVwiZmxvYXQ2NFwifHxuLnR5cGUhPT1cImZsb2F0MzJcIiYmbi50eXBlIT09XCJmbG9hdDY0XCIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfX0pO3ZhciBlbyxmdCxSLGRuLHRvLEh0PUUoKCk9PntcInVzZSBzdHJpY3RcIjtlbz1jbGFzc3tjb25zdHJ1Y3Rvcih0LG8sZSxyKXt0aGlzLmdsQ29udGV4dD10O3RoaXMucHJvZ3JhbUluZm89bzt0aGlzLmlucHV0VGV4dHVyZUxheW91dHM9ZTt0aGlzLm91dHB1dFRleHR1cmVMYXlvdXQ9cn19LGZ0PWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuY29udGV4dD10fX0sUj1jbGFzc3tjb25zdHJ1Y3Rvcih0LG8pe3RoaXMucm91dGluZUJvZHk9dDt0aGlzLmRlcGVuZGVuY2llcz1vfX0sZG49Y2xhc3N7Y29uc3RydWN0b3IodCxvLGUpe3RoaXMubmFtZT10O2U/dGhpcy5kZXBlbmRlbmNpZXM9ZTp0aGlzLmRlcGVuZGVuY2llcz1bXSxvJiYodGhpcy5yb3V0aW5lQm9keT1vKX1hZGREZXBlbmRlbmN5KHQpe3QmJnRoaXMuZGVwZW5kZW5jaWVzLnB1c2godCl9fSx0bz1jbGFzc3tzdGF0aWMgcmV0dXJuT3JkZXJlZE5vZGVzKHQpe2lmKCF0fHx0Lmxlbmd0aD09PTApcmV0dXJuW107aWYodC5sZW5ndGg9PT0xKXJldHVybiB0O2xldCBvPW5ldyBTZXQsZT1uZXcgU2V0LHI9bmV3IEFycmF5O3JldHVybiB0aGlzLmNyZWF0ZU9yZGVyZWROb2Rlcyh0LG8sZSxyKSxyfXN0YXRpYyBjcmVhdGVPcmRlcmVkTm9kZXModCxvLGUscil7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24pdGhpcy5kZnNUcmF2ZXJzZSh0W25dLG8sZSxyKX1zdGF0aWMgZGZzVHJhdmVyc2UodCxvLGUscil7aWYoIXR8fGUuaGFzKHQubmFtZSkpcmV0dXJuO2lmKG8uaGFzKHQubmFtZSkpdGhyb3cgbmV3IEVycm9yKFwiQ3ljbGljIGRlcGVuZGVuY3kgZGV0ZWN0ZWQuIENhbid0IHRvcG9sb2dpY2FsbHkgc29ydCByb3V0aW5lcyBuZWVkZWQgZm9yIHNoYWRlci5cIik7by5hZGQodC5uYW1lKTtsZXQgbj10LmRlcGVuZGVuY2llcztpZihuJiZuLmxlbmd0aD4wKWZvcihsZXQgcz0wO3M8bi5sZW5ndGg7KytzKXRoaXMuZGZzVHJhdmVyc2UobltzXSxvLGUscik7ci5wdXNoKHQpLGUuYWRkKHQubmFtZSksby5kZWxldGUodC5uYW1lKX19fSk7ZnVuY3Rpb24gZGgoKXtsZXQgYT1cImFkZF9cIjtyZXR1cm57Ym9keTpgXG4gIGZsb2F0ICR7YX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBhICsgYjtcbiAgfVxuICB2ZWM0ICR7YX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2MSArIHYyO1xuICB9XG4gIGAsbmFtZTphLHR5cGU6MH19ZnVuY3Rpb24gaGgoKXtsZXQgYT1cImRpdl9cIjtyZXR1cm57Ym9keTpgXG4gIGZsb2F0ICR7YX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBhIC8gYjtcbiAgfVxuICB2ZWM0ICR7YX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2MSAvIHYyO1xuICB9XG4gIGAsbmFtZTphLHR5cGU6MH19ZnVuY3Rpb24gbWgoKXtsZXQgYT1cIm11bF9cIjtyZXR1cm57Ym9keTpgXG4gIGZsb2F0ICR7YX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBhICogYjtcbiAgfVxuICB2ZWM0ICR7YX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2MSAqIHYyO1xuICB9XG4gIGAsbmFtZTphLHR5cGU6MH19ZnVuY3Rpb24gYmgoKXtsZXQgYT1cInN1Yl9cIjtyZXR1cm57Ym9keTpgXG4gIGZsb2F0ICR7YX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfVxuICB2ZWM0ICR7YX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2MSAtIHYyO1xuICB9XG4gIGAsbmFtZTphLHR5cGU6MH19ZnVuY3Rpb24gZ2goKXtsZXQgYT1cImVxdWFsX1wiO3JldHVybntib2R5OmBcbiAgZmxvYXQgJHthfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGZsb2F0KGEgPT0gYik7XG4gIH1cbiAgdmVjNCAke2F9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdmVjNChlcXVhbCh2MSwgdjIpKTtcbiAgfVxuICBgLG5hbWU6YSx0eXBlOjB9fWZ1bmN0aW9uIHloKCl7bGV0IGE9XCJncmVhdGVyX1wiO3JldHVybntib2R5OmBcbiAgZmxvYXQgJHthfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGZsb2F0KGEgPiBiKTtcbiAgfVxuICB2ZWM0ICR7YX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2ZWM0KCB2MS5yID4gdjIuciAsXG4gICAgICB2MS5nID4gdjIuZyxcbiAgICAgIHYxLmIgPiB2Mi5iLFxuICAgICAgdjEuYSA+IHYyLmEgKTtcbiAgfVxuICBgLG5hbWU6YSx0eXBlOjB9fWZ1bmN0aW9uIFRoKCl7bGV0IGE9XCJsZXNzX1wiO3JldHVybntib2R5OmBcbiAgZmxvYXQgJHthfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGZsb2F0KGEgPCBiKTtcbiAgfVxuICB2ZWM0ICR7YX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2ZWM0KCB2MS5yIDwgdjIuciAsXG4gICAgICAgICAgICAgICAgdjEuZyA8IHYyLmcsXG4gICAgICAgICAgICAgICAgdjEuYiA8IHYyLmIsXG4gICAgICAgICAgICAgICAgdjEuYSA8IHYyLmEgKTtcbiAgfVxuICBgLG5hbWU6YSx0eXBlOjB9fWZ1bmN0aW9uIHhoKCl7bGV0IGE9XCJhbmRfXCI7cmV0dXJue2JvZHk6YFxuICBmbG9hdCAke2F9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gZmxvYXQoIGJvb2woYSkgJiYgYm9vbChiKSApO1xuICB9XG4gIHZlYzQgJHthfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgYnZlYzQgYjEgPSBidmVjNCh2MSk7XG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XG4gICAgcmV0dXJuIHZlYzQoIGIxLnIgJiYgYjIuciAsXG4gICAgICAgICAgICAgICAgYjEuZyAmJiBiMi5nLFxuICAgICAgICAgICAgICAgIGIxLmIgJiYgYjIuYixcbiAgICAgICAgICAgICAgICBiMS5hICYmIGIyLmEgKTtcbiAgfVxuICBgLG5hbWU6YSx0eXBlOjB9fWZ1bmN0aW9uIHdoKCl7bGV0IGE9XCJvcl9cIjtyZXR1cm57Ym9keTpgXG4gIGZsb2F0ICR7YX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSB8fCBib29sKGIpICk7XG4gIH1cbiAgdmVjNCAke2F9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcbiAgICBidmVjNCBiMiA9IGJ2ZWM0KHYyKTtcbiAgICByZXR1cm4gdmVjNCggYjEuciB8fCBiMi5yICxcbiAgICAgICAgICAgICAgICBiMS5nIHx8IGIyLmcsXG4gICAgICAgICAgICAgICAgYjEuYiB8fCBiMi5iLFxuICAgICAgICAgICAgICAgIGIxLmEgfHwgYjIuYSApO1xuICB9XG4gIGAsbmFtZTphLHR5cGU6MH19ZnVuY3Rpb24gdmgoKXtsZXQgYT1cInhvcl9cIjtyZXR1cm57Ym9keTpgXG4gIGZsb2F0ICR7YX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSBeXiBib29sKGIpICk7XG4gIH1cbiAgdmVjNCAke2F9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcbiAgICBidmVjNCBiMiA9IGJ2ZWM0KHYyKTtcbiAgICByZXR1cm4gdmVjNCggYjEuciBeXiBiMi5yICxcbiAgICAgICAgICAgICAgICBiMS5nIF5eIGIyLmcsXG4gICAgICAgICAgICAgICAgYjEuYiBeXiBiMi5iLFxuICAgICAgICAgICAgICAgIGIxLmEgXl4gYjIuYSApO1xuICB9XG4gIGAsbmFtZTphLHR5cGU6MH19ZnVuY3Rpb24gX2goKXtyZXR1cm4gSWgoXCJwb3dcIil9ZnVuY3Rpb24gT2goKXtsZXQgYT1cInByZWx1X1wiO3JldHVybntib2R5OmBcbiAgZmxvYXQgJHthfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGEgPCAwLjAgPyBhICogYjogYTtcbiAgfVxuICB2ZWM0ICR7YX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2ZWM0KFxuICAgICAgdjEuciA8IDAuMCA/IHYxLnIgKiB2Mi5yOiB2MS5yLFxuICAgICAgdjEuZyA8IDAuMCA/IHYxLmcgKiB2Mi5nOiB2MS5nLFxuICAgICAgdjEuYiA8IDAuMCA/IHYxLmIgKiB2Mi5iOiB2MS5iLFxuICAgICAgdjEuYSA8IDAuMCA/IHYxLmEgKiB2Mi5hOiB2MS5hXG4gICAgICApO1xuICB9XG4gIGAsbmFtZTphLHR5cGU6MH19ZnVuY3Rpb24gSWgoYSl7bGV0IHQ9YCR7YX1fYDtyZXR1cm57Ym9keTpgXG4gIGZsb2F0ICR7dH0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiAke2F9KGEsIGIpO1xuICB9XG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgcmV0dXJuICR7YX0odjEsIHYyKTtcbiAgfVxuICBgLG5hbWU6dCx0eXBlOjB9fXZhciBjdCxTaCxzbCx1bCxsbCxmbCxjbCxwbCxkbCxobCxtbCxibCxnbCx5bCxUbD1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZmUoKTtIdCgpO3hlKCk7YWUoKTtjdD0oYSx0LG8sZT10WzBdLnR5cGUscik9PntsZXQgbj1hLnNlc3Npb24ucGFjaz8yOjA7cmV0dXJue25hbWU6by5uYW1lLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOltuLG5dLGNhY2hlSGludDpyLGdldDooKT0+U2goYSx0LG8sZSl9fSxTaD0oYSx0LG8sZT10WzBdLnR5cGUpPT57bGV0IHI9YS5zZXNzaW9uLnBhY2s/MjowLG49IVUuYXJlRXF1YWwodFswXS5kaW1zLHRbMV0uZGltcykscz10WzBdLmRpbXMsaT1hLnNlc3Npb24ucGFjaztpZihuKXtsZXQgZj1LZS5jYWxjU2hhcGUodFswXS5kaW1zLHRbMV0uZGltcywhMSk7aWYoIWYpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7cz1mO2xldCBwPXMubGVuZ3RoLGQ9dFswXS5kaW1zLmxlbmd0aCE9PTA/dFswXS5kaW1zLmxlbmd0aDoxLFQ9dFsxXS5kaW1zLmxlbmd0aCE9PTA/dFsxXS5kaW1zLmxlbmd0aDoxLHY9dFswXS5kaW1zLmxlbmd0aCE9PTA/XCJiY2FzdEluZGljZXNfQShpbmRpY2VzLCBhaW5kaWNlcyk7XCI6XCJhaW5kaWNlc1swXSA9IDA7XCIsdz10WzFdLmRpbXMubGVuZ3RoIT09MD9cImJjYXN0SW5kaWNlc19CKGluZGljZXMsIGJpbmRpY2VzKTtcIjpcImJpbmRpY2VzWzBdID0gMDtcIixJPXEoYS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLEw9aT9gXG4gICAgICAke28uYm9keX1cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCBhID0gZ2V0QUF0T3V0Q29vcmRzKCk7XG4gICAgICAgIHZlYzQgYiA9IGdldEJBdE91dENvb3JkcygpO1xuICAgICAgICB2ZWM0IHJlc3VsdCA9ICR7by5uYW1lfShhLCBiKTtcbiAgICAgICAgJHtJLm91dHB1dH0gPSByZXN1bHQ7XG4gICAgICB9YDpgXG4gICAgICAke28uYm9keX1cbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtwfV0pIHtcbiAgICAgICAgaW50IGFpbmRpY2VzWyR7ZH1dO1xuICAgICAgICBpbnQgYmluZGljZXNbJHtUfV07XG4gICAgICAgICR7dn1cbiAgICAgICAgJHt3fVxuICAgICAgICByZXR1cm4gJHtvLm5hbWV9KF9BKGFpbmRpY2VzKSwgX0IoYmluZGljZXMpKTtcbiAgICAgIH1gO3JldHVybntuYW1lOm8ubmFtZSxpbnB1dE5hbWVzOltcIkFcIixcIkJcIl0saW5wdXRUeXBlczpbcixyXSxvdXRwdXQ6e2RpbXM6cyx0eXBlOmUsdGV4dHVyZVR5cGU6cn0sc2hhZGVyU291cmNlOkwsaGFzTWFpbjppfX1sZXQgdT1xKGEuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxsPWBcbiAgICAke28uYm9keX1cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWM0IHYxID0gJHt1LnRleHR1cmUyRH0oQSwgVGV4Q29vcmRzKTtcbiAgICAgIHZlYzQgdjIgPSAke3UudGV4dHVyZTJEfShCLCBUZXhDb29yZHMpO1xuICAgICAgdmVjNCByZXN1bHQgPSAke28ubmFtZX0odjEsIHYyKTtcbiAgICAgICR7dS5vdXRwdXR9ID0gcmVzdWx0O1xuICAgIH1cbiAgICBgO3JldHVybntuYW1lOm8ubmFtZSxpbnB1dE5hbWVzOltcIkFcIixcIkJcIl0saW5wdXRUeXBlczpbcixyXSxvdXRwdXQ6e2RpbXM6dFswXS5kaW1zLHR5cGU6ZSx0ZXh0dXJlVHlwZTpyfSxzaGFkZXJTb3VyY2U6bCxoYXNNYWluOiEwfX0sc2w9KGEsdCk9PlthLnJ1bihjdChhLHQsZGgoKSksdCldLHVsPShhLHQpPT5bYS5ydW4oY3QoYSx0LHhoKCksXCJib29sXCIpLHQpXSxsbD0oYSx0KT0+W2EucnVuKGN0KGEsdCxoaCgpKSx0KV0sZmw9KGEsdCk9PlthLnJ1bihjdChhLHQsZ2goKSxcImJvb2xcIiksdCldLGNsPShhLHQpPT5bYS5ydW4oY3QoYSx0LHloKCksXCJib29sXCIpLHQpXSxwbD0oYSx0KT0+W2EucnVuKGN0KGEsdCxUaCgpLFwiYm9vbFwiKSx0KV0sZGw9KGEsdCk9PlthLnJ1bihjdChhLHQsbWgoKSksdCldLGhsPShhLHQpPT5bYS5ydW4oY3QoYSx0LHdoKCksXCJib29sXCIpLHQpXSxtbD0oYSx0KT0+W2EucnVuKGN0KGEsdCxfaCgpKSx0KV0sYmw9KGEsdCk9PlthLnJ1bihjdChhLHQsT2goKSksdCldLGdsPShhLHQpPT5bYS5ydW4oY3QoYSx0LGJoKCkpLHQpXSx5bD0oYSx0KT0+W2EucnVuKGN0KGEsdCx2aCgpLFwiYm9vbFwiKSx0KV19KTt2YXIgeGwsd2wsUGgsdmw9RSgoKT0+e1widXNlIHN0cmljdFwiO2ZlKCk7eGw9KGEsdCxvKT0+KFBoKHQpLFthLmNhc3QodFswXSxvKV0pLHdsPWE9PlZlLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGEuYXR0cmlidXRlcy5nZXRJbnQoXCJ0b1wiKSksUGg9YT0+e2lmKCFhfHxhLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiQ2FzdCByZXF1aXJlcyAxIGlucHV0LlwiKTtpZihhWzBdLnR5cGU9PT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSk7dmFyIEVoLERoLF9sLHJvLE9sPUUoKCk9PntcInVzZSBzdHJpY3RcIjt4ZSgpO2FlKCk7a3QoKTtncigpO0VoPShhLHQpPT4oe25hbWU6XCJDb25jYXQgKHBhY2tlZClcIixpbnB1dE5hbWVzOkFycmF5LmZyb20oe2xlbmd0aDphfSwobyxlKT0+YFgke2V9YCksaW5wdXRUeXBlczpBcnJheShhKS5maWxsKDIpLGNhY2hlSGludDp0fSksRGg9KGEsdCxvLGUpPT57bGV0IHI9b1swXS5kaW1zLnNsaWNlKCk7aWYoZT49ci5sZW5ndGh8fGU8LTEqci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhpcyBzcGVjaWZpZWQgZm9yIGNvbmNhdCBkb2Vzbid0IG1hdGNoIGlucHV0IGRpbWVuc2lvbmFsaXR5XCIpO2U8MCYmKGU9ci5sZW5ndGgrZSk7bGV0IG49ci5zbGljZSgwKTtmb3IobGV0IGo9MTtqPG8ubGVuZ3RoO2orKyl7bGV0IE09b1tqXS5kaW1zLnNsaWNlKCk7Zm9yKGxldCBpZT0wO2llPHIubGVuZ3RoO2llKyspaWYoaWU9PT1lKW5bZV0rPU1baWVdO2Vsc2UgaWYocltpZV0hPT1NW2llXSl0aHJvdyBuZXcgRXJyb3IoXCJub24gY29uY2F0IGRpbWVuc2lvbnMgbXVzdCBtYXRjaFwiKX1sZXQgcz1uLmxlbmd0aCxpPVJyKFwiY29vcmRzXCIscyksdT1KZShzKSxsPUJ0KCksZj1vLm1hcChqPT5qLmRpbXMpLHA9T3QocyksZD1uZXcgQXJyYXkoZi5sZW5ndGgtMSk7ZFswXT1mWzBdW2VdO2ZvcihsZXQgaj0xO2o8ZC5sZW5ndGg7aisrKWRbal09ZFtqLTFdK2Zbal1bZV07bGV0IFQ9cFtlXSx2PXAuc2xpY2UoLTIpLHc9cC5qb2luKCksST1gaWYgKCR7VH0gPCAke2RbMF19KSB7XG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxuICAgICAgICAgICAgZ2V0WDAoJHt3fSksIHZlYzIoJHt2LmpvaW4oKX0pKTtcbiAgICAgICAgfWA7Zm9yKGxldCBqPTE7ajxkLmxlbmd0aDtqKyspe2xldCBNPWRbai0xXTtJKz1gXG4gICAgICAgICAgICBpZiAoJHtUfSA8ICR7ZFtqXX0gICYmICR7VH0gPj0gJHtkW2otMV19KSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxuICAgICAgICAgICAgICAgIGdldFgke2p9KCR7cm8ocCxULE0pfSksXG4gICAgICAgICAgICAgICAgdmVjMigke3JvKHYsVCxNKX0pKTtcbiAgICAgICAgICAgIH1gfWxldCBMPWQubGVuZ3RoLEY9ZFtkLmxlbmd0aC0xXTtJKz1gXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcbiAgICAgICAgICAgICAgZ2V0WCR7TH0oJHtybyhwLFQsRil9KSxcbiAgICAgICAgICAgICAgdmVjMigke3JvKHYsVCxGKX0pKTtgO2xldCBDPXEoYS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLFk9YFxuICAgICAgICAgICR7bH1cbiAgICAgICAgICBmbG9hdCBnZXRWYWx1ZSgke3AubWFwKGo9PlwiaW50IFwiK2opfSkge1xuICAgICAgICAgICAgJHtJfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICR7dX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICAgICBpbnQgbGFzdERpbSA9IGNvb3Jkcy4ke3Bbcy0xXX07XG4gICAgICAgICAgICBjb29yZHMuJHtwW3MtMV19ID0gY29vcmRzLiR7cFtzLTJdfTtcbiAgICAgICAgICAgIGNvb3Jkcy4ke3Bbcy0yXX0gPSBsYXN0RGltO1xuXG4gICAgICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoZ2V0VmFsdWUoJHtpfSksIDAuLCAwLiwgMC4pO1xuXG4gICAgICAgICAgICAke2lbcy0xXX0gPSAke2lbcy0xXX0gKyAxO1xuICAgICAgICAgICAgaWYgKCR7aVtzLTFdfSA8ICR7bltzLTFdfSkge1xuICAgICAgICAgICAgICByZXN1bHQuZyA9IGdldFZhbHVlKCR7aX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAke2lbcy0yXX0gPSAke2lbcy0yXX0gKyAxO1xuICAgICAgICAgICAgaWYgKCR7aVtzLTJdfSA8ICR7bltzLTJdfSkge1xuICAgICAgICAgICAgICByZXN1bHQuYSA9IGdldFZhbHVlKCR7aX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAke2lbcy0xXX0gPSAke2lbcy0xXX0gLSAxO1xuICAgICAgICAgICAgaWYgKCR7aVtzLTJdfSA8ICR7bltzLTJdfSAmJlxuICAgICAgICAgICAgICAgICR7aVtzLTFdfSA8ICR7bltzLTFdfSkge1xuICAgICAgICAgICAgICByZXN1bHQuYiA9IGdldFZhbHVlKCR7aX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtDLm91dHB1dH0gPSByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBgO3JldHVybnsuLi50LG91dHB1dDp7ZGltczpuLHR5cGU6b1swXS50eXBlLHRleHR1cmVUeXBlOjJ9LHNoYWRlclNvdXJjZTpZLGhhc01haW46ITB9fSxfbD0oYSx0LG8pPT57bGV0IGU9RWgodC5sZW5ndGgsby5jYWNoZUtleSk7cmV0dXJuey4uLmUsZ2V0OigpPT5EaChhLGUsdCxvLmF4aXMpfX0scm89KGEsdCxvKT0+e2xldCBlPWEuaW5kZXhPZih0KTtyZXR1cm4gYS5tYXAoKG4scyk9PnM9PT1lP2Ake259IC0gJHtvfWA6bikuam9pbigpfX0pO3ZhciBJbCxMaCxGaCxDaCxTbCwkaCxraCxCaCxBbCxOaCxQbD1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7R2UoKTthZSgpO09sKCk7SWw9KGEsdCxvKT0+KE5oKHQpLGEuc2Vzc2lvbi5wYWNrJiZ0WzBdLmRpbXMubGVuZ3RoPjE/W2EucnVuKF9sKGEsdCxvKSx0KV06W2EucnVuKENoKGEsdCxvKSx0KV0pLExoPShhLHQpPT4oe25hbWU6XCJDb25jYXRcIixpbnB1dE5hbWVzOkFycmF5LmZyb20oe2xlbmd0aDphfSwobyxlKT0+YFgke2V9YCksaW5wdXRUeXBlczpBcnJheShhKS5maWxsKDApLGNhY2hlSGludDp0fSksRmg9KGEsdCxvLGUpPT57bGV0IHI9b1swXS5kaW1zLnNsaWNlKCk7aWYoZT49ci5sZW5ndGh8fGU8LTEqci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhpcyBzcGVjaWZpZWQgZm9yIGNvbmNhdCBkb2Vzbid0IG1hdGNoIGlucHV0IGRpbWVuc2lvbmFsaXR5XCIpO2U8MCYmKGU9ci5sZW5ndGgrZSk7bGV0IG49ci5zbGljZSgwKTtmb3IobGV0IFQ9MTtUPG8ubGVuZ3RoO1QrKyl7bGV0IHY9b1tUXS5kaW1zLnNsaWNlKCk7Zm9yKGxldCB3PTA7dzxyLmxlbmd0aDt3KyspaWYodz09PWUpbltlXSs9dlt3XTtlbHNlIGlmKHJbd10hPT12W3ddKXRocm93IG5ldyBFcnJvcihcIm5vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoXCIpfWxldCBzPW4ubGVuZ3RoLGk9bmV3IEFycmF5KG8ubGVuZ3RoKSx1PTA7Zm9yKGxldCBUPTA7VDxpLmxlbmd0aDsrK1QpdSs9b1tUXS5kaW1zW2VdLGlbVF09dTtsZXQgbD1cIlwiO28ubGVuZ3RoPDU/bD1TbChpKTpsPSRoKGkpO2xldCBmPWtoKG8ubGVuZ3RoLHMpLHA9QmgoaSksZD1gXG4gICAgICAgICR7Zn1cbiAgICAgICAgJHtwfVxuICAgICAgICAke2x9XG4gICAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtzfV0pIHtcbiAgICAgICAgICBpbnQgdGV4dHVyZUluZGV4ID0gZ2V0VGV4dHVyZVdoZXJlRGF0YVJlc2lkZXMgKGluZGljZXNbJHtlfV0pO1xuXG4gICAgICAgICAgaWYodGV4dHVyZUluZGV4ICE9IDApIHtcbiAgICAgICAgICAgIGluZGljZXNbJHtlfV0gPSBpbmRpY2VzWyR7ZX1dIC0gaW50KGdldFNpemVJbkNvbmNhdEF4aXNWYWx1ZUZyb21JbmRleCh0ZXh0dXJlSW5kZXgtaW50KDEpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZSh0ZXh0dXJlSW5kZXgsIGluZGljZXMpO1xuICAgICAgICB9YDtyZXR1cm57Li4udCxvdXRwdXQ6e2RpbXM6bix0eXBlOm9bMF0udHlwZSx0ZXh0dXJlVHlwZTowfSxzaGFkZXJTb3VyY2U6ZH19LENoPShhLHQsbyk9PntsZXQgZT1MaCh0Lmxlbmd0aCxvLmNhY2hlS2V5KTtyZXR1cm57Li4uZSxnZXQ6KCk9PkZoKGEsZSx0LG8uYXhpcyl9fSxTbD1hPT5gaW50IGdldFRleHR1cmVXaGVyZURhdGFSZXNpZGVzKGludCBpbmRleCkge1xuICAgICAgJHthLm1hcCgobyxlKT0+YGlmKGluZGV4PCR7b30pIHtyZXR1cm4gJHtlfTt9XG5gKS5qb2luKFwiXCIpfVxuICAgIH1gLCRoPWE9PlNsKGEpLGtoPShhLHQpPT57bGV0IG89W2BmbG9hdCBmZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmUoaW50IHRleHR1cmVJbmRleCwgaW50IGluZGljZXNbJHt0fV0pIHtgXTtmb3IobGV0IGU9MDtlPGE7KytlKWU9PT0wP28ucHVzaChgXHRpZiAodGV4dHVyZUluZGV4ID09ICR7ZX0pIHsgcmV0dXJuIF9YJHtlfShpbmRpY2VzKTsgfWApOmU9PT1hLTE/by5wdXNoKGBcdGVsc2UgeyByZXR1cm4gX1gke2V9KGluZGljZXMpOyB9YCk6by5wdXNoKGBcdGVsc2UgaWYgKHRleHR1cmVJbmRleCA9PSAke2V9KSB7IHJldHVybiBfWCR7ZX0oaW5kaWNlcyk7IH1gKTtyZXR1cm4gby5wdXNoKFwiXHR9XCIpLG8uam9pbihgXG5gKX0sQmg9YT0+e2xldCB0PVtcImludCBnZXRTaXplSW5Db25jYXRBeGlzVmFsdWVGcm9tSW5kZXgoaW50IGluZGV4KSB7XCJdO2ZvcihsZXQgbz0wO288YS5sZW5ndGg7KytvKW89PT0wP3QucHVzaChgXHRpZiAoaW5kZXggPT0gJHtvfSkgeyByZXR1cm4gJHthW29dfTsgfWApOm89PT1hLmxlbmd0aC0xP3QucHVzaChgXHRlbHNlIHsgcmV0dXJuICR7YVtvXX07IH1gKTp0LnB1c2goYFx0ZWxzZSBpZiAoaW5kZXggPT0gJHtvfSkgeyByZXR1cm4gJHthW29dfTsgfWApO3JldHVybiB0LnB1c2goXCJcdH1cIiksdC5qb2luKGBcbmApfSxBbD1hPT5lZSh7YXhpczphLmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiKX0pLE5oPWE9PntpZighYXx8YS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKTtsZXQgdD1hWzBdLnR5cGUsbz1hWzBdLmRpbXMubGVuZ3RoO2lmKHQ9PT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihcInN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7Zm9yKGxldCBlIG9mIGEpe2lmKGUudHlwZSE9PXQpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGVcIik7aWYoZS5kaW1zLmxlbmd0aCE9PW8pdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKX19fSk7ZnVuY3Rpb24gUmgoKXtyZXR1cm4gcHQoXCJhYnNcIil9ZnVuY3Rpb24gTWgoKXtyZXR1cm4gcHQoXCJhY29zXCIpfWZ1bmN0aW9uIEdoKCl7cmV0dXJuIHB0KFwiYXNpblwiKX1mdW5jdGlvbiBVaCgpe3JldHVybiBwdChcImF0YW5cIil9ZnVuY3Rpb24gemgoKXtyZXR1cm4gcHQoXCJjZWlsXCIpfWZ1bmN0aW9uIFZoKCl7cmV0dXJuIHB0KFwiY29zXCIpfWZ1bmN0aW9uIFdoKGEpe2xldCB0PVwiZWx1XCI7cmV0dXJue2JvZHk6YFxuICBjb25zdCBmbG9hdCBhbHBoYSA9IGZsb2F0KCR7YX0pO1xuXG4gIGZsb2F0ICR7dH1fKGZsb2F0IGEpIHtcbiAgICByZXR1cm4gYSA+PSAwLjAgPyBhOiAoZXhwKGEpIC0gMS4wKSAqIGFscGhhO1xuICB9XG4gIHZlYzQgJHt0fV8odmVjNCB2KSB7XG4gICAgcmV0dXJuIHZlYzQoJHt0fV8odi54KSwgJHt0fV8odi55KSwgJHt0fV8odi56KSwgJHt0fV8odi53KSk7XG4gIH1cbiAgYCxuYW1lOnQsdHlwZTowfX1mdW5jdGlvbiBIaCgpe3JldHVybiBwdChcImV4cFwiKX1mdW5jdGlvbiBxaCgpe3JldHVybiBwdChcImZsb29yXCIpfWZ1bmN0aW9uIHZpKGEsdCl7bGV0IG89XCJjbGlwXCI7cmV0dXJue2JvZHk6YFxuICBjb25zdCBmbG9hdCBtaW4gPSBmbG9hdCgke2F9KTtcbiAgY29uc3QgZmxvYXQgbWF4ID0gZmxvYXQoJHt0fSk7XG5cbiAgZmxvYXQgJHtvfV8oZmxvYXQgYSkge1xuICAgIHJldHVybiBjbGFtcChhLCBtaW4sIG1heCk7XG4gIH1cbiAgdmVjNCAke299Xyh2ZWM0IHYpIHtcbiAgICByZXR1cm4gY2xhbXAodiwgbWluLCBtYXgpO1xuICB9XG4gIGAsbmFtZTpvLHR5cGU6MH19ZnVuY3Rpb24gamgoKXtsZXQgYT1cImluZGVudGl0eVwiO3JldHVybntib2R5OmBcbiAgZmxvYXQgJHthfV8oZmxvYXQgYSkge1xuICAgIHJldHVybiBhO1xuICB9XG4gIHZlYzQgJHthfV8odmVjNCB2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgYCxuYW1lOmEsdHlwZTowfX1mdW5jdGlvbiBZaChhKXtsZXQgdD1cImxlYWt5UmVsdVwiO3JldHVybntib2R5OmBcbiAgY29uc3QgZmxvYXQgYWxwaGEgPSBmbG9hdCgke2F9KTtcblxuICBmbG9hdCAke3R9XyhmbG9hdCBhKSB7XG4gICAgcmV0dXJuIGEgPCAwLjAgPyBhICogYWxwaGEgOiBhO1xuICB9XG4gIHZlYzQgJHt0fV8odmVjNCB2KSB7XG4gICAgcmV0dXJuIHZlYzQoJHt0fV8odi54KSwgJHt0fV8odi55KSwgJHt0fV8odi56KSwgJHt0fV8odi53KSk7XG4gIH1cbiAgYCxuYW1lOnQsdHlwZTowfX1mdW5jdGlvbiBYaCgpe3JldHVybiBwdChcImxvZ1wiKX1mdW5jdGlvbiBLaCgpe2xldCBhPVwibmVnXCI7cmV0dXJue2JvZHk6YFxuICBmbG9hdCAke2F9XyhmbG9hdCBhKSB7XG4gICAgcmV0dXJuIC1hO1xuICB9XG4gIHZlYzQgJHthfV8odmVjNCB2KSB7XG4gICAgcmV0dXJuIC12O1xuICB9XG4gIGAsbmFtZTphLHR5cGU6MH19ZnVuY3Rpb24gSmgoKXtsZXQgYT1cIm5vdFwiO3JldHVybntib2R5OmBcbiAgZmxvYXQgJHthfV8oZmxvYXQgYSkge1xuICAgIHJldHVybiBmbG9hdCggISBib29sKGEpICk7XG4gIH1cbiAgYm9vbCAke2F9Xyhib29sIGEpIHtcbiAgICByZXR1cm4gIWE7XG4gIH1cbiAgdmVjNCAke2F9Xyh2ZWM0IHYpIHtcbiAgICByZXR1cm4gdmVjNCghYm9vbCh2LngpLCAhYm9vbCh2LnkpLCAhYm9vbCh2LnopLCAhYm9vbCh2LncpKTtcbiAgfVxuICBidmVjNCAke2F9XyhidmVjNCB2KSB7XG4gICAgcmV0dXJuIGJ2ZWM0KCF2LngsICF2LnksICF2LnosICF2LncpO1xuICB9XG4gIGAsbmFtZTphLHR5cGU6MH19ZnVuY3Rpb24gWmgoKXtyZXR1cm4gcHQoXCJzaW5cIil9ZnVuY3Rpb24gX2koKXtsZXQgYT1cInJlbHVcIjtyZXR1cm57Ym9keTpgXG4gIGZsb2F0ICR7YX1fKGZsb2F0IGEpIHtcbiAgICByZXR1cm4gbWF4KCBhLCAwLjAgKTtcbiAgfVxuICB2ZWM0ICR7YX1fKHZlYzQgdikge1xuICAgIHJldHVybiBtYXgoIHYsIDAuMCApO1xuICB9XG4gIGAsbmFtZTphLHR5cGU6MH19ZnVuY3Rpb24gT2koKXtsZXQgYT1cInNpZ21vaWRcIjtyZXR1cm57Ym9keTpgXG4gIGZsb2F0ICR7YX1fKGZsb2F0IGEpIHtcbiAgICByZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtYSkpO1xuICB9XG4gIHZlYzQgJHthfV8odmVjNCB2KSB7XG4gICAgcmV0dXJuIDEuMCAvICgxLjAgKyBleHAoLXYpKTtcbiAgfVxuICBgLG5hbWU6YSx0eXBlOjB9fWZ1bmN0aW9uIFFoKCl7cmV0dXJuIHB0KFwic3FydFwiKX1mdW5jdGlvbiBlbSgpe3JldHVybiBwdChcInRhblwiKX1mdW5jdGlvbiB0bSgpe2xldCBhPVwidGFuaFwiO3JldHVybntib2R5OmBcbiAgZmxvYXQgJHthfV8oZmxvYXQgYSkge1xuICAgIGEgPSBjbGFtcChhLCAtMTAuLCAxMC4pO1xuICAgIGEgPSBleHAoMi4qYSk7XG4gICAgcmV0dXJuIChhIC0gMS4pIC8gKGEgKyAxLik7XG4gIH1cbiAgdmVjNCAke2F9Xyh2ZWM0IHYpIHtcbiAgICB2ID0gY2xhbXAodiwgLTEwLiwgMTAuKTtcbiAgICB2ID0gZXhwKDIuKnYpO1xuICAgIHJldHVybiAodiAtIDEuKSAvICh2ICsgMS4pO1xuICB9XG4gIGAsbmFtZTphLHR5cGU6MH19ZnVuY3Rpb24gcHQoYSl7cmV0dXJue2JvZHk6YFxuICBmbG9hdCAke2F9XyhmbG9hdCBhKSB7XG4gICAgcmV0dXJuICR7YX0oYSk7XG4gIH1cbiAgdmVjNCAke2F9Xyh2ZWM0IHYpIHtcbiAgICByZXR1cm4gJHthfSh2KTtcbiAgfVxuICBgLG5hbWU6YSx0eXBlOjB9fXZhciBybSxEZSxFbCxEbCxMbCxGbCxJaSxDbCwkbCxubSxrbCxCbCxObCxSbCxNbCxHbCxTaSxVbCx6bCxWbCxXbCxIbCxxbCxqbCxZbCxYbCxLbCxKbCxBaT1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7R2UoKTtmZSgpO0h0KCk7eGUoKTthZSgpO3JtPShhLHQsbyxlKT0+e2xldCByPWEuc2Vzc2lvbi5wYWNrPzI6MCxuPXEoYS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO3JldHVybnsuLi50LG91dHB1dDp7ZGltczpvLmRpbXMsdHlwZTpvLnR5cGUsdGV4dHVyZVR5cGU6cn0sc2hhZGVyU291cmNlOmBcbiAgICAgJHtlLmJvZHl9XG4gICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICB2ZWM0IHYgPSAke24udGV4dHVyZTJEfShBLCBUZXhDb29yZHMpO1xuICAgICAgIHYgPSAke2UubmFtZX1fKHYpO1xuICAgICAgICR7bi5vdXRwdXR9ID0gdjtcbiAgICAgfVxuICAgICBgLGhhc01haW46ITB9fSxEZT0oYSx0LG8sZSk9PntsZXQgcj1hLnNlc3Npb24ucGFjaz8yOjAsbj17bmFtZTpvLm5hbWUsaW5wdXRUeXBlczpbcl0saW5wdXROYW1lczpbXCJBXCJdLGNhY2hlSGludDplfTtyZXR1cm57Li4ubixnZXQ6KCk9PnJtKGEsbix0LG8pfX0sRWw9KGEsdCk9PlthLnJ1bihEZShhLHRbMF0sUmgoKSksdCldLERsPShhLHQpPT5bYS5ydW4oRGUoYSx0WzBdLE1oKCkpLHQpXSxMbD0oYSx0KT0+W2EucnVuKERlKGEsdFswXSxHaCgpKSx0KV0sRmw9KGEsdCk9PlthLnJ1bihEZShhLHRbMF0sVWgoKSksdCldLElpPShhLHQsbyk9PlthLnJ1bihEZShhLHRbMF0sdmkoby5taW4sby5tYXgpLG8uY2FjaGVLZXkpLHQpXSxDbD1hPT5lZSh7bWluOmEuYXR0cmlidXRlcy5nZXRGbG9hdChcIm1pblwiLGhyKSxtYXg6YS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibWF4XCIsbXIpfSksJGw9KGEsdCk9PntsZXQgbz1ubShhLHQpO3JldHVybiBJaShhLFt0WzBdXSxvKX0sbm09KGEsdCk9PntpZih0Lmxlbmd0aD49MyYmKCFhLnNlc3Npb24uaXNJbml0aWFsaXplcih0WzFdLmRhdGFJZCl8fCFhLnNlc3Npb24uaXNJbml0aWFsaXplcih0WzJdLmRhdGFJZCkpKXRocm93IG5ldyBFcnJvcihcImR5bmFtaWMgY2xpcCBhdHRyaWJ1dGVzIGFyZSBub3QgYWxsb3dlZFwiKTtsZXQgbz10Lmxlbmd0aD49Mz90WzFdLm51bWJlckRhdGFbMF06aHIsZT10Lmxlbmd0aD49Mz90WzJdLm51bWJlckRhdGFbMF06bXI7cmV0dXJuIGVlKHttaW46byxtYXg6ZX0pfSxrbD0oYSx0KT0+W2EucnVuKERlKGEsdFswXSx6aCgpKSx0KV0sQmw9KGEsdCk9PlthLnJ1bihEZShhLHRbMF0sVmgoKSksdCldLE5sPShhLHQsbyk9PlthLnJ1bihEZShhLHRbMF0sV2goby5hbHBoYSksby5jYWNoZUtleSksdCldLFJsPWE9PmVlKHthbHBoYTphLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJhbHBoYVwiLDEpfSksTWw9KGEsdCk9PlthLnJ1bihEZShhLHRbMF0sSGgoKSksdCldLEdsPShhLHQpPT5bYS5ydW4oRGUoYSx0WzBdLHFoKCkpLHQpXSxTaT0oYSx0KT0+W2EucnVuKERlKGEsdFswXSxqaCgpKSx0KV0sVWw9KGEsdCxvKT0+W2EucnVuKERlKGEsdFswXSxZaChvLmFscGhhKSxvLmNhY2hlS2V5KSx0KV0semw9YT0+ZWUoe2FscGhhOmEuYXR0cmlidXRlcy5nZXRGbG9hdChcImFscGhhXCIsLjAxKX0pLFZsPShhLHQpPT5bYS5ydW4oRGUoYSx0WzBdLFhoKCkpLHQpXSxXbD0oYSx0KT0+W2EucnVuKERlKGEsdFswXSxLaCgpKSx0KV0sSGw9KGEsdCk9PlthLnJ1bihEZShhLHRbMF0sSmgoKSksdCldLHFsPShhLHQpPT5bYS5ydW4oRGUoYSx0WzBdLF9pKCkpLHQpXSxqbD0oYSx0KT0+W2EucnVuKERlKGEsdFswXSxPaSgpKSx0KV0sWWw9KGEsdCk9PlthLnJ1bihEZShhLHRbMF0sWmgoKSksdCldLFhsPShhLHQpPT5bYS5ydW4oRGUoYSx0WzBdLFFoKCkpLHQpXSxLbD0oYSx0KT0+W2EucnVuKERlKGEsdFswXSxlbSgpKSx0KV0sSmw9KGEsdCk9PlthLnJ1bihEZShhLHRbMF0sdG0oKSksdCldfSk7ZnVuY3Rpb24gTnQoYSl7bGV0IHQ7c3dpdGNoKGEuYWN0aXZhdGlvbil7Y2FzZVwiUmVsdVwiOnQ9X2koKTticmVhaztjYXNlXCJTaWdtb2lkXCI6dD1PaSgpO2JyZWFrO2Nhc2VcIkNsaXBcIjp0PXZpKGEuY2xpcE1pbixhLmNsaXBNYXgpO2JyZWFrO2RlZmF1bHQ6cmV0dXJue2FjdGl2YXRpb25GdW5jdGlvbjpcIlwiLGFwcGx5QWN0aXZhdGlvbjpcIlwifX1sZXQgbz10Lm5hbWUsZT10LmJvZHkscj1gdmFsdWUgPSAke299Xyh2YWx1ZSk7YDtyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOmUsYXBwbHlBY3RpdmF0aW9uOnJ9fXZhciBNcix5cj1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZmUoKTtBaSgpO01yPWE9PntsZXQgdD1hLmdldFN0cmluZyhcImFjdGl2YXRpb25cIixcIlwiKTtpZih0PT09XCJDbGlwXCIpe2xldFtvLGVdPWEuZ2V0RmxvYXRzKFwiYWN0aXZhdGlvbl9wYXJhbXNcIixbaHIsbXJdKTtyZXR1cm57YWN0aXZhdGlvbjp0LGNsaXBNYXg6ZSxjbGlwTWluOm8sYWN0aXZhdGlvbkNhY2hlS2V5OmAke3R9OiR7b30sJHtlfWB9fXJldHVybnthY3RpdmF0aW9uOnQsYWN0aXZhdGlvbkNhY2hlS2V5OnR9fX0pO3ZhciBpbSxhbSxabCxRbD1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YXQoKTt4ZSgpO2FlKCk7bm8oKTt5cigpO2ltPShhLHQpPT4oe25hbWU6XCJHcm91cGVkQ29udlwiLGlucHV0TmFtZXM6YT9bXCJYXCIsXCJXXCIsXCJCaWFzXCJdOltcIlhcIixcIldcIl0saW5wdXRUeXBlczphP1swLDAsMF06WzAsMF0sY2FjaGVIaW50OnR9KSxhbT0oYSx0LG8sZSk9PntsZXQgbj10Lmxlbmd0aD4yP1widmFsdWUgKz0gZ2V0QmlhcyhvdXRwdXRfY2hhbm5lbCk7XCI6XCJcIixzPXRbMF0uZGltcy5zbGljZSgpLGk9dFsxXS5kaW1zLnNsaWNlKCksdT1pWzBdL2UuZ3JvdXA7Y2UudmVyYm9zZShcIkdyb3VwZWRDb252XCIsYGF1dHBQYWQ6JHtlLmF1dG9QYWR9LCBkaWxhdGlvbnM6JHtlLmRpbGF0aW9uc30sIGdyb3VwOiR7ZS5ncm91cH0sIGtlcm5lbFNoYXBlOiR7ZS5rZXJuZWxTaGFwZX0sIHBhZHM6JHtlLnBhZHN9LCBzdHJpZGVzOiR7ZS5zdHJpZGVzfWApO2xldCBsPUdyKHMsaSxlLmRpbGF0aW9ucyxlLnBhZHMsZS5zdHJpZGVzKSxmPXEoYS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLHthY3RpdmF0aW9uRnVuY3Rpb246cCxhcHBseUFjdGl2YXRpb246ZH09TnQoZSksVD1gXG4gIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMigke2Uuc3RyaWRlc1swXX0sICR7ZS5zdHJpZGVzWzFdfSk7XG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke2UucGFkc1swXX0sICR7ZS5wYWRzWzFdfSk7XG4gICR7cH1cbiAgdm9pZCBtYWluKCkge1xuICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xuICAgIGludCBvdXRwdXRfY2hhbm5lbCA9IGNvb3Jkcy55O1xuICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy56dyAqIHN0cmlkZXMgLSBwYWRzO1xuICAgIGludCBncm91cF9pZCA9IG91dHB1dF9jaGFubmVsIC8gJHt1fTtcblxuICAgIGZsb2F0IHZhbHVlID0gMC4wO1xuICAgIGZvciAoaW50IHdJbkNoYW5uZWwgPSAwOyB3SW5DaGFubmVsIDwgJHtpWzFdfTsgd0luQ2hhbm5lbCsrKSB7XG4gICAgICBpbnQgaW5wdXRfY2hhbm5lbCA9IGdyb3VwX2lkICogJHtpWzFdfSArIHdJbkNoYW5uZWw7XG4gICAgICBmb3IgKGludCB3SGVpZ2h0ID0gMDsgd0hlaWdodCA8ICR7aVsyXX07IHdIZWlnaHQrKykge1xuICAgICAgICBpbnQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqICR7ZS5kaWxhdGlvbnNbMF19O1xuXG4gICAgICAgIGlmICh4SGVpZ2h0IDwgMCB8fCB4SGVpZ2h0ID49ICR7c1syXX0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaW50IHdXaWR0aCA9IDA7IHdXaWR0aCA8ICR7aVszXX07IHdXaWR0aCsrKSB7XG4gICAgICAgICAgaW50IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogJHtlLmRpbGF0aW9uc1sxXX07XG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDAgfHwgeFdpZHRoID49ICR7c1szXX0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCBpbnB1dF9jaGFubmVsLCB4V2lkdGgsIHhIZWlnaHQpO1xuICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKG91dHB1dF9jaGFubmVsLCB3SW5DaGFubmVsLCB3V2lkdGgsIHdIZWlnaHQpO1xuICAgICAgICAgIHZhbHVlICs9IHhWYWwqd1ZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAke259XG4gICAgJHtkfVxuICAgICR7Zi5vdXRwdXR9ID0gdmVjNCh2YWx1ZSwgLjAsIC4wLCAuMCk7XG4gIH1cbmA7cmV0dXJuey4uLm8sb3V0cHV0OntkaW1zOmwsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6MH0sc2hhZGVyU291cmNlOlQsaGFzTWFpbjohMH19LFpsPShhLHQsbyk9PntsZXQgZT1pbSh0Lmxlbmd0aD4yLG8uY2FjaGVLZXkpO3JldHVybnsuLi5lLGdldDooKT0+YW0oYSx0LGUsbyl9fX0pO3ZhciBzbSx1bSxlZix0Zj1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eGUoKTthZSgpO2dyKCk7c209YT0+KHtuYW1lOlwiSW0yQ29sIChwYWNrZWQpXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6WzJdLGNhY2hlSGludDphfSksdW09KGEsdCxvLGUscixuKT0+e2xldCBzPW8uZGltcyxpPWUuZGltcyx1PTIsbD0zLGY9ci5sZW5ndGgscD1baVsxXSppWzJdKmlbM10sclsyXSpyWzNdXSxkPWlbMl0qaVszXSxUPUJ0KCksdj1xKGEuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx3PVwiXCI7Zm9yKGxldCBMPTA7TDw9MTtMKyspZm9yKGxldCBGPTA7Rjw9MTtGKyspdys9YFxuICAgICAgICAgICAgYmxvY2tJbmRleCA9IHJjLnggKyAke0Z9O1xuICAgICAgICAgICAgcG9zID0gcmMueSArICR7TH07XG5cbiAgICAgICAgICAgIGlmKGJsb2NrSW5kZXggPCAke3BbMV19ICYmIHBvcyA8ICR7cFswXX0pIHtcbiAgICAgICAgICAgICAgb2Zmc2V0WSA9IGludChibG9ja0luZGV4IC8gKCR7cltmLTFdfSkpICogJHtuLnN0cmlkZXNbMF19IC1cbiAgICAgICAgICAgICAgICAke24ucGFkc1swXX07XG4gICAgICAgICAgICAgIGQwID0gb2Zmc2V0WSArICR7bi5kaWxhdGlvbnNbMF19ICogKGltb2QocG9zLCAke2R9KSAvICR7aVsyXX0pO1xuXG4gICAgICAgICAgICAgIGlmKGQwIDwgJHtzW3VdfSAmJiBkMCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0WCA9IGltb2QoYmxvY2tJbmRleCwgJHtyW2YtMV19KSAqICR7bi5zdHJpZGVzWzFdfSAtXG4gICAgICAgICAgICAgICAgICAke24ucGFkc1sxXX07XG4gICAgICAgICAgICAgICAgZDEgPSBvZmZzZXRYICsgJHtuLmRpbGF0aW9uc1sxXX0gKiBpbW9kKGltb2QocG9zLCAke2R9KSwgJHtpWzJdfSk7XG5cbiAgICAgICAgICAgICAgICBpZihkMSA8ICR7c1tsXX0gJiYgZDEgPj0gMCkge1xuXG4gICAgICAgICAgICAgICAgICBjaCA9IGludChmbG9hdChwb3MpLyAke2R9Lik7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyRGltcyA9IHZlYzIoZDAsIGQxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0WyR7TCoyK0Z9XSA9IGdldENoYW5uZWwoXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0QSgwLCBjaCwgaW50KGlubmVyRGltcy54KSxcbiAgICAgICAgICAgICAgICAgICAgICBpbnQoaW5uZXJEaW1zLnkpKSwgaW5uZXJEaW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGA7bGV0IEk9YFxuICAgICAgJHtUfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMyIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuMCk7XG4gICAgICAgICAgaW50IGJsb2NrSW5kZXgsIHBvcywgb2Zmc2V0WSwgZDAsIG9mZnNldFgsIGQxLCBjaDtcbiAgICAgICAgICB2ZWMyIGlubmVyRGltcztcbiAgICAgICAgICAke3d9XG4gICAgICAgICAgJHt2Lm91dHB1dH0gPSByZXN1bHQ7XG4gICAgICB9XG4gICAgICAgICAgICBgO3JldHVybnsuLi50LG91dHB1dDp7ZGltczpwLHR5cGU6by50eXBlLHRleHR1cmVUeXBlOjJ9LHNoYWRlclNvdXJjZTpJLGhhc01haW46ITB9fSxlZj0oYSx0LG8sZSxyKT0+e2xldCBuPXNtKHIuY2FjaGVLZXkpO3JldHVybnsuLi5uLGdldDooKT0+dW0oYSxuLHQsbyxlLHIpfX19KTtmdW5jdGlvbiBmbShhLHQsbyl7bGV0IGU9dFswXS5kaW1zLHI9dFsxXS5kaW1zLG49S2UuY2FsY1NoYXBlKGUsciwhMCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtsZXQgcz1KZShuLmxlbmd0aCksaT1PdCgpLHthY3RpdmF0aW9uRnVuY3Rpb246dSxhcHBseUFjdGl2YXRpb246bH09TnQobyksZj10Lmxlbmd0aD4yLHA9Zj9cInZhbHVlICs9IGdldEJpYXNGb3JNYXRtdWwoKTtcIjpcIlwiLGQ9Zj9gJHtFaShzLGksdFsyXS5kaW1zLG4sITEpfWA6XCJcIixUPW4ubGVuZ3RoLHY9ZS5sZW5ndGgsdz1yLmxlbmd0aCxJPWVbZS5sZW5ndGgtMV0sTD1gXG4gICAgJHt1fVxuICAgICR7ZH1cbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7VH1dKSB7XG4gICAgICAgIGludCBhWyR7dn1dO1xuICAgICAgICBpbnQgYlske3d9XTtcbiAgICAgICAgYmNhc3RNYXRtdWxJbmRpY2VzX0EoaW5kaWNlcywgYSk7XG4gICAgICAgIGJjYXN0TWF0bXVsSW5kaWNlc19CKGluZGljZXMsIGIpO1xuXG4gICAgICAgIGZsb2F0IHZhbHVlO1xuICAgICAgICBmb3IgKGludCBrPTA7IGs8JHtJfTsgKytrKSB7XG4gICAgICAgICAgICBhWyR7di0xfV0gPSBrO1xuICAgICAgICAgICAgYlske3ctMn1dID0gaztcbiAgICAgICAgICAgIHZhbHVlICs9IF9BKGEpICogX0IoYik7XG4gICAgICAgIH1cbiAgICAgICAgJHtwfVxuICAgICAgICAke2x9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9YDtyZXR1cm57Li4uYSxvdXRwdXQ6e2RpbXM6bix0eXBlOnRbMF0udHlwZSx0ZXh0dXJlVHlwZTowfSxzaGFkZXJTb3VyY2U6TH19ZnVuY3Rpb24gUGkoYSx0KXtsZXQgbz1sbShhLmxlbmd0aD4yLHQuYWN0aXZhdGlvbkNhY2hlS2V5KTtyZXR1cm57Li4ubyxnZXQ6KCk9PmZtKG8sYSx0KX19ZnVuY3Rpb24gRWkoYSx0LG8sZSxyKXtsZXQgbj1cIlwiLHM9by5sZW5ndGgsaT1lLmxlbmd0aCx1PWktcztpPDImJnM+MD9uPVwiY29vcmRzXCI6bj1vLm1hcCgodyxJKT0+YGNvb3Jkcy4ke3RbSSt1XX1gKS5qb2luKFwiLCBcIik7bGV0IGY9S2UuZ2V0QnJvYWRjYXN0RGltcyhvLGUpLm1hcCh3PT5gY29vcmRzLiR7dFt3K3VdfSA9IDA7YCkuam9pbihgXG5gKSxkPVUuc2l6ZShvKT09PTEsVD1cInZlYzQob3V0cHV0VmFsdWUueHgsIG91dHB1dFZhbHVlLnl5KVwiO3JldHVybiBkJiYoVD1cInZlYzQob3V0cHV0VmFsdWUueClcIikscj9gXG52ZWM0IGdldEJpYXNGb3JNYXRtdWwoKSB7XG4gICR7YX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICR7Zn1cbiAgdmVjNCBvdXRwdXRWYWx1ZSA9IGdldEJpYXMoJHtufSk7XG4gIHJldHVybiAke1R9O1xufWA6YFxuZmxvYXQgZ2V0Qmlhc0Zvck1hdG11bCgpIHtcbiAgJHthfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgJHtmfVxuICByZXR1cm4gZ2V0Qmlhcyhjb29yZHMueCk7XG59YH12YXIgcmYsbmYsbG0sY20sb289RSgoKT0+e1widXNlIHN0cmljdFwiO2ZlKCk7YWUoKTtrdCgpO3lyKCk7RGkoKTtyZj0oYSx0LG8pPT4oY20odCksYS5zZXNzaW9uLnBhY2s/W2EucnVuKGlvKGEsdCxvKSx0KV06W2EucnVuKFBpKHQsbyksdCldKSxuZj1hPT5NcihhLmF0dHJpYnV0ZXMpLGxtPShhLHQpPT4oe25hbWU6XCJNYXRNdWxcIixpbnB1dE5hbWVzOmE/W1wiQVwiLFwiQlwiLFwiQmlhc1wiXTpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6YT9bMCwwLDBdOlswLDBdLGNhY2hlSGludDp0fSk7Y209YT0+e2lmKCFhfHxhLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiTWF0TXVsIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihhWzBdLmRpbXNbYVswXS5kaW1zLmxlbmd0aC0xXSE9PWFbMV0uZGltc1thWzFdLmRpbXMubGVuZ3RoLTJdKXRocm93IG5ldyBFcnJvcihcInNoYXJlZCBkaW1lbnNpb24gZG9lcyBub3QgbWF0Y2guXCIpO2lmKGFbMF0udHlwZSE9PVwiZmxvYXQzMlwiJiZhWzBdLnR5cGUhPT1cImZsb2F0NjRcInx8YVsxXS50eXBlIT09XCJmbG9hdDMyXCImJmFbMV0udHlwZSE9PVwiZmxvYXQ2NFwiKXRocm93IG5ldyBFcnJvcihcImlucHV0cyBzaG91bGQgYmUgZmxvYXQgdHlwZVwiKTtpZihhWzBdLnR5cGUhPT1hWzFdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRzIHR5cGVzIHNob3VsZCBtYXRjaFwiKX19KTtmdW5jdGlvbiBobShhLHQsbyxlKXtsZXQgcj1bXSxuPVtdLHM9b1swXS5kaW1zLGk9b1sxXS5kaW1zLHU9cy5sZW5ndGgsbD1pLmxlbmd0aCxmPWUubGVuZ3RoLHA9Zi11LGQ9Zi1sO3I9cy5tYXAoKEMsWSk9PmBjb29yZHMuJHt0W1krcF19YCksclt1LTFdPVwiaSoyXCIsci5qb2luKFwiLCBcIiksbj1pLm1hcCgoQyxZKT0+YGNvb3Jkcy4ke3RbWStkXX1gKSxuW2wtMl09XCJpKjJcIixuLmpvaW4oXCIsIFwiKTtsZXQgVD1LZS5nZXRCcm9hZGNhc3REaW1zKHMsZSksdj1LZS5nZXRCcm9hZGNhc3REaW1zKGksZSksdz1ULm1hcChDPT5gY29vcmRzLiR7dFtDK3BdfSA9IDA7YCkuam9pbihgXG5gKSxJPXYubWFwKEM9PmBjb29yZHMuJHt0W0MrZF19ID0gMDtgKS5qb2luKGBcbmApLEw9YGludCBsYXN0RGltID0gY29vcmRzLiR7dFtmLTFdfTtcbiAgY29vcmRzLiR7dFtmLTFdfSA9IGNvb3Jkcy4ke3RbZi0yXX07XG4gIGNvb3Jkcy4ke3RbZi0yXX0gPSBsYXN0RGltO2A7cmV0dXJuYFxudmVjNCBnZXRBQXRPdXRDb29yZHNNYXRtdWwoaW50IGkpIHtcbiAgJHthfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgJHtMfVxuICAke3d9XG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRBKCR7cn0pO1xuICByZXR1cm4gb3V0cHV0VmFsdWU7XG59XG5cbnZlYzQgZ2V0QkF0T3V0Q29vcmRzTWF0bXVsKGludCBpKSB7XG4gICR7YX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICR7TH1cbiAgJHtJfVxuICB2ZWM0IG91dHB1dFZhbHVlID0gZ2V0Qigke259KTtcbiAgcmV0dXJuIG91dHB1dFZhbHVlO1xufWB9ZnVuY3Rpb24gbW0oYSx0KXtsZXQgbz1cIlwiO2ZvcihsZXQgZT0wO2U8dC0yO2UrKylvKz1gcmMuJHthW2VdfSwgYDtyZXR1cm4gbys9YHJjLiR7YVt0LTJdfSwgaSoyYCxvfWZ1bmN0aW9uIGJtKGEsdCl7bGV0IG89XCJcIjtmb3IobGV0IGU9MDtlPHQtMjtlKyspbys9YHJjLiR7YVtlXX0sIGA7cmV0dXJuIG8rPWBpKjIsIHJjLiR7YVt0LTFdfWAsb312YXIgcG0sZG0saW8sRGk9RSgoKT0+e1widXNlIHN0cmljdFwiO2ZlKCk7eGUoKTthZSgpO2t0KCk7eXIoKTtvbygpO3BtPShhLHQpPT4oe25hbWU6XCJNYXRNdWwgKHBhY2tlZClcIixpbnB1dE5hbWVzOmE/W1wiQVwiLFwiQlwiLFwiQmlhc1wiXTpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6YT9bMiwyLDJdOlsyLDJdLGNhY2hlSGludDp0fSksZG09KGEsdCxvLGUpPT57bGV0IHI9by5sZW5ndGg+MixuPXI/XCJ2YWx1ZSArPSBnZXRCaWFzRm9yTWF0bXVsKCk7XCI6XCJcIixzPW9bMF0uZGltcyxpPW9bMV0uZGltcyx1PUtlLmNhbGNTaGFwZShzLGksITApLGw9IVUuYXJlRXF1YWwob1swXS5kaW1zLG9bMV0uZGltcyk7aWYoIXUpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtsZXQgZj1zW3MubGVuZ3RoLTFdLHA9TWF0aC5jZWlsKGYvMiksZD1zLmxlbmd0aCxUPWkubGVuZ3RoLHY9cShhLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksdz1KZSh1Lmxlbmd0aCksST11Lmxlbmd0aCxMPU90KCkse2FjdGl2YXRpb25GdW5jdGlvbjpGLGFwcGx5QWN0aXZhdGlvbjpDfT1OdChlKSxZPXI/YCR7RWkodyxMLG9bMl0uZGltcyx1LCEwKX1gOlwiXCIsaj1sP2Ake2htKHcsTCxvLHUpfWA6XCJcIixNPWw/XCJnZXRBQXRPdXRDb29yZHNNYXRtdWwoaSlcIjpgZ2V0QSgke21tKEwsZCl9KWAsaWU9bD9cImdldEJBdE91dENvb3Jkc01hdG11bChpKVwiOmBnZXRCKCR7Ym0oTCxUKX0pYCxvdD1sP1wiXCI6YCR7d30gcmMgPVxuICAgICAgICAgIGdldE91dHB1dENvb3JkcygpOyBpbnQgbGFzdERpbSA9IHJjLiR7TFtJLTFdfTsgcmMuJHtMW0ktMV19ID1cbiAgICAgICAgICByYy4ke0xbSS0yXX07IHJjLiR7TFtJLTJdfSA9IGxhc3REaW07XG4gICAgICBgLFdlPWBcbiAgICAgICAgICAgICR7an1cbiAgICAgICAgICAgICR7WX1cbiAgICAgICAgICAgICR7Rn1cbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgJHtvdH1cblxuICAgICAgICAgICAgICB2ZWM0IHZhbHVlID0gdmVjNCgwKTtcbiAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke3B9OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2ZWM0IGEgPSAke019O1xuICAgICAgICAgICAgICAgIHZlYzQgYiA9ICR7aWV9O1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gKGEucnJiYiAqIGIucmdyZyk7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gKGEuZ2dhYSAqIGIuYmFiYSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHtufVxuICAgICAgICAgICAgICAke0N9XG4gICAgICAgICAgICAgICR7di5vdXRwdXR9ID0gdmFsdWU7XG4gICAgICAgICAgICB9YDtyZXR1cm57Li4udCxvdXRwdXQ6e2RpbXM6dSx0eXBlOm9bMF0udHlwZSx0ZXh0dXJlVHlwZToyfSxzaGFkZXJTb3VyY2U6V2UsaGFzTWFpbjohMH19LGlvPShhLHQsbyk9PntsZXQgZT1wbSh0Lmxlbmd0aD4yLG8uYWN0aXZhdGlvbkNhY2hlS2V5KTtyZXR1cm57Li4uZSxnZXQ6KCk9PmRtKGEsZSx0LG8pfX19KTt2YXIgb2YsYWY9RSgoKT0+e1widXNlIHN0cmljdFwiO25vKCk7dGYoKTtEaSgpO29mPShhLHQsbyk9PntsZXQgZT10WzBdLmRpbXMscj10WzFdLmRpbXMsbj1HcihlLHIsby5kaWxhdGlvbnMsby5wYWRzLG8uc3RyaWRlcykscz1hLnJ1bihlZihhLHRbMF0sdFsxXSxuLG8pLFt0WzBdXSksaT1hLnJlc2hhcGVQYWNrZWQodFsxXSxbclswXSxyWzFdKnJbMl0qclszXV0pLHU9dC5sZW5ndGg9PT0zP1tpLHMsdFsyXV06W2ksc10sbD1hLnJ1bihpbyhhLHUsbyksdSk7cmV0dXJuIGEucmVzaGFwZVBhY2tlZChsLG4pfX0pO3ZhciBnbSx5bSxzZixMaSxGaT1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YWUoKTtnbT1hPT4oe25hbWU6XCJJbTJDb2xcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbMF0sY2FjaGVIaW50OmF9KSx5bT0oYSx0LG8sZSxyLG4pPT57bGV0IHM9by5kaW1zLGk9ZS5kaW1zLHU9ci5sZW5ndGgsbD1MaShzLGksciw0KSxmPWBcbiAgICAgICAgY29uc3QgaW50IFhDID0gJHtzWzFdfTtcbiAgICAgICAgY29uc3QgaW50IFhIID0gJHtzWzJdfTtcbiAgICAgICAgY29uc3QgaW50IFhXID0gJHtzWzNdfTtcbiAgICAgICAgY29uc3QgaW50IEtIID0gJHtuLmtlcm5lbFNoYXBlWzBdfTtcbiAgICAgICAgY29uc3QgaW50IEtXID0gJHtuLmtlcm5lbFNoYXBlWzFdfTtcbiAgICAgICAgY29uc3QgaW50IGRpbGF0aW9uSCA9ICR7bi5kaWxhdGlvbnNbMF19O1xuICAgICAgICBjb25zdCBpbnQgZGlsYXRpb25XID0gJHtuLmRpbGF0aW9uc1sxXX07XG4gICAgICAgIGNvbnN0IGludCBzdHJpZGVIID0gJHtuLnN0cmlkZXNbMF19O1xuICAgICAgICBjb25zdCBpbnQgc3RyaWRlVyA9ICR7bi5zdHJpZGVzWzFdfTtcbiAgICAgICAgY29uc3QgaW50IHBhZEggPSAke24ucGFkc1swXX07XG4gICAgICAgIGNvbnN0IGludCBwYWRXID0gJHtuLnBhZHNbMV19O1xuICAgICAgICBjb25zdCBpbnQgS0hLVyA9IEtIKktXO1xuICAgICAgICBjb25zdCBpbnQgWENLSEtXID0gWEMgKiBLSEtXO1xuICAgICAgICBjb25zdCBpbnQgb3V0cHV0Q2hhbm5lbHMgPSA0O1xuICAgICAgICB2ZWM0IHByb2Nlc3MoaW50IGluZGljZXNbJHt1fV0pIHtcbiAgICAgICAgICBpbnQgYiAgPSBpbmRpY2VzWzBdOyAvLyBiYXRjaCBzaXplXG4gICAgICAgICAgaW50IG9oID0gaW5kaWNlc1sxXSAqIHN0cmlkZUggLSBwYWRIOyAvL291dHB1dCBoZWlnaHRcbiAgICAgICAgICBpbnQgb3cgPSBpbmRpY2VzWzJdICogc3RyaWRlVyAtIHBhZFc7IC8vb3V0cHV0IHdpZHRoXG4gICAgICAgICAgaW50IHAgPSBpbmRpY2VzWzNdICogb3V0cHV0Q2hhbm5lbHM7IC8vcGF0Y2hcbiAgICAgICAgICB2ZWM0IHZhbHVlID0gdmVjNCgwLjApO1xuICAgICAgICAgIGZvcihpbnQgaT0wOyBpIDwgb3V0cHV0Q2hhbm5lbHM7ICsraSkge1xuICAgICAgICAgICAgaWYocCA8IFhDS0hLVykge1xuICAgICAgICAgICAgICBpbnQgcGF0Y2hDID0gcCAvIEtIS1c7XG4gICAgICAgICAgICAgIGludCBwYXRjaEggPSAocCAtIHBhdGNoQypLSEtXKSAvIEtXO1xuICAgICAgICAgICAgICBpbnQgcGF0Y2hXID0gKHAgLSBwYXRjaEMqS0hLVykgLSBwYXRjaEggKiBLVztcbiAgICAgICAgICAgICAgaW50IHhoMiA9IG9oICsgcGF0Y2hIICogZGlsYXRpb25IO1xuICAgICAgICAgICAgICBpbnQgeHcyID0gb3cgKyBwYXRjaFcgKiBkaWxhdGlvblc7XG4gICAgICAgICAgICAgIGludCB4WyR7cy5sZW5ndGh9XTtcbiAgICAgICAgICAgICAgeFswXSA9IGI7XG4gICAgICAgICAgICAgIHhbMV0gPSBwYXRjaEM7XG4gICAgICAgICAgICAgIHhbMl0gPSB4aDI7XG4gICAgICAgICAgICAgIHhbM10gPSB4dzI7XG4gICAgICAgICAgICAgIGlmKHhoMiA+PSAwICYmXG4gICAgICAgICAgICAgICAgICB4aDIgPCBYSCAmJlxuICAgICAgICAgICAgICAgICAgeHcyID49IDAgJiZcbiAgICAgICAgICAgICAgICAgIHh3MiA8IFhXKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbaV0gPSBfWCh4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgYDtyZXR1cm57Li4udCxvdXRwdXQ6e2RpbXM6bCx0eXBlOm8udHlwZSx0ZXh0dXJlVHlwZTo0fSxzaGFkZXJTb3VyY2U6Zn19LHNmPShhLHQsbyxlLHIpPT57bGV0IG49Z20oci5jYWNoZUtleSk7cmV0dXJuey4uLm4sZ2V0OigpPT55bShhLG4sdCxvLGUscil9fSxMaT0oYSx0LG8sZT00KT0+W29bMF0sb1syXSxvWzNdLE1hdGguY2VpbChhWzFdKnRbMl0qdFszXS9lKV19KTt2YXIgVG0seG0sdWYsbGY9RSgoKT0+e1widXNlIHN0cmljdFwiO2ZlKCk7eGUoKTthZSgpO3lyKCk7RmkoKTtUbT0oYSx0KT0+KHtuYW1lOlwiQ29udkRvdFByb2R1Y3RcIixpbnB1dE5hbWVzOmE/W1wiSW0yQ29sXCIsXCJLXCIsXCJCXCJdOltcIkltMkNvbFwiLFwiS1wiXSxpbnB1dFR5cGVzOmE/WzAsNCwwXTpbMCw0XSxjYWNoZUtleTp0LmFjdGl2YXRpb25DYWNoZUtleX0pLHhtPShhLHQsbyxlLHIpPT57bGV0IG49b1swXS5kaW1zLHM9b1sxXS5kaW1zLGk9W3NbMF0sTWF0aC5jZWlsKG5bMV0qc1syXSpzWzNdLzQpXSx1PUxpKG4scyxlKSxbbCxmXT1hLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChpLDQpLHA9VS5jb21wdXRlU3RyaWRlcyh1KSxbZCxUXT1hLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh1LDQpLHY9ZS5sZW5ndGgsdz1vLmxlbmd0aDwzP1wiMC4wXCI6XCJfQihiKVwiLEk9TWF0aC5jZWlsKG5bMV0qc1syXSpzWzNdLzQpLHthY3RpdmF0aW9uRnVuY3Rpb246TCxhcHBseUFjdGl2YXRpb246Rn09TnQociksQz1xKGEuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxZPWBcbiR7TH1cbmZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHt2fV0pIHtcbiAgaW50IGJbMV07XG4gIGJbMF0gPSBpbmRpY2VzWzFdO1xuICBpbnQgaW0yY29sWzRdO1xuICBpbTJjb2xbMF0gPSBpbmRpY2VzWzBdO1xuICBpbTJjb2xbMV0gPSBpbmRpY2VzWzJdO1xuICBpbTJjb2xbMl0gPSBpbmRpY2VzWzNdO1xuICBpbnQgaW0yY29sT2Zmc2V0ID0gaW0yY29sWzBdICogJHtwWzBdfSArIGltMmNvbFsxXSAqICR7cFsxXX0gKyBpbTJjb2xbMl0gKiAke3BbMl19O1xuICBpbnQga2VybmVsT2Zmc2V0ID0gaW5kaWNlc1sxXSAqICR7aVsxXX07XG4gIGZsb2F0IHZhbHVlID0gJHt3fTtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCAke0l9OyArK2kpIHtcbiAgICB2ZWMyIGltMmNvbENvb3JkcyA9IG9mZnNldFRvQ29vcmRzKGltMmNvbE9mZnNldCwgJHtkfSwgJHtUfSk7XG4gICAgdmVjMiBrZXJuZWxDb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhrZXJuZWxPZmZzZXQsICR7bH0sICR7Zn0pO1xuICAgIHZhbHVlICs9IGRvdCgke0MudGV4dHVyZTJEfShJbTJDb2wsIGltMmNvbENvb3JkcyksICR7Qy50ZXh0dXJlMkR9KEssIGtlcm5lbENvb3JkcykpO1xuICAgICsraW0yY29sT2Zmc2V0O1xuICAgICsra2VybmVsT2Zmc2V0O1xuICB9XG4gICR7Rn1cbiAgcmV0dXJuIHZhbHVlO1xufWA7cmV0dXJuey4uLnQsb3V0cHV0OntkaW1zOmUsdHlwZTpvWzBdLnR5cGUsdGV4dHVyZVR5cGU6MH0sc2hhZGVyU291cmNlOll9fSx1Zj0oYSx0LG8sZSk9PntsZXQgcj1UbSh0Lmxlbmd0aD4yLGUpO3JldHVybnsuLi5yLGdldDooKT0+eG0oYSxyLHQsbyxlKX19fSk7dmFyIEdyLENpLHdtLHZtLF9tLE9tLCRpLEltLG5vPUUoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO2ZlKCk7UWwoKTthZigpO2xmKCk7eXIoKTtGaSgpO29vKCk7R3I9KGEsdCxvLGUscik9PntsZXQgbj1hWzBdLHM9YS5zbGljZSgyKSxpPXMubGVuZ3RoLHU9dFswXSxmPXQuc2xpY2UoMikubWFwKCh2LHcpPT52Kyh2LTEpKihvW3ddLTEpKSxkPXMubWFwKCh2LHcpPT52K2Vbd10rZVt3K2ldKS5tYXAoKHYsdyk9Pk1hdGguZmxvb3IoKHYtZlt3XStyW3ddKS9yW3ddKSk7cmV0dXJuW24sdV0uY29uY2F0KC4uLmQpfSxDaT0oYSx0LG8pPT4oSW0odCxvKSx3bShhLHQsbykpLHdtPShhLHQsbyk9PntsZXQgZT1PbShvLHQpLHI9YS5zZXNzaW9uLnBhY2ssbj1lLmtlcm5lbFNoYXBlWzBdPT09MSYmZS5rZXJuZWxTaGFwZVsxXT09PTE7cmV0dXJuIGUuZ3JvdXA+MT9bYS5ydW4oWmwoYSx0LGUpLHQpXTpuJiZyP1t2bShhLHQsZSldOnImJnRbMF0uZGltcy5sZW5ndGg9PT00JiZ0WzBdLmRpbXNbMF09PT0xJiYhbj9bb2YoYSx0LGUpXTpbX20oYSx0LGUpXX0sdm09KGEsdCxvKT0+e2xldCBlPXRbMF0uZGltcyxyPXRbMV0uZGltcyxuPUdyKGUscixvLmRpbGF0aW9ucyxvLnBhZHMsby5zdHJpZGVzKSxzPWEucmVzaGFwZVVucGFja2VkKHRbMF0sW2VbMV0sZVsyXSplWzNdXSksaT1hLnJlc2hhcGVVbnBhY2tlZCh0WzFdLFtyWzBdLHJbMV1dKSx1PXQubGVuZ3RoPjI/W2kscyx0WzJdXTpbaSxzXSxsPWEucnVuKFBpKHUsbyksdSk7cmV0dXJuIGEucmVzaGFwZVVucGFja2VkKGwsbil9LF9tPShhLHQsbyk9PntsZXQgZT10WzBdLmRpbXMscj10WzFdLmRpbXMsbj1HcihlLHIsby5kaWxhdGlvbnMsby5wYWRzLG8uc3RyaWRlcykscz1hLnJ1bihzZihhLHRbMF0sdFsxXSxuLG8pLFt0WzBdXSksaT10Lmxlbmd0aD09PTM/W3MsdFsxXSx0WzJdXTpbcyx0WzFdXTtyZXR1cm4gYS5ydW4odWYoYSx0LG4sbyksaSl9LE9tPShhLHQpPT57bGV0IG89YS5rZXJuZWxTaGFwZS5zbGljZSgpO2lmKGEua2VybmVsU2hhcGUubGVuZ3RoPT09MClmb3IobGV0IG49MjtuPHRbMV0uZGltcy5sZW5ndGg7KytuKW8ucHVzaCh0WzFdLmRpbXNbbl0pO2xldCBlPWEucGFkcy5zbGljZSgpO2RyLmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0WzBdLmRpbXMsYS5zdHJpZGVzLGEuZGlsYXRpb25zLG8sZSxhLmF1dG9QYWQpO2xldCByPU9iamVjdC5hc3NpZ24oe30sYSk7cmV0dXJuIE9iamVjdC5hc3NpZ24ocix7a2VybmVsU2hhcGU6byxwYWRzOmUsY2FjaGVLZXk6YS5jYWNoZUtleX0pLHJ9LCRpPWE9PntsZXQgdD1hLmF0dHJpYnV0ZXMsbz1Ncih0KSxlPXQuZ2V0U3RyaW5nKFwiYXV0b19wYWRcIixcIk5PVFNFVFwiKSxyPXQuZ2V0SW50cyhcImRpbGF0aW9uc1wiLFsxLDFdKSxuPXQuZ2V0SW50KFwiZ3JvdXBcIiwxKSxzPXQuZ2V0SW50cyhcImtlcm5lbF9zaGFwZVwiLFtdKSxpPXQuZ2V0SW50cyhcInBhZHNcIixbMCwwLDAsMF0pLHU9dC5nZXRJbnRzKFwic3RyaWRlc1wiLFsxLDFdKTtyZXR1cm4gZWUoe2F1dG9QYWQ6ZSxkaWxhdGlvbnM6cixncm91cDpuLGtlcm5lbFNoYXBlOnMscGFkczppLHN0cmlkZXM6dSwuLi5vfSl9LEltPShhLHQpPT57aWYoIWF8fGEubGVuZ3RoIT09MiYmYS5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZihhWzBdLmRpbXMubGVuZ3RoIT09NHx8YVsxXS5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG9ubHkgc3VwcG9ydCAyLWRpbWVuc2lvbmFsIGNvbnZcIik7bGV0IG89YVswXS5kaW1zWzFdLGU9YVsxXS5kaW1zWzFdKnQuZ3JvdXA7aWYobyE9PWUpdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtpZihhLmxlbmd0aD09PTMmJihhWzJdLmRpbXMubGVuZ3RoIT09MXx8YVsxXS5kaW1zWzBdIT09YVsyXS5kaW1zWzBdKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJpYXNcIik7bGV0IHI9YVswXS5kaW1zLmxlbmd0aC0yO2lmKHQuZGlsYXRpb25zLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7cn1EYCk7aWYodC5zdHJpZGVzLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3J9RGApO2lmKHQucGFkcy5sZW5ndGghPT1yKjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke3IqMn1EYCk7aWYodC5rZXJuZWxTaGFwZS5sZW5ndGghPT0wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PWFbMV0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtlcm5lbCBzaGFwZVwiKTtpZihhWzBdLnR5cGUhPT1cImZsb2F0MzJcInx8YVsxXS50eXBlIT09XCJmbG9hdDMyXCIpdGhyb3cgbmV3IEVycm9yKFwiQ29udiBpbnB1dChYLFcpIHNob3VsZCBiZSBmbG9hdCB0ZW5zb3JcIik7aWYoYS5sZW5ndGg9PT0zJiZhWzJdLnR5cGUhPT1cImZsb2F0MzJcIil0aHJvdyBuZXcgRXJyb3IoXCJDb252IGlucHV0KGJpYXMpIHNob3VsZCBiZSBmbG9hdCB0ZW5zb3JcIil9fSk7dmFyIFNtLEFtLFBtLGZmLEVtLERtLExtLEZtLENtLCRtLGNmLGttLHBmPUUoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO3hlKCk7YWUoKTt5cigpO1NtPShhLHQsbyxlLHIsbik9PihhLTEpKnQrbysoZS0xKSpyKzEtbixBbT0oYSx0LG8sZSxyKT0+e2xldCBuPU1hdGguZmxvb3IoYS8yKTt0PT09XCJTQU1FX1VQUEVSXCI/KG9bZV09bixvW3JdPWEtbik6dD09PVwiU0FNRV9MT1dFUlwiJiYob1tlXT1hLW4sb1tyXT1uKX0sUG09KGEsdCxvLGUscixuLHMsaSk9PntsZXQgdT1hLmxlbmd0aC0yLGw9aS5sZW5ndGg9PT0wO2ZvcihsZXQgZj0wO2Y8dTsrK2Ype2xldCBwPWw/YVtmKzJdKm5bZl06aVtmXSxkPVNtKGFbZisyXSxuW2ZdLHJbZl0sdFtmXSxvW2ZdLHApO0FtKGQsZSxyLGYsZit1KSxsJiZpLnB1c2gobltmXSooYVtmKzJdLTEpK3NbZl0rKHRbZl0tMSkqb1tmXSsxLXJbZl0tcltmK3VdKX19LGZmPShhLHQsbyk9PihrbSh0LG8pLEVtKGEsdCxvKSksRW09KGEsdCxvKT0+e2xldCBlPSRtKG8sdCk7cmV0dXJuW0NtKGEsdCxlKV19LERtPShhLHQpPT4oe25hbWU6XCJDb252VHJhbnNwb3NlXCIsaW5wdXROYW1lczphP1tcIlhcIixcIldcIixcIkJcIl06W1wiWFwiLFwiV1wiXSxpbnB1dFR5cGVzOmE/WzAsMCwwXTpbMCwwXSxjYWNoZUhpbnQ6dH0pLExtPShhLHQsbyxlKT0+e2xldCBuPXQubGVuZ3RoPjI/XCJnZXRCKG91dHB1dF9jaGFubmVsKVwiOlwiMC4wXCIscz10WzBdLmRpbXMsaT10WzFdLmRpbXMsdT1pWzFdLGw9aVswXS9lLmdyb3VwLGY9W3RbMF0uZGltc1swXSx0WzFdLmRpbXNbMV0qZS5ncm91cCwuLi5lLm91dHB1dFNoYXBlXSxwPXEoYS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLHthY3RpdmF0aW9uRnVuY3Rpb246ZCxhcHBseUFjdGl2YXRpb246VH09TnQoZSksdj1gXG4gIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMigke2Uuc3RyaWRlc1swXX0sICR7ZS5zdHJpZGVzWzFdfSk7XG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke2UucGFkc1swXX0sICR7ZS5wYWRzWzFdfSk7XG4gICR7ZH1cbiAgdm9pZCBtYWluKCkge1xuICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xuICAgIGludCBvdXRwdXRfY2hhbm5lbCA9IGNvb3Jkcy55O1xuXG4gICAgaXZlYzIgbG9jID0gY29vcmRzLnp3ICsgcGFkcztcblxuICAgIGludCBncm91cF9pZCA9IG91dHB1dF9jaGFubmVsIC8gJHt1fTtcbiAgICBpbnQgd091dENoYW5uZWwgPSBvdXRwdXRfY2hhbm5lbCAtIGdyb3VwX2lkICogJHt1fTtcblxuICAgIGZsb2F0IHZhbHVlID0gJHtufTtcbiAgICBmb3IgKGludCBpbkNoYW5uZWxPZmZzZXQgPSAwOyBpbkNoYW5uZWxPZmZzZXQgPCAke2x9OyBpbkNoYW5uZWxPZmZzZXQrKykge1xuICAgICAgaW50IGlucHV0X2NoYW5uZWwgPSBncm91cF9pZCAqICR7bH0gKyBpbkNoYW5uZWxPZmZzZXQ7XG4gICAgICBmb3IgKGludCB3V09mZiA9IDA7IHdXT2ZmIDwgJHtpWzJdfTsgd1dPZmYrKykge1xuICAgICAgICBmb3IgKGludCB3SE9mZiA9IDA7IHdIT2ZmIDwgJHtpWzNdfTsgd0hPZmYrKykge1xuICAgICAgICAgIGl2ZWMyIHdPZmYgPSBpdmVjMih3V09mZiAqICR7ZS5kaWxhdGlvbnNbMF19LCB3SE9mZiAqICR7ZS5kaWxhdGlvbnNbMV19KTtcbiAgICAgICAgICBpdmVjMiB3TG9jID0gbG9jIC0gd09mZjtcbiAgICAgICAgICBpdmVjMiB3TG9jSW4gPSB3TG9jIC8gc3RyaWRlcztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB3TG9jSW4gKiBzdHJpZGVzID09IHdMb2MgJiZcbiAgICAgICAgICAgIHdMb2NJbi54ID49IDAgJiYgd0xvY0luLnggPCAke3NbMl19ICYmXG4gICAgICAgICAgICB3TG9jSW4ueSA+PSAwICYmIHdMb2NJbi55IDwgJHtzWzNdfVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZmxvYXQgeFZhbCA9IGdldFgoYmF0Y2gsIGlucHV0X2NoYW5uZWwsIHdMb2NJbi55LCB3TG9jSW4ueCk7XG4gICAgICAgICAgICBmbG9hdCB3VmFsID0gZ2V0VyhpbnB1dF9jaGFubmVsLCB3T3V0Q2hhbm5lbCwgd0hPZmYsIHdXT2ZmKTtcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAke1R9XG4gICAgJHtwLm91dHB1dH0gPSB2ZWM0KHZhbHVlLCAuMCwgLjAsIC4wKTtcbiAgfVxuYDtyZXR1cm57Li4ubyxvdXRwdXQ6e2RpbXM6Zix0eXBlOnRbMF0udHlwZSx0ZXh0dXJlVHlwZTowfSxzaGFkZXJTb3VyY2U6dixoYXNNYWluOiEwfX0sRm09KGEsdCxvKT0+e2xldCBlPURtKHQubGVuZ3RoPjIsby5jYWNoZUtleSk7cmV0dXJuey4uLmUsZ2V0OigpPT5MbShhLHQsZSxvKX19LENtPShhLHQsbyk9PmEucnVuKEZtKGEsdCxvKSx0KSwkbT0oYSx0KT0+e2xldCBvPWEua2VybmVsU2hhcGUuc2xpY2UoKTtpZihhLmtlcm5lbFNoYXBlLmxlbmd0aD09PTApZm9yKGxldCBpPTI7aTx0WzFdLmRpbXMubGVuZ3RoOysraSlvLnB1c2godFsxXS5kaW1zW2ldKTtsZXQgZT1hLnBhZHMuc2xpY2UoKSxyPWEub3V0cHV0U2hhcGUuc2xpY2UoKSxuPXRbMF0uZGltcztQbShuLG8sYS5kaWxhdGlvbnMsYS5hdXRvUGFkLGUsYS5zdHJpZGVzLGEub3V0cHV0UGFkZGluZyxyKTtsZXQgcz1PYmplY3QuYXNzaWduKHt9LGEpO3JldHVybiBPYmplY3QuYXNzaWduKHMse2tlcm5lbFNoYXBlOm8scGFkczplLG91dHB1dFNoYXBlOnIsY2FjaGVLZXk6YS5jYWNoZUtleX0pLHN9LGNmPWE9PntsZXQgdD1hLmF0dHJpYnV0ZXMsbz1Ncih0KSxlPXQuZ2V0U3RyaW5nKFwiYXV0b19wYWRcIixcIk5PVFNFVFwiKSxyPXQuZ2V0SW50cyhcImRpbGF0aW9uc1wiLFsxLDFdKSxuPXQuZ2V0SW50KFwiZ3JvdXBcIiwxKSxzPXQuZ2V0SW50cyhcImtlcm5lbF9zaGFwZVwiLFtdKSxpPXQuZ2V0SW50cyhcIm91dHB1dF9wYWRkaW5nXCIsWzAsMF0pLHU9dC5nZXRJbnRzKFwib3V0cHV0X3NoYXBlXCIsW10pLGw9dC5nZXRJbnRzKFwicGFkc1wiLFswLDAsMCwwXSksZj10LmdldEludHMoXCJzdHJpZGVzXCIsWzEsMV0pO3JldHVybiBlZSh7YXV0b1BhZDplLGRpbGF0aW9uczpyLGdyb3VwOm4sa2VybmVsU2hhcGU6cyxvdXRwdXRQYWRkaW5nOmksb3V0cHV0U2hhcGU6dSxwYWRzOmwsc3RyaWRlczpmLC4uLm99KX0sa209KGEsdCk9PntpZighYXx8YS5sZW5ndGghPT0yJiZhLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGFbMF0uZGltcy5sZW5ndGghPT00fHxhWzFdLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udlwiKTtsZXQgbz1hWzBdLmRpbXNbMV0sZT1hWzFdLmRpbXNbMF07aWYobyE9PWUpdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtsZXQgcj1hWzFdLmRpbXNbMV0qdC5ncm91cDtpZihhLmxlbmd0aD09PTMmJihhWzJdLmRpbXMubGVuZ3RoIT09MXx8YVsyXS5kaW1zWzBdIT09cikpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2xldCBuPWFbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke259RGApO2lmKHQuc3RyaWRlcy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtufURgKTtpZih0LnBhZHMubGVuZ3RoIT09bioyKXRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtuKjJ9RGApO2lmKHQub3V0cHV0UGFkZGluZy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7bn1EYCk7aWYodC5rZXJuZWxTaGFwZS5sZW5ndGghPT0wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PWFbMV0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtlcm5lbCBzaGFwZVwiKTtpZih0Lm91dHB1dFNoYXBlLmxlbmd0aCE9PTAmJnQub3V0cHV0U2hhcGUubGVuZ3RoIT09YVswXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgb3V0cHV0IHNoYXBlXCIpO2lmKGFbMF0udHlwZSE9PVwiZmxvYXQzMlwifHxhWzFdLnR5cGUhPT1cImZsb2F0MzJcIil0aHJvdyBuZXcgRXJyb3IoXCJDb252VHJhbnNwb3NlIGlucHV0KFgsVykgc2hvdWxkIGJlIGZsb2F0IHRlbnNvclwiKTtpZihhLmxlbmd0aD09PTMmJmFbMl0udHlwZSE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBFcnJvcihcIkNvbnZUcmFuc3Bvc2UgaW5wdXQoYmlhcykgc2hvdWxkIGJlIGZsb2F0IHRlbnNvclwiKX19KTt2YXIgZGYsVHIsaGYsQm0sbWYsTm0sUm0sTW0sYW89RSgoKT0+e1widXNlIHN0cmljdFwiO0dlKCk7ZmUoKTthZSgpO2RmPXtuYW1lOlwiVHJhbnNwb3NlXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6WzBdfSxUcj0oYSx0LG8pPT4oTW0odCksW2EucnVuKHsuLi5kZixjYWNoZUhpbnQ6by5jYWNoZUtleSxnZXQ6KCk9PkJtKGEsdFswXSxvLnBlcm0pfSx0KV0pLGhmPWE9PmVlKHtwZXJtOmEuYXR0cmlidXRlcy5nZXRJbnRzKFwicGVybVwiLFtdKX0pLEJtPShhLHQsbyk9PntsZXQgZT10LmRpbXM7bz1tZihlLG8pO2xldCByPU5tKGUsbyksbj1lLmxlbmd0aCxzPWBcbiAgICAgICR7Um0oXCJwZXJtXCIsbyxuKX1cbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtufV0pIHtcbiAgICAgICAgaW50IGFbJHtufV07XG4gICAgICAgIHBlcm0oYSwgaW5kaWNlcyk7XG4gICAgICAgIHJldHVybiBfQShhKTtcbiAgICAgIH1gO3JldHVybnsuLi5kZixvdXRwdXQ6e2RpbXM6cix0eXBlOnQudHlwZSx0ZXh0dXJlVHlwZTowfSxzaGFkZXJTb3VyY2U6c319LG1mPShhLHQpPT4odCYmdC5sZW5ndGghPT1hLmxlbmd0aCYmKHQ9Wy4uLmEua2V5cygpXS5yZXZlcnNlKCkpLHQpLE5tPShhLHQpPT4odD1tZihhLHQpLFUuc29ydEJhc2VkT25QZXJtKGEsdCkpLFJtPShhLHQsbyk9PntsZXQgZT1bXTtlLnB1c2goYHZvaWQgJHthfShvdXQgaW50IGFbJHtvfV0sIGludCBzcmNbJHtvfV0pIHtgKTtmb3IobGV0IHI9MDtyPG87KytyKWUucHVzaChgXHRhWyR7dFtyXX1dPXNyY1ske3J9XTtgKTtyZXR1cm4gZS5wdXNoKFwiXHR9XCIpLGUuam9pbihgXG5gKX0sTW09YT0+e2lmKCFhfHxhLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKGFbMF0udHlwZSE9PVwiZmxvYXQzMlwiJiZhWzBdLnR5cGUhPT1cImZsb2F0NjRcIil0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfX0pO3ZhciBiZixnZixHbSx5Zj1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YW8oKTtiZj0oYSx0LG8pPT57R20odCk7bGV0IGU9by5ibG9ja3NpemUscj1lKmUsbj1vLm1vZGU9PT1cIkRDUlwiP1swLDMsNCwxLDUsMl06WzAsMSw0LDIsNSwzXSxzPW8ubW9kZT09PVwiRENSXCI/W3RbMF0uZGltc1swXSxlLGUsdFswXS5kaW1zWzFdL3IsdFswXS5kaW1zWzJdLHRbMF0uZGltc1szXV06W3RbMF0uZGltc1swXSx0WzBdLmRpbXNbMV0vcixlLGUsdFswXS5kaW1zWzJdLHRbMF0uZGltc1szXV0saT1hLnJlc2hhcGVVbnBhY2tlZCh0WzBdLHMpLHU9e3Blcm06bixjYWNoZUtleTpgJHtufWB9LFtsXT1UcihhLFtpXSx1KSxmPVt0WzBdLmRpbXNbMF0sdFswXS5kaW1zWzFdL3IsdFswXS5kaW1zWzJdKmUsdFswXS5kaW1zWzNdKmVdO3JldHVyblthLnJlc2hhcGVVbnBhY2tlZChsLGYpXX0sZ2Y9YT0+e2xldCB0PWEuYXR0cmlidXRlcy5nZXRJbnQoXCJibG9ja3NpemVcIik7aWYodDwxKXRocm93IG5ldyBFcnJvcihgYmxvY2tzaXplIG11c3QgYmUgPj0gMSwgYnV0IGdvdCA6ICR7dH0gZm9yIERlcHRoVG9TcGFjZWApO2xldCBvPWEuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJtb2RlXCIsXCJEQ1JcIik7aWYobyE9PVwiRENSXCImJm8hPT1cIkNSRFwiKXRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIG1vZGU6ICR7b30gZm9yIERlcHRoVG9TcGFjZWApO3JldHVybnttb2RlOm8sYmxvY2tzaXplOnR9fSxHbT1hPT57aWYoYS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihgRGVwdGhUb1NwYWNlIGV4cGVjdCAxIGlucHV0cywgYnV0IGdvdCAke2EubGVuZ3RofWApO2lmKGFbMF0udHlwZT09PVwic3RyaW5nXCJ8fGFbMF0uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXB0aFRvU3BhY2UgaW5wdXQgc2hvdWxkIGJlIGEgNC1EIG51bWVyaWMgdGVuc29yXCIpfX0pO3ZhciBUZix4ZixVbSx3Zj1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZmUoKTtUZj0oYSx0LG8pPT57VW0odCxvKTtsZXQgZT1VLmZsYXR0ZW5TaGFwZSh0WzBdLmRpbXMsbyk7cmV0dXJuW2EucmVzaGFwZVVucGFja2VkKHRbMF0sZSldfSx4Zj1hPT5hLmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiLDEpLFVtPShhLHQpPT57aWYoIWF8fGEubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0dGVuIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2xldCBvPWFbMF0uZGltcy5sZW5ndGg7aWYobz09PTApdGhyb3cgbmV3IEVycm9yKFwic2NhbGFyIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkLlwiKTtpZih0PC1vfHx0Pm8pdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBheGlzXCIpO2lmKGFbMF0udHlwZT09PVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkLlwiKX19KTt2YXIgSnQsaG49RSgoKT0+e1widXNlIHN0cmljdFwiO0p0PVtcImZsb2F0MzJcIixcImZsb2F0NjRcIixcImludDMyXCIsXCJpbnQxNlwiLFwiaW50OFwiLFwidWludDE2XCIsXCJ1aW50MzJcIixcInVpbnQ4XCJdfSk7dmFyIHZmLF9mLHptLFZtLFdtLEhtLE9mPUUoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO2huKCk7ZmUoKTthZSgpO3ZmPShhLHQsbyk9PihIbSh0LG8uYXhpcyksW2EucnVuKFdtKGEsdCxvKSx0KV0pLF9mPWE9PmVlKHtheGlzOmEuYXR0cmlidXRlcy5nZXRJbnQoXCJheGlzXCIsMCl9KSx6bT17bmFtZTpcIkdhdGhlclwiLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOlswLDBdfSxWbT0oYSx0LG8sZSk9PntsZXQgcj1vWzBdLmRpbXMuc2xpY2UoKSxuPW9bMV0uZGltcy5zbGljZSgpLHM9bmV3IEFycmF5KHIubGVuZ3RoK24ubGVuZ3RoLTEpO2U9VS5ub3JtYWxpemVBeGlzKGUsci5sZW5ndGgpO2xldCBpPVtdO2ZvcihsZXQgZD0wO2Q8cy5sZW5ndGg7ZCsrKWQ8ZT8oc1tkXT1yW2RdLGkucHVzaChgaW5wdXRJZHhbJHtkfV0gPSBvdXRwdXRJZHhbJHtkfV07YCkpOmQ8ZStuLmxlbmd0aD8oc1tkXT1uW2QtZV0saS5wdXNoKGBpbmRleERhdGFJZHhbJHtkLWV9XSA9IG91dHB1dElkeFske2R9XTtgKSk6KHNbZF09cltkLW4ubGVuZ3RoKzFdLGkucHVzaChgaW5wdXRJZHhbJHtkLW4ubGVuZ3RoKzF9XSA9IG91dHB1dElkeFske2R9XTtgKSk7bGV0IHU9cy5sZW5ndGh8fDEsbD1yLmxlbmd0aCxmPW4ubGVuZ3RofHwxLHA9YFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7dX1dKSB7XG4gICAgICAgIGludCBpbnB1dElkeFske2x9XTtcbiAgICAgICAgaW50IGluZGV4RGF0YUlkeFske2Z9XTtcbiAgICAgICAgaW5kZXhEYXRhSWR4WzBdID0gMDtcbiAgICAgICAgJHtpLmpvaW4oYFxuICAgICAgICBgKX1cbiAgICAgICAgaW50IGlkeCA9IGludChfQihpbmRleERhdGFJZHgpKTtcbiAgICAgICAgaW5wdXRJZHhbJHtlfV0gPSBpZHggPCAwID8gaWR4ICsgJHtyW2VdfSA6IGlkeDtcbiAgICAgICAgcmV0dXJuIF9BKGlucHV0SWR4KTtcbiAgICAgIH1gO3JldHVybnsuLi50LG91dHB1dDp7ZGltczpzLHR5cGU6b1swXS50eXBlLHRleHR1cmVUeXBlOjB9LHNoYWRlclNvdXJjZTpwfX0sV209KGEsdCxvKT0+e2xldCBlPXsuLi56bSxjYWNoZUhpbnQ6by5jYWNoZUtleX07cmV0dXJuey4uLmUsZ2V0OigpPT5WbShhLGUsdCxvLmF4aXMpfX0sSG09KGEsdCk9PntpZighYXx8YS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkdhdGhlciByZXF1aXJlcyAyIGlucHV0cy5cIik7bGV0IG89YVswXS5kaW1zLmxlbmd0aDtpZihvPDEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYodDwtb3x8dD5vLTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBheGlzLlwiKTtpZihKdC5pbmRleE9mKGFbMF0udHlwZSk9PT0tMSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhaWQgaW5wdXQgdHlwZS5cIik7aWYoYVsxXS50eXBlIT09XCJpbnQzMlwiJiZhWzFdLnR5cGUhPT1cImludDE2XCIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWlkIGlucHV0IHR5cGUuXCIpfX0pO3ZhciBraSxJZixTZixBZixxbSxqbSxZbSxQZj1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7R2UoKTtmZSgpO2FlKCk7a2k9KGEsdCxvKT0+KFltKHQsbyksW2EucnVuKHFtKHQsbyksdCldKSxJZj0oYSx0KT0+e2xldCBvPWEuYXR0cmlidXRlcy5nZXRJbnQoXCJ0cmFuc0FcIiwwKSE9PTAsZT1hLmF0dHJpYnV0ZXMuZ2V0SW50KFwidHJhbnNCXCIsMCkhPT0wLHI9YS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiYWxwaGFcIiwxKSxuPWEuYXR0cmlidXRlcy5nZXRGbG9hdChcImJldGFcIiwxKTtyZXR1cm4gZWUoe3RyYW5zQTpvLHRyYW5zQjplLGFscGhhOnIsYmV0YTpuLGlzT3B0aW9uYWxDOnR9KX0sU2Y9YT0+SWYoYSwhMSksQWY9YT0+SWYoYSwhMCkscW09KGEsdCk9PntsZXQgbz17bmFtZTpcIkdlbW1cIixpbnB1dE5hbWVzOmEubGVuZ3RoPT09Mz9bXCJBXCIsXCJCXCIsXCJDXCJdOltcIkFcIixcIkJcIl0saW5wdXRUeXBlczphLmxlbmd0aD09PTM/WzAsMCwwXTpbMCwwXSxrZXk6dC5jYWNoZUtleX07cmV0dXJuey4uLm8sZ2V0OigpPT5qbShvLGEsdCl9fSxqbT0oYSx0LG8pPT57bGV0IGU9dFswXS5kaW1zLnNsaWNlKCkscj10WzFdLmRpbXMuc2xpY2UoKSxbbixzXT1Ybi5nZXRTaGFwZU9mR2VtbVJlc3VsdChlLG8udHJhbnNBLHIsby50cmFuc0IsdC5sZW5ndGg9PT0zP3RbMl0uZGltczp2b2lkIDApLGk9W24sc107aWYoIWkpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIGdlbW0gb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bGV0IHU9ZVtlLmxlbmd0aC0xXSxsPVwiXCI7by50cmFuc0EmJih1PWVbMF0pLG8udHJhbnNBJiZvLnRyYW5zQj9sPVwidmFsdWUgKz0gX0FfVChhKSAqIF9CX1QoYik7XCI6by50cmFuc0EmJiFvLnRyYW5zQj9sPVwidmFsdWUgKz0gX0FfVChhKSAqIF9CKGIpO1wiOiFvLnRyYW5zQSYmby50cmFuc0I/bD1cInZhbHVlICs9IF9BKGEpICogX0JfVChiKTtcIjohby50cmFuc0EmJiFvLnRyYW5zQiYmKGw9XCJ2YWx1ZSArPSBfQShhKSAqIF9CKGIpO1wiKTtsZXQgZj1pLmxlbmd0aCxwPXQubGVuZ3RoPT09Mz9gaW50IGNbJHt0WzJdLmRpbXMubGVuZ3RofV07YDpcIlwiLGQ9dC5sZW5ndGg9PT0zP1wiYmNhc3RJbmRpY2VzX0MoaW5kaWNlcywgYyk7XCI6XCJcIixUPXQubGVuZ3RoPT09Mz9cInZhbHVlICs9IGJldGEgKiBfQyhjKTtcIjpcIlwiLHY9YFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2Z9XSkge1xuICAgICAgICAgIGludCBhWyR7Zn1dO1xuICAgICAgICAgIGludCBiWyR7Zn1dO1xuICAgICAgICAgICR7cH1cblxuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgYSk7XG4gICAgICAgICAgY29weVZlYyhpbmRpY2VzLCBiKTtcbiAgICAgICAgICAke2R9XG5cbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9IDAuMDtcbiAgICAgICAgICBmb3IgKGludCBrPTA7IGs8JHt1fTsgKytrKSB7XG4gICAgICAgICAgICAgIGFbJHtmLTF9XSA9IGs7XG4gICAgICAgICAgICAgIGJbJHtmLTJ9XSA9IGs7XG4gICAgICAgICAgICAgICR7bH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlICogYWxwaGE7XG4gICAgICAgICAgJHtUfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1gO3JldHVybnsuLi5hLG91dHB1dDp7ZGltczppLHR5cGU6dFswXS50eXBlLHRleHR1cmVUeXBlOjB9LHZhcmlhYmxlczpbe25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmbG9hdFwiLGRhdGE6by5hbHBoYX0se25hbWU6XCJiZXRhXCIsdHlwZTpcImZsb2F0XCIsZGF0YTpvLmJldGF9XSxzaGFkZXJTb3VyY2U6dn19LFltPShhLHQpPT57aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbWlzc2luZ1wiKTtpZih0LmlzT3B0aW9uYWxDJiYoYS5sZW5ndGg8Mnx8YS5sZW5ndGg+MykpdGhyb3cgbmV3IEVycm9yKFwiSW52YWlkIGlucHV0IHNoYXBlLlwiKTtpZighdC5pc09wdGlvbmFsQyYmYS5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcIkdlbW0gcmVxdWlyZXMgMyBpbnB1dHNcIik7aWYoYS5sZW5ndGg9PT0zJiZhWzJdLmRpbXMubGVuZ3RoIT09MSYmYVsyXS5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZSBvZiBDXCIpO2lmKGFbMF0udHlwZSE9PVwiZmxvYXQzMlwiJiZhWzBdLnR5cGUhPT1cImZsb2F0NjRcInx8YVsxXS50eXBlIT09XCJmbG9hdDMyXCImJmFbMV0udHlwZSE9PVwiZmxvYXQ2NFwifHxhLmxlbmd0aD09PTMmJmFbMl0udHlwZSE9PVwiZmxvYXQzMlwiJiZhWzJdLnR5cGUhPT1cImZsb2F0NjRcIil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKGFbMF0udHlwZSE9PWFbMV0udHlwZXx8YS5sZW5ndGg9PT0zJiZhWzBdLnR5cGUhPT1hWzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZXMgYXJlIG1pc21hdGNoZWRcIil9fSk7dmFyIEVmLERmLFhtLEttLEptLFptLFFtLExmPUUoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO2FlKCk7RWY9KGEsdCxvKT0+KFFtKHQpLFthLnJ1bihKbShhLHQsbyksdCldKSxEZj1hPT57bGV0IHQ9YS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwic2NhbGVcIiksbz1hLmF0dHJpYnV0ZXMuZ2V0RmxvYXRzKFwiYmlhc1wiKTtyZXR1cm4gZWUoe3NjYWxlOnQsYmlhczpvfSl9LFhtPXtuYW1lOlwiSW1hZ2VTY2FsZXJcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbMF19LEttPShhLHQsbyxlKT0+e2xldCByPW9bMF0uZGltcy5zbGljZSgpLG49ci5sZW5ndGgsaT1gXG4gICAgICAke1ptKGUuYmlhcy5sZW5ndGgpfVxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske259XSkge1xuICAgICAgICByZXR1cm4gX1goaW5kaWNlcykgKiBzY2FsZSArIGdldEJpYXMoYmlhcywgaW5kaWNlc1sxXSk7XG4gICAgICB9YDtyZXR1cm57Li4udCxvdXRwdXQ6e2RpbXM6cix0eXBlOm9bMF0udHlwZSx0ZXh0dXJlVHlwZTowfSx2YXJpYWJsZXM6W3tuYW1lOlwiYmlhc1wiLHR5cGU6XCJmbG9hdFwiLGFycmF5TGVuZ3RoOmUuYmlhcy5sZW5ndGgsZGF0YTplLmJpYXN9LHtuYW1lOlwic2NhbGVcIix0eXBlOlwiZmxvYXRcIixkYXRhOmUuc2NhbGV9XSxzaGFkZXJTb3VyY2U6aX19LEptPShhLHQsbyk9PntsZXQgZT17Li4uWG0sY2FjaGVIaW50Om8uY2FjaGVLZXl9O3JldHVybnsuLi5lLGdldDooKT0+S20oYSxlLHQsbyl9fSxabT1hPT57bGV0IHQ9W2BmbG9hdCBnZXRCaWFzKGZsb2F0IGJpYXNbJHthfV0sIGludCBjaGFubmVsKSB7YF07Zm9yKGxldCBvPTA7bzxhOysrbylvPT09MD90LnB1c2goYFx0aWYgKGNoYW5uZWwgPT0gJHtvfSkgeyByZXR1cm4gYmlhc1ske299XTsgfWApOm89PT1hLTE/dC5wdXNoKGBcdGVsc2UgeyByZXR1cm4gYmlhc1ske299XTsgfWApOnQucHVzaChgXHRlbHNlIGlmIChjaGFubmVsID09ICR7b30pIHsgcmV0dXJuIGJpYXNbJHtvfV07IH1gKTtyZXR1cm4gdC5wdXNoKFwiXHR9XCIpLHQuam9pbihgXG5gKX0sUW09YT0+e2lmKCFhfHxhLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2VTY2FsZXIgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoYVswXS5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYoYVswXS50eXBlIT09XCJmbG9hdDMyXCImJmFbMF0udHlwZSE9PVwiZmxvYXQ2NFwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSk7dmFyIENmLCRmLEZmLGViLHRiLHJiLG5iLG9iLGliLGtmPUUoKCk9PntcInVzZSBzdHJpY3RcIjt4ZSgpO2FlKCk7Q2Y9KGEsdCxvKT0+e2liKHQpO2xldCBlPWEucnVuKHRiKHRbMF0pLHQpO3JldHVyblthLnJ1bihvYihhLHRbMF0sbyxlLmRpbXMpLFt0WzBdLGUsdFsxXSx0WzJdXSldfSwkZj1hPT5hLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJlcHNpbG9uXCIsMWUtNSksRmY9e25hbWU6XCJJbnN0YW5jZU5vcm1hbGl6YXRpb25fTWVhbkFuZFZhcmlhbmNlXCIsaW5wdXROYW1lczpbXCJYXCJdLGlucHV0VHlwZXM6WzBdfSxlYj0oYSx0KT0+e2xldCBvPXQuZGltcy5zbGljZSgpLGU9b1sxXSxyPW9bMl0qb1szXSxuPVtvWzBdLGVdLHM9YFxuICAgICAgdmVjNCBwcm9jZXNzKGludFsyXSBpbmRpY2VzKSB7XG4gICAgICAgIHZlYzQgdiA9IHZlYzQoMC4wKTtcbiAgICAgICAgaW50IGFbNF07XG4gICAgICAgIGFbMF0gPSBpbmRpY2VzWzBdO1xuICAgICAgICBhWzFdID0gaW5kaWNlc1sxXTtcbiAgICAgICAgZmxvYXQgdGVtcCA9IDAuMDtcbiAgICAgICAgZm9yKGludCBhMj0wOyBhMjwke29bMl19OyBhMisrKSB7XG4gICAgICAgICAgYVsyXSA9IGEyO1xuICAgICAgICAgIGZvcihpbnQgYTM9MDsgYTM8JHtvWzNdfTsgYTMrKykge1xuICAgICAgICAgICAgYVszXSA9IGEzO1xuICAgICAgICAgICAgZmxvYXQgeCA9IF9YKGEpO1xuICAgICAgICAgICAgdGVtcCArPSB4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmbG9hdCBtZWFuID0gdGVtcCAvIGZsb2F0KCR7cn0pO1xuICAgICAgICB0ZW1wID0gMC4wO1xuICAgICAgICBmb3IoaW50IGEyPTA7IGEyPCR7b1syXX07IGEyKyspIHtcbiAgICAgICAgICBhWzJdID0gYTI7XG4gICAgICAgICAgZm9yKGludCBhMz0wOyBhMzwke29bM119OyBhMysrKSB7XG4gICAgICAgICAgICBhWzNdID0gYTM7XG4gICAgICAgICAgICBmbG9hdCB4ID0gX1goYSk7XG4gICAgICAgICAgICB0ZW1wICs9ICh4IC0gbWVhbikgKiAoeCAtIG1lYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2LnIgPSBtZWFuO1xuICAgICAgICB2LmcgPSB0ZW1wIC8gZmxvYXQoJHtyfSk7XG5cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9YDtyZXR1cm57Li4uYSxvdXRwdXQ6e2RpbXM6bix0eXBlOnQudHlwZSx0ZXh0dXJlVHlwZTo0fSxzaGFkZXJTb3VyY2U6c319LHRiPWE9Pih7Li4uRmYsZ2V0OigpPT5lYihGZixhKX0pLHJiPXtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uX0NvbXB1dGVPdXRwdXRcIixpbnB1dE5hbWVzOltcIlhcIixcIk1lYW5BbmRWYXJpYW5jZVwiLFwiU2NhbGVcIixcIkJcIl0saW5wdXRUeXBlczpbMCw0LDAsMF19LG5iPShhLHQsbyxlLHIpPT57bGV0IG49cShhLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksW3MsaV09YS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQociw0KSxbdSxsXT1bcy80LGldLGY9YFxuICAgICAgdmVjNCBnZXRfTWVhbkFuZFZhcmlhbmNlKGludFsyXSBtdikge1xuICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0X01lYW5BbmRWYXJpYW5jZShtdik7XG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke3V9LCAke2x9KTtcbiAgICAgICAgcmV0dXJuICR7bi50ZXh0dXJlMkR9KE1lYW5BbmRWYXJpYW5jZSwgY29vcmRzKTtcbiAgICAgIH1cblxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbNF0gaW5kaWNlcykge1xuICAgICAgICBpbnQgbXZbMl07XG4gICAgICAgIG12WzBdID0gaW5kaWNlc1swXTtcbiAgICAgICAgbXZbMV0gPSBpbmRpY2VzWzFdO1xuICAgICAgICB2ZWM0IG1lYW5fYW5kX3ZhcmlhbmNlID0gZ2V0X01lYW5BbmRWYXJpYW5jZShtdik7XG4gICAgICAgIGZsb2F0IG1lYW4gPSBtZWFuX2FuZF92YXJpYW5jZS5yO1xuICAgICAgICBmbG9hdCB2YXJpYW5jZSA9IG1lYW5fYW5kX3ZhcmlhbmNlLmc7XG5cbiAgICAgICAgaW50IHNiWzFdO1xuICAgICAgICBzYlswXSA9IGluZGljZXNbMV07XG4gICAgICAgIGZsb2F0IHNjYWxlID0gX1NjYWxlKHNiKTtcbiAgICAgICAgZmxvYXQgYiA9IF9CKHNiKTtcblxuICAgICAgICByZXR1cm4gc2NhbGUgKiAoX1goaW5kaWNlcykgLSBtZWFuKSAvIHNxcnQodmFyaWFuY2UgKyBlcHNpbG9uKSArIGI7XG4gICAgICB9YDtyZXR1cm57Li4udCxvdXRwdXQ6e2RpbXM6by5kaW1zLHR5cGU6by50eXBlLHRleHR1cmVUeXBlOjB9LHZhcmlhYmxlczpbe25hbWU6XCJlcHNpbG9uXCIsdHlwZTpcImZsb2F0XCIsZGF0YTplfV0sc2hhZGVyU291cmNlOmZ9fSxvYj0oYSx0LG8sZSk9PntsZXQgcj17Li4ucmIsY2FjaGVIaW50OmAke299YH07cmV0dXJuey4uLnIsZ2V0OigpPT5uYihhLHIsdCxvLGUpfX0saWI9YT0+e2lmKCFhfHxhLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uIHJlcXVpcmVzIDMgaW5wdXRzLlwiKTtsZXQgdD1hWzBdLG89YVsxXSxlPWFbMl07aWYodC5kaW1zLmxlbmd0aDwzfHxvLmRpbXMubGVuZ3RoIT09MXx8ZS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYoby5kaW1zWzBdIT09dC5kaW1zWzFdfHxlLmRpbXNbMF0hPT10LmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc2hhcGVzIGFyZSBtaXNtYXRjaGVkLlwiKTtpZih0LnR5cGUhPT1cImZsb2F0MzJcIiYmdC50eXBlIT09XCJmbG9hdDY0XCJ8fG8udHlwZSE9PVwiZmxvYXQzMlwiJiZvLnR5cGUhPT1cImZsb2F0NjRcInx8ZS50eXBlIT09XCJmbG9hdDMyXCImJmUudHlwZSE9PVwiZmxvYXQ2NFwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoYVswXS5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKFwiT25seSBzdXBwb3J0IDQtRCBpbnB1dCBzaGFwZS5cIil9fSk7ZnVuY3Rpb24gYWIoYSx0KXtsZXQgbz1hWzBdLmRpbXNbMV0sZT1hWzBdLmRpbXMubGVuZ3RoLHI9LU1hdGguZmxvb3IoKHQuc2l6ZS0xKS8yKSxuPU1hdGguY2VpbCgodC5zaXplLTEpLzIpLHM9YGZsb2F0KCR7dC5hbHBoYX0pIC8gZmxvYXQoJHt0LnNpemV9KWAsaT1gZmxvYXQoJHt0LmJpYXN9KWAsdT1gZmxvYXQoJHt0LmJldGF9KWAsbD1gXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2V9XSkge1xuICAgICAgICBpbnQgYyA9IGluZGljZXNbMV07XG4gICAgICAgIGZsb2F0IHggPSBfWChpbmRpY2VzKTtcbiAgICAgICAgZmxvYXQgc3F1YXJlX3N1bSA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCBpID0gJHtyfTsgaSA8PSAke259OyBpKyspIHtcbiAgICAgICAgICBpbnQgaWR4ID0gYyArIGk7XG4gICAgICAgICAgaWYgKGMgPj0gMCAmJiBjIDwgJHtvfSkge1xuICAgICAgICAgICAgaW5kaWNlc1sxXSA9IGlkeDtcbiAgICAgICAgICAgIGZsb2F0IGogPSBfWChpbmRpY2VzKTtcbiAgICAgICAgICAgIHNxdWFyZV9zdW0gKz0gaiAqIGo7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IC8gcG93KCR7aX0gKyAke3N9ICogc3F1YXJlX3N1bSwgJHt1fSk7XG4gICAgfWA7cmV0dXJuey4uLlJmLGNhY2hlSGludDp0LmNhY2hlS2V5LG91dHB1dDp7ZGltczphWzBdLmRpbXMsdHlwZTphWzBdLnR5cGUsdGV4dHVyZVR5cGU6MH0sc2hhZGVyU291cmNlOmx9fWZ1bmN0aW9uIHNiKGEsdCl7cmV0dXJuey4uLlJmLGNhY2hlSGludDp0LmNhY2hlS2V5LGdldDooKT0+YWIoYSx0KX19dmFyIEJmLE5mLFJmLHViLE1mPUUoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO2FlKCk7QmY9KGEsdCxvKT0+KHViKHQpLFthLnJ1bihzYih0LG8pLHQpXSksTmY9YT0+e2xldCB0PWEuYXR0cmlidXRlcy5nZXRGbG9hdChcImFscGhhXCIsMWUtNCksbz1hLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJiZXRhXCIsLjc1KSxlPWEuYXR0cmlidXRlcy5nZXRGbG9hdChcImJpYXNcIiwxKSxyPWEuYXR0cmlidXRlcy5nZXRJbnQoXCJzaXplXCIpO3JldHVybiBlZSh7YWxwaGE6dCxiZXRhOm8sYmlhczplLHNpemU6cn0pfSxSZj17bmFtZTpcIkxSTlwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOlswXX07dWI9YT0+e2lmKCFhfHxhLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiTFJOIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKGFbMF0uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignY3VycmVudGx5IG9ubHkgc3VwcG9ydCBMUk4gZm9yIGlucHV0IHdpdGggXCJOQ0hXXCIgZm9ybWF0Jyk7aWYoYVswXS50eXBlIT09XCJmbG9hdDMyXCIpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGJlIGZsb2F0IHR5cGVcIil9fSk7dmFyIGxiLEJpLEdmLFVmLHpmLGZiLGNiLHBiLGRiLGhiLG1iLGJiLGdiLFZmPUUoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO2ZlKCk7eGUoKTthZSgpO2xiPXtuYW1lOlwiUGFkXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6WzBdfSxCaT0oYSx0LG8pPT4ocGIodCksW2EucnVuKHsuLi5sYixjYWNoZUhpbnQ6by5jYWNoZUtleSxnZXQ6KCk9PmNiKGEsdFswXSxvKX0sdCldKSxHZj1hPT57bGV0IHQ9YS5hdHRyaWJ1dGVzLmdldFN0cmluZyhcIm1vZGVcIixcImNvbnN0YW50XCIpLG89YS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwidmFsdWVcIiwwKSxlPWEuYXR0cmlidXRlcy5nZXRJbnRzKFwicGFkc1wiKTtyZXR1cm4gZWUoe21vZGU6dCx2YWx1ZTpvLHBhZHM6ZX0pfSxVZj0oYSx0LG8pPT57ZGIodCk7bGV0IGU9ZmIoYSx0LG8pO3JldHVybiBCaShhLFt0WzBdXSxlKX0semY9YT0+YS5hdHRyaWJ1dGVzLmdldFN0cmluZyhcIm1vZGVcIixcImNvbnN0YW50XCIpLGZiPShhLHQsbyk9PntpZighYS5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIodFsxXS5kYXRhSWQpfHx0Lmxlbmd0aD49MyYmIWEuc2Vzc2lvbi5pc0luaXRpYWxpemVyKHRbMl0uZGF0YUlkKSl0aHJvdyBuZXcgRXJyb3IoXCJkeW5hbWljIHBhZCBhdHRyaWJ1dGVzIGFyZSBub3QgYWxsb3dlZFwiKTtsZXQgZT1BcnJheS5mcm9tKHRbMV0uaW50ZWdlckRhdGEpLHI9dC5sZW5ndGg+PTM/dFsyXS5mbG9hdERhdGFbMF06MDtyZXR1cm4gZWUoe21vZGU6byxwYWRzOmUsdmFsdWU6cn0pfSxjYj0oYSx0LG8pPT57bGV0IGU9VS5wYWRTaGFwZSh0LmRpbXMuc2xpY2UoKSxvLnBhZHMpLHI9ZS5sZW5ndGgscz1gXG4gICAgICAke2hiKGEsdCxvKX1cbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7cn1dIGluZGljZXMpIHtcbiAgICAgICAgICByZXR1cm4gcGFkQShpbmRpY2VzKTtcbiAgICAgIH1gO3JldHVybntuYW1lOlwiUGFkXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6WzBdLG91dHB1dDp7ZGltczplLHR5cGU6dC50eXBlLHRleHR1cmVUeXBlOjB9LHNoYWRlclNvdXJjZTpzfX0scGI9YT0+e2lmKCFhfHxhLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiUGFkIHJlcXVpcmVzIDEgaW5wdXRcIik7aWYoYVswXS50eXBlIT09XCJmbG9hdDMyXCImJmFbMF0udHlwZSE9PVwiZmxvYXQ2NFwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9LGRiPWE9PntpZighYXx8YS5sZW5ndGghPT0yJiZhLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiUGFkIHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoYVsxXS50eXBlIT09XCJpbnQzMlwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoYS5sZW5ndGg+PTMmJmFbMl0udHlwZT09PVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0saGI9KGEsdCxvKT0+e2xldCBlPXEoYS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLFtyLG5dPWEuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KHQuZGltcywwKSxzPVUuY29tcHV0ZVN0cmlkZXModC5kaW1zKTtzd2l0Y2goby5tb2RlKXtjYXNlXCJjb25zdGFudFwiOnJldHVybiBtYihlLHQuZGltcyxzLHIsbixvLnBhZHMsby52YWx1ZSk7Y2FzZVwicmVmbGVjdFwiOnJldHVybiBiYihlLHQuZGltcyxzLHIsbixvLnBhZHMpO2Nhc2VcImVkZ2VcIjpyZXR1cm4gZ2IoZSx0LmRpbXMscyxyLG4sby5wYWRzKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbW9kZVwiKX19LG1iPShhLHQsbyxlLHIsbixzKT0+e2xldCBpPXQubGVuZ3RoLHU9XCJcIjtmb3IobGV0IGw9aS0xO2w+PTA7LS1sKXUrPWBcbiAgICAgICAgayA9IG1bJHtsfV0gLSAke25bbF19O1xuICAgICAgICBpZiAoayA8IDApICByZXR1cm4gY29uc3RhbnQ7XG4gICAgICAgIGlmIChrID49ICR7dFtsXX0pIHJldHVybiBjb25zdGFudDtcbiAgICAgICAgb2Zmc2V0ICs9IGsgKiAke29bbF19O1xuICAgICAgICBgO3JldHVybmBcbiAgICAgIGZsb2F0IHBhZEEoaW50IG1bJHtpfV0pIHtcbiAgICAgICAgY29uc3QgZmxvYXQgY29uc3RhbnQgPSBmbG9hdCgke3N9KTtcbiAgICAgICAgaW50IG9mZnNldCA9IDA7XG4gICAgICAgIGludCBrID0gMDtcbiAgICAgICAgJHt1fVxuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHtlfSwgJHtyfSk7XG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7YS50ZXh0dXJlMkR9KEEsIGNvb3JkcykpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBgfSxiYj0oYSx0LG8sZSxyLG4pPT57bGV0IHM9dC5sZW5ndGgsaT1cIlwiO2ZvcihsZXQgdT1zLTE7dT49MDstLXUpaSs9YFxuICAgICAgICBrID0gbVske3V9XSAtICR7blt1XX07XG4gICAgICAgIGlmIChrIDwgMCkgeyBrID0gLWs7IH1cbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGludCBfMm5fMSA9ICR7MioodFt1XS0xKX07XG4gICAgICAgICAgayA9IGludCggbW9kKCBmbG9hdChrKSwgZmxvYXQoXzJuXzEpICkgKSA7XG4gICAgICAgICAgaWYoayA+PSAke3RbdV19KSB7IGsgPSBfMm5fMSAtIGs7IH1cbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gayAqICR7b1t1XX07XG4gICAgICAgIGA7cmV0dXJuYFxuICAgICAgZmxvYXQgcGFkQShpbnQgbVske3N9XSkge1xuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcbiAgICAgICAgaW50IGsgPSAwO1xuICAgICAgICAke2l9XG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke2V9LCAke3J9KTtcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHthLnRleHR1cmUyRH0oQSwgY29vcmRzKSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGB9LGdiPShhLHQsbyxlLHIsbik9PntsZXQgcz10Lmxlbmd0aCxpPVwiXCI7Zm9yKGxldCB1PXMtMTt1Pj0wOy0tdSlpKz1gXG4gICAgICAgIGsgPSBtWyR7dX1dIC0gJHtuW3VdfTtcbiAgICAgICAgaWYgKGsgPCAwKSAgayA9IDA7XG4gICAgICAgIGlmIChrID49ICR7dFt1XX0pIGsgPSAke3RbdV0tMX07XG4gICAgICAgIG9mZnNldCArPSBrICogJHtvW3VdfTtcbiAgICAgIGA7cmV0dXJuYFxuICAgICAgZmxvYXQgcGFkQShpbnQgbVske3N9XSkge1xuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcbiAgICAgICAgaW50IGsgPSAwO1xuICAgICAgICAke2l9XG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke2V9LCAke3J9KTtcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHthLnRleHR1cmUyRH0oQSwgY29vcmRzKSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGB9fSk7dmFyIEhmLHFmLGpmLFlmLFhmLEtmLEpmLFpmLFFmLHliLFdmLGVjLHVvLHRjLHNvLFRiLHJjPUUoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO2ZlKCk7YWUoKTtIZj0oYSx0LG8pPT57dW8odCk7bGV0IGU9e25hbWU6XCJBdmVyYWdlUG9vbFwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOlswXSxjYWNoZUhpbnQ6by5jYWNoZUtleX07cmV0dXJuW2EucnVuKHsuLi5lLGdldDooKT0+amYodCxlLCExLG8pfSx0KV19LHFmPWE9PntsZXQgdD1hLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwiYXV0b19wYWRcIixcIk5PVFNFVFwiKSxvPWEuYXR0cmlidXRlcy5nZXRJbnQoXCJjZWlsX21vZGVcIiwwKSxlPWEuYXR0cmlidXRlcy5nZXRJbnQoXCJjb3VudF9pbmNsdWRlX3BhZFwiLDApIT09MCxyPWEuYXR0cmlidXRlcy5nZXRJbnRzKFwia2VybmVsX3NoYXBlXCIpLG49YS5hdHRyaWJ1dGVzLmdldEludHMoXCJzdHJpZGVzXCIsW10pLHM9YS5hdHRyaWJ1dGVzLmdldEludHMoXCJwYWRzXCIsW10pO2lmKG8hPT0wKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgQXZlcmFnZVBvb2xcIik7cmV0dXJuIGVlKHthdXRvUGFkOnQsY2VpbE1vZGU6byxjb3VudEluY2x1ZGVQYWQ6ZSxrZXJuZWxTaGFwZTpyLHN0cmlkZXM6bixwYWRzOnN9KX0samY9KGEsdCxvLGUpPT57bGV0W3Isbl09UWYoYSxlLG8pLHM9VS5zaXplKHIua2VybmVsU2hhcGUpLGk9XCJ2YWx1ZSArPSBfWCh4KTtcIix1PVwiXCI7ci5jb3VudEluY2x1ZGVQYWQ/dSs9YHZhbHVlIC89IGZsb2F0KCR7c30pO2A6dSs9YHZhbHVlIC89IGZsb2F0KCR7c30gLSBwYWQpO2A7bGV0IGY9YFxuICAgICAgICAke3RjKGFbMF0uZGltcyxyLGksdSxcIjAuMFwiKX1cbiAgICAgIGA7cmV0dXJuey4uLnQsb3V0cHV0OntkaW1zOm4sdHlwZTphWzBdLnR5cGUsdGV4dHVyZVR5cGU6MH0sc2hhZGVyU291cmNlOmZ9fSxZZj0oYSx0LG8pPT57dW8odCk7bGV0IGU9e25hbWU6XCJHbG9iYWxBdmVyYWdlUG9vbFwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOlswXSxjYWNoZUhpbnQ6YCR7by5jb3VudEluY2x1ZGVQYWR9YH07cmV0dXJuW2EucnVuKHsuLi5lLGdldDooKT0+amYodCxlLCEwLG8pfSx0KV19LFhmPWE9PntsZXQgdD1hLmF0dHJpYnV0ZXMuZ2V0SW50KFwiY291bnRfaW5jbHVkZV9wYWRcIiwwKSE9PTA7cmV0dXJuIGVlKHthdXRvUGFkOlwiXCIsY2VpbE1vZGU6MCxjb3VudEluY2x1ZGVQYWQ6dCxrZXJuZWxTaGFwZTpbXSxzdHJpZGVzOltdLHBhZHM6W119KX0sS2Y9KGEsdCxvKT0+e3VvKHQpO2xldCBlPXtuYW1lOlwiTWF4UG9vbFwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOlswXSxjYWNoZUhpbnQ6by5jYWNoZUtleX07cmV0dXJuW2EucnVuKHsuLi5lLGdldDooKT0+WmYodCxlLCExLG8pfSx0KV19LEpmPWE9PntsZXQgdD1hLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwiYXV0b19wYWRcIixcIk5PVFNFVFwiKSxvPWEuYXR0cmlidXRlcy5nZXRJbnQoXCJjZWlsX21vZGVcIiwwKSxlPWEuYXR0cmlidXRlcy5nZXRJbnRzKFwia2VybmVsX3NoYXBlXCIpLHI9YS5hdHRyaWJ1dGVzLmdldEludHMoXCJzdHJpZGVzXCIsW10pLG49YS5hdHRyaWJ1dGVzLmdldEludHMoXCJwYWRzXCIsW10pLHM9YS5hdHRyaWJ1dGVzLmdldEludChcInN0b3JhZ2Vfb3JkZXJcIiwwKSxpPWEuYXR0cmlidXRlcy5nZXRJbnRzKFwiZGlsYXRpb25zXCIsW10pO2lmKHMhPT0wKXRocm93IG5ldyBFcnJvcihcImNvbHVtbiBtYWpvciBzdG9yYWdlIG9yZGVyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO2lmKG8hPT0wKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtyZXR1cm4gZWUoe2F1dG9QYWQ6dCxjZWlsTW9kZTpvLGNvdW50SW5jbHVkZVBhZDohMSxrZXJuZWxTaGFwZTplLHN0cmlkZXM6cixwYWRzOm4sc3RvcmFnZU9yZGVyOnMsZGlsYXRpb25zOml9KX0sWmY9KGEsdCxvLGUpPT57bGV0W3Isbl09UWYoYSxlLG8pLHM9YFxuICAgICAgdmFsdWUgPSBtYXgoX1goeCksIHZhbHVlKTtcbiAgICBgLGk9XCJcIixsPWBcbiAgICAgICR7dGMoYVswXS5kaW1zLHIscyxpLFwiLTFlNVwiKX1cbiAgICBgO3JldHVybnsuLi50LG91dHB1dDp7ZGltczpuLHR5cGU6YVswXS50eXBlLHRleHR1cmVUeXBlOjB9LHNoYWRlclNvdXJjZTpsfX0sUWY9KGEsdCxvKT0+e2xldCBlPWFbMF0uZGltcy5zbGljZSgpLHI9T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxcImRpbGF0aW9uc1wiKSxuPXQua2VybmVsU2hhcGUuc2xpY2UoKSxzPXQuc3RyaWRlcy5zbGljZSgpLGk9cj90LmRpbGF0aW9ucy5zbGljZSgpOltdLHU9dC5wYWRzLnNsaWNlKCk7ZHIuYWRqdXN0UG9vbEF0dHJpYnV0ZXMobyxlLG4scyxpLHUpO2xldCBsPWRyLmNvbXB1dGVQb29sT3V0cHV0U2hhcGUobyxlLHMsaSxuLHUsdC5hdXRvUGFkKSxmPU9iamVjdC5hc3NpZ24oe30sdCk7cmV0dXJuIHI/T2JqZWN0LmFzc2lnbihmLHtrZXJuZWxTaGFwZTpuLHN0cmlkZXM6cyxwYWRzOnUsZGlsYXRpb25zOmksY2FjaGVLZXk6dC5jYWNoZUtleX0pOk9iamVjdC5hc3NpZ24oZix7a2VybmVsU2hhcGU6bixzdHJpZGVzOnMscGFkczp1LGNhY2hlS2V5OnQuY2FjaGVLZXl9KSxbZixsXX0seWI9e2F1dG9QYWQ6XCJcIixjZWlsTW9kZTowLGNvdW50SW5jbHVkZVBhZDohMSxrZXJuZWxTaGFwZTpbXSxzdHJpZGVzOltdLHBhZHM6W10sc3RvcmFnZU9yZGVyOjAsZGlsYXRpb25zOltdLGNhY2hlS2V5OlwiXCJ9LFdmPXtuYW1lOlwiR2xvYmFsTWF4UG9vbFwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOlswXX0sZWM9KGEsdCk9Pih1byh0KSxbYS5ydW4oey4uLldmLGdldDooKT0+WmYodCxXZiwhMCx5Yil9LHQpXSksdW89YT0+e2lmKCFhfHxhLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiUG9vbCBvcHMgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoYVswXS50eXBlIT09XCJmbG9hdDMyXCImJmFbMF0udHlwZSE9PVwiZmxvYXQ2NFwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9LHRjPShhLHQsbyxlLHIpPT57bGV0IG49YS5sZW5ndGg7aWYodC5rZXJuZWxTaGFwZS5sZW5ndGg8PTIpe2xldCBzPXQua2VybmVsU2hhcGVbdC5rZXJuZWxTaGFwZS5sZW5ndGgtMV0saT10LnN0cmlkZXNbdC5zdHJpZGVzLmxlbmd0aC0xXSx1PXQucGFkc1t0LnBhZHMubGVuZ3RoLzItMV0sbD10LnBhZHNbdC5wYWRzLmxlbmd0aC0xXSxmPWFbbi0xXSxwPVwiXCIsZD1cIlwiLFQ9XCJcIjtpZih1K2whPT0wP3A9YFxuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtzfTsgaSsrKSB7XG4gICAgICAgICAgICB4WyR7bn0gLSAxXSA9IGluZGljZXNbJHtufSAtIDFdICogJHtpfSAtICR7dX0gKyBpO1xuICAgICAgICAgICAgaWYgKHhbJHtufSAtIDFdIDwgMCB8fCB4WyR7bn0gLSAxXSA+PSAke2Z9KSB7XG4gICAgICAgICAgICAgIHBhZCsrO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR7b31cbiAgICAgICAgICB9YDpwPWBcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7c307IGkrKykge1xuICAgICAgICAgICAgeFske259IC0gMV0gPSBpbmRpY2VzWyR7bn0gLSAxXSAqICR7aX0gLSAke3V9ICsgaTtcbiAgICAgICAgICAgICR7b31cbiAgICAgICAgICB9YCx0Lmtlcm5lbFNoYXBlLmxlbmd0aD09PTIpe2xldCB3PXQua2VybmVsU2hhcGVbdC5rZXJuZWxTaGFwZS5sZW5ndGgtMl0sST10LnN0cmlkZXNbdC5zdHJpZGVzLmxlbmd0aC0yXSxMPXQucGFkc1t0LnBhZHMubGVuZ3RoLzItMl0sRj10LnBhZHNbdC5wYWRzLmxlbmd0aC0yXSxDPWFbbi0yXTtMK0YhPT0wP2Q9YFxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCAke3d9OyBqKyspIHtcbiAgICAgICAgICAgICAgeFske259IC0gMl0gPSBpbmRpY2VzWyR7bn0gLSAyXSAqICR7SX0gLSAke0x9ICsgajtcbiAgICAgICAgICAgICAgaWYgKHhbJHtufSAtIDJdIDwgMCB8fCB4WyR7bn0gLSAyXSA+PSAke0N9KSB7XG4gICAgICAgICAgICAgICAgcGFkKz0gJHtzfTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIGA6ZD1gXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8ICR7d307IGorKykge1xuICAgICAgICAgICAgICB4WyR7bn0gLSAyXSA9IGluZGljZXNbJHtufSAtIDJdICogJHtJfSAtICR7TH0gKyBqO1xuICAgICAgICAgICAgYCxUPWBcbiAgICAgICAgICB9XG4gICAgICAgIGB9cmV0dXJuYFxuICAgICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7bn1dKSB7XG4gICAgICAgICAgaW50IHhbJHtufV07XG4gICAgICAgICAgY29weVZlYyhpbmRpY2VzLCB4KTtcblxuICAgICAgICAgIGZsb2F0IHZhbHVlID0gJHtyfTtcbiAgICAgICAgICBpbnQgcGFkID0gMDtcbiAgICAgICAgICAke2R9XG4gICAgICAgICAgJHtwfVxuICAgICAgICAgICR7VH1cbiAgICAgICAgICAke2V9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICBgfWVsc2V7bGV0IHM9VS5zaXplKHQua2VybmVsU2hhcGUpLGk9VS5jb21wdXRlU3RyaWRlcyh0Lmtlcm5lbFNoYXBlKSx1PWkubGVuZ3RoLGw9dC5wYWRzLmxlbmd0aCxmPVRiKHUpLHA9c28oYSxcImlucHV0RGltc1wiKSxkPXNvKHQucGFkcyxcInBhZHNcIiksVD1zbyhpLFwia2VybmVsU3RyaWRlc1wiKSx2PXNvKHQuc3RyaWRlcyxcInN0cmlkZXNcIiksdz10LnBhZHMucmVkdWNlKChGLEMpPT5GK0MpLEk9XCJcIjtyZXR1cm4gdz9JPWBcbiAgICAgICAgICAgIGlmICh4W2pdID49IGlucHV0RGltc1tqXSB8fCB4W2pdIDwgMCkge1xuICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgaXNQYWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1BhZCkge1xuICAgICAgICAgICAgJHtvfVxuICAgICAgICAgIH1gOkk9YFxuICAgICAgICAgIH1cbiAgICAgICAgICAke299XG4gICAgICAgIGAsYFxuICAgICAgICAke2Z9XG4gICAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtufV0pIHtcbiAgICAgICAgICBpbnQgeFske259XTtcbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIHgpO1xuICAgICAgICAgIGludCBvZmZzZXRbJHt1fV07XG4gICAgICAgICAgaW50IHBhZHNbJHtsfV07XG4gICAgICAgICAgaW50IGlucHV0RGltc1ske259XTtcbiAgICAgICAgICBpbnQga2VybmVsU3RyaWRlc1ske3V9XTtcbiAgICAgICAgICBpbnQgc3RyaWRlc1ske3V9XTtcbiAgICAgICAgICAke2R9XG4gICAgICAgICAgJHtwfVxuICAgICAgICAgICR7dn1cbiAgICAgICAgICAke1R9XG5cbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9ICR7cn07XG4gICAgICAgICAgaW50IHBhZCA9IDA7XG4gICAgICAgICAgYm9vbCBpc1BhZCA9IGZhbHNlO1xuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtzfTsgaSsrKSB7XG4gICAgICAgICAgICBvZmZzZXRUb0luZGljZXMoaSwga2VybmVsU3RyaWRlcywgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGludCBqID0gJHtufSAtICR7dX07IGogPCAke259OyBqKyspIHtcbiAgICAgICAgICAgICAgeFtqXSA9IGluZGljZXNbal0gKiBzdHJpZGVzW2ogLSAke259ICsgJHt1fV1cbiAgICAgICAgICAgICAgICArIG9mZnNldFtqIC0gJHtufSArICR7dX1dIC0gcGFkc1tqIC0gMl07XG4gICAgICAgICAgICAgICR7SX1cbiAgICAgICAgICB9XG4gICAgICAgICAgJHtlfVxuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICBgfX0sc289KGEsdCk9PntsZXQgbz1cIlwiO2ZvcihsZXQgZT0wO2U8YS5sZW5ndGg7ZSsrKW8rPWBcbiAgICAgICR7dH1bJHtlfV0gPSAke2FbZV19O1xuICAgIGA7cmV0dXJuIG99LFRiPWE9PmBcbiAgdm9pZCBvZmZzZXRUb0luZGljZXMoaW50IG9mZnNldCwgaW50WyR7YX1dIHN0cmlkZXMsIG91dCBpbnRbJHthfV0gaW5kaWNlcykge1xuICAgIGlmICgke2F9ID09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2F9IC0gMTsgKytpKSB7XG4gICAgICBpbmRpY2VzW2ldID0gb2Zmc2V0IC8gc3RyaWRlc1tpXTtcbiAgICAgIG9mZnNldCAtPSBpbmRpY2VzW2ldICogc3RyaWRlc1tpXTtcbiAgICB9XG4gICAgaW5kaWNlc1ske2F9IC0gMV0gPSBvZmZzZXQ7XG4gIH1gfSk7dmFyIHhyLFp0LHhiLHdiLG5jLG9jLGljLGFjLHNjLHVjLGxjLGZjPUUoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO2huKCk7ZmUoKTthZSgpO3hyPShhLHQsbyxlLHIpPT57d2IodCk7bGV0IG49e25hbWU6ZSxpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbMF19O3JldHVyblthLnJ1bih7Li4ubixjYWNoZUhpbnQ6by5jYWNoZUtleSxnZXQ6KCk9PnhiKGEsdCxvLGUscixuKX0sdCldfSxadD1hPT57bGV0IHQ9YS5hdHRyaWJ1dGVzLmdldEludHMoXCJheGVzXCIsW10pLG89YS5hdHRyaWJ1dGVzLmdldEludChcImtlZXBkaW1zXCIsMSk9PT0xO3JldHVybiBlZSh7YXhlczp0LGtlZXBEaW1zOm99KX0seGI9KGEsdCxvLGUscixuKT0+e2xldCBzPVtdLGk9dFswXS5kaW1zLmxlbmd0aHx8MSx1PVtdLGw9VS5ub3JtYWxpemVBeGVzKG8uYXhlcyx0WzBdLmRpbXMubGVuZ3RoKSxmPXIodCxsKSxwPWZbMV07Zm9yKGxldCB2PTA7djx0WzBdLmRpbXMubGVuZ3RoO3YrKylsLmluZGV4T2Yodik+PTB8fGwubGVuZ3RoPT09MD8oby5rZWVwRGltcyYmcy5wdXNoKDEpLHA9YFxuICAgICAgICAgIGZvcihpbnQgaiR7dn0gPSAwOyBqJHt2fSA8ICR7dFswXS5kaW1zW3ZdfTsgaiR7dn0rKykge1xuICAgICAgICAgICAgaW5wdXRJZHhbJHt2fV0gPSBqJHt2fTtcbiAgICAgICAgICAgICR7cH1cbiAgICAgICAgICB9YCk6KHUucHVzaChgaW5wdXRJZHhbJHt2fV0gPSBvdXRwdXRJZHhbJHtzLmxlbmd0aH1dO2ApLHMucHVzaCh0WzBdLmRpbXNbdl0pKTtsZXQgVD1gXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHtzLmxlbmd0aHx8MX1dKSB7XG4gICAgICAgIGZsb2F0IHZhbHVlOyAgICAgICAgICAgICAgICAgLy8gZmluYWwgcmVzdWx0XG4gICAgICAgIGludCBpbnB1dElkeFske2l9XTsgICAgICAvLyBhZGRyZXNzaW5nIGlucHV0IGRhdGFcbiAgICAgICAgJHt1LmpvaW4oYFxuYCl9XG4gICAgICAgICR7ZlswXX0gICAgICAgLy8gaW5pdCBvcHMgZm9yIHJlZHVjZSBtYXgvbWluXG4gICAgICAgICR7cH1cbiAgICAgICAgJHtmWzJdfSAgICAgICAvLyBmaW5hbCBjb21wdXRhdGlvbiBmb3IgcmVkdWNlIG1lYW5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfWA7cmV0dXJuey4uLm4sb3V0cHV0OntkaW1zOnMsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6MH0sc2hhZGVyU291cmNlOlR9fSx3Yj1hPT57aWYoIWF8fGEubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJSZWR1Y2Ugb3AgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoSnQuaW5kZXhPZihhWzBdLnR5cGUpPT09LTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0sbmM9KGEsdCxvKT0+eHIoYSx0LG8sXCJSZWR1Y2VTdW1cIiwoKT0+W1widmFsdWUgPSAwLjA7XCIsXCJ2YWx1ZSArPSBfQShpbnB1dElkeCk7XCIsXCJcIl0pLG9jPShhLHQsbyk9PnhyKGEsdCxvLFwiUmVkdWNlTWVhblwiLChyLG4pPT57bGV0IHM9MTtmb3IobGV0IGk9MDtpPHJbMF0uZGltcy5sZW5ndGg7aSsrKShuLmluZGV4T2YoaSk+PTB8fG4ubGVuZ3RoPT09MCkmJihzKj1yWzBdLmRpbXNbaV0pO3JldHVybltcInZhbHVlID0gMC4wO1wiLFwidmFsdWUgKz0gX0EoaW5wdXRJZHgpO1wiLGB2YWx1ZSAvPSAke3N9LjtgXX0pLGljPShhLHQsbyk9PnhyKGEsdCxvLFwiUmVkdWNlTWF4XCIsKHIsbik9PntsZXQgcz1bXTtmb3IobGV0IGk9MDtpPHJbMF0uZGltcy5sZW5ndGg7aSsrKShuLmluZGV4T2YoaSk+PTB8fG4ubGVuZ3RoPT09MCkmJnMucHVzaChgaW5wdXRJZHhbJHtpfV0gPSAwO2ApO3JldHVybltgJHtzLmpvaW4oYFxuYCl9XG52YWx1ZSA9IF9BKGlucHV0SWR4KTtgLFwidmFsdWUgPSBtYXgodmFsdWUsIF9BKGlucHV0SWR4KSk7XCIsXCJcIl19KSxhYz0oYSx0LG8pPT54cihhLHQsbyxcIlJlZHVjZU1pblwiLChyLG4pPT57bGV0IHM9W107Zm9yKGxldCBpPTA7aTxyWzBdLmRpbXMubGVuZ3RoO2krKykobi5pbmRleE9mKGkpPj0wfHxuLmxlbmd0aD09PTApJiZzLnB1c2goYGlucHV0SWR4WyR7aX1dID0gMDtgKTtyZXR1cm5bYCR7cy5qb2luKGBcbmApfVxudmFsdWUgPSBfQShpbnB1dElkeCk7YCxcInZhbHVlID0gbWluKHZhbHVlLCBfQShpbnB1dElkeCkpO1wiLFwiXCJdfSksc2M9KGEsdCxvKT0+eHIoYSx0LG8sXCJSZWR1Y2VQcm9kXCIsKCk9PltcInZhbHVlID0gMS4wO1wiLFwidmFsdWUgKj0gX0EoaW5wdXRJZHgpO1wiLFwiXCJdKSx1Yz0oYSx0LG8pPT54cihhLHQsbyxcIlJlZHVjZUxvZ1N1bVwiLCgpPT5bXCJ2YWx1ZSA9IDAuMDtcIixcInZhbHVlICs9IF9BKGlucHV0SWR4KTtcIixcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pLGxjPShhLHQsbyk9PnhyKGEsdCxvLFwiUmVkdWNlTG9nU3VtU3F1YXJlXCIsKCk9PltcImZsb2F0IHQ7IHZhbHVlID0gMC4wO1wiLFwidCA9IF9BKGlucHV0SWR4KTsgdmFsdWUgKz0gdCAqIHQ7XCIsXCJcIl0pfSk7dmFyIGNjLHBjPUUoKCk9PntcInVzZSBzdHJpY3RcIjtmZSgpO2NjPShhLHQpPT57bGV0IG89VS5jYWxjdWxhdGVSZXNoYXBlZERpbXModFswXS5kaW1zLHRbMV0uaW50ZWdlckRhdGEpO3JldHVybiBhLnNlc3Npb24ucGFjaz9bYS5yZXNoYXBlUGFja2VkKHRbMF0sbyldOlthLnJlc2hhcGVVbnBhY2tlZCh0WzBdLG8pXX19KTt2YXIgZGMsTmksaGMsbWMsbW4sdmIsUmksbG8sTWk9RSgoKT0+e1widXNlIHN0cmljdFwiO0dlKCk7eGUoKTthZSgpO2RjPXtuYW1lOlwiVXBzYW1wbGVcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbMF19LE5pPShhLHQsbyk9PihSaSh0LG8pLFthLnJ1bih7Li4uZGMsY2FjaGVIaW50Om8uY2FjaGVLZXksZ2V0OigpPT52YihhLHQsbyl9LHQpXSksaGM9YT0+bW4oYSw3KSxtYz1hPT5tbihhLDkpLG1uPShhLHQpPT57bGV0IG89dD49MTAsZT1hLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwibW9kZVwiLFwibmVhcmVzdFwiKTtpZihlIT09XCJuZWFyZXN0XCImJmUhPT1cImxpbmVhclwiJiYodDwxMXx8ZSE9PVwiY3ViaWNcIikpdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgbW9kZTogJHtlfWApO2xldCByPVtdO3Q8OSYmKHI9YS5hdHRyaWJ1dGVzLmdldEZsb2F0cyhcInNjYWxlc1wiKSxsbyhyLGUsbykpO2xldCBuPWEuYXR0cmlidXRlcy5nZXRGbG9hdChcImV4dHJhcG9sYXRpb25fdmFsdWVcIiwwKSxzPXQ+MTA/YS5hdHRyaWJ1dGVzLmdldFN0cmluZyhcImNvb3JkaW5hdGVfdHJhbnNmb3JtYXRpb25fbW9kZVwiLFwiaGFsZl9waXhlbFwiKTpcImFzeW1tZXRyaWNcIjtpZihbXCJhc3ltbWV0cmljXCIsXCJweXRvcmNoX2hhbGZfcGl4ZWxcIixcInRmX2hhbGZfcGl4ZWxfZm9yX25uXCIsXCJhbGlnbl9jb3JuZXJzXCIsXCJ0Zl9jcm9wX2FuZF9yZXNpemVcIixcImhhbGZfcGl4ZWxcIl0uaW5kZXhPZihzKT09PS0xKXRocm93IG5ldyBFcnJvcihgY29vcmRpbmF0ZV90cmFuc2Zvcm1fbW9kZSAnJHtzfScgaXMgbm90IHN1cHBvcnRlZGApO2xldCBpPXM9PT1cInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiLHU9aSxsPWU9PT1cIm5lYXJlc3RcIiYmdD49MTE/YS5hdHRyaWJ1dGVzLmdldFN0cmluZyhcIm5lYXJlc3RfbW9kZVwiLFwicm91bmRfcHJlZmVyX2Zsb29yXCIpOlwiXCI7aWYoW1wicm91bmRfcHJlZmVyX2Zsb29yXCIsXCJyb3VuZF9wcmVmZXJfY2VpbFwiLFwiZmxvb3JcIixcImNlaWxcIixcIlwiXS5pbmRleE9mKGwpPT09LTEpdGhyb3cgbmV3IEVycm9yKGBuZWFyZXN0X21vZGUgJyR7bH0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtsZXQgZj1hLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJjdWJpY19jb2VmZl9hXCIsLS43NSkscD1hLmF0dHJpYnV0ZXMuZ2V0SW50KFwiZXhjbHVkZV9vdXRzaWRlXCIsMCkhPT0wO2lmKHAmJmUhPT1cImN1YmljXCIpdGhyb3cgbmV3IEVycm9yKFwiZXhjbHVkZV9vdXRzaWRlIGNhbiBiZSBzZXQgdG8gMSBvbmx5IHdoZW4gbW9kZSBpcyBDVUJJQy5cIik7bGV0IGQ9dDwxMT8hMDplPT09XCJuZWFyZXN0XCImJnM9PT1cImFzeW1tZXRyaWNcIiYmbD09PVwiZmxvb3JcIixUPTAsdj0wLHc9MDtyZXR1cm4gdD4xMD9hLmlucHV0cy5sZW5ndGg+Mj8oVD0xLHY9Mix3PTMpOih2PTEsdz0yKTp0PT09OSYmKHY9MSksZWUoe29wc2V0OnQsaXNSZXNpemU6byxtb2RlOmUsc2NhbGVzOnIsZXh0cmFwb2xhdGlvblZhbHVlOm4sY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6cyx1c2VFeHRyYXBvbGF0aW9uOnUsbmVlZFJvaUlucHV0OmksbmVhcmVzdE1vZGU6bCxjdWJpY0NvZWZmaWNpZW50QTpmLGV4Y2x1ZGVPdXRzaWRlOnAsdXNlTmVhcmVzdDJ4T3B0aW1pemF0aW9uOmQscm9pSW5wdXRJZHg6VCxzY2FsZXNJbnB1dElkeDp2LHNpemVzSW5wdXRJZHg6d30pfSx2Yj0oYSx0LG8pPT57bGV0IGU9cShhLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksW3Isbl09YS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQodFswXS5kaW1zLDApLHM9dFswXS5kaW1zLm1hcCgodyxJKT0+TWF0aC5mbG9vcih3Km8uc2NhbGVzW0ldKSksW2ksdV09YS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQocywwKSxsPXMubGVuZ3RoLGY9bmV3IEFycmF5KGwpLHA9bmV3IEFycmF5KGwpLGQ9YFxuICAgICAgaW50IG91dHB1dF9waXRjaGVzWyR7bH1dO1xuICAgICAgaW50IGlucHV0X3BpdGNoZXNbJHtsfV07XG4gICAgICBgO2ZvcihsZXQgdz1sLTE7dz49MDt3LS0pZlt3XT13PT09bC0xPzE6Zlt3KzFdKnNbdysxXSxwW3ddPXc9PT1sLTE/MTpwW3crMV0qdFswXS5kaW1zW3crMV0sZCs9YFxuICAgICAgICBvdXRwdXRfcGl0Y2hlc1ske3d9XSA9ICR7Zlt3XX07XG4gICAgICAgIGlucHV0X3BpdGNoZXNbJHt3fV0gPSAke3Bbd119O1xuICAgICAgICBgO2xldCBUPWBcbiAgICAgIGZsb2F0IGdldElucHV0RmxvYXQoaW50IGluZGV4KSB7XG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMoaW5kZXgsICR7cn0sICR7bn0pO1xuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke2UudGV4dHVyZTJEfShYLCBjb29yZHMpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgYCx2PW8ubW9kZT09PVwibmVhcmVzdFwiP2BcbiAgICAke1R9XG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2x9XSkge1xuICAgICAgaW50IGlucHV0X2luZGV4ID0gMDtcbiAgICAgIGludCBvdXRwdXRfaW5kZXggPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7aX0sICR7dX0pO1xuXG4gICAgICAke2R9XG5cbiAgICAgIGludCBkLCBtO1xuICAgICAgZm9yIChpbnQgZGltID0gMDsgZGltIDwgJHtsfTsgKytkaW0pIHtcbiAgICAgICAgZCA9IG91dHB1dF9pbmRleCAvIG91dHB1dF9waXRjaGVzW2RpbV07XG4gICAgICAgIG0gPSBvdXRwdXRfaW5kZXggLSBkICogb3V0cHV0X3BpdGNoZXNbZGltXTtcbiAgICAgICAgb3V0cHV0X2luZGV4ID0gbTtcblxuICAgICAgICBpZiAoc2NhbGVzW2RpbV0gIT0gMSAmJiBkID4gMCkge1xuICAgICAgICAgIGludCBkMiA9IGQgLyBzY2FsZXNbZGltXTtcbiAgICAgICAgICBtID0gZCAtIGQyICogc2NhbGVzW2RpbV07XG4gICAgICAgICAgZCA9IGQyO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0X2luZGV4ICs9IGlucHV0X3BpdGNoZXNbZGltXSAqIGQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4KTtcbiAgICB9YDpsPT09ND9gXG4gICAgJHtUfVxuICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbNF0pIHtcbiAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XG4gICAgICBpbnQgb3V0cHV0X2luZGV4ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke2l9LCAke3V9KTtcblxuICAgICAgJHtkfVxuXG4gICAgICBpbnQgbTtcbiAgICAgIGludCBpbmRleF9vZl9kaW0wLCBpbmRleF9vZl9kaW0xLCBpbmRleF9vZl9kaW0yLCBpbmRleF9vZl9kaW0zO1xuICAgICAgaW5kZXhfb2ZfZGltMCA9IG91dHB1dF9pbmRleCAvIG91dHB1dF9waXRjaGVzWzBdO1xuICAgICAgbSA9IG91dHB1dF9pbmRleCAtIGluZGV4X29mX2RpbTAgKiBvdXRwdXRfcGl0Y2hlc1swXTtcbiAgICAgIGluZGV4X29mX2RpbTEgPSBtIC8gb3V0cHV0X3BpdGNoZXNbMV07XG4gICAgICBtID0gbSAtIGluZGV4X29mX2RpbTEgKiBvdXRwdXRfcGl0Y2hlc1sxXTtcbiAgICAgIGluZGV4X29mX2RpbTIgPSBtIC8gb3V0cHV0X3BpdGNoZXNbMl07XG4gICAgICBtID0gbSAtIGluZGV4X29mX2RpbTIgKiBvdXRwdXRfcGl0Y2hlc1syXTtcbiAgICAgIGluZGV4X29mX2RpbTMgPSBtO1xuXG4gICAgICBpbnQgaW5kZXhfb2ZfaW5wdXRfZGltMiwgaW5kZXhfb2ZfaW5wdXRfZGltMywgeF9vZmZzZXQsIHlfb2Zmc2V0O1xuICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMiA9IGluZGV4X29mX2RpbTIgLyBzY2FsZXNbMl07XG4gICAgICB5X29mZnNldCA9IGluZGV4X29mX2RpbTIgLSBpbmRleF9vZl9pbnB1dF9kaW0yICogc2NhbGVzWzJdO1xuICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMyA9IGluZGV4X29mX2RpbTMgLyBzY2FsZXNbM107XG4gICAgICB4X29mZnNldCA9IGluZGV4X29mX2RpbTMgLSBpbmRleF9vZl9pbnB1dF9kaW0zICogc2NhbGVzWzNdO1xuXG4gICAgICBpbnB1dF9pbmRleCA9IGluZGV4X29mX2RpbTAgKiBpbnB1dF9waXRjaGVzWzBdICtcbiAgICAgICAgICAgIGluZGV4X29mX2RpbTEgKiBpbnB1dF9waXRjaGVzWzFdICtcbiAgICAgICAgICAgIGluZGV4X29mX2lucHV0X2RpbTIgKiBpbnB1dF9waXRjaGVzWzJdICtcbiAgICAgICAgICAgIGluZGV4X29mX2lucHV0X2RpbTM7XG5cbiAgICAgIGZsb2F0IHgwMCA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXgpO1xuICAgICAgZmxvYXQgeDEwLCB4MDEsIHgxMTtcblxuICAgICAgYm9vbCBlbmRfb2ZfZGltMiA9IGZhbHNlO1xuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTIgPT0gKCR7dFswXS5kaW1zWzJdfSAtIDEpKSB7XG4gICAgICAgIC8vIEl0J3MgdGhlIGVuZCBpbiBkaW1lbnNpb24gMlxuICAgICAgICB4MDEgPSB4MDA7XG4gICAgICAgIGVuZF9vZl9kaW0yID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgwMSA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzJdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTMgPT0gKGlucHV0X3BpdGNoZXNbMl0gLSAxKSkge1xuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDNcbiAgICAgICAgeDEwID0geDAwO1xuICAgICAgICB4MTEgPSB4MDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgeDEwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIDEpO1xuICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMiA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzJdICsgMSk7XG4gICAgICB9XG5cbiAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xuICAgICAgZmxvYXQgeTEgPSB4MTAgKyBmbG9hdCh5X29mZnNldCkgKiAoeDExIC0geDEwKSAvIGZsb2F0KHNjYWxlc1syXSk7XG4gICAgICByZXR1cm4geTAgKyBmbG9hdCh4X29mZnNldCkgKiAoeTEgLSB5MCkgLyBmbG9hdChzY2FsZXNbM10pO1xuICAgIH1gOmBcbiAgICAke1R9XG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1syXSkge1xuICAgICAgaW50IGlucHV0X2luZGV4ID0gMDtcbiAgICAgIGludCBvdXRwdXRfaW5kZXggPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7aX0sICR7dX0pO1xuXG4gICAgICAke2R9XG5cbiAgICAgIGludCBtO1xuICAgICAgaW50IGluZGV4X29mX2RpbTAsIGluZGV4X29mX2RpbTE7XG4gICAgICBpbmRleF9vZl9kaW0wID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbMF07XG4gICAgICBtID0gb3V0cHV0X2luZGV4IC0gaW5kZXhfb2ZfZGltMCAqIG91dHB1dF9waXRjaGVzWzBdO1xuICAgICAgaW5kZXhfb2ZfZGltMSA9IG07XG5cbiAgICAgIGludCBpbmRleF9vZl9pbnB1dF9kaW0wLCBpbmRleF9vZl9pbnB1dF9kaW0xLCB4X29mZnNldCwgeV9vZmZzZXQ7XG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0wID0gaW5kZXhfb2ZfZGltMCAvIHNjYWxlc1swXTtcbiAgICAgIHlfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMCAtIGluZGV4X29mX2lucHV0X2RpbTAgKiBzY2FsZXNbMF07XG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0xID0gaW5kZXhfb2ZfZGltMSAvIHNjYWxlc1sxXTtcbiAgICAgIHhfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMSAtIGluZGV4X29mX2lucHV0X2RpbTEgKiBzY2FsZXNbMV07XG5cbiAgICAgIGlucHV0X2luZGV4ID0gaW5kZXhfb2ZfaW5wdXRfZGltMCAqIGlucHV0X3BpdGNoZXNbMF0gKyBpbmRleF9vZl9pbnB1dF9kaW0xO1xuXG4gICAgICBmbG9hdCB4MDAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4KTtcbiAgICAgIGZsb2F0IHgxMCwgeDAxLCB4MTE7XG5cbiAgICAgIGJvb2wgZW5kX29mX2RpbTAgPSBmYWxzZTtcbiAgICAgIGlmIChpbmRleF9vZl9pbnB1dF9kaW0wID09ICgke3RbMF0uZGltc1swXX0gLSAxKSkge1xuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDBcbiAgICAgICAgeDAxID0geDAwO1xuICAgICAgICBlbmRfb2ZfZGltMCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MDEgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgaW5wdXRfcGl0Y2hlc1swXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleF9vZl9pbnB1dF9kaW0xID09IChpbnB1dF9waXRjaGVzWzBdIC0gMSkpIHtcbiAgICAgICAgLy8gSXQncyB0aGUgZW5kIGluIGRpbWVuc2lvbiAxXG4gICAgICAgIHgxMCA9IHgwMDtcbiAgICAgICAgeDExID0geDAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHgxMCA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyAxKTtcbiAgICAgICAgeDExID0gZW5kX29mX2RpbTAgPyB4MTAgOiBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgaW5wdXRfcGl0Y2hlc1swXSArIDEpO1xuICAgICAgfVxuXG4gICAgICBmbG9hdCB5MCA9IHgwMCArIGZsb2F0KHlfb2Zmc2V0KSAqICh4MDEgLSB4MDApIC8gZmxvYXQoc2NhbGVzWzBdKTtcbiAgICAgIGZsb2F0IHkxID0geDEwICsgZmxvYXQoeV9vZmZzZXQpICogKHgxMSAtIHgxMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xuICAgICAgcmV0dXJuIHkwICsgZmxvYXQoeF9vZmZzZXQpICogKHkxIC0geTApIC8gZmxvYXQoc2NhbGVzWzFdKTtcbiAgICB9YDtyZXR1cm57Li4uZGMsb3V0cHV0OntkaW1zOnMsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6MH0sc2hhZGVyU291cmNlOnYsdmFyaWFibGVzOlt7bmFtZTpcInNjYWxlc1wiLHR5cGU6XCJpbnRcIixhcnJheUxlbmd0aDpvLnNjYWxlcy5sZW5ndGgsZGF0YTpvLnNjYWxlcy5tYXAodz0+TWF0aC5jZWlsKHcpKX1dfX0sUmk9KGEsdCk9PntpZighYXx8dC5vcHNldDw5JiZhLmxlbmd0aCE9PTF8fHQub3BzZXQ+PTkmJnQub3BzZXQ8MTEmJmEubGVuZ3RoIT09Mnx8dC5vcHNldD49MTEmJmEubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dHMuXCIpO2lmKHQuc2NhbGVzLmxlbmd0aD4wJiZhWzBdLmRpbXMubGVuZ3RoIT09dC5zY2FsZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKGFbMF0udHlwZT09PVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSxsbz0oYSx0LG8pPT57aWYobyl7Zm9yKGxldCBlIG9mIGEpaWYoZTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJTY2FsZSB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDAuXCIpfWVsc2UgZm9yKGxldCBlIG9mIGEpaWYoZTwxKXRocm93IG5ldyBFcnJvcihcIlNjYWxlIHZhbHVlIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMS5cIik7aWYoKHQ9PT1cImxpbmVhclwifHx0PT09XCJjdWJpY1wiKSYmYS5sZW5ndGghPT0yJiYoYS5sZW5ndGghPT00fHxhWzBdIT09MXx8YVsxXSE9PTEpKXRocm93IG5ldyBFcnJvcihgJ0xpbmVhcicgbW9kZSBhbmQgJ0N1YmljJyBtb2RlIG9ubHkgc3VwcG9ydCAyLUQgaW5wdXRzICgnQmlsaW5lYXInLCAnQmljdWJpYycpICAgICAgICAgb3IgNC1EIGlucHV0cyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIG91dGVybW9zdCAyIHNjYWxlIHZhbHVlcyBiZWluZyAxICAgICAgICAgaW4gdGhlICR7bz9cIlJlc2l6ZVwiOlwiVXBzYW1wbGVcIn0gb3BlYXJ0b3IuYCl9fSk7dmFyIEdpLFVpLGJjLGdjLF9iLE9iLEliLFNiLHljPUUoKCk9PntcInVzZSBzdHJpY3RcIjt4ZSgpO2FlKCk7a3QoKTtncigpO01pKCk7R2k9e25hbWU6XCJSZXNpemVcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbMl19LFVpPShhLHQsbyk9PihSaSh0LG8pLFthLnJ1bih7Li4uR2ksY2FjaGVIaW50Om8uY2FjaGVLZXksZ2V0OigpPT5fYihhLHQsbyl9LHQpXSksYmM9YT0+bW4oYSwxMCksZ2M9YT0+bW4oYSwxMSksX2I9KGEsdCxvKT0+e2xldCBlPXEoYS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLFtyLG5dPU9iKHQsbyk7aWYoci5ldmVyeShDPT5DPT09MSkmJm8uY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUhPT1cInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiKXJldHVybnsuLi5HaSxvdXRwdXQ6e2RpbXM6bix0eXBlOnRbMF0udHlwZSx0ZXh0dXJlVHlwZToyfSxoYXNNYWluOiEwLHNoYWRlclNvdXJjZTpgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICAgICB2ZWM0IHYgPSAke2UudGV4dHVyZTJEfShYLCBUZXhDb29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAke2Uub3V0cHV0fSA9IHY7XG4gICAgICAgICAgICAgICAgfWB9O2xldCBpPW4ubGVuZ3RoO2lmKGk8Mil0aHJvdyBuZXcgRXJyb3IoYG91dHB1dCBkaW1lbnNpb24gc2hvdWxkIGJlIGF0IGxlYXN0IDIsIGJ1dCBnb3QgJHtpfWApO2xldCB1PW5baS0yXSxsPW5baS0xXSxmPXRbMF0uZGltcztpZihpIT09Zi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBvdXRwdXQgZGltZW5zaW9uIHNob3VsZCBtYXRjaCBpbnB1dCAke2YubGVuZ3RofSwgYnV0IGdvdCAke2l9YCk7bGV0IHA9ZltpLTJdLGQ9ZltpLTFdLFQ9cltpLTJdLHY9cltpLTFdLHc9XCJcIjtpZihvLm1vZGUhPT1cImxpbmVhclwiKXRocm93IG5ldyBFcnJvcihgcmVzaXplIChwYWNrZWQpIGRvZXMgbm90IHN1cHBvcnQgbW9kZTogJyR7by5tb2RlfSdgKTtzd2l0Y2goby5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSl7Y2FzZVwiYXN5bW1ldHJpY1wiOnc9YFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZWM0KGNvb3JkcykgLyBzY2FsZVdIV0g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBgO2JyZWFrO2Nhc2VcImhhbGZfcGl4ZWxcIjp3PWBcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHZlYzQoY29vcmRzKSArIDAuNSkgLyBzY2FsZVdIV0ggLSAwLjU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBgO2JyZWFrO2Nhc2VcInB5dG9yY2hfaGFsZl9waXhlbFwiOnc9YFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgZmNvb3JkcyA9IHZlYzQoY29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZWM0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7bH0uMCA+IDEuMCA/IChmY29vcmRzLnggKyAwLjUpIC8gc2NhbGVXSFdILnggLSAwLjUgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHt1fS4wID4gMS4wID8gKGZjb29yZHMueSArIDAuNSkgLyBzY2FsZVdIV0gueSAtIDAuNSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2x9LjAgPiAxLjAgPyAoZmNvb3Jkcy56ICsgMC41KSAvIHNjYWxlV0hXSC56IC0gMC41IDogMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7dX0uMCA+IDEuMCA/IChmY29vcmRzLncgKyAwLjUpIC8gc2NhbGVXSFdILncgLSAwLjUgOiAwLjBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGA7YnJlYWs7Y2FzZVwiYWxpZ25fY29ybmVyc1wiOnc9YFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgcmVzaXplZCA9IHZlYzQoJHtsfS4wIC0gMS4wLCAke3V9LjAgLSAxLjAsICR7bH0uMCAtIDEuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke3V9LjAgLSAxLjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBvcmlnaW5hbCA9IHZlYzQoJHtkfS4wIC0gMS4wLCAke3B9LjAgLSAxLjAsICR7ZH0uMCAtIDEuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke3B9LjAgLSAxLjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBuZXdfc2NhbGUgPSBvcmlnaW5hbCAvIHJlc2l6ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpICogbmV3X3NjYWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYDticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgcmVzaXplIChwYWNrZWQpIGRvZXMgbm90IHN1cHBvcnQgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyR7by5jb29yZGluYXRlVHJhbnNmb3JtTW9kZX0nYCl9bGV0IEk9SmUoaSksTD1CdCgpLEY9YFxuICAgICAgICAgICAgY29uc3QgdmVjMiBpbnB1dFdIID0gdmVjMigke3B9LjAsICR7ZH0uMCk7XG4gICAgICAgICAgICBjb25zdCB2ZWM0IHNjYWxlV0hXSCA9IHZlYzQoZmxvYXQoJHtUfSksIGZsb2F0KCR7dn0pLCBmbG9hdCgke1R9KSwgZmxvYXQoJHt2fSkpO1xuICAgICAgICAgICAgJHtMfVxuICAgICAgICAgICAgJHt3fVxuICAgICAgICAgICAgZmxvYXQgZ2V0QVZhbHVlKGludCB4MTAsIGludCByLCBpbnQgYywgaW50IGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRBKHgxMCwgciwgYywgZCksIHZlYzIoYywgZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICR7SX0gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcblxuICAgICAgICAgICAgICAgIGludCBiYXRjaCA9IHJjWzBdO1xuICAgICAgICAgICAgICAgIGludCBkZXB0aCA9IHJjWzFdO1xuXG4gICAgICAgICAgICAgICAgLy8gcmV0cmlldmUgdGhlIDQgY29vcmRpbmF0ZXMgdGhhdCBpcyB1c2VkIGluIHRoZSA0IHBhY2tlZCBvdXRwdXQgdmFsdWVzLlxuICAgICAgICAgICAgICAgIGl2ZWM0IGNvb3JkcyA9IGl2ZWM0KHJjLnd6LCByYy53ICsgMSwgcmMueiArIDEpO1xuXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBzb3VyY2UgaW5kZXggaW4gZnJhY3Rpb25cbiAgICAgICAgICAgICAgICB2ZWM0IHNvdXJjZUZyYWMgPSBnZXRTb3VyY2VGcmFjSW5kZXgoY29vcmRzKTtcblxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgbG93ZXIgYW5kIHVwcGVyIGJvdW5kIG9mIHRoZSA0IHZhbHVlcyB0aGF0IHdpbGwgYmUgcGFja2VkIGludG8gb25lIHRleGVsLlxuICAgICAgICAgICAgICAgIGl2ZWM0IHgwMCA9IGl2ZWM0KG1heChzb3VyY2VGcmFjLnh5LCB2ZWMyKDAuMCkpLCBtaW4oaW5wdXRXSCAtIDEuMCwgY2VpbChzb3VyY2VGcmFjLnh5KSkpO1xuICAgICAgICAgICAgICAgIGl2ZWM0IHgwMSA9IGl2ZWM0KG1heChzb3VyY2VGcmFjLnh3LCB2ZWMyKDAuMCkpLCBtaW4oaW5wdXRXSCAtIDEuMCwgY2VpbChzb3VyY2VGcmFjLnh3KSkpO1xuICAgICAgICAgICAgICAgIGl2ZWM0IHgxMCA9IGl2ZWM0KG1heChzb3VyY2VGcmFjLnp5LCB2ZWMyKDAuMCkpLCBtaW4oaW5wdXRXSCAtIDEuMCwgY2VpbChzb3VyY2VGcmFjLnp5KSkpO1xuICAgICAgICAgICAgICAgIGl2ZWM0IHgxMSA9IGl2ZWM0KG1heChzb3VyY2VGcmFjLnp3LCB2ZWMyKDAuMCkpLCBtaW4oaW5wdXRXSCAtIDEuMCwgY2VpbChzb3VyY2VGcmFjLnp3KSkpO1xuXG4gICAgICAgICAgICAgICAgYm9vbCBoYXNOZXh0Um93ID0gcmMudyA8ICR7dS0xfTtcbiAgICAgICAgICAgICAgICBib29sIGhhc05leHRDb2wgPSByYy56IDwgJHtsLTF9O1xuXG4gICAgICAgICAgICAgICAgLy8gcGFjayB4MDAsIHgwMSwgeDEwLCB4MTEncyB0b3AtbGVmdCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICB2ZWM0IHRvcExlZnQgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueCwgeDAwLnkpLFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLngsIHgwMS55KSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC54LCB4MTAueSkgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLngsIHgxMS55KSA6IDAuMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIHRvcC1yaWdodCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICB2ZWM0IHRvcFJpZ2h0ID0gdmVjNChcbiAgICAgICAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLngsIHgwMC53KSxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS54LCB4MDEudykgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTAueCwgeDEwLncpIDogMC4wLFxuICAgICAgICAgICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS54LCB4MTEudykgOiAwLjApO1xuXG4gICAgICAgICAgICAgICAgLy8gcGFjayB4MDAsIHgwMSwgeDEwLCB4MTEncyBib3R0b20tbGVmdCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbUxlZnQgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueiwgeDAwLnkpLFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLnosIHgwMS55KSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC56LCB4MTAueSkgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLnosIHgxMS55KSA6IDAuMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIGJvdHRvbS1yaWdodCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbVJpZ2h0ID0gdmVjNChcbiAgICAgICAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLnosIHgwMC53KSxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS56LCB4MDEudykgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTAueiwgeDEwLncpIDogMC4wLFxuICAgICAgICAgICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS56LCB4MTEudykgOiAwLjApO1xuXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBpbnRlcnBvbGF0aW9uIGZyYWN0aW9uIG9uIHUgYW5kIHYgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgdmVjNCBmcmFjID0gdmVjNChzb3VyY2VGcmFjKSAtIGZsb29yKHNvdXJjZUZyYWMpO1xuICAgICAgICAgICAgICAgIHZlYzQgY2xhbXBGcmFjID0gY2xhbXAoZnJhYywgdmVjNCgwLjApLCB2ZWM0KDEuMCkpO1xuXG4gICAgICAgICAgICAgICAgdmVjNCB0b3AgPSBtaXgodG9wTGVmdCwgdG9wUmlnaHQsIGNsYW1wRnJhYy55d3l3KTtcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbSA9IG1peChib3R0b21MZWZ0LCBib3R0b21SaWdodCwgY2xhbXBGcmFjLnl3eXcpO1xuICAgICAgICAgICAgICAgIHZlYzQgbmV3VmFsdWUgPSBtaXgodG9wLCBib3R0b20sIGNsYW1wRnJhYy54eHp6KTtcblxuICAgICAgICAgICAgICAgICR7ZS5vdXRwdXR9ID0gdmVjNChuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGA7cmV0dXJuey4uLkdpLG91dHB1dDp7ZGltczpuLHR5cGU6dFswXS50eXBlLHRleHR1cmVUeXBlOjJ9LGhhc01haW46ITAsc2hhZGVyU291cmNlOkZ9fSxPYj0oYSx0KT0+e2xldCBlPWFbMF0uZGltcyxyPXQuc2NhbGVzLG47aWYoci5sZW5ndGg9PT0wKXtsZXQgaT1hW3Quc2NhbGVzSW5wdXRJZHhdO2lmKGkmJmkuc2l6ZSE9PTApe2lmKGFbdC5zaXplc0lucHV0SWR4XSl0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBvZiBzY2FsZXMgb3Igc2l6ZXMgbXVzdCBiZSBwcm92aWRlZCBhcyBpbnB1dC5cIik7cj1JYihpLHQubW9kZSx0LmlzUmVzaXplKX1lbHNle2xldCB1PWFbdC5zaXplc0lucHV0SWR4XTtpZighdXx8dS5zaXplPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJFaXRoZXIgc2NhbGVzIG9yIHNpemVzIE1VU1QgYmUgcHJvdmlkZWQgYXMgaW5wdXQuXCIpO249QXJyYXkuZnJvbSh1LmludGVnZXJEYXRhKSxyPVNiKG4sZSx0Lm1vZGUsdC5pc1Jlc2l6ZSl9fWVsc2UgaWYoYVt0LnNpemVzSW5wdXRJZHhdKXRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIG9mIHNjYWxlcyBvciBzaXplcyBtdXN0IGJlIHByb3ZpZGVkIGFzIGlucHV0LlwiKTtsZXQgcz1ufHxlLm1hcCgoaSx1KT0+TWF0aC5mbG9vcihpKnJbdV0pKTtyZXR1cm5bcixzXX0sSWI9KGEsdCxvKT0+e2xldCBlPUFycmF5LmZyb20oYS5mbG9hdERhdGEpO3JldHVybiBsbyhlLHQsbyksZX0sU2I9KGEsdCxvLGUpPT57bGV0IHI9dC5sZW5ndGgsbj1uZXcgQXJyYXkocik7Zm9yKGxldCBzPTAsaT1yO3M8aTtzKyspaWYodFtzXT09PTApe2lmKGFbc10hPT0wKXRocm93IG5ldyBFcnJvcihcIklucHV0IGRpbSBpcyB6ZXJvIGJ1dCByZXF1aXJlZCBvdXRwdXQgZGltIGlzIG5vbi16ZXJvLlwiKTtuW3NdPTF9ZWxzZSBuW3NdPWFbc10vdFtzXTtyZXR1cm4gbG8obixvLGUpLG59fSk7dmFyIFRjLEFiLHhjPUUoKCk9PntcInVzZSBzdHJpY3RcIjticigpO1RjPShhLHQpPT4oQWIodCksW25ldyBDZShbdFswXS5kaW1zLmxlbmd0aF0sXCJpbnQzMlwiLHZvaWQgMCx2b2lkIDAsbmV3IEludDMyQXJyYXkodFswXS5kaW1zKSldKSxBYj1hPT57aWYoIWF8fGEubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZSByZXF1aXJlcyAxIGlucHV0LlwiKX19KTt2YXIgemksd2MsdmMsX2MsUGIsT2MsRWIsRGIsSWM9RSgoKT0+e1widXNlIHN0cmljdFwiO0dlKCk7aG4oKTtmZSgpO2FlKCk7emk9e25hbWU6XCJTbGljZVwiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOlswXX0sd2M9KGEsdCxvKT0+KFBiKHQpLFthLnJ1bih7Li4uemksY2FjaGVIaW50Om8uY2FjaGVLZXksZ2V0OigpPT5fYyhhLHRbMF0sbyl9LHQpXSksdmM9YT0+e2xldCB0PWEuYXR0cmlidXRlcy5nZXRJbnRzKFwic3RhcnRzXCIpLG89YS5hdHRyaWJ1dGVzLmdldEludHMoXCJlbmRzXCIpLGU9YS5hdHRyaWJ1dGVzLmdldEludHMoXCJheGVzXCIsW10pO3JldHVybiBlZSh7c3RhcnRzOnQsZW5kczpvLGF4ZXM6ZX0pfSxfYz0oYSx0LG8pPT57bGV0IGU9by5heGVzLmxlbmd0aD09PTA/dC5kaW1zLnNsaWNlKDApLm1hcCgocCxkKT0+ZCk6by5heGVzLHI9VS5ub3JtYWxpemVBeGVzKGUsdC5kaW1zLmxlbmd0aCksbj1vLnN0YXJ0cy5tYXAoKHAsZCk9PnA+dC5kaW1zW3JbZF1dLTE/dC5kaW1zW3JbZF1dOlUubm9ybWFsaXplQXhpcyhwLHQuZGltc1tyW2RdXSkpLHM9by5lbmRzLm1hcCgocCxkKT0+cD50LmRpbXNbcltkXV0tMT90LmRpbXNbcltkXV06VS5ub3JtYWxpemVBeGlzKHAsdC5kaW1zW3JbZF1dKSksaT10LmRpbXMuc2xpY2UoKSx1PVtdO2ZvcihsZXQgcD0wO3A8ci5sZW5ndGg7cCsrKWlbcltwXV09c1twXS1uW3BdLG5bcF0+MCYmdS5wdXNoKGBvdXRwdXRJZHhbJHtyW3BdfV0gKz0gJHtuW3BdfTtgKTtsZXQgZj1gXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHtpLmxlbmd0aH1dKSB7XG4gICAgICAgICR7dS5qb2luKGBcbiAgICAgIGApfVxuICAgICAgICByZXR1cm4gX0Eob3V0cHV0SWR4KTtcbiAgICAgIH1gO3JldHVybnsuLi56aSxvdXRwdXQ6e2RpbXM6aSx0eXBlOnQudHlwZSx0ZXh0dXJlVHlwZTowfSxzaGFkZXJTb3VyY2U6Zn19LFBiPWE9PntpZighYXx8YS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlNsaWNlIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKEp0LmluZGV4T2YoYVswXS50eXBlKT09PS0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9LE9jPShhLHQpPT57RGIodCk7bGV0IG89RWIoYSx0KTtyZXR1cm5bYS5ydW4oey4uLnppLGNhY2hlSGludDpvLmNhY2hlS2V5LGdldDooKT0+X2MoYSx0WzBdLG8pfSxbdFswXV0pXX0sRWI9KGEsdCk9PntpZighYS5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIodFsxXS5kYXRhSWQpfHwhYS5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIodFsyXS5kYXRhSWQpfHx0Lmxlbmd0aD49NCYmIWEuc2Vzc2lvbi5pc0luaXRpYWxpemVyKHRbM10uZGF0YUlkKXx8dC5sZW5ndGg+PTUmJiFhLnNlc3Npb24uaXNJbml0aWFsaXplcih0WzRdLmRhdGFJZCkpdGhyb3cgbmV3IEVycm9yKFwiZHluYW1pYyBzbGljZSBhdHRyaWJ1dGVzIGFyZSBub3QgYWxsb3dlZFwiKTtpZih0Lmxlbmd0aD49NSYmdFs0XS5pbnRlZ2VyRGF0YS5zb21lKHM9PnMhPT0xKSl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgbm9uLTEgc3RlcHMgaXMgbm90IHN1cHBvcnRlZCBmb3IgU2xpY2VcIik7bGV0IG89QXJyYXkuZnJvbSh0WzFdLmludGVnZXJEYXRhKSxlPUFycmF5LmZyb20odFsyXS5pbnRlZ2VyRGF0YSkscj10Lmxlbmd0aD49ND9BcnJheS5mcm9tKHRbM10uaW50ZWdlckRhdGEpOltdLG49YCR7cn07JHtvfTske2V9YDtyZXR1cm57c3RhcnRzOm8sZW5kczplLGF4ZXM6cixjYWNoZUtleTpufX0sRGI9YT0+e2lmKCFhfHxhLmxlbmd0aDwzfHxhLmxlbmd0aD41KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgbnVtYmVyLlwiKTtpZihhWzFdLnR5cGUhPT1cImludDMyXCJ8fGFbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoYVsyXS50eXBlIT09XCJpbnQzMlwifHxhWzJdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKGEubGVuZ3RoPj00JiYoYVszXS50eXBlIT09XCJpbnQzMlwifHxhWzNdLmRpbXMubGVuZ3RoIT09MSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZihhLmxlbmd0aD49NSYmKGFbNF0udHlwZSE9PVwiaW50MzJcInx8YVs0XS5kaW1zLmxlbmd0aCE9PTEpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSk7dmFyIFNjLEFjLFBjLEVjLERjLExjLEZjLENjLExiLEZiLENiLCRjLGtjPUUoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO2ZlKCk7eGUoKTthZSgpO2FvKCk7U2M9e25hbWU6XCJTb2Z0bWF4Q29tcHV0ZU1heFwiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOlswXX0sQWM9e25hbWU6XCJTb2Z0bWF4Q29tcHV0ZVNjYWxlXCIsaW5wdXROYW1lczpbXCJBXCIsXCJNYXhcIl0saW5wdXRUeXBlczpbMCwwXX0sUGM9e25hbWU6XCJTb2Z0TWF4XCIsaW5wdXROYW1lczpbXCJBXCIsXCJNYXhcIixcIk5vcm1cIl0saW5wdXRUeXBlczpbMCwwLDBdfSxFYz0oYSx0LG8pPT57JGModCk7bGV0IGU9dFswXS5kaW1zLnNsaWNlKCkscj1VLm5vcm1hbGl6ZUF4aXMoby5heGlzLGUubGVuZ3RoKSxuPVUuc2l6ZVRvRGltZW5zaW9uKGUscikscz1VLnNpemVGcm9tRGltZW5zaW9uKGUscik7cmV0dXJuIENjKGEsdCxvLG4scyl9LERjPWE9PmVlKHtheGlzOmEuYXR0cmlidXRlcy5nZXRJbnQoXCJheGlzXCIsMSl9KSxMYz1hPT5lZSh7YXhpczphLmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiLC0xKX0pLEZjPShhLHQsbyk9PnskYyh0KTtsZXQgZT10WzBdLmRpbXMuc2xpY2UoKSxyPVUubm9ybWFsaXplQXhpcyhvLmF4aXMsZS5sZW5ndGgpLG49ZS5sZW5ndGgscz1yIT09bi0xLGk9W10sdT1bXSxsPVtdLGY7cyYmKHU9QXJyYXkuZnJvbSh7bGVuZ3RoOm59KS5tYXAoKHYsdyk9PncpLHVbcl09bi0xLHVbbi0xXT1yLHUubWFwKHY9PmkucHVzaChlW3ZdKSksZj1lZSh7cGVybTp1fSksbD1UcihhLHQsZikpO2xldCBwPXM/VS5zaXplVG9EaW1lbnNpb24oaSxuLTEpOlUuc2l6ZVRvRGltZW5zaW9uKGUsbi0xKSxkPXM/VS5zaXplRnJvbURpbWVuc2lvbihpLG4tMSk6VS5zaXplRnJvbURpbWVuc2lvbihlLG4tMSksVD1DYyhhLHM/bDp0LG8scCxkKTtyZXR1cm4gcz9UcihhLFQsZik6VH0sQ2M9KGEsdCxvLGUscik9PntsZXQgbj1MYihhLHRbMF0sZSxyLFtlXSkscz1hLnJ1bih7Li4uU2MsY2FjaGVIaW50Om8uY2FjaGVLZXksZ2V0OigpPT5ufSx0KSxpPUZiKGEsdFswXSxlLHIsbi5vdXRwdXQuZGltcyxbZV0pLHU9YS5ydW4oey4uLkFjLGNhY2hlSGludDpvLmNhY2hlS2V5LGdldDooKT0+aX0sW3RbMF0sc10pLGw9Q2IoYSx0WzBdLGUscixuLm91dHB1dC5kaW1zLGkub3V0cHV0LmRpbXMpO3JldHVyblthLnJ1bih7Li4uUGMsY2FjaGVIaW50Om8uY2FjaGVLZXksZ2V0OigpPT5sfSxbdFswXSxzLHVdKV19LExiPShhLHQsbyxlLHIpPT57bGV0W24sc109YS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQodC5kaW1zLDApLGk9ci5sZW5ndGg7aWYobzwxfHxlPDEpdGhyb3cgbmV3IEVycm9yKFwiTG9naWNhbCByb3cgY291bnQgTiBhbmQgZmVhdHVyZSBjb3VudCBEIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIik7aWYoci5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkRpbWVuc2lvbmFsaXR5IG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIDFcIik7aWYoclswXSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnRcIik7bGV0IHU9cShhLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksbD1gXG4gICAgICBmbG9hdCBwcm9jZXNzKGludFske2l9XSBpbmRpY2VzKSB7XG4gICAgICAgIGludCBsb2dpY2FsX3Jvd19zdGFydF9vZmZzZXQgPSBpbmRpY2VzWzBdICogJHtlfTtcblxuICAgICAgICBmbG9hdCBtYXggPSBnZXRDb2xvckFzRmxvYXQoJHt1LnRleHR1cmUyRH0oQSwgb2Zmc2V0VG9Db29yZHMobG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0LCAke259LFxuICAgICAgICAke3N9ICkpKTtcbiAgICAgICAgZm9yKGludCBpPTE7IGk8JHtlfTsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgZmxvYXQgY3VycmVudCA9IGdldENvbG9yQXNGbG9hdCgke3UudGV4dHVyZTJEfShBLCBvZmZzZXRUb0Nvb3Jkcyhsb2dpY2FsX3Jvd19zdGFydF9vZmZzZXQgKyBpLFxuICAgICAgICAgICAgJHtufSwgJHtzfSkpKTtcbiAgICAgICAgICBpZihjdXJyZW50ID4gbWF4KVxuICAgICAgICAgIG1heCA9IGN1cnJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgfWA7cmV0dXJuey4uLlNjLG91dHB1dDp7ZGltczpyLHR5cGU6dC50eXBlLHRleHR1cmVUeXBlOjB9LHNoYWRlclNvdXJjZTpsfX0sRmI9KGEsdCxvLGUscixuKT0+e2xldFtzLGldPWEuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KHQuZGltcywwKSx1PW4ubGVuZ3RoO2lmKG88MXx8ZTwxKXRocm93IG5ldyBFcnJvcihcIkxvZ2ljYWwgcm93IGNvdW50IE4gYW5kIGZlYXR1cmUgY291bnQgRCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpO2lmKG4ubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgb3V0cHV0IHNob3VsZCBiZSAxXCIpO2lmKG5bMF0hPT1vKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50XCIpO2lmKHIubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDFcIik7aWYoclswXSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgb2YgdGhlIGludGVybWVkaWF0ZSByZXN1bHRzIHNob3VsZCBiZSBlcXVhbCB0byBsb2dpY2FsIHJvdyBjb3VudFwiKTtsZXQgbD1xKGEuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxmPWBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7dX1dIGluZGljZXMpIHtcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke2V9O1xuXG4gICAgICAgIGZsb2F0IG5vcm1fZmFjdG9yID0gMC4wO1xuICAgICAgICBmbG9hdCBtYXggPSBfTWF4KGluZGljZXMpO1xuICAgICAgICBmb3IoaW50IGk9MDsgaTwke2V9OyArK2kpXG4gICAgICAgIHtcbiAgICAgICAgICBub3JtX2ZhY3RvciArPSBleHAoZ2V0Q29sb3JBc0Zsb2F0KCR7bC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCArIGksXG4gICAgICAgICAgICAke3N9LCAke2l9KSkpIC0gbWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtX2ZhY3RvcjtcbiAgICAgIH1gO3JldHVybnsuLi5BYyxvdXRwdXQ6e2RpbXM6bix0eXBlOnQudHlwZSx0ZXh0dXJlVHlwZTowfSxzaGFkZXJTb3VyY2U6Zn19LENiPShhLHQsbyxlLHIsbik9PntsZXRbcyxpXT1hLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh0LmRpbXMsMCksdT10LmRpbXMubGVuZ3RoO2lmKG88MXx8ZTwxKXRocm93IG5ldyBFcnJvcihcIkxvZ2ljYWwgcm93IGNvdW50IE4gYW5kIGZlYXR1cmUgY291bnQgRCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpO2lmKHIubGVuZ3RoIT09MXx8bi5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkRpbWVuc2lvbmFsaXR5IG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgMVwiKTtpZihyWzBdIT09b3x8blswXSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgb2YgdGhlIGludGVybWVkaWF0ZSByZXN1bHRzIHNob3VsZCBiZSBlcXVhbCB0byBsb2dpY2FsIHJvdyBjb3VudFwiKTtsZXQgbD1gXG4gICAgICBmbG9hdCBwcm9jZXNzKGludFske3V9XSBpbmRpY2VzKSB7XG5cbiAgICAgIC8vIGdldCBvZmZzZXQgb2YgY3VycmVudCBsb2dpY2FsIHRlbnNvciBpbmRleCBmcm9tIHRoZSAyLUQgdGV4dHVyZSBjb29yZGluYXRlcyAoVGV4Q29vcmRzKVxuICAgICAgaW50IG9mZnNldCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtzfSwgJHtpfSk7XG5cbiAgICAgIC8vZGV0ZXJtaW5lIHRoZSBsb2dpY2FsIHJvdyBmb3IgdGhpcyBpbmRleFxuICAgICAgaW50IGxvZ2ljYWxfcm93X2luZGV4WzFdO1xuICAgICAgbG9naWNhbF9yb3dfaW5kZXhbMF0gPSBvZmZzZXQgLyAke2V9O1xuXG4gICAgICBmbG9hdCBub3JtX2ZhY3RvciA9IF9Ob3JtKGxvZ2ljYWxfcm93X2luZGV4KTtcblxuICAgICAgLy8gYXZvaWQgcG9zc2libGUgZGl2aXNpb24gYnkgMFxuICAgICAgLy8gaWYgbm9ybV9mYWNvciBpcyAwLCBhbGwgZWxlbWVudHMgYXJlIHplcm9cbiAgICAgIC8vIGlmIHNvLCByZXR1cm4gMFxuICAgICAgaWYobm9ybV9mYWN0b3IgPT0gMC4wKVxuICAgICAgICByZXR1cm4gMC4wO1xuXG4gICAgICByZXR1cm4gZXhwKF9BKGluZGljZXMpIC0gX01heChsb2dpY2FsX3Jvd19pbmRleCkpIC8gbm9ybV9mYWN0b3I7XG4gICAgfWA7cmV0dXJuey4uLlBjLG91dHB1dDp7ZGltczp0LmRpbXMsdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6MH0sc2hhZGVyU291cmNlOmx9fSwkYz1hPT57aWYoIWF8fGEubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJTb2Z0bWF4IHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKGFbMF0udHlwZSE9PVwiZmxvYXQzMlwiJiZhWzBdLnR5cGUhPT1cImZsb2F0NjRcIil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGVcIil9fSk7dmFyIEJjLE5jLFJjLCRiLGtiLEJiLE1jPUUoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO2ZlKCk7YWUoKTtCYz17bmFtZTpcIlNwbGl0XCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6WzBdfSxOYz0oYSx0LG8pPT57QmIodCk7bGV0IGU9VS5ub3JtYWxpemVBeGlzKG8uYXhpcyx0WzBdLmRpbXMubGVuZ3RoKSxyPSRiKGEsdCxlLG8pLG49W107Zm9yKGxldCBzPTA7czxyOysrcyluLnB1c2goYS5ydW4oey4uLkJjLGNhY2hlSGludDpgJHtvLmNhY2hlS2V5fTske3N9YCxnZXQ6KCk9PmtiKGEsdFswXSxvLGUscyl9LHQpKTtyZXR1cm4gbn0sUmM9YT0+e2xldCB0PWEuYXR0cmlidXRlcy5nZXRJbnQoXCJheGlzXCIsMCksbz1hLmF0dHJpYnV0ZXMuZ2V0SW50cyhcInNwbGl0XCIsW10pLGU9YS5vdXRwdXRzLmxlbmd0aDtyZXR1cm4gZWUoe2F4aXM6dCxzcGxpdDpvLG51bU91dHB1dHM6ZX0pfSwkYj0oYSx0LG8sZSk9PntsZXRbLHJdPXVuLnNwbGl0U2hhcGUodFswXS5kaW1zLG8sZS5zcGxpdCxlLm51bU91dHB1dHMpO3JldHVybiByLmxlbmd0aH0sa2I9KGEsdCxvLGUscik9PntsZXRbbixzXT11bi5zcGxpdFNoYXBlKHQuZGltcyxlLG8uc3BsaXQsby5udW1PdXRwdXRzKSxpPXNbcl0sdT1uW3JdLGY9YFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3UubGVuZ3RofV0pIHtcbiAgICAgICAgaW5kaWNlc1ske2V9XSArPSAke2l9O1xuICAgICAgICByZXR1cm4gX0EoaW5kaWNlcyk7XG4gICAgICB9XG4gICAgYDtyZXR1cm57Li4uQmMsY2FjaGVIaW50OmAke28uY2FjaGVLZXl9OiR7cn1gLG91dHB1dDp7ZGltczp1LHR5cGU6dC50eXBlLHRleHR1cmVUeXBlOjB9LHNoYWRlclNvdXJjZTpmfX0sQmI9YT0+e2lmKCFhfHxhLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiU3BsaXQgcmVxdWlyZXMgb25lIGlucHV0LlwiKTtpZihhWzBdLnR5cGUhPT1cImludDhcIiYmYVswXS50eXBlIT09XCJ1aW50OFwiJiZhWzBdLnR5cGUhPT1cImludDE2XCImJmFbMF0udHlwZSE9PVwidWludDE2XCImJmFbMF0udHlwZSE9PVwiaW50MzJcIiYmYVswXS50eXBlIT09XCJ1aW50MzJcIiYmYVswXS50eXBlIT09XCJmbG9hdDMyXCImJmFbMF0udHlwZSE9PVwiZmxvYXQ2NFwiJiZhWzBdLnR5cGUhPT1cImJvb2xcIil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0pO3ZhciBWaSxHYyxVYyxOYixSYix6Yz1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZmUoKTtWaT0oYSx0LG8pPT57TmIodCk7bGV0IGU9VS5zcXVlZXplU2hhcGUodFswXS5kaW1zLG8pO3JldHVyblthLnJlc2hhcGVVbnBhY2tlZCh0WzBdLGUpXX0sR2M9KGEsdCk9PihSYih0KSxWaShhLFt0WzBdXSxBcnJheS5mcm9tKHRbMV0uaW50ZWdlckRhdGEpKSksVWM9YT0+YS5hdHRyaWJ1dGVzLmdldEludHMoXCJheGVzXCIpLE5iPWE9PntpZighYXx8YS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlNxdWVlemUgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoYVswXS50eXBlPT09XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHRlbnNvciB0eXBlcy5cIil9LFJiPWE9PntpZighYXx8YS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIlNxdWVlemUgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKGFbMV0udHlwZSE9PVwiaW50MzJcIil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0pO3ZhciBWYyxNYixHYixXYz1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eGUoKTthZSgpO1ZjPShhLHQpPT57R2IodCk7bGV0IG89e25hbWU6XCJTdW1cIixpbnB1dE5hbWVzOnQubWFwKChyLG4pPT5gWCR7bn1gKSxpbnB1dFR5cGVzOm5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbCgwKX07cmV0dXJuW2EucnVuKHsuLi5vLGdldDooKT0+TWIoYSx0LG8pfSx0KV19LE1iPShhLHQsbyk9PntsZXQgZT1xKGEuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxyPXRbMF0uZGltcy5zbGljZSgpLHM9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWM0IHJlc3VsdCA9ICR7dC5tYXAoKGksdSk9PmAke2UudGV4dHVyZTJEfShYJHt1fSxUZXhDb29yZHMpYCkuam9pbihcIiArIFwiKX07XG4gICAgICAgICR7ZS5vdXRwdXR9ID0gcmVzdWx0O1xuICAgICAgfVxuICAgIGA7cmV0dXJuey4uLm8sb3V0cHV0OntkaW1zOnIsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6MH0saGFzTWFpbjohMCxzaGFkZXJTb3VyY2U6c319LEdiPWE9PntpZighYXx8YS5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcihcIlN1bSByZXF1aXJlcyBpbnB1dHMuXCIpO2xldCB0PWFbMF0uZGltcy5sZW5ndGg7Zm9yKGxldCBvPTE7bzxhLmxlbmd0aDtvKyspe2lmKHQhPT1hW29dLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIklucHV0IHNoYXBlcyBhcmUgbWlzbWF0Y2hlZC5cIik7Zm9yKGxldCBlPTA7ZTx0O2UrKylpZihhWzBdLmRpbXNbZV0hPT1hW29dLmRpbXNbZV0pdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc2hhcGVzIGFyZSBub3QgbWF0Y2hlZC5cIil9aWYoYVswXS50eXBlIT09XCJmbG9hdDMyXCImJmFbMF0udHlwZSE9PVwiZmxvYXQ2NFwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7Zm9yKGxldCBvPTE7bzxhLmxlbmd0aDtvKyspaWYoYVswXS50eXBlIT09YVtvXS50eXBlKXRocm93IG5ldyBFcnJvcihcIklucHV0IHR5cGVzIGFyZSBub3QgbWF0Y2hlZC5cIil9fSk7dmFyIEhjLFViLHpiLHFjPUUoKCk9PntcInVzZSBzdHJpY3RcIjtobigpO2FlKCk7SGM9KGEsdCk9Pnt6Yih0KTtsZXQgbz17bmFtZTpcIlRpbGVcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbMF19O3JldHVyblthLnJ1bih7Li4ubyxnZXQ6KCk9PlViKGEsdCxvKX0sdCldfSxVYj0oYSx0LG8pPT57bGV0IGU9dFswXS5kaW1zLnNsaWNlKCkscj1uZXcgQXJyYXkoZS5sZW5ndGgpLG49W107Zm9yKGxldCB1PTA7dTxlLmxlbmd0aDt1Kyspclt1XT1lW3VdKnRbMV0ubnVtYmVyRGF0YVt1XSxuLnB1c2goYGlucHV0SWR4WyR7dX1dID0gaW50KG1vZChmbG9hdChvdXRwdXRJZHhbJHt1fV0pLCAke2VbdV19LikpO2ApO2xldCBzPXIubGVuZ3RoLGk9YFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7c31dKSB7XG4gICAgICAgIGludCBpbnB1dElkeFske3N9XTtcbiAgICAgICAgJHtuLmpvaW4oYFxuYCl9XG4gICAgICAgIHJldHVybiBfQShpbnB1dElkeCk7XG4gICAgICB9XG4gICAgYDtyZXR1cm57Li4ubyxvdXRwdXQ6e2RpbXM6cix0eXBlOnRbMF0udHlwZSx0ZXh0dXJlVHlwZTowfSxzaGFkZXJTb3VyY2U6aX19LHpiPWE9PntpZighYXx8YS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIlRpbGUgcmVxdWlyZXMgMiBpbnB1dC5cIik7aWYoYVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNlY29uZCBpbnB1dCBzaGFwZSBtdXN0IDEgZGltZW5zaW9uLlwiKTtpZihhWzFdLmRpbXNbMF0hPT1hWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKEp0LmluZGV4T2YoYVswXS50eXBlKT09PS0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoYVsxXS50eXBlIT09XCJpbnQzMlwiJiZhWzFdLnR5cGUhPT1cImludDE2XCIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXBlYXQgdHlwZS5cIil9fSk7dmFyIFdpLGpjLFljLFZiLFdiLFhjPUUoKCk9PntcInVzZSBzdHJpY3RcIjtmZSgpO1dpPShhLHQsbyk9PntWYih0KTtsZXQgZT1VLnVuc3F1ZWV6ZVNoYXBlKHRbMF0uZGltcyxvKTtyZXR1cm5bYS5yZXNoYXBlVW5wYWNrZWQodFswXSxlKV19LGpjPShhLHQpPT4oV2IodCksV2koYSxbdFswXV0sQXJyYXkuZnJvbSh0WzFdLmludGVnZXJEYXRhKSkpLFljPWE9PmEuYXR0cmlidXRlcy5nZXRJbnRzKFwiYXhlc1wiKSxWYj1hPT57aWYoIWF8fGEubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJVbnNxdWVlemUgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoYVswXS50eXBlPT09XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHRlbnNvciB0eXBlcy5cIil9LFdiPWE9PntpZighYXx8YS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIlVuc3F1ZWV6ZSByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoYVsxXS50eXBlIT09XCJpbnQzMlwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSk7dmFyIEtjLEpjPUUoKCk9PntcInVzZSBzdHJpY3RcIjthbCgpO1RsKCk7dmwoKTtQbCgpO25vKCk7cGYoKTt5ZigpO3dmKCk7T2YoKTtQZigpO0xmKCk7a2YoKTtNZigpO29vKCk7VmYoKTtyYygpO2ZjKCk7cGMoKTt5YygpO3hjKCk7SWMoKTtrYygpO01jKCk7emMoKTtXYygpO3FjKCk7YW8oKTtBaSgpO1hjKCk7TWkoKTtLYz1bW1wiQWJzXCIsXCJcIixcIjYrXCIsRWxdLFtcIkFjb3NcIixcIlwiLFwiNytcIixEbF0sW1wiQWRkXCIsXCJcIixcIjcrXCIsc2xdLFtcIkFuZFwiLFwiXCIsXCI3K1wiLHVsXSxbXCJBc2luXCIsXCJcIixcIjcrXCIsTGxdLFtcIkF0YW5cIixcIlwiLFwiNytcIixGbF0sW1wiQXZlcmFnZVBvb2xcIixcIlwiLFwiNytcIixIZixxZl0sW1wiQmF0Y2hOb3JtYWxpemF0aW9uXCIsXCJcIixcIjcrXCIsb2wsaWxdLFtcIkNhc3RcIixcIlwiLFwiNitcIix4bCx3bF0sW1wiQ2VpbFwiLFwiXCIsXCI2K1wiLGtsXSxbXCJDbGlwXCIsXCJcIixcIjYtMTBcIixJaSxDbF0sW1wiQ2xpcFwiLFwiXCIsXCIxMStcIiwkbF0sW1wiQ29uY2F0XCIsXCJcIixcIjQrXCIsSWwsQWxdLFtcIkNvbnZcIixcIlwiLFwiMStcIixDaSwkaV0sW1wiQ29udlRyYW5zcG9zZVwiLFwiXCIsXCIxK1wiLGZmLGNmXSxbXCJDb3NcIixcIlwiLFwiNytcIixCbF0sW1wiRGl2XCIsXCJcIixcIjcrXCIsbGxdLFtcIkRyb3BvdXRcIixcIlwiLFwiNytcIixTaV0sW1wiRGVwdGhUb1NwYWNlXCIsXCJcIixcIjErXCIsYmYsZ2ZdLFtcIkVxdWFsXCIsXCJcIixcIjcrXCIsZmxdLFtcIkVsdVwiLFwiXCIsXCI2K1wiLE5sLFJsXSxbXCJFeHBcIixcIlwiLFwiNitcIixNbF0sW1wiRmxhdHRlblwiLFwiXCIsXCIxK1wiLFRmLHhmXSxbXCJGbG9vclwiLFwiXCIsXCI2K1wiLEdsXSxbXCJGdXNlZENvbnZcIixcImNvbS5taWNyb3NvZnRcIixcIjErXCIsQ2ksJGldLFtcIkdhdGhlclwiLFwiXCIsXCIxK1wiLHZmLF9mXSxbXCJHZW1tXCIsXCJcIixcIjctMTBcIixraSxTZl0sW1wiR2VtbVwiLFwiXCIsXCIxMStcIixraSxBZl0sW1wiR2xvYmFsQXZlcmFnZVBvb2xcIixcIlwiLFwiMStcIixZZixYZl0sW1wiR2xvYmFsTWF4UG9vbFwiLFwiXCIsXCIxK1wiLGVjXSxbXCJHcmVhdGVyXCIsXCJcIixcIjcrXCIsY2xdLFtcIklkZW50aXR5XCIsXCJcIixcIjErXCIsU2ldLFtcIkltYWdlU2NhbGVyXCIsXCJcIixcIjErXCIsRWYsRGZdLFtcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLFwiXCIsXCI2K1wiLENmLCRmXSxbXCJMZWFreVJlbHVcIixcIlwiLFwiNitcIixVbCx6bF0sW1wiTGVzc1wiLFwiXCIsXCI3K1wiLHBsXSxbXCJMUk5cIixcIlwiLFwiMStcIixCZixOZl0sW1wiTG9nXCIsXCJcIixcIjYrXCIsVmxdLFtcIk1hdE11bFwiLFwiXCIsXCIxK1wiLHJmLG5mXSxbXCJNYXhQb29sXCIsXCJcIixcIjErXCIsS2YsSmZdLFtcIk11bFwiLFwiXCIsXCI3K1wiLGRsXSxbXCJOZWdcIixcIlwiLFwiNitcIixXbF0sW1wiTm90XCIsXCJcIixcIjErXCIsSGxdLFtcIk9yXCIsXCJcIixcIjcrXCIsaGxdLFtcIlBhZFwiLFwiXCIsXCIyLTEwXCIsQmksR2ZdLFtcIlBhZFwiLFwiXCIsXCIxMStcIixVZix6Zl0sW1wiUG93XCIsXCJcIixcIjcrXCIsbWxdLFtcIlBSZWx1XCIsXCJcIixcIjcrXCIsYmxdLFtcIlJlZHVjZUxvZ1N1bVwiLFwiXCIsXCIxK1wiLHVjLFp0XSxbXCJSZWR1Y2VNYXhcIixcIlwiLFwiMStcIixpYyxadF0sW1wiUmVkdWNlTWVhblwiLFwiXCIsXCIxK1wiLG9jLFp0XSxbXCJSZWR1Y2VNaW5cIixcIlwiLFwiMStcIixhYyxadF0sW1wiUmVkdWNlUHJvZFwiLFwiXCIsXCIxK1wiLHNjLFp0XSxbXCJSZWR1Y2VTdW1cIixcIlwiLFwiMS0xMlwiLG5jLFp0XSxbXCJSZWR1Y2VTdW1TcXVhcmVcIixcIlwiLFwiMStcIixsYyxadF0sW1wiUmVsdVwiLFwiXCIsXCI2K1wiLHFsXSxbXCJSZXNoYXBlXCIsXCJcIixcIjUrXCIsY2NdLFtcIlJlc2l6ZVwiLFwiXCIsXCIxMFwiLFVpLGJjXSxbXCJSZXNpemVcIixcIlwiLFwiMTErXCIsVWksZ2NdLFtcIlNoYXBlXCIsXCJcIixcIjErXCIsVGNdLFtcIlNpZ21vaWRcIixcIlwiLFwiNitcIixqbF0sW1wiU2luXCIsXCJcIixcIjcrXCIsWWxdLFtcIlNsaWNlXCIsXCJcIixcIjEwK1wiLE9jXSxbXCJTbGljZVwiLFwiXCIsXCIxLTlcIix3Yyx2Y10sW1wiU29mdG1heFwiLFwiXCIsXCIxLTEyXCIsRWMsRGNdLFtcIlNvZnRtYXhcIixcIlwiLFwiMTMrXCIsRmMsTGNdLFtcIlNwbGl0XCIsXCJcIixcIjItMTJcIixOYyxSY10sW1wiU3FydFwiLFwiXCIsXCI2K1wiLFhsXSxbXCJTcXVlZXplXCIsXCJcIixcIjEtMTJcIixWaSxVY10sW1wiU3F1ZWV6ZVwiLFwiXCIsXCIxMytcIixHY10sW1wiU3ViXCIsXCJcIixcIjcrXCIsZ2xdLFtcIlN1bVwiLFwiXCIsXCI2K1wiLFZjXSxbXCJUYW5cIixcIlwiLFwiNytcIixLbF0sW1wiVGFuaFwiLFwiXCIsXCI2K1wiLEpsXSxbXCJUaWxlXCIsXCJcIixcIjYrXCIsSGNdLFtcIlRyYW5zcG9zZVwiLFwiXCIsXCIxK1wiLFRyLGhmXSxbXCJVcHNhbXBsZVwiLFwiXCIsXCI3LThcIixOaSxoY10sW1wiVXBzYW1wbGVcIixcIlwiLFwiOVwiLE5pLG1jXSxbXCJVbnNxdWVlemVcIixcIlwiLFwiMS0xMlwiLFdpLFljXSxbXCJVbnNxdWVlemVcIixcIlwiLFwiMTMrXCIsamNdLFtcIlhvclwiLFwiXCIsXCI3K1wiLHlsXV19KTtmdW5jdGlvbiBRYyhhKXtsZXQgdD17fSxvO2Zvcig7KG89WmMuZXhlYyhhKSkhPT1udWxsOyl7bGV0IGU9b1szXS5zcGxpdChcIixcIikubWFwKHI9PntsZXQgbj1yLnRyaW0oKS5zcGxpdChcIiBcIik7cmV0dXJuIG4mJm4ubGVuZ3RoPT09Mj97dHlwZTpuWzBdLG5hbWU6blsxXX06bnVsbH0pLmZpbHRlcihyPT5yIT09bnVsbCk7dFtvWzJdXT17cGFyYW1zOmUsYm9keTpvWzRdfX1mb3IobGV0IGUgaW4gdCl7bGV0IHI9SGIucmVwbGFjZShcIl9fRlVOQ19fXCIsZSksbj1uZXcgUmVnRXhwKHIsXCJnbVwiKTtmb3IoOyhvPW4uZXhlYyhhKSkhPT1udWxsOyl7bGV0IHM9b1sxXSxpPW9bMl0sdT1vWzNdLnNwbGl0KFwiLFwiKSxsPXM/YCR7c30gJHtpfTtgOlwiXCIsZj10W2VdLmJvZHkscD1cIlwiO3RbZV0ucGFyYW1zLmZvckVhY2goKFQsdik9PntUJiYocCs9YCR7VC50eXBlfSAke1QubmFtZX0gPSAke3Vbdl19O1xuYCl9KSxmPWAke3B9XG4gJHtmfWAsZj1mLnJlcGxhY2UoXCJyZXR1cm5cIixgJHtpfSA9IGApO2xldCBkPWBcbiAgICAgICR7bH1cbiAgICAgIHtcbiAgICAgICAgJHtmfVxuICAgICAgfVxuICAgICAgYDthPWEucmVwbGFjZShvWzBdLGQpfX1yZXR1cm4gYT1hLnJlcGxhY2UoWmMsXCJcIiksYX12YXIgWmMsSGIsZXA9RSgoKT0+e1widXNlIHN0cmljdFwiO1pjPS9AaW5saW5lW1xcc1xcblxccl0rKFxcdyspW1xcc1xcblxccl0rKFswLTlhLXpBLVpfXSspXFxzKlxcKChbXildKilcXClcXHMqeygoW159XXxbXFxuXFxyXSkqKX0vZ20sSGI9XCIoXFxcXHcrKT9cXFxccysoW18wLTlhLXpBLVpdKylcXFxccys9XFxcXHMrX19GVU5DX19cXFxcKCguKilcXFxcKVxcXFxzKjtcIn0pO2Z1bmN0aW9uIFVyKGEsdCl7bGV0IG89W10sZT1bXSxyPXQhPW51bGwmJkFycmF5LmlzQXJyYXkodCkmJnQubGVuZ3RoPT09MCxuPXQ9PW51bGx8fHI/bnVsbDpxYih0LGEpLnNvcnQoKSxzPTA7Zm9yKGxldCBpPTA7aTxhLmxlbmd0aDsrK2kpe2lmKG4hPW51bGwpe2lmKG5bc109PT1pJiZhW2ldIT09MSl0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNxdWVlemUgYXhpcyAke2l9IHNpbmNlIGl0cyBkaW0gJyR7YVtpXX0nIGlzIG5vdCAxYCk7KG5bc109PW51bGx8fG5bc10+aSkmJmFbaV09PT0xJiYoby5wdXNoKGFbaV0pLGUucHVzaChpKSksbltzXTw9aSYmcysrfWFbaV0hPT0xJiYoby5wdXNoKGFbaV0pLGUucHVzaChpKSl9cmV0dXJue25ld1NoYXBlOm8sa2VwdERpbXM6ZX19ZnVuY3Rpb24gcWIoYSx0KXtsZXQgbz10Lmxlbmd0aDtyZXR1cm4gYT1hPT1udWxsP3QubWFwKChlLHIpPT5yKTpbXS5jb25jYXQoYSksa3IoYS5ldmVyeShlPT5lPj0tbyYmZTxvKSwoKT0+YEFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGluIHJhbmdlIFstJHtvfSwgJHtvfSkgYnV0IGdvdCBheGlzICR7YX1gKSxrcihhLmV2ZXJ5KGpiKSwoKT0+YEFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGludGVnZXJzIGJ1dCBnb3QgYXhpcyAke2F9YCksYS5tYXAoZT0+ZTwwP28rZTplKX1mdW5jdGlvbiBqYihhKXtyZXR1cm4gYSUxPT09MH1mdW5jdGlvbiBZYihhKXtpZihhLmxlbmd0aD09PTApcmV0dXJuIDE7bGV0IHQ9YVswXTtmb3IobGV0IG89MTtvPGEubGVuZ3RoO28rKyl0Kj1hW29dO3JldHVybiB0fWZ1bmN0aW9uIHRwKGEpe2xldCB0PU1hdGguY2VpbChNYXRoLnNxcnQoYSkpO3JldHVyblt0LE1hdGguY2VpbChhL3QpXX12YXIgZm8sSGk9RSgoKT0+e1widXNlIHN0cmljdFwiO2F0KCk7ZmUoKTtmbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLm1heFRleHR1cmVTaXplPXR9Y29tcHV0ZVRleHR1cmVXSCh0LG8pe2xldCBlPXRoaXMuY29tcHV0ZVRleHR1cmUodCxvKTtyZXR1cm4gbyYmby5pc1BhY2tlZCYmKGVbMF0vPTIsZVsxXS89MiksbyYmby5yZXZlcnNlV0g/W2VbMV0sZVswXV06ZX1jb21wdXRlVGV4dHVyZSh0LG8pe2xldCBlPW8mJm8uaXNQYWNrZWQ7aWYodC5sZW5ndGg9PT0wKXJldHVybiBlP1syLDJdOlsxLDFdO2xldCByPXRoaXMubWF4VGV4dHVyZVNpemU7aWYobyYmby5icmVha0F4aXMhPT12b2lkIDApe2xldCBpPW8uYnJlYWtBeGlzPj10Lmxlbmd0aD8xOnQuc2xpY2Uoby5icmVha0F4aXMpLnJlZHVjZSgobCxmKT0+bCpmKSx1PW8uYnJlYWtBeGlzPD0wPzE6dC5zbGljZSgwLG8uYnJlYWtBeGlzKS5yZWR1Y2UoKGwsZik9PmwqZik7aWYoaT5yfHx1PnIpY2UudmVyYm9zZShcIlRleHR1cmVMYXlvdXRcIixgR2l2ZW4gd2lkdGgvaGVpZ2h0IHByZWZlcmVuY2VzIHdlcmUgdW5hdHRhaW5hYmxlOiBzaGFwZToke3R9LCBicmVha0F4aXM6JHtvLmJyZWFrQXhpc31gKTtlbHNlIHJldHVybltpLHVdfWxldCBuPXQuc2xpY2UoMCk7ZSYmKHI9cioyLG49bi5tYXAoKGksdSk9PnU+PW4ubGVuZ3RoLTI/blt1XSUyPT09MD9uW3VdOm5bdV0rMTpuW3VdKSxuLmxlbmd0aD09PTEmJihuPVsyLG5bMF1dKSksbi5sZW5ndGghPT0yJiYobj1VcihuKS5uZXdTaGFwZSk7bGV0IHM9WWIobik7cmV0dXJuIG4ubGVuZ3RoPD0xJiZzPD1yP1sxLHNdOm4ubGVuZ3RoPT09MiYmblswXTw9ciYmblsxXTw9cj9uOm4ubGVuZ3RoPT09MyYmblswXSpuWzFdPD1yJiZuWzJdPD1yP1tuWzBdKm5bMV0sblsyXV06bi5sZW5ndGg9PT0zJiZuWzBdPD1yJiZuWzFdKm5bMl08PXI/W25bMF0sblsxXSpuWzJdXTpuLmxlbmd0aD09PTQmJm5bMF0qblsxXSpuWzJdPD1yJiZuWzNdPD1yP1tuWzBdKm5bMV0qblsyXSxuWzNdXTpuLmxlbmd0aD09PTQmJm5bMF08PXImJm5bMV0qblsyXSpuWzNdPD1yP1tuWzBdLG5bMV0qblsyXSpuWzNdXTplP3RwKHMvNCkubWFwKGk9PmkqMik6dHAocyl9fX0pO3ZhciBjbyxycD1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZmUoKTtIdCgpO3hlKCk7SGkoKTtrdCgpO2NvPWNsYXNzIGV4dGVuZHMgZnR7Y29uc3RydWN0b3Iobyl7c3VwZXIobyl9Z2V0RnVuY3Rpb25zKCl7cmV0dXJuey4uLnRoaXMub2Zmc2V0VG9Db29yZHMoKSwuLi50aGlzLmNvb3Jkc1RvT2Zmc2V0KCksLi4udGhpcy50b1ZlYygpLC4uLnRoaXMudmFsdWVGcm9tKCksLi4udGhpcy5nZXRDb21tb25VdGlsRnVuY3MoKSwuLi50aGlzLmdldElucHV0c1NhbXBsaW5nU25pcHBldHMoKSwuLi50aGlzLmdldE91dHB1dFNhbXBsaW5nU25pcHBldCgpfX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fW9mZnNldFRvQ29vcmRzKCl7bGV0IG89XCJvZmZzZXRUb0Nvb3Jkc1wiO3JldHVybntvZmZzZXRUb0Nvb3JkczpuZXcgUihgXG4gICAgICB2ZWMyICR7b30oaW50IG9mZnNldCwgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XG4gICAgICAgIGludCB0ID0gb2Zmc2V0IC8gd2lkdGg7XG4gICAgICAgIGludCBzID0gb2Zmc2V0IC0gdCp3aWR0aDtcbiAgICAgICAgdmVjMiBjb29yZHMgPSAodmVjMihzLHQpICsgdmVjMigwLjUsMC41KSkgLyB2ZWMyKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgICAgfVxuICAgICAgYCl9fWNvb3Jkc1RvT2Zmc2V0KCl7bGV0IG89XCJjb29yZHNUb09mZnNldFwiO3JldHVybntjb29yZHNUb09mZnNldDpuZXcgUihgXG4gICAgICBpbnQgJHtvfSh2ZWMyIGNvb3JkcywgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XG4gICAgICAgIGZsb2F0IHMgPSBjb29yZHMucyAqIGZsb2F0KHdpZHRoKTtcbiAgICAgICAgZmxvYXQgdCA9IGNvb3Jkcy50ICogZmxvYXQoaGVpZ2h0KTtcbiAgICAgICAgaW50IG9mZnNldCA9IGludCh0KSAqIHdpZHRoICsgaW50KHMpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgfVxuICAgICAgYCl9fWdldE91dHB1dFNhbXBsaW5nU25pcHBldCgpe2xldCBvPXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O3JldHVybiBvLmlzUGFja2VkP3RoaXMuZ2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KG8pOnRoaXMuZ2V0VW5wYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQobyl9Z2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KG8pe2xldCBlPW8udW5wYWNrZWRTaGFwZSxyPVtvLndpZHRoLG8uaGVpZ2h0XSxuPXt9LHM9XCJnZXRPdXRwdXRDb29yZHNcIjtzd2l0Y2goZS5sZW5ndGgpe2Nhc2UgMDpuW3NdPXRoaXMuZ2V0T3V0cHV0U2NhbGFyQ29vcmRzKCk7YnJlYWs7Y2FzZSAxOm5bc109dGhpcy5nZXRPdXRwdXRQYWNrZWQxRENvb3JkcyhlLHIpO2JyZWFrO2Nhc2UgMjpuW3NdPXRoaXMuZ2V0T3V0cHV0UGFja2VkMkRDb29yZHMoZSxyKTticmVhaztjYXNlIDM6bltzXT10aGlzLmdldE91dHB1dFBhY2tlZDNEQ29vcmRzKGUscik7YnJlYWs7ZGVmYXVsdDpuW3NdPXRoaXMuZ2V0T3V0cHV0UGFja2VkTkRDb29yZHMoZSxyKX1sZXQgdT1gXG4gICAgICB2b2lkIHNldE91dHB1dCh2ZWM0IHZhbCkge1xuICAgICAgICAke3EodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKS5vdXRwdXR9ID0gdmFsO1xuICAgICAgfVxuICAgIGAsbD1cImZsb2F0VGV4dHVyZVNldFJHQkFcIjtyZXR1cm4gbltsXT1uZXcgUih1KSxufWdldFVucGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KG8pe2xldCBlPW8udW5wYWNrZWRTaGFwZSxyPVtvLndpZHRoLG8uaGVpZ2h0XSxuPXt9LHM9XCJnZXRPdXRwdXRDb29yZHNcIjtzd2l0Y2goZS5sZW5ndGgpe2Nhc2UgMDpuW3NdPXRoaXMuZ2V0T3V0cHV0U2NhbGFyQ29vcmRzKCk7YnJlYWs7Y2FzZSAxOm5bc109dGhpcy5nZXRPdXRwdXRVbnBhY2tlZDFEQ29vcmRzKGUscik7YnJlYWs7Y2FzZSAyOm5bc109dGhpcy5nZXRPdXRwdXRVbnBhY2tlZDJEQ29vcmRzKGUscik7YnJlYWs7Y2FzZSAzOm5bc109dGhpcy5nZXRPdXRwdXRVbnBhY2tlZDNEQ29vcmRzKGUscik7YnJlYWs7Y2FzZSA0Om5bc109dGhpcy5nZXRPdXRwdXRVbnBhY2tlZDREQ29vcmRzKGUscik7YnJlYWs7Y2FzZSA1Om5bc109dGhpcy5nZXRPdXRwdXRVbnBhY2tlZDVEQ29vcmRzKGUscik7YnJlYWs7Y2FzZSA2Om5bc109dGhpcy5nZXRPdXRwdXRVbnBhY2tlZDZEQ29vcmRzKGUscik7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG91dHB1dCBkaW1lbnNpb25hbGl0eTogJHtlLmxlbmd0aH1gKX1sZXQgdT1gXG4gICAgICAgIHZvaWQgc2V0T3V0cHV0KGZsb2F0IHZhbCkge1xuICAgICAgICAgICR7cSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pLm91dHB1dH0gPSB2ZWM0KHZhbCwgMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICBgLGw9XCJmbG9hdFRleHR1cmVTZXRSXCI7cmV0dXJuIG5bbF09bmV3IFIodSksbn1nZXRPdXRwdXRTY2FsYXJDb29yZHMoKXtyZXR1cm4gbmV3IFIoYFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgYCl9Z2V0T3V0cHV0UGFja2VkMURDb29yZHMobyxlKXtsZXQgcj1lLG49XCJcIjtyZXR1cm4gclswXT09PTE/KG49YFxuICAgICAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gMiAqIGludChUZXhDb29yZHMueSAqICR7clsxXX0uMCk7XG4gICAgICAgICAgfVxuICAgICAgICBgLG5ldyBSKG4pKTpyWzFdPT09MT8obj1gXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiAyICogaW50KFRleENvb3Jkcy54ICogJHtyWzBdfS4wKTtcbiAgICAgICAgICB9XG4gICAgICAgIGAsbmV3IFIobikpOihuPWBcbiAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7clswXX0sICR7clsxXX0pKTtcbiAgICAgICAgICByZXR1cm4gMiAqIChyZXNUZXhSQy55ICogJHtyWzBdfSArIHJlc1RleFJDLngpO1xuICAgICAgICB9XG4gICAgICBgLG5ldyBSKG4pKX1nZXRPdXRwdXRQYWNrZWQyRENvb3JkcyhvLGUpe2xldCByPVwiXCI7aWYocHIuYXJyYXlzRXF1YWwobyxlKSlyZXR1cm4gcj1gXG4gICAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICByZXR1cm4gMiAqIGl2ZWMyKFRleENvb3Jkcy54eSAqIHZlYzIoJHtlWzBdfSwgJHtlWzFdfSkpO1xuICAgICAgICB9XG4gICAgICBgLG5ldyBSKHIpO2xldCBuPWUscz1NYXRoLmNlaWwob1sxXS8yKTtyZXR1cm4gcj1gXG4gICAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtuWzBdfSwgJHtuWzFdfSkpO1xuXG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7blswXX0gKyByZXNUZXhSQy54O1xuXG4gICAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxuICAgICAgICAgIGludCByID0gaW1vZChpbmRleCwgJHtzfSkgKiAyO1xuICAgICAgICAgIGludCBjID0gMiAqIChpbmRleCAvICR7c30pO1xuXG4gICAgICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xuICAgICAgICB9XG4gICAgICBgLG5ldyBSKHIpfWdldE91dHB1dFBhY2tlZDNEQ29vcmRzKG8sZSl7bGV0IHI9W2VbMF0sZVsxXV0sbj1NYXRoLmNlaWwob1syXS8yKSxzPW4qTWF0aC5jZWlsKG9bMV0vMiksaT1gXG4gICAgICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtyWzBdfSwgJHtyWzFdfSkpO1xuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke3JbMF19ICsgcmVzVGV4UkMueDtcblxuICAgICAgICAgIGludCBiID0gaW5kZXggLyAke3N9O1xuICAgICAgICAgIGluZGV4IC09IGIgKiAke3N9O1xuXG4gICAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxuICAgICAgICAgIGludCByID0gaW1vZChpbmRleCwgJHtufSkgKiAyO1xuICAgICAgICAgIGludCBjID0gMiAqIChpbmRleCAvICR7bn0pO1xuXG4gICAgICAgICAgcmV0dXJuIGl2ZWMzKGIsIHIsIGMpO1xuICAgICAgICB9XG4gICAgICBgO3JldHVybiBuZXcgUihpKX1nZXRPdXRwdXRQYWNrZWRORENvb3JkcyhvLGUpe2xldCByPVtlWzBdLGVbMV1dLG49TWF0aC5jZWlsKG9bby5sZW5ndGgtMV0vMikscz1uKk1hdGguY2VpbChvW28ubGVuZ3RoLTJdLzIpLGk9cyx1PVwiXCIsbD1cImIsIHIsIGNcIjtmb3IobGV0IHA9MjtwPG8ubGVuZ3RoLTE7cCsrKWkqPW9bby5sZW5ndGgtcC0xXSx1PWBcbiAgICAgIGludCBiJHtwfSA9IGluZGV4IC8gJHtpfTtcbiAgICAgIGluZGV4IC09IGIke3B9ICogJHtpfTtcbiAgICBgK3UsbD1gYiR7cH0sIGArbDtsZXQgZj1gXG4gICAgICBpdmVjJHtvLmxlbmd0aH0gZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7clswXX0sICR7clsxXX0pKTtcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7clswXX0gKyByZXNUZXhSQy54O1xuXG4gICAgICAgICR7dX1cblxuICAgICAgICBpbnQgYiA9IGluZGV4IC8gJHtzfTtcbiAgICAgICAgaW5kZXggLT0gYiAqICR7c307XG5cbiAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxuICAgICAgICBpbnQgciA9IGltb2QoaW5kZXgsICR7bn0pICogMjtcbiAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHtufSk7XG5cbiAgICAgICAgcmV0dXJuIGl2ZWMke28ubGVuZ3RofSgke2x9KTtcbiAgICAgIH1cbiAgICBgO3JldHVybiBuZXcgUihmKX1nZXRPdXRwdXRVbnBhY2tlZDFEQ29vcmRzKG8sZSl7bGV0IHI9YFxuICAgICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XG4gICAgICAgICAgcmV0dXJuIHJlc1RleFJDLnkgKiAke2VbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgfVxuICAgICAgYDtyZXR1cm4gbmV3IFIocil9Z2V0T3V0cHV0VW5wYWNrZWQyRENvb3JkcyhvLGUpe2xldCByPWBcbiAgICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7ZVswXX0gKyByZXNUZXhSQy54O1xuICAgICAgICAgIGludCByID0gaW5kZXggLyAke29bMV19O1xuICAgICAgICAgIGludCBjID0gaW5kZXggLSByICogJHtvWzFdfTtcbiAgICAgICAgICByZXR1cm4gaXZlYzIociwgYyk7XG4gICAgICAgIH1cbiAgICAgIGA7cmV0dXJuIG5ldyBSKHIpfWdldE91dHB1dFVucGFja2VkM0RDb29yZHMobyxlKXtsZXQgcj1cIlwiLG49by5sZW5ndGgscz1udWxsO248MiYmKHM9W10pLHM9bmV3IEFycmF5KG4tMSksc1tuLTJdPW9bbi0xXTtmb3IobGV0IGw9bi0zO2w+PTA7LS1sKXNbbF09c1tsKzFdKm9bbCsxXTtsZXQgaT1bXCJyXCIsXCJjXCIsXCJkXCJdLHU9cy5tYXAoKGwsZik9PntsZXQgcD1gaW50ICR7aVtmXX0gPSBpbmRleCAvICR7bH1gLGQ9Zj09PXMubGVuZ3RoLTE/YGludCAke2lbZisxXX0gPSBpbmRleCAtICR7aVtmXX0gKiAke2x9YDpgaW5kZXggLT0gJHtpW2ZdfSAqICR7bH1gO3JldHVybmAke3B9OyAke2R9O2B9KS5qb2luKFwiXCIpO3JldHVybiByPWBcbiAgICAgICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7ZVswXX0gKyByZXNUZXhSQy54O1xuICAgICAgICAgICR7dX1cbiAgICAgICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XG4gICAgICAgIH1cbiAgICAgIGAsbmV3IFIocil9Z2V0T3V0cHV0VW5wYWNrZWQ0RENvb3JkcyhvLGUpe2xldCByPVwiXCIsbj1vLmxlbmd0aCxzPW51bGw7bjwyJiYocz1bXSkscz1uZXcgQXJyYXkobi0xKSxzW24tMl09b1tuLTFdO2ZvcihsZXQgbD1uLTM7bD49MDstLWwpc1tsXT1zW2wrMV0qb1tsKzFdO2xldCBpPVtcInJcIixcImNcIixcImRcIixcImQyXCJdLHU9cy5tYXAoKGwsZik9PntsZXQgcD1gaW50ICR7aVtmXX0gPSBpbmRleCAvICR7bH1gLGQ9Zj09PXMubGVuZ3RoLTE/YGludCAke2lbZisxXX0gPSBpbmRleCAtICR7aVtmXX0gKiAke2x9YDpgaW5kZXggLT0gJHtpW2ZdfSAqICR7bH1gO3JldHVybmAke3B9OyAke2R9O2B9KS5qb2luKFwiXCIpO3JldHVybiByPWBcbiAgICAgIGl2ZWM0IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtlWzBdfSwgJHtlWzFdfSkpO1xuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke2VbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgICAke3V9XG4gICAgICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcbiAgICAgICAgfVxuICAgICAgYCxuZXcgUihyKX1nZXRPdXRwdXRVbnBhY2tlZDVEQ29vcmRzKG8sZSl7bGV0IHI9XCJcIixuPW8ubGVuZ3RoLHM9bnVsbDtuPDImJihzPVtdKSxzPW5ldyBBcnJheShuLTEpLHNbbi0yXT1vW24tMV07Zm9yKGxldCBsPW4tMztsPj0wOy0tbClzW2xdPXNbbCsxXSpvW2wrMV07bGV0IGk9W1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIixcImQzXCJdLHU9cy5tYXAoKGwsZik9PntsZXQgcD1gaW50ICR7aVtmXX0gPSBpbmRleCAvICR7bH1gLGQ9Zj09PXMubGVuZ3RoLTE/YGludCAke2lbZisxXX0gPSBpbmRleCAtICR7aVtmXX0gKiAke2x9YDpgaW5kZXggLT0gJHtpW2ZdfSAqICR7bH1gO3JldHVybmAke3B9OyAke2R9O2B9KS5qb2luKFwiXCIpO3JldHVybiByPWBcbiAgICAgIGl2ZWM1IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtlWzBdfSwgJHtlWzFdfSkpO1xuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke2VbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgICAke3V9XG4gICAgICAgICAgcmV0dXJuIGl2ZWM1KHIsIGMsIGQsIGQyLCBkMyk7XG4gICAgICAgIH1cbiAgICAgIGAsbmV3IFIocil9Z2V0T3V0cHV0VW5wYWNrZWQ2RENvb3JkcyhvLGUpe2xldCByPVwiXCIsbj1vLmxlbmd0aCxzPW51bGw7bjwyJiYocz1bXSkscz1uZXcgQXJyYXkobi0xKSxzW24tMl09b1tuLTFdO2ZvcihsZXQgbD1uLTM7bD49MDstLWwpc1tsXT1zW2wrMV0qb1tsKzFdO2xldCBpPVtcInJcIixcImNcIixcImRcIixcImQyXCIsXCJkM1wiLFwiZDRcIl0sdT1zLm1hcCgobCxmKT0+e2xldCBwPWBpbnQgJHtpW2ZdfSA9IGluZGV4IC8gJHtsfWAsZD1mPT09cy5sZW5ndGgtMT9gaW50ICR7aVtmKzFdfSA9IGluZGV4IC0gJHtpW2ZdfSAqICR7bH1gOmBpbmRleCAtPSAke2lbZl19ICogJHtsfWA7cmV0dXJuYCR7cH07ICR7ZH07YH0pLmpvaW4oXCJcIik7cmV0dXJuIHI9YFxuICAgICBpdmVjNiBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XG4gICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtlWzBdfSArIHJlc1RleFJDLng7XG4gICAgICAgICAke3V9XG4gICAgICAgICByZXR1cm4gaXZlYzYociwgYywgZCwgZDIsIGQzLCBkNCk7XG4gICAgICAgfVxuICAgICBgLG5ldyBSKHIpfWdldENvbW1vblV0aWxGdW5jcygpe2xldCBvPXt9LGU9XCJ1dkZyb21GbGF0XCI7b1tlXT1uZXcgUihgXG4gICAgdmVjMiB1dkZyb21GbGF0KGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XG4gICAgICBpbnQgdGV4QyA9IGluZGV4IC8gdGV4TnVtUjtcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLSB0ZXhDICogdGV4TnVtUjtcbiAgICAgIC8vIFRPRE86IHN3YXAgdGV4UiwgdGV4QyBvcmRlciBpbiBmb2xsb3dpbmcgZnVuY3Rpb24gc28gcm93IGlzIGNvcnJlc3BvbmRpbmcgdG8gdSBhbmQgY29sdW1uIGlzIGNvcnJlc3BvbmRpbmcgdG9cbiAgICAgIC8vICAgICAgIHYuXG4gICAgICByZXR1cm4gKHZlYzIodGV4UiwgdGV4QykgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1SLCB0ZXhOdW1DKTtcbiAgICB9XG4gICAgYCksZT1cInBhY2tlZFVWZnJvbTFEXCIsb1tlXT1uZXcgUihgXG4gICAgICB2ZWMyIHBhY2tlZFVWZnJvbTFEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XG4gICAgICAgIGludCB0ZXhlbEluZGV4ID0gaW5kZXggLyAyO1xuICAgICAgICBpbnQgdGV4UiA9IHRleGVsSW5kZXggLyB0ZXhOdW1DO1xuICAgICAgICBpbnQgdGV4QyA9IHRleGVsSW5kZXggLSB0ZXhSICogdGV4TnVtQztcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XG4gICAgICB9XG4gICAgICBgKSxlPVwicGFja2VkVVZmcm9tMkRcIixvW2VdPW5ldyBSKGBcbiAgICAgIHZlYzIgcGFja2VkVVZmcm9tMkQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgIGludCB0ZXhlbEluZGV4ID0gKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xuICAgICAgICBpbnQgdGV4UiA9IHRleGVsSW5kZXggLyB0ZXhOdW1DO1xuICAgICAgICBpbnQgdGV4QyA9IHRleGVsSW5kZXggLSB0ZXhSICogdGV4TnVtQztcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XG4gICAgICB9XG4gICAgICBgKSxlPVwicGFja2VkVVZmcm9tM0RcIixvW2VdPW5ldyBSKGBcbiAgICAgIHZlYzIgcGFja2VkVVZmcm9tM0QoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLFxuICAgICAgICAgIGludCB0ZXhlbHNJbkJhdGNoLCBpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgYixcbiAgICAgICAgICBpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgIGludCBpbmRleCA9IGIgKiB0ZXhlbHNJbkJhdGNoICsgKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xuICAgICAgICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcbiAgICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xuICAgICAgICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcbiAgICAgIH1cbiAgICAgIGApLGU9XCJzYW1wbGVUZXh0dXJlXCI7bGV0IHI9cSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO3JldHVybiBvW2VdPW5ldyBSKGBcbiAgICAgICAgZmxvYXQgc2FtcGxlVGV4dHVyZShzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXIsIHZlYzIgdXYpIHtcbiAgICAgICAgICAgIHJldHVybiAke3IudGV4dHVyZTJEfSh0ZXh0dXJlU2FtcGxlciwgdXYpLnI7XG4gICAgICAgIH1gKSxvfWdldElucHV0c1NhbXBsaW5nU25pcHBldHMoKXtsZXQgbz17fSxlPXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKChyLG4pPT57bGV0IHM9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0saT1LbihyKTtzLmlzUGFja2VkP29baV09dGhpcy5nZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KGkscixzKTpvW2ldPXRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGkscixzKTtsZXQgdT16dShyKTtzLnVucGFja2VkU2hhcGUubGVuZ3RoPD1lLnVucGFja2VkU2hhcGUubGVuZ3RoJiYocy5pc1BhY2tlZD9vW3VdPXRoaXMuZ2V0UGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKHUscyxlLHIpOm9bdV09dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3Jkcyh1LHMsZSxyKSl9KSxvfWdldFBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhvLGUscixuKXtsZXQgcz1lLnVucGFja2VkU2hhcGUsaT1yLnVucGFja2VkU2hhcGUsbD1LbihuKSxmPXMubGVuZ3RoLHA9aS5sZW5ndGgsZD1LZS5nZXRCcm9hZGNhc3REaW1zKHMsaSksVD1KZShwKSx2PXAtZix3LEk9T3QoKTtmPT09MD93PVwiXCI6cDwyJiZkLmxlbmd0aD49MT93PVwiY29vcmRzID0gMDtcIjp3PWQubWFwKFdlPT5gY29vcmRzLiR7SVtXZSt2XX0gPSAwO2ApLmpvaW4oYFxuYCk7bGV0IEw9XCJcIjtwPDImJmY+MD9MPVwiY29vcmRzXCI6TD1zLm1hcCgoV2UsRmUpPT5gY29vcmRzLiR7SVtGZSt2XX1gKS5qb2luKFwiLCBcIik7bGV0IEY9XCJyZXR1cm4gb3V0cHV0VmFsdWU7XCIsWT1VLnNpemUocyk9PT0xLE09VS5zaXplKGkpPT09MTtpZihmPT09MSYmIVkmJiFNKUY9YFxuICAgICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54eSwgb3V0cHV0VmFsdWUueHkpO1xuICAgICAgYDtlbHNlIGlmKFkmJiFNKXA9PT0xP0Y9YFxuICAgICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLngsIDAuLCAwLik7XG4gICAgICAgIGA6Rj1gXG4gICAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCk7XG4gICAgICAgIGA7ZWxzZSBpZihkLmxlbmd0aCl7bGV0IFdlPWYtMixGZT1mLTE7ZC5pbmRleE9mKFdlKT4tMSYmZC5pbmRleE9mKEZlKT4tMT9GPVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCk7XCI6ZC5pbmRleE9mKFdlKT4tMT9GPVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSwgb3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSk7XCI6ZC5pbmRleE9mKEZlKT4tMSYmKEY9XCJyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54eCwgb3V0cHV0VmFsdWUuenopO1wiKX1sZXQgaWU9YFxuICAgICAgICBpbnQgbGFzdERpbSA9IGNvb3Jkcy4ke0lbcC0xXX07XG4gICAgICAgIGNvb3Jkcy4ke0lbcC0xXX0gPSBjb29yZHMuJHtJW3AtMl19O1xuICAgICAgICBjb29yZHMuJHtJW3AtMl19ID0gbGFzdERpbTtcbiAgICAgIGAsb3Q9YFxuICAgICAgdmVjNCAke299KCkge1xuICAgICAgICAke1R9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAke2llfVxuICAgICAgICAke3d9XG4gICAgICAgIHZlYzQgb3V0cHV0VmFsdWUgPSAke2x9KCR7TH0pO1xuICAgICAgICAke0Z9XG4gICAgICB9XG4gICAgYDtyZXR1cm4gbmV3IFIob3QsW1wiY29vcmRpbmF0ZXMuZ2V0T3V0cHV0Q29vcmRzXCJdKX1nZXRVbnBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhvLGUscixuKXtsZXQgcz1bci53aWR0aCxyLmhlaWdodF0saT1bZS53aWR0aCxlLmhlaWdodF0sdT1lLnVucGFja2VkU2hhcGUubGVuZ3RoLGw9ci51bnBhY2tlZFNoYXBlLmxlbmd0aCxmPWUudW5wYWNrZWRTaGFwZSxwPXIudW5wYWNrZWRTaGFwZSxkPUtuKG4pO2lmKHU9PT1sJiZwci5hcnJheXNFcXVhbChpLHMpKXtsZXQgWT1gXG4gICAgICAgICAgZmxvYXQgJHtvfSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bn0sIFRleENvb3Jkcyk7XG4gICAgICAgICAgfVxuICAgICAgICBgO3JldHVybiBuZXcgUihZLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWxldCBUPUplKGwpLHY9S2UuZ2V0QnJvYWRjYXN0RGltcyhmLHApLHc9bC11LEksTD1PdCgpO3U9PT0wP0k9XCJcIjpsPDImJnYubGVuZ3RoPj0xP0k9XCJjb29yZHMgPSAwO1wiOkk9di5tYXAoWT0+YGNvb3Jkcy4ke0xbWSt3XX0gPSAwO2ApLmpvaW4oYFxuYCk7bGV0IEY9XCJcIjtsPDImJnU+MD9GPVwiY29vcmRzXCI6Rj1lLnVucGFja2VkU2hhcGUubWFwKChZLGopPT5gY29vcmRzLiR7TFtqK3ddfWApLmpvaW4oXCIsIFwiKTtsZXQgQz1gXG4gICAgICAgIGZsb2F0ICR7b30oKSB7XG4gICAgICAgICAgJHtUfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgICAke0l9XG4gICAgICAgICAgcmV0dXJuICR7ZH0oJHtGfSk7XG4gICAgICAgIH1cbiAgICAgIGA7cmV0dXJuIG5ldyBSKEMsW1wiY29vcmRpbmF0ZXMuZ2V0T3V0cHV0Q29vcmRzXCJdKX1nZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KG8sZSxyKXtzd2l0Y2goci51bnBhY2tlZFNoYXBlLmxlbmd0aCl7Y2FzZSAwOnJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXJTY2FsYXIobyxlKTtjYXNlIDE6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlcjFEKG8sZSxyKTtjYXNlIDI6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlcjJEKG8sZSxyKTtjYXNlIDM6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlcjNEKG8sZSxyKTtkZWZhdWx0OnJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXJORChvLGUscil9fWdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChvLGUscil7bGV0IG49ci51bnBhY2tlZFNoYXBlO3N3aXRjaChuLmxlbmd0aCl7Y2FzZSAwOnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlclNjYWxhcihvLGUscik7Y2FzZSAxOnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjFEKG8sZSxyKTtjYXNlIDI6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyMkQobyxlLHIpO2Nhc2UgMzpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIzRChvLGUscik7Y2FzZSA0OnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjREKG8sZSxyKTtjYXNlIDU6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyNUQobyxlLHIpO2Nhc2UgNjpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI2RChvLGUscik7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRpbWVuc2lvbiAke24ubGVuZ3RofS1EYCl9fWdldFBhY2tlZFNhbXBsZXJTY2FsYXIobyxlKXtsZXQgcj1xKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbiksbj1gXG4gICAgICAgICAgdmVjNCAke299KCkge1xuICAgICAgICAgICAgcmV0dXJuICR7ci50ZXh0dXJlMkR9KCR7ZX0sIGhhbGZDUik7XG4gICAgICAgICAgfVxuICAgICAgICBgO3JldHVybiBuZXcgUihuKX1nZXRQYWNrZWRTYW1wbGVyMUQobyxlLHIpe2xldCBuPVtyLndpZHRoLHIuaGVpZ2h0XSxzPVtuWzFdLG5bMF1dLGk9cSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pLGw9YHZlYzQgJHtvfShpbnQgaW5kZXgpIHtcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20xRChcbiAgICAgICR7c1swXX0sICR7c1sxXX0sIGluZGV4KTtcbiAgICAgIHJldHVybiAke2kudGV4dHVyZTJEfSgke2V9LCB1dik7XG4gICAgfWA7cmV0dXJuIG5ldyBSKGwsW1wiY29vcmRpbmF0ZXMucGFja2VkVVZmcm9tMURcIl0pfWdldFBhY2tlZFNhbXBsZXIyRChvLGUscil7bGV0IG49ci51bnBhY2tlZFNoYXBlLHM9W3Iud2lkdGgsci5oZWlnaHRdLGk9cSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pLHU9c1swXSxsPXNbMV07aWYocyE9bnVsbCYmcHIuYXJyYXlzRXF1YWwobixzKSl7bGV0IHY9YHZlYzQgJHtvfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgIHZlYzIgdXYgPSAodmVjMihjb2wsIHJvdykgKyBoYWxmQ1IpIC8gdmVjMigke2x9LjAsICR7dX0uMCk7XG4gICAgICAgIHJldHVybiAke2kudGV4dHVyZTJEfSgke2V9LCB1dik7XG4gICAgICB9YDtyZXR1cm4gbmV3IFIodil9bGV0IGY9cyxwPU1hdGguY2VpbChuWzFdLzIpLFQ9YHZlYzQgJHtvfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tMkQoJHtmWzFdfSwgJHtmWzBdfSwgJHtwfSwgcm93LCBjb2wpO1xuICAgICAgcmV0dXJuICR7aS50ZXh0dXJlMkR9KCR7ZX0sIHV2KTtcbiAgICB9YDtyZXR1cm4gbmV3IFIoVCxbXCJjb29yZGluYXRlcy5wYWNrZWRVVmZyb20yRFwiXSl9Z2V0UGFja2VkU2FtcGxlcjNEKG8sZSxyKXtsZXQgbj1yLnVucGFja2VkU2hhcGUscz1bci53aWR0aCxyLmhlaWdodF0saT1bc1swXSxzWzFdXSx1PXEodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtpZihuWzBdPT09MSl7bGV0IHc9bi5zbGljZSgxKSxJPVsxLDJdLEw9QnIobix3KSxGPVtcImJcIixcInJvd1wiLFwiY29sXCJdLEM9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyKSk7Qy51bnBhY2tlZFNoYXBlPUw7bGV0IFk9dGhpcy5nZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KG8sZSxDKSxNPWAke1kucm91dGluZUJvZHl9XG4gICAgICB2ZWM0ICR7b30oaW50IGIsIGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgcmV0dXJuICR7b30oJHtOcihGLEkpfSk7XG4gICAgICB9IGA7cmV0dXJuIG5ldyBSKE0sWS5kZXBlbmRlbmNpZXMpfWxldCBsPWlbMF0sZj1pWzFdLHA9TWF0aC5jZWlsKG5bMl0vMiksZD1wKk1hdGguY2VpbChuWzFdLzIpLHY9YHZlYzQgJHtvfShpbnQgYiwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTNEKFxuICAgICAgICAke2Z9LCAke2x9LCAke2R9LCAke3B9LCBiLCByb3csIGNvbCk7XG4gICAgICByZXR1cm4gJHt1LnRleHR1cmUyRH0oJHtlfSwgdXYpO31gO3JldHVybiBuZXcgUih2LFtcImNvb3JkaW5hdGVzLnBhY2tlZFVWZnJvbTNEXCJdKX1nZXRQYWNrZWRTYW1wbGVyTkQobyxlLHIpe2xldCBuPXIudW5wYWNrZWRTaGFwZSxzPW4ubGVuZ3RoLGk9W3Iud2lkdGgsci5oZWlnaHRdLHU9cSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pLGw9W2lbMF0saVsxXV0sZj1sWzFdLHA9bFswXSxkPU1hdGguY2VpbChuW3MtMV0vMiksVD1kKk1hdGguY2VpbChuW3MtMl0vMiksdj1cImludCBiLCBpbnQgcm93LCBpbnQgY29sXCIsdz1gYiAqICR7VH0gKyAocm93IC8gMikgKiAke2R9ICsgKGNvbCAvIDIpYDtmb3IobGV0IEY9MjtGPHMtMTtGKyspdj1gaW50IGIke0Z9LCBgK3YsVCo9bltzLUYtMV0sdz1gYiR7Rn0gKiAke1R9ICsgYCt3O2xldCBMPWB2ZWM0ICR7b30oJHt2fSkge1xuICAgICAgaW50IGluZGV4ID0gJHt3fTtcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLyAke3B9O1xuICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiAke3B9O1xuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoJHtwfSwgJHtmfSk7XG4gICAgICByZXR1cm4gJHt1LnRleHR1cmUyRH0oJHtlfSwgdXYpO1xuICAgIH1gO3JldHVybiBuZXcgUihMKX1nZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIobyxlLHIpe2xldFtuLHNdPVtyLndpZHRoLHIuaGVpZ2h0XTtpZihuPT09MSYmcz09PTEpe2xldCB1PWBcbiAgICAgICAgICBmbG9hdCAke299KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgaGFsZkNSKTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7cmV0dXJuIG5ldyBSKHUsW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9bGV0IGk9YFxuICAgICAgICBmbG9hdCAke299KCkge1xuICAgICAgICAgIGludCBvZmZzZXRfJHtlfSA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtufSwgJHtzfSk7XG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtufSwgJHtzfSwgb2Zmc2V0XyR7ZX0pO1xuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcbiAgICAgICAgfVxuICAgICAgYDtyZXR1cm4gbmV3IFIoaSxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyMUQobyxlLHIpe2xldCBuPXIud2lkdGgscz1yLmhlaWdodDtpZihzPT09MSYmbj09PTEpe2xldCB1PWBcbiAgICAgICAgZmxvYXQgJHtvfShpbnQgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCBoYWxmQ1IpO1xuICAgICAgICB9XG4gICAgICBgO3JldHVybiBuZXcgUih1LFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWlmKHM9PT0xKXtsZXQgdT1gXG4gICAgICAgICAgZmxvYXQgJHtvfShpbnQgaW5kZXgpIHtcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKChmbG9hdChpbmRleCkgKyAwLjUpIC8gJHtufS4wLCAwLjUpO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtyZXR1cm4gbmV3IFIodSxbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1pZihuPT09MSl7bGV0IHU9YFxuICAgICAgICAgIGZsb2F0ICR7b30oaW50IGluZGV4KSB7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChmbG9hdChpbmRleCkgKyAwLjUpIC8gJHtzfS4wKTtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7cmV0dXJuIG5ldyBSKHUsW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9bGV0IGk9YFxuICAgICAgICBmbG9hdCAke299KGludCBpbmRleCkge1xuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7bn0sICR7c30sIGluZGV4KTtcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XG4gICAgICAgIH1cbiAgICAgIGA7cmV0dXJuIG5ldyBSKGksW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyMkQobyxlLHIpe2xldCBuPXIudW5wYWNrZWRTaGFwZSxzPVtyLmhlaWdodCxyLndpZHRoXTtpZihzIT1udWxsJiZwci5hcnJheXNFcXVhbChuLHMpKXtsZXQgVD1zWzFdLHY9c1swXSx3PWBcbiAgICAgICAgICBmbG9hdCAke299KGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgICAgIHZlYzIgdXYgPSAodmVjMihyb3csIGNvbCkgKyBoYWxmQ1IpIC8gdmVjMigke1R9LjAsICR7dn0uMCk7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XG4gICAgICAgICAgfVxuICAgICAgICBgO3JldHVybiBuZXcgUih3LFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWxldHtuZXdTaGFwZTppLGtlcHREaW1zOnV9PVVyKG4pLGw9aTtpZihsLmxlbmd0aDxuLmxlbmd0aCl7bGV0IFQ9QnIobixsKSx2PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocikpO3YudW5wYWNrZWRTaGFwZT1UO2xldCB3PVtcImNvbFwiLFwicm93XCJdLEk9YFxuICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQobyxlLHYpLnJvdXRpbmVCb2R5fVxuICAgICAgICAgIGZsb2F0ICR7b30oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgcmV0dXJuICR7b30oJHtOcih3LHUpfSk7XG4gICAgICAgICAgfVxuICAgICAgICBgO3JldHVybiBuZXcgUihJLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWxldCBmPXNbMV0scD1zWzBdO2lmKHA9PT0xKXtsZXQgVD1gXG4gICAgICAgICAgZmxvYXQgJHtvfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgICBpbnQgb2Zmc2V0XyR7ZX0gPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7Zn0sICR7cH0pO1xuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7ZX0pLCB2ZWMzKCR7blsxXX0sIDEsIDEpKTtcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGluZGV4ICsgMC41KSAvICR7Zn0uMCk7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XG4gICAgICAgICAgfVxuICAgICAgICBgO3JldHVybiBuZXcgUihULFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX1pZihmPT09MSl7bGV0IFQ9YFxuICAgICAgICAgIGZsb2F0ICR7b30oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgaW50IG9mZnNldF8ke2V9ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke2Z9LCAke3B9KTtcbiAgICAgICAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzMocm93LCBjb2wsIG9mZnNldF8ke2V9KSwgdmVjMygke25bMV19LCAxLCAxKSk7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoaW5kZXggKyAwLjUpIC8gJHtwfS4wLCAwLjUpO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtyZXR1cm4gbmV3IFIoVCxbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9bGV0IGQ9YFxuICAgICAgICBmbG9hdCAke299KGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgICBpbnQgaW5kZXggPSBjb2wgKiAke25bMV19ICsgcm93O1xuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7Zn0sICR7cH0sIGluZGV4KTtcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XG4gICAgICAgIH1cbiAgICAgIGA7cmV0dXJuIG5ldyBSKGQsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXRcIl0pfWdldFVucGFja2VkU2FtcGxlcjNEKG8sZSxyKXtsZXQgbj1yLnVucGFja2VkU2hhcGUscz1uWzFdKm5bMl0saT1uWzJdLHtuZXdTaGFwZTp1LGtlcHREaW1zOmx9PVVyKG4pLGY9dTtpZihmLmxlbmd0aDxuLmxlbmd0aCl7bGV0IHY9QnIobixmKSx3PVtcImJhdGNoXCIsXCJjb2xcIixcInJvd1wiXSxJPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocikpO0kudW5wYWNrZWRTaGFwZT12O2xldCBMPXRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KG8sZSxJKSxGPWwucmV2ZXJzZSgpLEM9YFxuICAgICAgICAgICR7TC5yb3V0aW5lQm9keX1cbiAgICAgICAgICBmbG9hdCAke299KGludCBiYXRjaCwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgcmV0dXJuICR7b30oJHtOcih3LEYpfSk7XG4gICAgICAgICAgfVxuICAgICAgICBgO3JldHVybiBuZXcgUihDLEwuZGVwZW5kZW5jaWVzKX1sZXQgcD1yLndpZHRoLGQ9ci5oZWlnaHQsVD1gXG4gICAgICAgICAgZmxvYXQgJHtvfShpbnQgZGVwdGgsIGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cbiAgICAgICAgICAgIGludCBpbmRleCA9IGRlcHRoICogJHtzfSArIGNvbCAqICR7aX0gKyByb3c7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3B9LCAke2R9LCBpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XG4gICAgICAgICAgfVxuICAgICAgYDtyZXR1cm4gbmV3IFIoVCxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyNEQobyxlLHIpe2xldCBuPXIudW5wYWNrZWRTaGFwZSxzPW5bM10saT1uWzJdKnMsdT1uWzFdKmksbD1yLndpZHRoLGY9ci5oZWlnaHQscD1gXG4gICAgICAgIGZsb2F0ICR7b30oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XG4gICAgICAgICAgaW50IGluZGV4ID0gcm93ICogJHt1fSArIGNvbCAqICR7aX0gK1xuICAgICAgICAgICAgICBkZXB0aDIgKiAke3N9ICsgZGVwdGg7XG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtsfSwgJHtmfSwgaW5kZXgpO1xuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcbiAgICAgICAgfVxuICAgICAgYDtyZXR1cm4gbmV3IFIocCxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1nZXRVbnBhY2tlZFNhbXBsZXI1RChvLGUscil7bGV0IG49ci51bnBhY2tlZFNoYXBlLHM9bls0XSxpPW5bM10qcyx1PW5bMl0qaSxsPW5bMV0qdSx7bmV3U2hhcGU6ZixrZXB0RGltczpwfT1VcihuKTtpZihmLmxlbmd0aDxuLmxlbmd0aCl7bGV0IHc9QnIobixmKSxJPVtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCIsXCJkZXB0aDNcIl0sTD1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHIpKTtMLnVucGFja2VkU2hhcGU9dztsZXQgRj1gXG4gICAgICAgICAgJHt0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChvLGUsTCkucm91dGluZUJvZHl9XG4gICAgICAgICAgZmxvYXQgJHtvfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcbiAgICAgICAgICAgIHJldHVybiAke299KCR7TnIoSSxwKX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtyZXR1cm4gbmV3IFIoRixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCJdKX1sZXQgZD1yLndpZHRoLFQ9ci5oZWlnaHQsdj1gXG4gICAgICAgIGZsb2F0ICR7b30oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XG4gICAgICAgICAgaW50IGluZGV4ID0gcm93ICogJHtsfSArIGNvbCAqICR7dX0gKyBkZXB0aCAqICR7aX0gK1xuICAgICAgICAgIGRlcHRoMyAqICR7c30gKyBkZXB0aDI7XG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtkfSwgJHtUfSwgaW5kZXgpO1xuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcbiAgICAgICAgfVxuICAgICAgYDtyZXR1cm4gbmV3IFIodixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCJdKX1nZXRVbnBhY2tlZFNhbXBsZXI2RChvLGUscil7bGV0IG49ci51bnBhY2tlZFNoYXBlLHM9bls1XSxpPW5bNF0qcyx1PW5bM10qaSxsPW5bMl0qdSxmPW5bMV0qbCx7bmV3U2hhcGU6cCxrZXB0RGltczpkfT1VcihuKTtpZihwLmxlbmd0aDxuLmxlbmd0aCl7bGV0IEk9QnIobixwKSxMPVtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCIsXCJkZXB0aDNcIixcImRlcHRoNFwiXSxGPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocikpO0YudW5wYWNrZWRTaGFwZT1JO2xldCBDPWBcbiAgICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQobyxlLEYpLnJvdXRpbmVCb2R5fVxuICAgICAgICAgICAgZmxvYXQgJHtvfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXG4gICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICR7b30oJHtOcihMLGQpfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgYDtyZXR1cm4gbmV3IFIoQyxbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCJdKX1sZXQgVD1yLndpZHRoLHY9ci5oZWlnaHQsdz1gXG4gICAgICAgICAgZmxvYXQgJHtvfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXG4gICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XG4gICAgICAgICAgICBpbnQgaW5kZXggPSByb3cgKiAke2Z9ICsgY29sICogJHtsfSArIGRlcHRoICogJHt1fSArXG4gICAgICAgICAgICBkZXB0aDIgKiAke2l9ICsgZGVwdGgzICogJHtzfSArIGRlcHRoNDtcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7VH0sICR7dn0sIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7cmV0dXJuIG5ldyBSKHcsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXRcIl0pfXRvVmVjKCl7bGV0IG89dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQsZT1vLnNoYXBlLmxlbmd0aCxyPW8uc3RyaWRlcyxuPW8ud2lkdGgscz1vLmhlaWdodCxpPVtdO2ZvcihsZXQgbD0wO2w8ZS0xOysrbClpLnB1c2goYFxuICAgICAgICBjWyR7bH1dID0gb2Zmc2V0IC8gJHtyW2xdfTtgKSxpLnB1c2goYFxuICAgICAgICBvZmZzZXQgLT0gY1ske2x9XSAqICR7cltsXX07YCk7aS5wdXNoKGBcbiAgICAgICAgY1ske2UtMX1dID0gb2Zmc2V0O2ApO2xldCB1PWBcbiAgICAgIHZvaWQgdG9WZWModmVjMiB0ZXhDb29yZHMsIG91dCBpbnQgY1ske2V9XSkge1xuICAgICAgICBpbnQgb2Zmc2V0ID0gY29vcmRzVG9PZmZzZXQodGV4Q29vcmRzLCAke259LCAke3N9KTtcbiAgICAgICAgJHtpLmpvaW4oXCJcIil9XG4gICAgICB9XG4gICAgICB2b2lkIHRvVmVjKGludCBvZmZzZXQsIG91dCBpbnQgY1ske2V9XSkge1xuICAgICAgICAke2kuam9pbihcIlwiKX1cbiAgICAgIH1cbiAgICBgO3JldHVybnt0b1ZlYzpuZXcgUih1LFtcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX19dmFsdWVGcm9tKCl7bGV0IG89e307cmV0dXJuIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKGUscik9PntsZXQgbj10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tyXSxpPShuLnVucGFja2VkU2hhcGUubGVuZ3RoPjA/bi51bnBhY2tlZFNoYXBlOm4uc2hhcGUpLmxlbmd0aCx1PWBfJHtlfWA7b1t1XT1uZXcgUih0aGlzLmdldFZhbHVlRnJvbVNpbmdsZShlLGksbi53aWR0aCxuLmhlaWdodCwhMSksW2BzaGFwZVV0aWxzLmluZGljZXNUb09mZnNldCR7dX1gLFwiY29vcmRpbmF0ZXMub2Zmc2V0VG9Db29yZHNcIixcImZyYWdjb2xvci5nZXRDb2xvckFzRmxvYXRcIl0pLHU9dStcIl9UXCIsb1t1XT1uZXcgUih0aGlzLmdldFZhbHVlRnJvbVNpbmdsZShlLGksbi53aWR0aCxuLmhlaWdodCwhMCksW2BzaGFwZVV0aWxzLmluZGljZXNUb09mZnNldCR7dX1gLFwiY29vcmRpbmF0ZXMub2Zmc2V0VG9Db29yZHNcIixcImZyYWdjb2xvci5nZXRDb2xvckFzRmxvYXRcIl0pfSksb31nZXRWYWx1ZUZyb21TaW5nbGUobyxlLHIsbixzKXtsZXQgaT1gXyR7b31gO3MmJihpPWkrXCJfVFwiKTtsZXQgdT1xKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7cmV0dXJuYFxuICAgICAgICBmbG9hdCAke2l9KGludCBtWyR7ZX1dKSB7XG4gICAgICAgICAgaW50IG9mZnNldCA9IGluZGljZXNUb09mZnNldCR7aX0obSk7XG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7cn0sICR7bn0pO1xuICAgICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7dS50ZXh0dXJlMkR9KCR7b30sIGNvb3JkcykpO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBgfWdldFBhY2tlZFZhbHVlRnJvbShvLGUscixuLHMpe2xldCBpPWBfJHtvfV9QYWNrYDtzJiYoaT1pK1wiX1RcIik7bGV0IHU9cSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO3JldHVybmBcbiAgICAgICAgdmVjNCAke2l9KGludCBtWyR7ZX1dKSB7XG4gICAgICAgICAgaW50IG9mZnNldCA9IGluZGljZXNUb09mZnNldF8ke299KG0pO1xuICAgICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke3J9LCAke259KTtcbiAgICAgICAgICByZXR1cm4gJHt1LnRleHR1cmUyRH0oJHtvfSwgY29vcmRzKTtcbiAgICAgICAgfVxuICAgICAgICBgfX19KTt2YXIgcG8sbnA9RSgoKT0+e1widXNlIHN0cmljdFwiO0h0KCk7cG89Y2xhc3MgYSBleHRlbmRzIGZ0e2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpfWdldEZ1bmN0aW9ucygpe3JldHVybnsuLi50aGlzLmVuY29kZUZsb2F0MzIoKSwuLi50aGlzLmRlY29kZUZsb2F0MzIoKX19Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1lbmNvZGVGbG9hdDMyKCl7cmV0dXJue2VuY29kZTpuZXcgUihgaGlnaHAgdmVjNCBlbmNvZGUoaGlnaHAgZmxvYXQgZikge1xuICAgICAgICByZXR1cm4gdmVjNChmLCAwLjAsIDAuMCwgMC4wKTtcbiAgICAgIH1cbiAgICAgICAgYCl9fWRlY29kZUZsb2F0MzIoKXtyZXR1cm57ZGVjb2RlOm5ldyBSKGBoaWdocCBmbG9hdCBkZWNvZGUoaGlnaHAgdmVjNCByZ2JhKSB7XG4gICAgICAgIHJldHVybiByZ2JhLnI7XG4gICAgICB9XG4gICAgICAgIGApfX1lbmNvZGVVaW50OCgpe2xldCB0PWEuaXNMaXR0bGVFbmRpYW4oKT9cInJnYmEucmdiYT1yZ2JhLmFiZ3I7XCI6XCJcIjtyZXR1cm57ZW5jb2RlOm5ldyBSKGBcbiAgICAgIGhpZ2hwIHZlYzQgZW5jb2RlKGhpZ2hwIGZsb2F0IGYpIHtcbiAgICAgICAgaGlnaHAgZmxvYXQgRiA9IGFicyhmKTtcbiAgICAgICAgaGlnaHAgZmxvYXQgU2lnbiA9IHN0ZXAoMC4wLC1mKTtcbiAgICAgICAgaGlnaHAgZmxvYXQgRXhwb25lbnQgPSBmbG9vcihsb2cyKEYpKTtcbiAgICAgICAgaGlnaHAgZmxvYXQgTWFudGlzc2EgPSAoZXhwMigtIEV4cG9uZW50KSAqIEYpO1xuICAgICAgICBFeHBvbmVudCA9IGZsb29yKGxvZzIoRikgKyAxMjcuMCkgKyBmbG9vcihsb2cyKE1hbnRpc3NhKSk7XG4gICAgICAgIGhpZ2hwIHZlYzQgcmdiYTtcbiAgICAgICAgcmdiYVswXSA9IDEyOC4wICogU2lnbiAgKyBmbG9vcihFeHBvbmVudCpleHAyKC0xLjApKTtcbiAgICAgICAgcmdiYVsxXSA9IDEyOC4wICogbW9kKEV4cG9uZW50LDIuMCkgKyBtb2QoZmxvb3IoTWFudGlzc2EqMTI4LjApLDEyOC4wKTtcbiAgICAgICAgcmdiYVsyXSA9IGZsb29yKG1vZChmbG9vcihNYW50aXNzYSpleHAyKDIzLjAgLTguMCkpLGV4cDIoOC4wKSkpO1xuICAgICAgICByZ2JhWzNdID0gZmxvb3IoZXhwMigyMy4wKSptb2QoTWFudGlzc2EsZXhwMigtMTUuMCkpKTtcbiAgICAgICAgJHt0fVxuICAgICAgICByZ2JhID0gcmdiYSAvIDI1NS4wOyAvLyB2YWx1ZXMgbmVlZCB0byBiZSBub3JtYWxpemVkIHRvIFswLDFdXG4gICAgICAgIHJldHVybiByZ2JhO1xuICAgIH1cbiAgICAgICAgYCl9fWRlY29kZVVpbnQ4KCl7bGV0IHQ9YS5pc0xpdHRsZUVuZGlhbigpP1wicmdiYS5yZ2JhPXJnYmEuYWJncjtcIjpcIlwiO3JldHVybntkZWNvZGU6bmV3IFIoYFxuICAgICAgICBoaWdocCBmbG9hdCBkZWNvZGUoaGlnaHAgdmVjNCByZ2JhKSB7XG4gICAgICAgICAgcmdiYSA9IHJnYmEgKiAyNTUuMDsgLy8gdmFsdWVzIG5lZWQgdG8gYmUgZGUtbm9ybWFsaXplZCBmcm9tIFswLDFdIHRvIFswLDI1NV1cbiAgICAgICAgICAke3R9XG4gICAgICAgICAgaGlnaHAgZmxvYXQgU2lnbiA9IDEuMCAtIHN0ZXAoMTI4LjAscmdiYVswXSkqMi4wO1xuICAgICAgICAgIGhpZ2hwIGZsb2F0IEV4cG9uZW50ID0gMi4wICogbW9kKHJnYmFbMF0sMTI4LjApICsgc3RlcCgxMjguMCxyZ2JhWzFdKSAtIDEyNy4wO1xuICAgICAgICAgIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMV0sMTI4LjApKjY1NTM2LjAgKyByZ2JhWzJdKjI1Ni4wICtyZ2JhWzNdICsgZmxvYXQoMHg4MDAwMDApO1xuICAgICAgICAgIGhpZ2hwIGZsb2F0IFJlc3VsdCA9ICBTaWduICogZXhwMihFeHBvbmVudCkgKiAoTWFudGlzc2EgKiBleHAyKC0yMy4wICkpO1xuICAgICAgICAgIHJldHVybiBSZXN1bHQ7XG4gICAgICB9XG4gICAgICAgIGApfX1zdGF0aWMgaXNMaXR0bGVFbmRpYW4oKXtsZXQgdD1uZXcgQXJyYXlCdWZmZXIoNCksbz1uZXcgVWludDMyQXJyYXkodCksZT1uZXcgVWludDhBcnJheSh0KTtpZihvWzBdPTM3MzU5Mjg1NTksZVswXT09PTIzOSlyZXR1cm4hMDtpZihlWzBdPT09MjIyKXJldHVybiExO3Rocm93IG5ldyBFcnJvcihcInVua25vd24gZW5kaWFubmVzc1wiKX19fSk7dmFyIGhvLG9wPUUoKCk9PntcInVzZSBzdHJpY3RcIjtIdCgpO3hlKCk7aG89Y2xhc3MgZXh0ZW5kcyBmdHtjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXRGdW5jdGlvbnMoKXtyZXR1cm57Li4udGhpcy5zZXRGcmFnQ29sb3IoKSwuLi50aGlzLmdldENvbG9yQXNGbG9hdCgpfX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fXNldEZyYWdDb2xvcigpe2xldCB0PXEodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtyZXR1cm57c2V0RnJhZ0NvbG9yOm5ldyBSKGBcbiAgICAgICAgdm9pZCBzZXRGcmFnQ29sb3IoZmxvYXQgdmFsdWUpIHtcbiAgICAgICAgICAgICR7dC5vdXRwdXR9ID0gZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBgLFtcImVuY29kaW5nLmVuY29kZVwiXSl9fWdldENvbG9yQXNGbG9hdCgpe3JldHVybntnZXRDb2xvckFzRmxvYXQ6bmV3IFIoYFxuICAgICAgICBmbG9hdCBnZXRDb2xvckFzRmxvYXQodmVjNCBjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZShjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgYCxbXCJlbmNvZGluZy5kZWNvZGVcIl0pfX19fSk7dmFyIG1vLGlwPUUoKCk9PntcInVzZSBzdHJpY3RcIjtIdCgpO21vPWNsYXNzIGEgZXh0ZW5kcyBmdHtjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXRGdW5jdGlvbnMoKXtyZXR1cm57Li4udGhpcy5iY2FzdEluZGV4KCksLi4udGhpcy5iY2FzdE1hdG11bEluZGV4KCksLi4udGhpcy5vZmZzZXRUb0luZGljZXMoKSwuLi50aGlzLmluZGljZXNUb09mZnNldCgpLC4uLnRoaXMuaW5jcmVtZW50SW5kaWNlcygpfX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fWJjYXN0SW5kZXgoKXtsZXQgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGgsbz17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoZSxyKT0+e2xldCBuPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW3JdLnVucGFja2VkU2hhcGU7aWYobi5sZW5ndGg8PXQpe2xldCBzPW4ubGVuZ3RoLGk9dC1zLHU9YGJjYXN0SW5kaWNlc18ke2V9YCxsPVwiXCI7Zm9yKGxldCBwPTA7cDxzOysrcClsKz1gXG4gICAgICAgICAgcmVhbEluZGljZXNbJHtwfV0gPSBpbnQoIG1vZChmbG9hdChiY2FzdGVkSW5kaWNlc1ske2krcH1dKSwgJHtuW3BdfS4wKSApO1xuICAgICAgICAgIGA7bGV0IGY9YFxuICAgICAgICB2b2lkICR7dX0gKGludCBiY2FzdGVkSW5kaWNlc1ske3R9XSwgb3V0IGludCByZWFsSW5kaWNlc1ske3N9XSkge1xuICAgICAgICAgICR7bH1cbiAgICAgICAgfVxuICAgICAgICBgO29bdV09bmV3IFIoZil9fSksb31iY2FzdE1hdG11bEluZGV4KCl7bGV0IHQ9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoLG89e307cmV0dXJuIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKGUscik9PntsZXQgbj10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tyXS5zaGFwZTtpZighKG4ubGVuZ3RoPDJ8fG4ubGVuZ3RoPnQpKXtsZXQgcz1uLmxlbmd0aCxpPXQtcyx1PWBiY2FzdE1hdG11bEluZGljZXNfJHtlfWAsbD1cIlwiO2ZvcihsZXQgcD0wO3A8cy0yOysrcClsKz1gXG4gICAgICAgICAgcmVhbEluZGljZXNbJHtwfV0gPSBpbnQoIG1vZChmbG9hdChiY2FzdGVkSW5kaWNlc1ske2krcH1dKSwgJHtuW3BdfS4wKSApO1xuICAgICAgICAgIGA7bGV0IGY9YFxuICAgICAgICB2b2lkICR7dX0oaW50IGJjYXN0ZWRJbmRpY2VzWyR7dH1dLCBvdXQgaW50IHJlYWxJbmRpY2VzWyR7c31dKSB7XG4gICAgICAgICAgJHtsfVxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7cy0xfV0gPSBiY2FzdGVkSW5kaWNlc1ske3QtMX1dO1xuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7cy0yfV0gPSBiY2FzdGVkSW5kaWNlc1ske3QtMn1dO1xuICAgICAgICB9XG4gICAgICAgIGA7b1t1XT1uZXcgUihmKX19KSxvfWluZGljZXNUb09mZnNldCgpe2xldCB0PXt9O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKChvLGUpPT57bGV0IHI9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbZV0uc2hhcGUsbj10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tlXS5zdHJpZGVzLHM9ci5sZW5ndGgsaT1gaW5kaWNlc1RvT2Zmc2V0XyR7b31gO3RbaV09bmV3IFIoYS5pbmRleFRvT2Zmc2V0U2luZ2xlKGkscyxuKSksaT1gaW5kaWNlc1RvT2Zmc2V0XyR7b31fVGAsdFtpXT1uZXcgUihhLmluZGV4VG9PZmZzZXRTaW5nbGUoaSxzLG4uc2xpY2UoKS5yZXZlcnNlKCkpKX0pLHR9c3RhdGljIGluZGV4VG9PZmZzZXRTaW5nbGUodCxvLGUpe2xldCByPVwiXCI7Zm9yKGxldCBuPW8tMTtuPj0wOy0tbilyKz1gXG4gICAgICAgIG9mZnNldCArPSBpbmRpY2VzWyR7bn1dICogJHtlW25dfTtcbiAgICAgICAgYDtyZXR1cm5gXG4gICAgICBpbnQgJHt0fShpbnQgaW5kaWNlc1ske299XSkge1xuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcbiAgICAgICAgJHtyfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgfVxuICAgICAgYH1vZmZzZXRUb0luZGljZXMoKXtsZXQgdD17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgobyxlKT0+e2xldCByPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW2VdLnNoYXBlLG49dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbZV0uc3RyaWRlcyxzPXIubGVuZ3RoLGk9YG9mZnNldFRvSW5kaWNlc18ke299YDt0W2ldPW5ldyBSKGEub2Zmc2V0VG9JbmRpY2VzU2luZ2xlKGkscyxuKSksaT1gb2Zmc2V0VG9JbmRpY2VzXyR7b31fVGAsdFtpXT1uZXcgUihhLm9mZnNldFRvSW5kaWNlc1NpbmdsZShpLHMsbi5zbGljZSgpLnJldmVyc2UoKSkpfSksdH1zdGF0aWMgb2Zmc2V0VG9JbmRpY2VzU2luZ2xlKHQsbyxlKXtsZXQgcj1bXTtmb3IobGV0IG49MDtuPG8tMTsrK24pci5wdXNoKGBcbiAgICAgIGluZGljZXNbJHtufV0gPSBvZmZzZXQgLyAke2Vbbl19O2ApLHIucHVzaChgXG4gICAgICAgIG9mZnNldCAtPSBpbmRpY2VzWyR7bn1dICogJHtlW25dfTtgKTtyZXR1cm4gci5wdXNoKGBcbiAgICAgIGluZGljZXNbJHtvLTF9XSA9IG9mZnNldDtgKSxgXG4gICAgICB2b2lkICR7dH0oaW50IG9mZnNldCwgb3V0IGludCBpbmRpY2VzWyR7b31dKSB7XG4gICAgICAgICR7ci5qb2luKFwiXCIpfVxuICAgICAgfVxuICAgICAgYH1pbmNyZW1lbnRJbmRpY2VzKCl7bGV0IHQ9e307cmV0dXJuIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKG8sZSk9PntsZXQgcj10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tlXS5zaGFwZSxuPXIubGVuZ3RoLHM9YGluY3JlbWVudEluZGljZXNfJHtvfWAsaT1cIlwiO2ZvcihsZXQgbD0wO2w8bjsrK2wpaSs9YFxuICAgICAgICBzaGFwZVske2x9XSA9ICR7cltsXX07YDtsZXQgdT1gXG4gICAgICAgIHZvaWQgJHtzfShpbnQgYXhpcywgb3V0IGludCBpbmRpY2VzWyR7bn1dKSB7XG4gICAgICAgICAgaW50IHNoYXBlWyR7bn1dO1xuICAgICAgICAgICR7aX07XG4gICAgICAgICAgZm9yKGludCBpID0gJHtufSAtMSA7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBpZihpID4gYXhpcykgY29udGludWU7XG4gICAgICAgICAgICBpbmRpY2VzW2ldICs9IDE7XG4gICAgICAgICAgICBpZihpbmRpY2VzW2ldIDwgc2hhcGVbaV0pIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRpY2VzW2ldID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYDt0W3NdPW5ldyBSKHUpfSksdH19fSk7dmFyIGJvLGFwPUUoKCk9PntcInVzZSBzdHJpY3RcIjtIdCgpO2JvPWNsYXNzIGV4dGVuZHMgZnR7Y29uc3RydWN0b3IodCl7c3VwZXIodCl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1nZXRGdW5jdGlvbnMoKXtyZXR1cm57Li4udGhpcy5iaW5hcnlWZWNGdW5jdGlvbnMoKSwuLi50aGlzLmNvcHlWZWMoKSwuLi50aGlzLnNldFZlY0l0ZW0oKSwuLi50aGlzLmdldFZlY0l0ZW0oKX19YmluYXJ5VmVjRnVuY3Rpb25zKCl7bGV0IG89dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoLGU9e2FkZDpcIis9XCIsc3ViOlwiLT1cIixtdWw6XCIqPVwiLGRpdjpcIi89XCJ9LHI9e307Zm9yKGxldCBuIGluIGUpe2xldCBzPWAke259VmVjYCxpPVwiXCI7Zm9yKGxldCBsPTA7bDxvOysrbClpKz1gXG4gICAgICAgICAgZGVzdFske2x9XSAke2Vbbl19IHNyY1ske2x9XTtcbiAgICAgICAgICBgO2xldCB1PWBcbiAgICAgICAgdm9pZCAke3N9KGludCBzcmNbJHtvfV0sIG91dCBpbnQgZGVzdFske299XSkge1xuICAgICAgICAgICR7aX1cbiAgICAgICAgfVxuICAgICAgICBgO3Jbc109bmV3IFIodSl9cmV0dXJuIHJ9Y29weVZlYygpe2xldCBvPXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aCxlPVwiXCI7Zm9yKGxldCBuPTA7bjxvOysrbillKz1gXG4gICAgICAgIGRlc3RbJHtufV0gPSBzcmNbJHtufV07XG4gICAgICAgIGA7bGV0IHI9YFxuICAgICAgdm9pZCBjb3B5VmVjKGludCBzcmNbJHtvfV0sIG91dCBpbnQgZGVzdFske299XSkge1xuICAgICAgICAke2V9XG4gICAgICB9XG4gICAgICBgO3JldHVybntjb3B5VmVjOm5ldyBSKHIpfX1zZXRWZWNJdGVtKCl7bGV0IG89dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoLGU9YFxuICAgICAgICBpZihpbmRleCA8IDApXG4gICAgICAgICAgICBpbmRleCA9JHtvfSArIGluZGV4O1xuICAgICAgICBpZiAoaW5kZXggPT0gMClcbiAgICAgICAgICAgIG1bMF0gPSB2YWx1ZTtcbiAgICAgICAgYDtmb3IobGV0IG49MTtuPG8tMTsrK24pZSs9YFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAke259KVxuICAgICAgICAgICAgbVske259XSA9IHZhbHVlO1xuICAgICAgICAgICAgYDtlKz1gXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1bJHtvLTF9XSA9IHZhbHVlO1xuICAgICAgICBgO2xldCByPWBcbiAgICAgIHZvaWQgc2V0VmVjSXRlbShvdXQgaW50IG1bJHtvfV0sIGludCBpbmRleCwgaW50IHZhbHVlKSB7XG4gICAgICAgICR7ZX1cbiAgICAgIH1cbiAgICAgICAgYDtyZXR1cm57c2V0VmVjSXRlbTpuZXcgUihyKX19Z2V0VmVjSXRlbSgpe2xldCBvPXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aCxlPWBcbiAgICAgICAgaWYoaW5kZXggPCAwKVxuICAgICAgICAgICAgaW5kZXggPSAke299ICsgaW5kZXg7XG4gICAgICAgIGlmIChpbmRleCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG1bMF07XG4gICAgICBgO2ZvcihsZXQgbj0xO248by0xOysrbillKz1gXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09ICR7bn0pXG4gICAgICAgICAgICByZXR1cm4gbVske259XTtcbiAgICAgIGA7ZSs9YFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbVske28tMX1dO1xuICAgICAgICBgO2xldCByPWBcbiAgICAgIGludCBnZXRWZWNJdGVtKGludCBtWyR7b31dLCBpbnQgaW5kZXgpIHtcbiAgICAgICAgJHtlfVxuICAgICAgfVxuICAgIGA7cmV0dXJue2dldFZlY0l0ZW06bmV3IFIocil9fX19KTt2YXIgcWksc3A9RSgoKT0+e1widXNlIHN0cmljdFwiO3JwKCk7bnAoKTtvcCgpO2lwKCk7YXAoKTtxaT17ZW5jb2Rpbmc6cG8sZnJhZ2NvbG9yOmhvLHZlYzpibyxzaGFwZVV0aWxzOm1vLGNvb3JkaW5hdGVzOmNvfX0pO3ZhciBnbyx1cD1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SHQoKTtlcCgpO3NwKCk7eGUoKTtnbz1jbGFzc3tjb25zdHJ1Y3Rvcih0LG8sZSxyKXt0aGlzLmxpYnM9e307dGhpcy5nbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaD17fTt0aGlzLmNvbnRleHQ9bmV3IGVvKHQsbyxlLHIpLE9iamVjdC5rZXlzKHFpKS5mb3JFYWNoKHM9PntsZXQgaT1uZXcgcWlbc10odGhpcy5jb250ZXh0KTt0aGlzLmxpYnNbc109aX0pO2xldCBuPXRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGg7Zm9yKGxldCBzIGluIHRoaXMubGlicyl7bGV0IHU9dGhpcy5saWJzW3NdLmdldEZ1bmN0aW9ucygpO2ZvcihsZXQgbCBpbiB1KXtsZXQgZj1zK1wiLlwiK2wscDtuW2ZdPyhwPW5bZl0scC5yb3V0aW5lQm9keT11W2xdLnJvdXRpbmVCb2R5KToocD1uZXcgZG4oZix1W2xdLnJvdXRpbmVCb2R5KSxuW2ZdPXApO2xldCBkPXVbbF0uZGVwZW5kZW5jaWVzO2lmKGQpZm9yKGxldCBUPTA7VDxkLmxlbmd0aDsrK1QpaWYobltkW1RdXSlwLmFkZERlcGVuZGVuY3kobltkW1RdXSk7ZWxzZXtsZXQgdj1uZXcgZG4oZFtUXSk7bltkW1RdXT12LHAuYWRkRGVwZW5kZW5jeSh2KX19fX1wcmVwcm9jZXNzKCl7bGV0IHQ9dGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLG89dC5zaGFkZXJTb3VyY2U7cmV0dXJuIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5oYXNNYWlufHwobz1gJHtvfVxuICAgICAgJHtVdSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24sdGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoKX1gKSxvPVFjKG8pLGAke0d1KHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbil9XG4gICAgJHt0aGlzLmdldFVuaWZvcm1zKHQuaW5wdXROYW1lcyx0LnZhcmlhYmxlcyl9XG4gICAgJHt0aGlzLmdldEltcG9ydHMobyl9XG4gICAgJHtvfWB9Z2V0SW1wb3J0cyh0KXtsZXQgbz10aGlzLnNlbGVjdEdsc2xMaWJSb3V0aW5lc1RvQmVJbmNsdWRlZCh0KTtpZihvLmxlbmd0aD09PTApcmV0dXJuXCJcIjtsZXQgZT1cIlwiO2ZvcihsZXQgcj0wO3I8by5sZW5ndGg7KytyKWlmKG9bcl0ucm91dGluZUJvZHkpZSs9b1tyXS5yb3V0aW5lQm9keStgXG5gO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGJvZHkgZm9yIHRoZSBHbHNsIExpYnJhcnkgcm91dGluZTogJHtvW3JdLm5hbWV9YCk7cmV0dXJuIGV9c2VsZWN0R2xzbExpYlJvdXRpbmVzVG9CZUluY2x1ZGVkKHQpe2xldCBvPVtdO3JldHVybiBPYmplY3Qua2V5cyh0aGlzLmdsc2xMaWJSb3V0aW5lRGVwZW5kZW5jeUdyYXBoKS5mb3JFYWNoKGU9PntsZXQgcj1lLnNwbGl0KFwiLlwiKVsxXTt0LmluZGV4T2YocikhPT0tMSYmby5wdXNoKHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGhbZV0pfSksdG8ucmV0dXJuT3JkZXJlZE5vZGVzKG8pfWdldFVuaWZvcm1zKHQsbyl7bGV0IGU9W107aWYodClmb3IobGV0IHIgb2YgdCllLnB1c2goYHVuaWZvcm0gc2FtcGxlcjJEICR7cn07YCk7aWYobylmb3IobGV0IHIgb2YgbyllLnB1c2goYHVuaWZvcm0gJHtyLnR5cGV9ICR7ci5uYW1lfSR7ci5hcnJheUxlbmd0aD9gWyR7ci5hcnJheUxlbmd0aH1dYDpcIlwifTtgKTtyZXR1cm4gZS5qb2luKGBcbmApfX19KTt2YXIgeW8sbHA9RSgoKT0+e1widXNlIHN0cmljdFwiO1R0KCk7YXQoKTt1cCgpO3hlKCk7eW89Y2xhc3N7Y29uc3RydWN0b3IodCxvLGUpe3RoaXMucHJvZmlsZXI9dDt0aGlzLmdsQ29udGV4dD1vO3RoaXMudGV4dHVyZUxheW91dFN0cmF0ZWd5PWU7dGhpcy5yZXBvPW5ldyBNYXAsdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITF9Z2V0QXJ0aWZhY3QodCl7cmV0dXJuIHRoaXMucmVwby5nZXQodCl9c2V0QXJ0aWZhY3QodCxvKXt0aGlzLnJlcG8uc2V0KHQsbyl9cnVuKHQsbyxlKXt0aGlzLnByb2ZpbGVyLmV2ZW50KFwib3BcIixgUHJvZ3JhbU1hbmFnZXIucnVuICR7dC5wcm9ncmFtSW5mby5uYW1lPz9cInVua25vd24ga2VybmVsXCJ9YCwoKT0+e2xldCByPXRoaXMuZ2xDb250ZXh0LmdsLG49dC5wcm9ncmFtO3IudXNlUHJvZ3JhbShuKTt0cnl7dGhpcy5iaW5kT3V0cHV0KGUpLHRoaXMuYXR0cmlidXRlc0JvdW5kfHx0aGlzLmJpbmRBdHRyaWJ1dGVzKHQuYXR0cmliTG9jYXRpb25zKSx0aGlzLmJpbmRVbmlmb3Jtcyh0LnVuaWZvcm1Mb2NhdGlvbnMsdC5wcm9ncmFtSW5mby52YXJpYWJsZXM/P1tdLG8pfWNhdGNoKHMpe3Rocm93IGNlLmVycm9yKFwiUHJvZ3JhbU1hbmFnZXJcIix0LnByb2dyYW1JbmZvLnNoYWRlclNvdXJjZSksc310aGlzLnByb2ZpbGVyLmV2ZW50KFwiYmFja2VuZFwiLFwiR2xDb250ZXh0LmRyYXcoKVwiLCgpPT57dGhpcy5nbENvbnRleHQuZHJhdygpfSl9LHRoaXMuZ2xDb250ZXh0KX1kaXNwb3NlKCl7dGhpcy52ZXJ0ZXhTaGFkZXImJnRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRleFNoYWRlciksdGhpcy5yZXBvLmZvckVhY2godD0+dGhpcy5nbENvbnRleHQuZGVsZXRlUHJvZ3JhbSh0LnByb2dyYW0pKX1idWlsZCh0LG8sZSl7cmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoXCJiYWNrZW5kXCIsXCJQcm9ncmFtTWFuYWdlci5idWlsZFwiLCgpPT57bGV0IHI9bmV3IGdvKHRoaXMuZ2xDb250ZXh0LHQsbyxlKSxuPXIucHJlcHJvY2VzcygpLHM9dGhpcy5jb21waWxlKG4pO3JldHVybntwcm9ncmFtSW5mbzp0LHByb2dyYW06cyx1bmlmb3JtTG9jYXRpb25zOnRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9ucyhzLHIuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLHIuY29udGV4dC5wcm9ncmFtSW5mby52YXJpYWJsZXMpLGF0dHJpYkxvY2F0aW9uczp0aGlzLmdldEF0dHJpYkxvY2F0aW9ucyhzKX19KX1jb21waWxlKHQpe2lmKCF0aGlzLnZlcnRleFNoYWRlcil7Y2UudmVyYm9zZShcIlByb3JncmFtTWFuYWdlclwiLFwiQ29tcGlsaW5nIGFuZCBjYWNoaW5nIFZlcnRleCBzaGFkZXIgZm9yIHRoZSBmaXJzdCB0aW1lXCIpO2xldCByPU11KHRoaXMuZ2xDb250ZXh0LnZlcnNpb24pO3RoaXMudmVydGV4U2hhZGVyPXRoaXMuZ2xDb250ZXh0LmNvbXBpbGVTaGFkZXIocix0aGlzLmdsQ29udGV4dC5nbC5WRVJURVhfU0hBREVSKX1aLmRlYnVnJiZjZS52ZXJib3NlKFwiUHJvcmdyYW1NYW5hZ2VyXCIsYEZyYWdTaGFkZXI6XG4ke3R9XG5gKTtsZXQgbz10aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKHQsdGhpcy5nbENvbnRleHQuZ2wuRlJBR01FTlRfU0hBREVSKSxlPXRoaXMuZ2xDb250ZXh0LmNyZWF0ZVByb2dyYW0odGhpcy52ZXJ0ZXhTaGFkZXIsbyk7cmV0dXJuIHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcihvKSxlfWJpbmRPdXRwdXQodCl7bGV0IG89dC53aWR0aCxlPXQuaGVpZ2h0O2NlLnZlcmJvc2UoXCJQcm9yZ3JhbU1hbmFnZXJcIixgQmluZGluZyBvdXRwdXQgdGV4dHVyZSB0byBGcmFtZWJ1ZmZlcjogdy9oPSR7b30vJHtlfSwgc2hhcGU9JHt0LnNoYXBlfSwgdHlwZT0ke3QudGVuc29yLnR5cGV9YCksdGhpcy5nbENvbnRleHQuYXR0YWNoRnJhbWVidWZmZXIodC50ZXh0dXJlLG8sZSl9YmluZEF0dHJpYnV0ZXModCl7bGV0IG89dC5wb3NpdGlvbixlPXQudGV4dHVyZUNvb3JkO3RoaXMuZ2xDb250ZXh0LnNldFZlcnRleEF0dHJpYnV0ZXMobyxlKSx0aGlzLmF0dHJpYnV0ZXNCb3VuZD0hMH1iaW5kVW5pZm9ybXModCxvLGUpe2xldCByPXRoaXMuZ2xDb250ZXh0LmdsLG49MDtmb3IobGV0e25hbWU6cyx0eXBlOmksbG9jYXRpb246dSxhcnJheUxlbmd0aDpsfW9mIHQpe2xldCBmPW8uZmluZChwPT5wLm5hbWU9PT1zKT8uZGF0YTtpZihpIT09XCJzYW1wbGVyMkRcIiYmIWYpdGhyb3cgbmV3IEVycm9yKGB2YXJpYWJsZSAnJHtzfScgZG9lcyBub3QgaGF2ZSBkYXRhIGRlZmluZWQgaW4gcHJvZ3JhbSBpbmZvYCk7c3dpdGNoKGkpe2Nhc2VcInNhbXBsZXIyRFwiOnRoaXMuYmluZFRleHR1cmUoZVtuXSx1LG4pLG4rKzticmVhaztjYXNlXCJmbG9hdFwiOmw/ci51bmlmb3JtMWZ2KHUsZik6ci51bmlmb3JtMWYodSxmKTticmVhaztjYXNlXCJpbnRcIjpsP3IudW5pZm9ybTFpdih1LGYpOnIudW5pZm9ybTFpKHUsZik7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gbm90IGltcGxlbWVudGVkOiAke2l9YCl9fX1iaW5kVGV4dHVyZSh0LG8sZSl7dGhpcy5nbENvbnRleHQuYmluZFRleHR1cmVUb1VuaWZvcm0odC50ZXh0dXJlLGUsbyl9Z2V0QXR0cmliTG9jYXRpb25zKHQpe3JldHVybntwb3NpdGlvbjp0aGlzLmdldEF0dHJpYkxvY2F0aW9uKHQsXCJwb3NpdGlvblwiKSx0ZXh0dXJlQ29vcmQ6dGhpcy5nZXRBdHRyaWJMb2NhdGlvbih0LFwidGV4dHVyZUNvb3JkXCIpfX1nZXRVbmlmb3JtTG9jYXRpb25zKHQsbyxlKXtsZXQgcj1bXTtpZihvKWZvcihsZXQgbiBvZiBvKXIucHVzaCh7bmFtZTpuLHR5cGU6XCJzYW1wbGVyMkRcIixsb2NhdGlvbjp0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbih0LG4pfSk7aWYoZSlmb3IobGV0IG4gb2YgZSlyLnB1c2goey4uLm4sbG9jYXRpb246dGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odCxuLm5hbWUpfSk7cmV0dXJuIHJ9Z2V0VW5pZm9ybUxvY2F0aW9uKHQsbyl7bGV0IHI9dGhpcy5nbENvbnRleHQuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHQsbyk7aWYocj09PW51bGwpdGhyb3cgbmV3IEVycm9yKGBVbmlmb3JtICR7b30gbm90IGZvdW5kLmApO3JldHVybiByfWdldEF0dHJpYkxvY2F0aW9uKHQsbyl7cmV0dXJuIHRoaXMuZ2xDb250ZXh0LmdsLmdldEF0dHJpYkxvY2F0aW9uKHQsbyl9fX0pO3ZhciBUbyxmcD1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YXQoKTtjbigpO1RvPWNsYXNze2NvbnN0cnVjdG9yKHQsbyxlLHIpe3RoaXMuZ2xDb250ZXh0PXQ7dGhpcy5sYXlvdXRTdHJhdGVneT1vO3RoaXMucHJvZmlsZXI9ZTt0aGlzLmNvbmZpZz1yO3RoaXMucGVuZGluZ1JlYWQ9bmV3IE1hcDtyLnJldXNlVGV4dHVyZXMmJih0aGlzLmluVXNlVGV4dHVyZXM9bmV3IE1hcCx0aGlzLmlkbGVUZXh0dXJlcz1uZXcgTWFwLHRoaXMudGV4dHVyZUxvb2t1cD1uZXcgTWFwKX1jcmVhdGVUZXh0dXJlRnJvbUxheW91dCh0LG8sZSxyKXtsZXQgbj10aGlzLnRvRW5jb2RlclR5cGUodCkscz10aGlzLmdsQ29udGV4dC5nZXRFbmNvZGVyKG4sby5jaGFubmVsc3x8MSxyKTtpZihvLmlzUGFja2VkJiZyPT09MSl0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7bGV0IGk9by53aWR0aCx1PW8uaGVpZ2h0LGwsZjtpZih0aGlzLmNvbmZpZy5yZXVzZVRleHR1cmVzKXtsPWAke2l9eCR7dX1fJHtzLmZvcm1hdH1fJHtzLmludGVybmFsRm9ybWF0fV8ke3MudGV4dHVyZVR5cGV9YCxmPXRoaXMuaW5Vc2VUZXh0dXJlcy5nZXQobCksZnx8KGY9W10sdGhpcy5pblVzZVRleHR1cmVzLnNldChsLGYpKTtsZXQgZD10aGlzLmlkbGVUZXh0dXJlcy5nZXQobCk7aWYoZCYmZC5sZW5ndGg+MCl7bGV0IFQ9ZC5wb3AoKTtyZXR1cm4gZi5wdXNoKFQpLHI9PT0xJiZ0aGlzLmdsQ29udGV4dC51cGRhdGVUZXh0dXJlKFQsaSx1LHMsdGhpcy50b1RleHR1cmVEYXRhKHQsZSkpLFR9fWNlLnZlcmJvc2UoXCJUZXh0dXJlTWFuYWdlclwiLGBDcmVhdGluZyBuZXcgdGV4dHVyZSBvZiBzaXplICR7by53aWR0aH14JHtvLmhlaWdodH1gKTtsZXQgcD10aGlzLmdsQ29udGV4dC5hbGxvY2F0ZVRleHR1cmUoaSx1LHMsdGhpcy50b1RleHR1cmVEYXRhKHQsZSkpO3JldHVybiB0aGlzLmNvbmZpZy5yZXVzZVRleHR1cmVzJiYoZi5wdXNoKHApLHRoaXMudGV4dHVyZUxvb2t1cC5zZXQocCxsKSkscH1yZWFkVGV4dHVyZSh0LG8sZSl7cmV0dXJuIGV8fChlPTEpLHRoaXMucHJvZmlsZXIuZXZlbnQoXCJiYWNrZW5kXCIsXCJUZXh0dXJlTWFuYWdlci5yZWFkVGV4dHVyZVwiLCgpPT57bGV0IHI9dC5zaGFwZS5yZWR1Y2UoKHMsaSk9PnMqaSkqZSxuPXRoaXMuZ2xDb250ZXh0LnJlYWRUZXh0dXJlKHQudGV4dHVyZSx0LndpZHRoLHQuaGVpZ2h0LHIsdGhpcy50b0VuY29kZXJUeXBlKG8pLGUpO3JldHVybiB0aGlzLnRvVGVuc29yRGF0YShvLG4pfSl9YXN5bmMgcmVhZFRleHR1cmVBc3luYyh0LG8sZSl7bGV0IHI9dC50ZW5zb3IuZGF0YUlkO2lmKGV8fChlPTEpLHRoaXMucGVuZGluZ1JlYWQuaGFzKHIpKXtsZXQgbj10aGlzLnBlbmRpbmdSZWFkLmdldChyKTtyZXR1cm4gbmV3IFByb21pc2Uocz0+bj8ucHVzaChzKSl9cmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoXCJiYWNrZW5kXCIsXCJUZXh0dXJlTWFuYWdlci5yZWFkVGV4dHVyZUFzeW5jXCIsYXN5bmMoKT0+e3RoaXMucGVuZGluZ1JlYWQuc2V0KHIsW10pO2xldCBuPXQuc2hhcGUucmVkdWNlKChsLGYpPT5sKmYpKmU7YXdhaXQgdGhpcy5nbENvbnRleHQuY3JlYXRlQW5kV2FpdEZvckZlbmNlKCk7bGV0IHM9dGhpcy5nbENvbnRleHQucmVhZFRleHR1cmUodC50ZXh0dXJlLHQud2lkdGgsdC5oZWlnaHQsbix0aGlzLnRvRW5jb2RlclR5cGUobyksZSksaT10aGlzLnRvVGVuc29yRGF0YShvLHMpLHU9dGhpcy5wZW5kaW5nUmVhZC5nZXQocik7cmV0dXJuIHRoaXMucGVuZGluZ1JlYWQuZGVsZXRlKHIpLHU/LmZvckVhY2gobD0+bChpKSksaX0pfXJlYWRVaW50OFRleHR1cmVBc0Zsb2F0KHQpe3JldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KFwiYmFja2VuZFwiLFwiVGV4dHVyZU1hbmFnZXIucmVhZFVpbnQ4VGV4dHVyZUFzRmxvYXRcIiwoKT0+e2xldCBvPXQuc2hhcGUucmVkdWNlKChyLG4pPT5yKm4pLGU9dGhpcy5nbENvbnRleHQucmVhZFRleHR1cmUodC50ZXh0dXJlLHQud2lkdGgsdC5oZWlnaHQsbyo0LFwiYnl0ZVwiLDQpO3JldHVybiBuZXcgRmxvYXQzMkFycmF5KGUuYnVmZmVyLGUuYnl0ZU9mZnNldCxvKX0pfXJlbGVhc2VUZXh0dXJlKHQsbyl7bGV0IGU7aWYodGhpcy5jb25maWcucmV1c2VUZXh0dXJlcyYmKGU9dGhpcy50ZXh0dXJlTG9va3VwLmdldCh0LnRleHR1cmUpLGUpKXtvJiZ0aGlzLnRleHR1cmVMb29rdXAuZGVsZXRlKGUpO2xldCByPXRoaXMuaW5Vc2VUZXh0dXJlcy5nZXQoZSk7aWYocil7bGV0IG49ci5pbmRleE9mKHQudGV4dHVyZSk7aWYobiE9PS0xKXtyLnNwbGljZShuLDEpO2xldCBzPXRoaXMuaWRsZVRleHR1cmVzLmdldChlKTtzfHwocz1bXSx0aGlzLmlkbGVUZXh0dXJlcy5zZXQoZSxzKSkscy5wdXNoKHQudGV4dHVyZSl9fX0oIWV8fG8pJiYoY2UudmVyYm9zZShcIlRleHR1cmVNYW5hZ2VyXCIsYERlbGV0aW5nIHRleHR1cmUgb2Ygc2l6ZSAke3Qud2lkdGh9eCR7dC5oZWlnaHR9YCksdGhpcy5nbENvbnRleHQuZGVsZXRlVGV4dHVyZSh0LnRleHR1cmUpKX10b1RlbnNvckRhdGEodCxvKXtzd2l0Y2godCl7Y2FzZVwiaW50MTZcIjpyZXR1cm4gbyBpbnN0YW5jZW9mIEludDE2QXJyYXk/bzpJbnQxNkFycmF5LmZyb20obyk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gbyBpbnN0YW5jZW9mIEludDMyQXJyYXk/bzpJbnQzMkFycmF5LmZyb20obyk7Y2FzZVwiaW50OFwiOnJldHVybiBvIGluc3RhbmNlb2YgSW50OEFycmF5P286SW50OEFycmF5LmZyb20obyk7Y2FzZVwidWludDE2XCI6cmV0dXJuIG8gaW5zdGFuY2VvZiBVaW50MTZBcnJheT9vOlVpbnQxNkFycmF5LmZyb20obyk7Y2FzZVwidWludDMyXCI6cmV0dXJuIG8gaW5zdGFuY2VvZiBVaW50MzJBcnJheT9vOlVpbnQzMkFycmF5LmZyb20obyk7Y2FzZVwidWludDhcIjpjYXNlXCJib29sXCI6cmV0dXJuIG8gaW5zdGFuY2VvZiBVaW50OEFycmF5P286VWludDhBcnJheS5mcm9tKG8pO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gbyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheT9vOkZsb2F0MzJBcnJheS5mcm9tKG8pO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gbyBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheT9vOkZsb2F0NjRBcnJheS5mcm9tKG8pO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBUZW5zb3JEYXRhIHR5cGUgJHt0fSBpcyBub3Qgc3VwcG9ydGVkYCl9fXRvVGV4dHVyZURhdGEodCxvKXtpZihvKXJldHVybiBvIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5P286bmV3IEZsb2F0MzJBcnJheShvKX10b0VuY29kZXJUeXBlKHQpe3JldHVyblwiZmxvYXRcIn1jbGVhckFjdGl2ZVRleHR1cmVzKCl7dGhpcy5nbENvbnRleHQuY2xlYXJBY3RpdmVUZXh0dXJlcygpfX19KTt2YXIgeG8sY3A9RSgoKT0+e1widXNlIHN0cmljdFwiO2F0KCk7SXMoKTtybCgpO0pjKCk7bHAoKTtIaSgpO2ZwKCk7eG89Y2xhc3N7Y29uc3RydWN0b3IodCxvKXt0aGlzLmJhY2tlbmQ9dDt0aGlzLmNvbnRleHQ9bzt0aGlzLmxheW91dFN0cmF0ZWd5PW5ldyBmbyh0LmdsQ29udGV4dC5tYXhUZXh0dXJlU2l6ZSksdGhpcy5wcm9ncmFtTWFuYWdlcj1uZXcgeW8odGhpcy5jb250ZXh0LnByb2ZpbGVyLHQuZ2xDb250ZXh0LHRoaXMubGF5b3V0U3RyYXRlZ3kpLHRoaXMudGV4dHVyZU1hbmFnZXI9bmV3IFRvKHQuZ2xDb250ZXh0LHRoaXMubGF5b3V0U3RyYXRlZ3ksdGhpcy5jb250ZXh0LnByb2ZpbGVyLHtyZXVzZVRleHR1cmVzOnQudGV4dHVyZUNhY2hlTW9kZT09PVwiZnVsbFwifSksdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXAsdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnBhY2s9dC5wYWNrLHRoaXMucGFjazJ1bnBhY2tNYXA9bmV3IE1hcCx0aGlzLnVucGFjazJwYWNrTWFwPW5ldyBNYXB9Y3JlYXRlSW5mZXJlbmNlSGFuZGxlcigpe3JldHVybiBuZXcgUW4odGhpcyl9b25HcmFwaEluaXRpYWxpemVkKHQpe2xldCBvPXQuZ2V0VmFsdWVzKCkuZmlsdGVyKGU9PmUuZnJvbT09PS0xJiZlLnRlbnNvcikubWFwKGU9PmUudGVuc29yLmRhdGFJZCk7dGhpcy5pbml0aWFsaXplcnM9bmV3IFNldChvKX1pc0luaXRpYWxpemVyKHQpe3JldHVybiB0aGlzLmluaXRpYWxpemVycz90aGlzLmluaXRpYWxpemVycy5oYXModCk6ITF9YWRkSW5pdGlhbGl6ZXIodCl7dGhpcy5pbml0aWFsaXplcnMuYWRkKHQpfWdldFRleHR1cmVEYXRhKHQsbyl7cmV0dXJuIG8/dGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldCh0KTp0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQodCl9c2V0VGV4dHVyZURhdGEodCxvLGU9ITEpe2NlLnZlcmJvc2UoXCJXZWJHTFNlc3Npb25IYW5kbGVyXCIsXCJTdG9yaW5nIFRleHR1cmUgZGF0YSBpbiBjYWNoZVwiKSxlP3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5zZXQodCxvKTp0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZS5zZXQodCxvKX1kaXNwb3NlKCl7dGhpcy5wcm9ncmFtTWFuYWdlci5kaXNwb3NlKCksdGhpcy50ZXh0dXJlTWFuYWdlci5jbGVhckFjdGl2ZVRleHR1cmVzKCksdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2godD0+dGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZSh0LCEwKSksdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXAsdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCh0PT50aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHQsITApKSx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfXJlc29sdmUodCxvLGUpe2xldCByPU9zKHQsbyxLYyk7cmV0dXJue2ltcGw6ci5vcEltcGwsY29udGV4dDpyLm9wSW5pdD9yLm9wSW5pdCh0LGUpOnR9fX19KTtmdW5jdGlvbiBYYihhKXtsZXQgdD0wO2Zvcig7dDxhLmxlbmd0aCYmYVt0XSgpOysrdCk7cmV0dXJuIHQtMX12YXIgYm4scHA9RSgoKT0+e1widXNlIHN0cmljdFwiO1R0KCk7Y24oKTtjbigpO2t0KCk7Ym49Y2xhc3N7Y29uc3RydWN0b3IodCxvKXt0aGlzLmZyYW1lQnVmZmVyQm91bmQ9ITE7dGhpcy5pdGVtc1RvUG9sbD1bXTt0aGlzLmdsPXQsdGhpcy52ZXJzaW9uPW8sdGhpcy5nZXRFeHRlbnNpb25zKCksdGhpcy52ZXJ0ZXhidWZmZXI9dGhpcy5jcmVhdGVWZXJ0ZXhidWZmZXIoKSx0aGlzLmZyYW1lYnVmZmVyPXRoaXMuY3JlYXRlRnJhbWVidWZmZXIoKSx0aGlzLnF1ZXJ5Vml0YWxQYXJhbWV0ZXJzKCl9YWxsb2NhdGVUZXh0dXJlKHQsbyxlLHIpe2xldCBuPXRoaXMuZ2wscz1uLmNyZWF0ZVRleHR1cmUoKTtuLmJpbmRUZXh0dXJlKG4uVEVYVFVSRV8yRCxzKSxuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELG4uVEVYVFVSRV9NSU5fRklMVEVSLG4uTkVBUkVTVCksbi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCxuLlRFWFRVUkVfTUFHX0ZJTFRFUixuLk5FQVJFU1QpLG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsbi5URVhUVVJFX1dSQVBfUyxuLkNMQU1QX1RPX0VER0UpLG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsbi5URVhUVVJFX1dSQVBfVCxuLkNMQU1QX1RPX0VER0UpO2xldCBpPXI/ZS5lbmNvZGUocix0Km8pOm51bGw7cmV0dXJuIG4udGV4SW1hZ2UyRChuLlRFWFRVUkVfMkQsMCxlLmludGVybmFsRm9ybWF0LHQsbywwLGUuZm9ybWF0LGUudGV4dHVyZVR5cGUsaSksdGhpcy5jaGVja0Vycm9yKCksc311cGRhdGVUZXh0dXJlKHQsbyxlLHIsbil7bGV0IHM9dGhpcy5nbDtzLmJpbmRUZXh0dXJlKHMuVEVYVFVSRV8yRCx0KTtsZXQgaT1yLmVuY29kZShuLG8qZSk7cy50ZXhTdWJJbWFnZTJEKHMuVEVYVFVSRV8yRCwwLDAsMCxvLGUsci5mb3JtYXQsci50ZXh0dXJlVHlwZSxpKSx0aGlzLmNoZWNrRXJyb3IoKX1hdHRhY2hGcmFtZWJ1ZmZlcih0LG8sZSl7bGV0IHI9dGhpcy5nbDtyLmJpbmRUZXh0dXJlKHIuVEVYVFVSRV8yRCx0KSxyLmJpbmRGcmFtZWJ1ZmZlcihyLkZSQU1FQlVGRkVSLHRoaXMuZnJhbWVidWZmZXIpLHIuZnJhbWVidWZmZXJUZXh0dXJlMkQoci5GUkFNRUJVRkZFUixyLkNPTE9SX0FUVEFDSE1FTlQwLHIuVEVYVFVSRV8yRCx0LDApLHRoaXMuY2hlY2tFcnJvcigpLHIudmlld3BvcnQoMCwwLG8sZSksci5zY2lzc29yKDAsMCxvLGUpfXJlYWRUZXh0dXJlKHQsbyxlLHIsbixzKXtsZXQgaT10aGlzLmdsO3N8fChzPTEpLHRoaXMuZnJhbWVCdWZmZXJCb3VuZHx8dGhpcy5hdHRhY2hGcmFtZWJ1ZmZlcih0LG8sZSk7bGV0IHU9dGhpcy5nZXRFbmNvZGVyKG4scyksbD11LmFsbG9jYXRlKG8qZSk7cmV0dXJuIGkuYmluZFRleHR1cmUoaS5URVhUVVJFXzJELHQpLGkuZnJhbWVidWZmZXJUZXh0dXJlMkQoaS5GUkFNRUJVRkZFUixpLkNPTE9SX0FUVEFDSE1FTlQwLGkuVEVYVFVSRV8yRCx0LDApLGkucmVhZFBpeGVscygwLDAsbyxlLGkuUkdCQSx1LnRleHR1cmVUeXBlLGwpLHRoaXMuY2hlY2tFcnJvcigpLHUuZGVjb2RlKGwscil9aXNGcmFtZWJ1ZmZlclJlYWR5KCl7cmV0dXJuITB9Z2V0QWN0aXZlVGV4dHVyZSgpe2xldCB0PXRoaXMuZ2w7cmV0dXJuYFRFWFRVUkUke3QuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuQUNUSVZFX1RFWFRVUkUpLXQuVEVYVFVSRTB9YH1nZXRUZXh0dXJlQmluZGluZygpe3JldHVybiB0aGlzLmdsLmdldFBhcmFtZXRlcih0aGlzLmdsLlRFWFRVUkVfQklORElOR18yRCl9Z2V0RnJhbWVidWZmZXJCaW5kaW5nKCl7cmV0dXJuIHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuRlJBTUVCVUZGRVJfQklORElORyl9c2V0VmVydGV4QXR0cmlidXRlcyh0LG8pe2xldCBlPXRoaXMuZ2w7ZS52ZXJ0ZXhBdHRyaWJQb2ludGVyKHQsMyxlLkZMT0FULCExLDIwLDApLGUuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodCksbyE9PS0xJiYoZS52ZXJ0ZXhBdHRyaWJQb2ludGVyKG8sMixlLkZMT0FULCExLDIwLDEyKSxlLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KG8pKSx0aGlzLmNoZWNrRXJyb3IoKX1jcmVhdGVQcm9ncmFtKHQsbyl7bGV0IGU9dGhpcy5nbCxyPWUuY3JlYXRlUHJvZ3JhbSgpO3JldHVybiBlLmF0dGFjaFNoYWRlcihyLHQpLGUuYXR0YWNoU2hhZGVyKHIsbyksZS5saW5rUHJvZ3JhbShyKSxyfWNvbXBpbGVTaGFkZXIodCxvKXtsZXQgZT10aGlzLmdsLHI9ZS5jcmVhdGVTaGFkZXIobyk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKGBjcmVhdGVTaGFkZXIoKSByZXR1cm5lZCBudWxsIHdpdGggdHlwZSAke299YCk7aWYoZS5zaGFkZXJTb3VyY2Uocix0KSxlLmNvbXBpbGVTaGFkZXIociksZS5nZXRTaGFkZXJQYXJhbWV0ZXIocixlLkNPTVBJTEVfU1RBVFVTKT09PSExKXRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNvbXBpbGUgc2hhZGVyOiAke2UuZ2V0U2hhZGVySW5mb0xvZyhyKX1cblNoYWRlciBzb3VyY2U6XG4ke3R9YCk7cmV0dXJuIHJ9ZGVsZXRlU2hhZGVyKHQpe3RoaXMuZ2wuZGVsZXRlU2hhZGVyKHQpfWJpbmRUZXh0dXJlVG9Vbmlmb3JtKHQsbyxlKXtsZXQgcj10aGlzLmdsO3IuYWN0aXZlVGV4dHVyZShyLlRFWFRVUkUwK28pLHRoaXMuY2hlY2tFcnJvcigpLHIuYmluZFRleHR1cmUoci5URVhUVVJFXzJELHQpLHRoaXMuY2hlY2tFcnJvcigpLHIudW5pZm9ybTFpKGUsbyksdGhpcy5jaGVja0Vycm9yKCl9ZHJhdygpe3RoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLlRSSUFOR0xFX1NUUklQLDAsNCksdGhpcy5jaGVja0Vycm9yKCl9Y2hlY2tFcnJvcigpe2lmKFouZGVidWcpe2xldCB0PXRoaXMuZ2wsbz10LmdldEVycm9yKCksZT1cIlwiO3N3aXRjaChvKXtjYXNlIHQuTk9fRVJST1I6cmV0dXJuO2Nhc2UgdC5JTlZBTElEX0VOVU06ZT1cIklOVkFMSURfRU5VTVwiO2JyZWFrO2Nhc2UgdC5JTlZBTElEX1ZBTFVFOmU9XCJJTlZBTElEX1ZBTFVFXCI7YnJlYWs7Y2FzZSB0LklOVkFMSURfT1BFUkFUSU9OOmU9XCJJTlZBTElEX09QRVJBVElPTlwiO2JyZWFrO2Nhc2UgdC5JTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTjplPVwiSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT05cIjticmVhaztjYXNlIHQuT1VUX09GX01FTU9SWTplPVwiT1VUX09GX01FTU9SWVwiO2JyZWFrO2Nhc2UgdC5DT05URVhUX0xPU1RfV0VCR0w6ZT1cIkNPTlRFWFRfTE9TVF9XRUJHTFwiO2JyZWFrO2RlZmF1bHQ6ZT1gVW5rbm93biBXZWJHTCBFcnJvcjogJHtvLnRvU3RyaW5nKDE2KX1gfXRocm93IG5ldyBFcnJvcihlKX19ZGVsZXRlVGV4dHVyZSh0KXt0aGlzLmdsLmRlbGV0ZVRleHR1cmUodCl9ZGVsZXRlUHJvZ3JhbSh0KXt0aGlzLmdsLmRlbGV0ZVByb2dyYW0odCl9Z2V0RW5jb2Rlcih0LG8sZT0wKXtpZih0aGlzLnZlcnNpb249PT0yKXJldHVybiBuZXcgSm4odGhpcy5nbCxvKTtzd2l0Y2godCl7Y2FzZVwiZmxvYXRcIjpyZXR1cm4gZT09PTF8fHRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkP25ldyBmbih0aGlzLmdsLG8pOm5ldyBmbih0aGlzLmdsLG8sdGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uLkhBTEZfRkxPQVRfT0VTKTtjYXNlXCJpbnRcIjp0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7Y2FzZVwiYnl0ZVwiOnJldHVybiBuZXcgWm4odGhpcy5nbCxvKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhVHlwZTogJHt0fWApfX1jbGVhckFjdGl2ZVRleHR1cmVzKCl7bGV0IHQ9dGhpcy5nbDtmb3IobGV0IG89MDtvPHRoaXMubWF4VGV4dHVyZUltYWdlVW5pdHM7KytvKXQuYWN0aXZlVGV4dHVyZSh0LlRFWFRVUkUwK28pLHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG51bGwpfWRpc3Bvc2UoKXtpZih0aGlzLmRpc3Bvc2VkKXJldHVybjtsZXQgdD10aGlzLmdsO3QuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsbnVsbCksdC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLmZyYW1lYnVmZmVyKSx0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIsbnVsbCksdC5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhidWZmZXIpLHQuYmluZEJ1ZmZlcih0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLG51bGwpLHQuZmluaXNoKCksdGhpcy5kaXNwb3NlZD0hMH1jcmVhdGVEZWZhdWx0R2VvbWV0cnkoKXtyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbLTEsMSwwLDAsMSwtMSwtMSwwLDAsMCwxLDEsMCwxLDEsMSwtMSwwLDEsMF0pfWNyZWF0ZVZlcnRleGJ1ZmZlcigpe2xldCB0PXRoaXMuZ2wsbz10LmNyZWF0ZUJ1ZmZlcigpO2lmKCFvKXRocm93IG5ldyBFcnJvcihcImNyZWF0ZUJ1ZmZlcigpIHJldHVybmVkIG51bGxcIik7bGV0IGU9dGhpcy5jcmVhdGVEZWZhdWx0R2VvbWV0cnkoKTtyZXR1cm4gdC5iaW5kQnVmZmVyKHQuQVJSQVlfQlVGRkVSLG8pLHQuYnVmZmVyRGF0YSh0LkFSUkFZX0JVRkZFUixlLHQuU1RBVElDX0RSQVcpLHRoaXMuY2hlY2tFcnJvcigpLG99Y3JlYXRlRnJhbWVidWZmZXIoKXtsZXQgdD10aGlzLmdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiY3JlYXRlRnJhbWVidWZmZXIgcmV0dXJuZWQgbnVsbFwiKTtyZXR1cm4gdH1xdWVyeVZpdGFsUGFyYW1ldGVycygpe2xldCB0PXRoaXMuZ2w7aWYodGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyPXRoaXMuY2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpLHRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkPXRoaXMuY2hlY2tSZW5kZXJGbG9hdDMyKCksdGhpcy5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZD10aGlzLmNoZWNrRmxvYXQzMkRvd25sb2FkKCksdGhpcy52ZXJzaW9uPT09MSYmIXRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiYmIXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkKXRocm93IG5ldyBFcnJvcihcImJvdGggZmxvYXQzMiBhbmQgZmxvYXQxNiBUZXh0dXJlVHlwZSBhcmUgbm90IHN1cHBvcnRlZFwiKTt0aGlzLmlzQmxlbmRTdXBwb3J0ZWQ9IXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkfHx0aGlzLmNoZWNrRmxvYXQzMkJsZW5kKCksdGhpcy5tYXhUZXh0dXJlU2l6ZT10LmdldFBhcmFtZXRlcih0Lk1BWF9URVhUVVJFX1NJWkUpLHRoaXMubWF4VGV4dHVyZUltYWdlVW5pdHM9dC5nZXRQYXJhbWV0ZXIodC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksdGhpcy52ZXJzaW9ufWdldEV4dGVuc2lvbnMoKXt0aGlzLnZlcnNpb249PT0yPyh0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpLHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKSk6KHRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIiksdGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKSl9Y2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpe2xldCB0PXRoaXMuZ2wsbz10LmNyZWF0ZVRleHR1cmUoKTt0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxvKTtsZXQgZT10aGlzLnZlcnNpb249PT0yP3QuUkdCQTMyRjp0LlJHQkE7dC50ZXhJbWFnZTJEKHQuVEVYVFVSRV8yRCwwLGUsMSwxLDAsdC5SR0JBLHQuRkxPQVQsbnVsbCk7bGV0IHI9dC5jcmVhdGVGcmFtZWJ1ZmZlcigpO3QuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsciksdC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0LkZSQU1FQlVGRkVSLHQuQ09MT1JfQVRUQUNITUVOVDAsdC5URVhUVVJFXzJELG8sMCk7bGV0IG49dC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKHQuRlJBTUVCVUZGRVIpPT09dC5GUkFNRUJVRkZFUl9DT01QTEVURTtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCksdC5iaW5kRnJhbWVidWZmZXIodC5GUkFNRUJVRkZFUixudWxsKSx0LmRlbGV0ZVRleHR1cmUobyksdC5kZWxldGVGcmFtZWJ1ZmZlcihyKSxufWNoZWNrUmVuZGVyRmxvYXQzMigpe2lmKHRoaXMudmVyc2lvbj09PTIpe2lmKCF0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb24pcmV0dXJuITF9ZWxzZSBpZighdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb24pcmV0dXJuITE7cmV0dXJuIHRoaXMuaXNGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcn1jaGVja0Zsb2F0MzJEb3dubG9hZCgpe2lmKHRoaXMudmVyc2lvbj09PTIpe2lmKCF0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb24pcmV0dXJuITF9ZWxzZSBpZighdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb258fCF0aGlzLmdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSlyZXR1cm4hMTtyZXR1cm4gdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyfWNoZWNrRmxvYXQzMkJsZW5kKCl7bGV0IHQ9dGhpcy5nbCxvLGUscixuLHM7dHJ5e289dC5jcmVhdGVUZXh0dXJlKCksZT10LmNyZWF0ZUZyYW1lYnVmZmVyKCksdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbyk7bGV0IGk9dGhpcy52ZXJzaW9uPT09Mj90LlJHQkEzMkY6dC5SR0JBO3JldHVybiB0LnRleEltYWdlMkQodC5URVhUVVJFXzJELDAsaSwxLDEsMCx0LlJHQkEsdC5GTE9BVCxudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLGUpLHQuZnJhbWVidWZmZXJUZXh0dXJlMkQodC5GUkFNRUJVRkZFUix0LkNPTE9SX0FUVEFDSE1FTlQwLHQuVEVYVFVSRV8yRCxvLDApLHQuZW5hYmxlKHQuQkxFTkQpLHI9dC5jcmVhdGVTaGFkZXIodC5WRVJURVhfU0hBREVSKSwhcnx8KHQuc2hhZGVyU291cmNlKHIsXCJ2b2lkIG1haW4oKXt9XCIpLHQuY29tcGlsZVNoYWRlcihyKSxuPXQuY3JlYXRlU2hhZGVyKHQuRlJBR01FTlRfU0hBREVSKSwhbil8fCh0LnNoYWRlclNvdXJjZShuLFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O3ZvaWQgbWFpbigpe2dsX0ZyYWdDb2xvcj12ZWM0KDAuNSk7fVwiKSx0LmNvbXBpbGVTaGFkZXIobikscz10LmNyZWF0ZVByb2dyYW0oKSwhcyk/ITE6KHQuYXR0YWNoU2hhZGVyKHMsciksdC5hdHRhY2hTaGFkZXIocyxuKSx0LmxpbmtQcm9ncmFtKHMpLHQudXNlUHJvZ3JhbShzKSx0LmRyYXdBcnJheXModC5QT0lOVFMsMCwxKSx0LmdldEVycm9yKCk9PT10Lk5PX0VSUk9SKX1maW5hbGx5e3QuZGlzYWJsZSh0LkJMRU5EKSxzJiZ0LmRlbGV0ZVByb2dyYW0ocyksciYmdC5kZWxldGVTaGFkZXIociksbiYmdC5kZWxldGVTaGFkZXIobiksZSYmKHQuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsbnVsbCksdC5kZWxldGVGcmFtZWJ1ZmZlcihlKSksbyYmKHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG51bGwpLHQuZGVsZXRlVGV4dHVyZShvKSl9fWJlZ2luVGltZXIoKXtpZih0aGlzLnZlcnNpb249PT0yJiZ0aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbil7bGV0IHQ9dGhpcy5nbCxvPXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uLGU9dC5jcmVhdGVRdWVyeSgpO3JldHVybiB0LmJlZ2luUXVlcnkoby5USU1FX0VMQVBTRURfRVhULGUpLGV9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTDEgcHJvZmlsaW5nIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLlwiKX1lbmRUaW1lcigpe2lmKHRoaXMudmVyc2lvbj09PTImJnRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKXtsZXQgdD10aGlzLmdsLG89dGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb247dC5lbmRRdWVyeShvLlRJTUVfRUxBUFNFRF9FWFQpO3JldHVybn1lbHNlIHRocm93IG5ldyBFcnJvcihcIldlYkdMMSBwcm9maWxpbmcgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIil9aXNUaW1lclJlc3VsdEF2YWlsYWJsZSh0KXtsZXQgbz0hMSxlPSExO2lmKHRoaXMudmVyc2lvbj09PTImJnRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKXtsZXQgcj10aGlzLmdsLG49dGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb247bz1yLmdldFF1ZXJ5UGFyYW1ldGVyKHQsci5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFKSxlPXIuZ2V0UGFyYW1ldGVyKG4uR1BVX0RJU0pPSU5UX0VYVCl9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTDEgcHJvZmlsaW5nIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiBvJiYhZX1nZXRUaW1lclJlc3VsdCh0KXtsZXQgbz0wO2lmKHRoaXMudmVyc2lvbj09PTIpe2xldCBlPXRoaXMuZ2w7bz1lLmdldFF1ZXJ5UGFyYW1ldGVyKHQsZS5RVUVSWV9SRVNVTFQpLGUuZGVsZXRlUXVlcnkodCl9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTDEgcHJvZmlsaW5nIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiBvLzFlNn1hc3luYyB3YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKHQpe3JldHVybiBhd2FpdCBnaSgoKT0+dGhpcy5pc1RpbWVyUmVzdWx0QXZhaWxhYmxlKHQpKSx0aGlzLmdldFRpbWVyUmVzdWx0KHQpfWFzeW5jIGNyZWF0ZUFuZFdhaXRGb3JGZW5jZSgpe2xldCB0PXRoaXMuY3JlYXRlRmVuY2UodGhpcy5nbCk7cmV0dXJuIHRoaXMucG9sbEZlbmNlKHQpfWNyZWF0ZUZlbmNlKHQpe2xldCBvLGU9dCxyPWUuZmVuY2VTeW5jKGUuU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsMCk7cmV0dXJuIHQuZmx1c2goKSxyPT09bnVsbD9vPSgpPT4hMDpvPSgpPT57bGV0IG49ZS5jbGllbnRXYWl0U3luYyhyLDAsMCk7cmV0dXJuIG49PT1lLkFMUkVBRFlfU0lHTkFMRUR8fG49PT1lLkNPTkRJVElPTl9TQVRJU0ZJRUR9LHtxdWVyeTpyLGlzRmVuY2VQYXNzZWQ6b319YXN5bmMgcG9sbEZlbmNlKHQpe3JldHVybiBuZXcgUHJvbWlzZShvPT57dGhpcy5hZGRJdGVtVG9Qb2xsKCgpPT50LmlzRmVuY2VQYXNzZWQoKSwoKT0+bygpKX0pfXBvbGxJdGVtcygpe2xldCB0PVhiKHRoaXMuaXRlbXNUb1BvbGwubWFwKG89Pm8uaXNEb25lRm4pKTtmb3IobGV0IG89MDtvPD10Oysrbyl7bGV0e3Jlc29sdmVGbjplfT10aGlzLml0ZW1zVG9Qb2xsW29dO2UoKX10aGlzLml0ZW1zVG9Qb2xsPXRoaXMuaXRlbXNUb1BvbGwuc2xpY2UodCsxKX1hc3luYyBhZGRJdGVtVG9Qb2xsKHQsbyl7dGhpcy5pdGVtc1RvUG9sbC5wdXNoKHtpc0RvbmVGbjp0LHJlc29sdmVGbjpvfSksISh0aGlzLml0ZW1zVG9Qb2xsLmxlbmd0aD4xKSYmYXdhaXQgZ2koKCk9Pih0aGlzLnBvbGxJdGVtcygpLHRoaXMuaXRlbXNUb1BvbGwubGVuZ3RoPT09MCkpfX19KTtmdW5jdGlvbiBqaShhKXtsZXQgdDtpZigoIWF8fGE9PT1cIndlYmdsMlwiKSYmXCJ3ZWJnbDJcImluIHpyP3Q9enIud2ViZ2wyOighYXx8YT09PVwid2ViZ2xcIikmJlwid2ViZ2xcImluIHpyJiYodD16ci53ZWJnbCksIXQpdHJ5e2xldCBlPUpiKCk7dD1kcChlLGEpfWNhdGNoe2xldCByPUtiKCk7dD1kcChyLGEpfWE9YXx8dC52ZXJzaW9uPT09MT9cIndlYmdsXCI6XCJ3ZWJnbDJcIjtsZXQgbz10LmdsO3JldHVybiB6clthXT10LG8uaXNDb250ZXh0TG9zdCgpPyhkZWxldGUgenJbYV0samkoYSkpOihvLmRpc2FibGUoby5ERVBUSF9URVNUKSxvLmRpc2FibGUoby5TVEVOQ0lMX1RFU1QpLG8uZGlzYWJsZShvLkJMRU5EKSxvLmRpc2FibGUoby5ESVRIRVIpLG8uZGlzYWJsZShvLlBPTFlHT05fT0ZGU0VUX0ZJTEwpLG8uZGlzYWJsZShvLlNBTVBMRV9DT1ZFUkFHRSksby5lbmFibGUoby5TQ0lTU09SX1RFU1QpLG8uZW5hYmxlKG8uQ1VMTF9GQUNFKSxvLmN1bGxGYWNlKG8uQkFDSyksdCl9ZnVuY3Rpb24gZHAoYSx0KXtsZXQgbz17YWxwaGE6ITEsZGVwdGg6ITEsYW50aWFsaWFzOiExLHN0ZW5jaWw6ITEscHJlc2VydmVEcmF3aW5nQnVmZmVyOiExLHByZW11bHRpcGxpZWRBbHBoYTohMSxmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiExfSxlLHI9bztpZigoIXR8fHQ9PT1cIndlYmdsMlwiKSYmKGU9YS5nZXRDb250ZXh0KFwid2ViZ2wyXCIsciksZSkpdHJ5e3JldHVybiBuZXcgYm4oZSwyKX1jYXRjaChuKXtjZS53YXJuaW5nKFwiR2xDb250ZXh0RmFjdG9yeVwiLGBmYWlsZWQgdG8gY3JlYXRlIFdlYkdMQ29udGV4dCB1c2luZyBjb250ZXh0SWQgJ3dlYmdsMicuIEVycm9yOiAke259YCl9aWYoKCF0fHx0PT09XCJ3ZWJnbFwiKSYmKGU9YS5nZXRDb250ZXh0KFwid2ViZ2xcIixyKXx8YS5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsciksZSkpdHJ5e3JldHVybiBuZXcgYm4oZSwxKX1jYXRjaChuKXtjZS53YXJuaW5nKFwiR2xDb250ZXh0RmFjdG9yeVwiLGBmYWlsZWQgdG8gY3JlYXRlIFdlYkdMQ29udGV4dCB1c2luZyBjb250ZXh0SWQgJ3dlYmdsJyBvciAnZXhwZXJpbWVudGFsLXdlYmdsJy4gRXJyb3I6ICR7bn1gKX10aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBpcyBub3Qgc3VwcG9ydGVkXCIpfWZ1bmN0aW9uIEtiKCl7aWYodHlwZW9mIGRvY3VtZW50PlwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJmYWlsZWQgdG8gY3JlYXRlIGNhbnZhczogZG9jdW1lbnQgaXMgbm90IHN1cHBvcnRlZFwiKTtsZXQgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO3JldHVybiBhLndpZHRoPTEsYS5oZWlnaHQ9MSxhfWZ1bmN0aW9uIEpiKCl7aWYodHlwZW9mIE9mZnNjcmVlbkNhbnZhcz5cInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiZmFpbGVkIHRvIGNyZWF0ZSBvZmZzY3JlZW4gY2FudmFzOiBPZmZzY3JlZW5DYW52YXMgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpfXZhciB6cixocD1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YXQoKTtwcCgpO3pyPXt9fSk7dmFyIHdvLG1wPUUoKCk9PntcInVzZSBzdHJpY3RcIjtUdCgpO2F0KCk7Y3AoKTtocCgpO3dvPWNsYXNze2dldCBjb250ZXh0SWQoKXtyZXR1cm4gWi53ZWJnbC5jb250ZXh0SWR9c2V0IGNvbnRleHRJZCh0KXtaLndlYmdsLmNvbnRleHRJZD10fWdldCBtYXRtdWxNYXhCYXRjaFNpemUoKXtyZXR1cm4gWi53ZWJnbC5tYXRtdWxNYXhCYXRjaFNpemV9c2V0IG1hdG11bE1heEJhdGNoU2l6ZSh0KXtaLndlYmdsLm1hdG11bE1heEJhdGNoU2l6ZT10fWdldCB0ZXh0dXJlQ2FjaGVNb2RlKCl7cmV0dXJuIFoud2ViZ2wudGV4dHVyZUNhY2hlTW9kZX1zZXQgdGV4dHVyZUNhY2hlTW9kZSh0KXtaLndlYmdsLnRleHR1cmVDYWNoZU1vZGU9dH1nZXQgcGFjaygpe3JldHVybiBaLndlYmdsLnBhY2t9c2V0IHBhY2sodCl7Wi53ZWJnbC5wYWNrPXR9Z2V0IGFzeW5jKCl7cmV0dXJuIFoud2ViZ2wuYXN5bmN9c2V0IGFzeW5jKHQpe1oud2ViZ2wuYXN5bmM9dH1pbml0aWFsaXplKCl7dHJ5e3JldHVybiB0aGlzLmdsQ29udGV4dD1qaSh0aGlzLmNvbnRleHRJZCksdHlwZW9mIHRoaXMubWF0bXVsTWF4QmF0Y2hTaXplIT1cIm51bWJlclwiJiYodGhpcy5tYXRtdWxNYXhCYXRjaFNpemU9MTYpLHR5cGVvZiB0aGlzLnRleHR1cmVDYWNoZU1vZGUhPVwic3RyaW5nXCImJih0aGlzLnRleHR1cmVDYWNoZU1vZGU9XCJmdWxsXCIpLHR5cGVvZiB0aGlzLnBhY2shPVwiYm9vbGVhblwiJiYodGhpcy5wYWNrPSExKSx0eXBlb2YgdGhpcy5hc3luYyE9XCJib29sZWFuXCImJih0aGlzLmFzeW5jPSExKSxjZS5zZXRXaXRoRW52KFopLFoud2ViZ2wuY29udGV4dHx8T2JqZWN0LmRlZmluZVByb3BlcnR5KFoud2ViZ2wsXCJjb250ZXh0XCIse3ZhbHVlOnRoaXMuZ2xDb250ZXh0LmdsfSksY2UudmVyYm9zZShcIldlYkdMQmFja2VuZFwiLGBDcmVhdGVkIFdlYkdMQ29udGV4dDogJHt0eXBlb2YgdGhpcy5nbENvbnRleHR9IHdpdGggbWF0bXVsTWF4QmF0Y2hTaXplOiAke3RoaXMubWF0bXVsTWF4QmF0Y2hTaXplfTsgdGV4dHVyZUNhY2hlTW9kZTogJHt0aGlzLnRleHR1cmVDYWNoZU1vZGV9OyBwYWNrOiAke3RoaXMucGFja307IGFzeW5jOiAke3RoaXMuYXN5bmN9LmApLCEwfWNhdGNoKHQpe3JldHVybiBjZS53YXJuaW5nKFwiV2ViR0xCYWNrZW5kXCIsYFVuYWJsZSB0byBpbml0aWFsaXplIFdlYkdMQmFja2VuZC4gJHt0fWApLCExfX1jcmVhdGVTZXNzaW9uSGFuZGxlcih0KXtyZXR1cm4gbmV3IHhvKHRoaXMsdCl9ZGlzcG9zZSgpe3RoaXMuZ2xDb250ZXh0LmRpc3Bvc2UoKX19fSk7YXN5bmMgZnVuY3Rpb24gWWkoYSl7aWYoYSl7bGV0IHQ9dHlwZW9mIGE9PVwic3RyaW5nXCI/W2FdOmE7Zm9yKGxldCBvIG9mIHQpe2xldCBlPWJwLmdldChvKTtpZihlKXJldHVybiBlO2xldCByPWF3YWl0IFFiKG8pO2lmKHIpcmV0dXJuIHJ9fWVsc2UgcmV0dXJuIFlpKFtcIndlYmdsXCJdKTt0aHJvdyBuZXcgRXJyb3IoXCJubyBhdmFpbGFibGUgYmFja2VuZCB0byB1c2VcIil9YXN5bmMgZnVuY3Rpb24gUWIoYSl7bGV0IHQ9WmI7aWYodHlwZW9mIHRbYV08XCJ1XCImJmVnKHRbYV0pKXtsZXQgbz10W2FdLGU9by5pbml0aWFsaXplKCk7aWYodHlwZW9mIGU9PVwib2JqZWN0XCImJlwidGhlblwiaW4gZSYmKGU9YXdhaXQgZSksZSlyZXR1cm4gYnAuc2V0KGEsbyksb319ZnVuY3Rpb24gZWcoYSl7bGV0IHQ9YTtyZXR1cm5cImluaXRpYWxpemVcImluIHQmJnR5cGVvZiB0LmluaXRpYWxpemU9PVwiZnVuY3Rpb25cIiYmXCJjcmVhdGVTZXNzaW9uSGFuZGxlclwiaW4gdCYmdHlwZW9mIHQuY3JlYXRlU2Vzc2lvbkhhbmRsZXI9PVwiZnVuY3Rpb25cIiYmXCJkaXNwb3NlXCJpbiB0JiZ0eXBlb2YgdC5kaXNwb3NlPT1cImZ1bmN0aW9uXCJ9dmFyIGJwLFpiLGdwPUUoKCk9PntcInVzZSBzdHJpY3RcIjttcCgpO2JwPW5ldyBNYXAsWmI9e3dlYmdsOm5ldyB3b319KTt2YXIgWGksdm8seXA9RSgoKT0+e1widXNlIHN0cmljdFwiO2F0KCk7WGk9Y2xhc3N7Y29uc3RydWN0b3IodCxvKXt0aGlzLm9wPXQ7dGhpcy5ub2RlPW99fSx2bz1jbGFzc3tjb25zdHJ1Y3Rvcih0LG8sZSl7dGhpcy5ncmFwaD10O3RoaXMucHJvZmlsZXI9ZTt0aGlzLmluaXRpYWxpemUobyl9aW5pdGlhbGl6ZSh0KXt0aGlzLnByb2ZpbGVyLmV2ZW50KFwic2Vzc2lvblwiLFwiRXhlY3V0aW9uUGxhbi5pbml0aWFsaXplXCIsKCk9PntsZXQgbz10aGlzLmdyYXBoLmdldE5vZGVzKCk7aWYoby5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2l6ZSBvZiBub2RlcyBhbmQgT1BzIGRvIG5vdCBtYXRjaC5cIik7dGhpcy5fb3BzPXQubWFwKChlLHIpPT5uZXcgWGkoZSxvW3JdKSksdGhpcy5yZXNldCgpLHRoaXMuX3N0YXJ0ZXI9W10sdGhpcy5fb3BzLmZvckVhY2goKGUscik9PntsZXQgbj0hMDtmb3IobGV0IHMgb2YgZS5ub2RlLmlucHV0cylpZighdGhpcy5fdmFsdWVzW3NdJiZ0aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpLmluZGV4T2Yocyk9PT0tMSl7bj0hMTticmVha31uJiZ0aGlzLl9zdGFydGVyLnB1c2gocil9KX0pfXJlc2V0KCl7dGhpcy5fdmFsdWVzPXRoaXMuZ3JhcGguZ2V0VmFsdWVzKCkubWFwKHQ9PnQudGVuc29yKX1hc3luYyBleGVjdXRlKHQsbyl7cmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoXCJzZXNzaW9uXCIsXCJFeGVjdXRpb25QbGFuLmV4ZWN1dGVcIixhc3luYygpPT57dGhpcy5yZXNldCgpO2xldCBlPXQuY3JlYXRlSW5mZXJlbmNlSGFuZGxlcigpLHI9dGhpcy5ncmFwaC5nZXRJbnB1dEluZGljZXMoKTtpZihvLmxlbmd0aCE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgbnVtYmVyIG9mIGlucHV0IHRlbnNvcnMgZG9uJ3QgbWF0Y2ggdGhlIG51bWJlciBvZiBpbnB1dHMgdG8gdGhlIG1vZGVsOiBhY3R1YWw6ICR7by5sZW5ndGh9IGV4cGVjdGVkOiAke3IubGVuZ3RofWApO28uZm9yRWFjaCgoZixwKT0+e2xldCBkPXJbcF07dGhpcy5fdmFsdWVzW2RdPWZ9KTtsZXQgbj10aGlzLl9zdGFydGVyLnNsaWNlKDApLHM9dGhpcy5ncmFwaC5nZXRWYWx1ZXMoKSxpPXRoaXMuZ3JhcGguZ2V0Tm9kZXMoKSx1PTA7Zm9yKDt1PG4ubGVuZ3RoOyl7bGV0IGY9blt1KytdLHA9dGhpcy5fb3BzW2ZdLGQ9cC5ub2RlLmlucHV0cy5tYXAoST0+dGhpcy5fdmFsdWVzW0ldKTtpZihkLmluZGV4T2Yodm9pZCAwKSE9PS0xKXRocm93IG5ldyBFcnJvcihgdW5yZXNvbHZlZCBpbnB1dCBkZXRlY3RlZDogb3A6ICR7cC5ub2RlfWApO2xldCBUPWQ7Y2UudmVyYm9zZShcIkV4ZWNQbGFuXCIsYFJ1bmluZyBvcDoke3Aubm9kZS5uYW1lfSAoJHtULm1hcCgoSSxMKT0+YCcke3Aubm9kZS5pbnB1dHNbTF19JzogJHtJLnR5cGV9WyR7SS5kaW1zLmpvaW4oXCIsXCIpfV1gKS5qb2luKFwiLCBcIil9KWApO2xldCB2PWF3YWl0IHRoaXMucHJvZmlsZXIuZXZlbnQoXCJub2RlXCIscC5ub2RlLm5hbWUsYXN5bmMoKT0+cC5vcC5pbXBsKGUsVCxwLm9wLmNvbnRleHQpKTtpZih2Lmxlbmd0aCE9PXAubm9kZS5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgc2l6ZSBvZiBvdXRwdXQgZG9lcyBub3QgbWF0Y2ggbW9kZWwgZGVmaW5pdGlvbi5cIik7di5mb3JFYWNoKChJLEwpPT57bGV0IEY9cC5ub2RlLm91dHB1dHNbTF07aWYodGhpcy5fdmFsdWVzW0ZdKXRocm93IG5ldyBFcnJvcihgb3V0cHV0IFske0Z9XSBhbHJlYWR5IGhhcyB2YWx1ZTogb3A6JHtwLm5vZGUubmFtZX1gKTt0aGlzLl92YWx1ZXNbRl09SX0pO2xldCB3PW5ldyBTZXQ7di5mb3JFYWNoKChJLEwpPT57bGV0IEY9cC5ub2RlLm91dHB1dHNbTF07Zm9yKGxldCBDIG9mIHNbRl0udG8pe2xldCBZPWlbQ10saj0hMDtmb3IobGV0IE0gb2YgWS5pbnB1dHMpaWYoIXRoaXMuX3ZhbHVlc1tNXSl7aj0hMTticmVha31qJiZ3LmFkZChDKX19KSxuLnB1c2goLi4udyl9bGV0IGw9W107Zm9yKGxldCBmPTA7Zjx0aGlzLmdyYXBoLmdldE91dHB1dEluZGljZXMoKS5sZW5ndGg7ZisrKXtsZXQgcD10aGlzLmdyYXBoLmdldE91dHB1dEluZGljZXMoKVtmXSxkPXRoaXMuX3ZhbHVlc1twXTtpZihkPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgb3V0cHV0IFske3B9XSBkb2VzIG5vdCBoYXZlIHZhbHVlYCk7cD09PTA/YXdhaXQgZC5nZXREYXRhKCk6ZC5kYXRhLGwucHVzaChkKX1yZXR1cm4gY2UudmVyYm9zZShcIkV4ZWNQbGFuXCIsXCJkaXNwb3Npbmcgb2YgaW5mZXJlbmNlSGFuZGxlclwiKSxlLmRpc3Bvc2UoKSxsfSl9fX0pO3ZhciBvZSxkdCxnbixUcD1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7bm4oKTtvZT1FcigkcigpKTticigpO2ZlKCk7ZHQ9Vy5leHBlcmltZW50YWwuZmJzLGduPWNsYXNzIGF7Y29uc3RydWN0b3IodCl7aWYodGhpcy5fYXR0cmlidXRlcz1uZXcgTWFwLHQhPW51bGwpe2ZvcihsZXQgbyBvZiB0KW8gaW5zdGFuY2VvZiBvZS5vbm54LkF0dHJpYnV0ZVByb3RvP3RoaXMuX2F0dHJpYnV0ZXMuc2V0KG8ubmFtZSxbYS5nZXRWYWx1ZShvKSxhLmdldFR5cGUobyldKTpvIGluc3RhbmNlb2YgZHQuQXR0cmlidXRlJiZ0aGlzLl9hdHRyaWJ1dGVzLnNldChvLm5hbWUoKSxbYS5nZXRWYWx1ZShvKSxhLmdldFR5cGUobyldKTtpZih0aGlzLl9hdHRyaWJ1dGVzLnNpemU8dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZHVwbGljYXRlZCBhdHRyaWJ1dGUgbmFtZXNcIil9fXNldCh0LG8sZSl7dGhpcy5fYXR0cmlidXRlcy5zZXQodCxbZSxvXSl9ZGVsZXRlKHQpe3RoaXMuX2F0dHJpYnV0ZXMuZGVsZXRlKHQpfWdldEZsb2F0KHQsbyl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJmbG9hdFwiLG8pfWdldEludCh0LG8pe3JldHVybiB0aGlzLmdldCh0LFwiaW50XCIsbyl9Z2V0U3RyaW5nKHQsbyl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJzdHJpbmdcIixvKX1nZXRUZW5zb3IodCxvKXtyZXR1cm4gdGhpcy5nZXQodCxcInRlbnNvclwiLG8pfWdldEZsb2F0cyh0LG8pe3JldHVybiB0aGlzLmdldCh0LFwiZmxvYXRzXCIsbyl9Z2V0SW50cyh0LG8pe3JldHVybiB0aGlzLmdldCh0LFwiaW50c1wiLG8pfWdldFN0cmluZ3ModCxvKXtyZXR1cm4gdGhpcy5nZXQodCxcInN0cmluZ3NcIixvKX1nZXRUZW5zb3JzKHQsbyl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJ0ZW5zb3JzXCIsbyl9Z2V0KHQsbyxlKXtsZXQgcj10aGlzLl9hdHRyaWJ1dGVzLmdldCh0KTtpZihyPT09dm9pZCAwKXtpZihlIT09dm9pZCAwKXJldHVybiBlO3Rocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgYXR0cmlidXRlIG5vdCBmb3VuZDogJHt0fWApfWlmKHJbMV0hPT1vKXRocm93IG5ldyBFcnJvcihgdHlwZSBtaXNtYXRjaDogZXhwZWN0ZWQgJHtvfSBidXQgZ290ICR7clsxXX1gKTtyZXR1cm4gclswXX1zdGF0aWMgZ2V0VHlwZSh0KXtsZXQgbz10IGluc3RhbmNlb2Ygb2Uub25ueC5BdHRyaWJ1dGVQcm90bz90LnR5cGU6dC50eXBlKCk7c3dpdGNoKG8pe2Nhc2Ugb2Uub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkZMT0FUOnJldHVyblwiZmxvYXRcIjtjYXNlIG9lLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlQ6cmV0dXJuXCJpbnRcIjtjYXNlIG9lLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkc6cmV0dXJuXCJzdHJpbmdcIjtjYXNlIG9lLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1I6cmV0dXJuXCJ0ZW5zb3JcIjtjYXNlIG9lLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVFM6cmV0dXJuXCJmbG9hdHNcIjtjYXNlIG9lLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlRTOnJldHVyblwiaW50c1wiO2Nhc2Ugb2Uub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6cmV0dXJuXCJzdHJpbmdzXCI7Y2FzZSBvZS5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzpyZXR1cm5cInRlbnNvcnNcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgYXR0cmlidXRlIHR5cGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQ6ICR7b2Uub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW29dfWApfX1zdGF0aWMgZ2V0VmFsdWUodCl7bGV0IG89dCBpbnN0YW5jZW9mIG9lLm9ubnguQXR0cmlidXRlUHJvdG8/dC50eXBlOnQudHlwZSgpO2lmKG89PT1vZS5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuR1JBUEh8fG89PT1vZS5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuR1JBUEhTKXRocm93IG5ldyBFcnJvcihcImdyYXBoIGF0dHJpYnV0ZSBpcyBub3Qgc3VwcG9ydGVkIHlldFwiKTtsZXQgZT10aGlzLmdldFZhbHVlTm9DaGVjayh0KTtpZihvPT09b2Uub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVCYmbnQuaXNMb25nKGUpKXJldHVybiBudC5sb25nVG9OdW1iZXIoZSk7aWYobz09PW9lLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlRTKXtsZXQgcj1lLG49bmV3IEFycmF5KHIubGVuZ3RoKTtmb3IobGV0IHM9MDtzPHIubGVuZ3RoO3MrKyl7bGV0IGk9cltzXTtuW3NdPW50LmxvbmdUb051bWJlcihpKX1yZXR1cm4gbn1pZihvPT09b2Uub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUilyZXR1cm4gdCBpbnN0YW5jZW9mIG9lLm9ubnguQXR0cmlidXRlUHJvdG8/Q2UuZnJvbVByb3RvKGUpOkNlLmZyb21PcnRUZW5zb3IoZSk7aWYobz09PW9lLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1JTKXtpZih0IGluc3RhbmNlb2Ygb2Uub25ueC5BdHRyaWJ1dGVQcm90bylyZXR1cm4gZS5tYXAobj0+Q2UuZnJvbVByb3RvKG4pKTtpZih0IGluc3RhbmNlb2YgZHQuQXR0cmlidXRlKXJldHVybiBlLm1hcChuPT5DZS5mcm9tT3J0VGVuc29yKG4pKX1yZXR1cm4gbz09PW9lLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkcmJnQgaW5zdGFuY2VvZiBvZS5vbm54LkF0dHJpYnV0ZVByb3RvP2xuKGUpOm89PT1vZS5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HUyYmdCBpbnN0YW5jZW9mIG9lLm9ubnguQXR0cmlidXRlUHJvdG8/ZS5tYXAobG4pOmV9c3RhdGljIGdldFZhbHVlTm9DaGVjayh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIG9lLm9ubnguQXR0cmlidXRlUHJvdG8/dGhpcy5nZXRWYWx1ZU5vQ2hlY2tGcm9tT25ueEZvcm1hdCh0KTp0aGlzLmdldFZhbHVlTm9DaGVja0Zyb21PcnRGb3JtYXQodCl9c3RhdGljIGdldFZhbHVlTm9DaGVja0Zyb21Pbm54Rm9ybWF0KHQpe3N3aXRjaCh0LnR5cGUpe2Nhc2Ugb2Uub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkZMT0FUOnJldHVybiB0LmY7Y2FzZSBvZS5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UOnJldHVybiB0Lmk7Y2FzZSBvZS5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HOnJldHVybiB0LnM7Y2FzZSBvZS5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SOnJldHVybiB0LnQ7Y2FzZSBvZS5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuR1JBUEg6cmV0dXJuIHQuZztjYXNlIG9lLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVFM6cmV0dXJuIHQuZmxvYXRzO2Nhc2Ugb2Uub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFM6cmV0dXJuIHQuaW50cztjYXNlIG9lLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTOnJldHVybiB0LnN0cmluZ3M7Y2FzZSBvZS5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzpyZXR1cm4gdC50ZW5zb3JzO2Nhc2Ugb2Uub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUzpyZXR1cm4gdC5ncmFwaHM7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGF0dHJpYnV0ZSB0eXBlOiAke29lLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVt0LnR5cGVdfWApfX1zdGF0aWMgZ2V0VmFsdWVOb0NoZWNrRnJvbU9ydEZvcm1hdCh0KXtzd2l0Y2godC50eXBlKCkpe2Nhc2UgZHQuQXR0cmlidXRlVHlwZS5GTE9BVDpyZXR1cm4gdC5mKCk7Y2FzZSBkdC5BdHRyaWJ1dGVUeXBlLklOVDpyZXR1cm4gdC5pKCk7Y2FzZSBkdC5BdHRyaWJ1dGVUeXBlLlNUUklORzpyZXR1cm4gdC5zKCk7Y2FzZSBkdC5BdHRyaWJ1dGVUeXBlLlRFTlNPUjpyZXR1cm4gdC50KCk7Y2FzZSBkdC5BdHRyaWJ1dGVUeXBlLkdSQVBIOnJldHVybiB0LmcoKTtjYXNlIGR0LkF0dHJpYnV0ZVR5cGUuRkxPQVRTOnJldHVybiB0LmZsb2F0c0FycmF5KCk7Y2FzZSBkdC5BdHRyaWJ1dGVUeXBlLklOVFM6e2xldCBvPVtdO2ZvcihsZXQgZT0wO2U8dC5pbnRzTGVuZ3RoKCk7ZSsrKW8ucHVzaCh0LmludHMoZSkpO3JldHVybiBvfWNhc2UgZHQuQXR0cmlidXRlVHlwZS5TVFJJTkdTOntsZXQgbz1bXTtmb3IobGV0IGU9MDtlPHQuc3RyaW5nc0xlbmd0aCgpO2UrKylvLnB1c2godC5zdHJpbmdzKGUpKTtyZXR1cm4gb31jYXNlIGR0LkF0dHJpYnV0ZVR5cGUuVEVOU09SUzp7bGV0IG89W107Zm9yKGxldCBlPTA7ZTx0LnRlbnNvcnNMZW5ndGgoKTtlKyspby5wdXNoKHQudGVuc29ycyhlKSk7cmV0dXJuIG99ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGF0dHJpYnV0ZSB0eXBlOiAke2R0LkF0dHJpYnV0ZVR5cGVbdC50eXBlKCldfWApfX19fSk7dmFyIEppLF9vLFppLFJ0LE9vLEtpLHhwPUUoKCk9PntcInVzZSBzdHJpY3RcIjtUcCgpO25uKCk7Smk9RXIoJHIoKSk7YnIoKTtmZSgpO19vPVcuZXhwZXJpbWVudGFsLmZicyxaaT17ZnJvbTooYSx0KT0+bmV3IEtpKGEsdCl9LFJ0PWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuX2Zyb209dm9pZCAwLHRoaXMuX3RvPVtdLHRoaXMudGVuc29yPXZvaWQgMCx0aGlzLnR5cGU9dm9pZCAwLHQmJih0aGlzLnR5cGU9VmUudGVuc29yVmFsdWVUeXBlRnJvbVByb3RvKHQudHlwZS50ZW5zb3JUeXBlKSl9Z2V0IGZyb20oKXtyZXR1cm4gdGhpcy5fZnJvbX1nZXQgdG8oKXtyZXR1cm4gdGhpcy5fdG99fSxPbz1jbGFzc3tjb25zdHJ1Y3Rvcih0LG8pe3QgaW5zdGFuY2VvZiBKaS5vbm54Lk5vZGVQcm90bz8odGhpcy5uYW1lPXQubmFtZSx0aGlzLm9wVHlwZT10Lm9wVHlwZSx0aGlzLmF0dHJpYnV0ZXM9bmV3IGduKHQuYXR0cmlidXRlKSk6dCBpbnN0YW5jZW9mIF9vLk5vZGUmJih0aGlzLm5hbWU9bz8/dC5uYW1lKCksdGhpcy5vcFR5cGU9dC5vcFR5cGUoKSx0aGlzLmF0dHJpYnV0ZXM9bmV3IGduKFZlLnRlbnNvckF0dHJpYnV0ZXNGcm9tT1JURm9ybWF0KHQpKSksdGhpcy5pbnB1dHM9W10sdGhpcy5vdXRwdXRzPVtdLHRoaXMuZXhlY3V0ZU5vZGU9ITB9fSxLaT1jbGFzc3tjb25zdHJ1Y3Rvcih0LG8pe2lmKCF0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJncmFwaCBpcyBlbXB0eVwiKTt0aGlzLmJ1aWxkR3JhcGgodCksdGhpcy50cmFuc2Zvcm1HcmFwaChvKSx0aGlzLmNoZWNrSXNBY3ljbGljKCl9Z2V0SW5wdXRJbmRpY2VzKCl7cmV0dXJuIHRoaXMuX2FsbElucHV0SW5kaWNlc31nZXRJbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX2FsbElucHV0TmFtZXN9Z2V0T3V0cHV0SW5kaWNlcygpe3JldHVybiB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzfWdldE91dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX2FsbE91dHB1dE5hbWVzfWdldFZhbHVlcygpe3JldHVybiB0aGlzLl9hbGxEYXRhfWdldE5vZGVzKCl7cmV0dXJuIHRoaXMuX25vZGVzfWJ1aWxkR3JhcGgodCl7aWYodCBpbnN0YW5jZW9mIEppLm9ubnguR3JhcGhQcm90byl0aGlzLmJ1aWxkR3JhcGhGcm9tT25ueEZvcm1hdCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBfby5HcmFwaCl0aGlzLmJ1aWxkR3JhcGhGcm9tT3J0Rm9ybWF0KHQpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdyYXBoIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cIil9YnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KHQpe2xldCBvPW5ldyBNYXA7dGhpcy5fYWxsRGF0YT1bXSx0aGlzLl9hbGxJbnB1dEluZGljZXM9W10sdGhpcy5fYWxsSW5wdXROYW1lcz1bXSx0aGlzLl9hbGxPdXRwdXRJbmRpY2VzPVtdLHRoaXMuX2FsbE91dHB1dE5hbWVzPVtdLHRoaXMuX25vZGVzPVtdO2xldCBlPW5ldyBNYXA7aWYoIXQuaW5wdXQpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBpbmZvcm1hdGlvbiBpbiBncmFwaDogaW5wdXRcIik7bGV0IHI9W107Zm9yKGxldCBuIG9mIHQuaW5wdXQpe2lmKG8uaGFzKG4ubmFtZSkpdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIGlucHV0IG5hbWU6ICR7bi5uYW1lfWApO2xldCBzPXRoaXMuX2FsbERhdGEucHVzaChuZXcgUnQobikpLTE7by5zZXQobi5uYW1lLHMpLHIucHVzaChuLm5hbWUpfWlmKCF0LmluaXRpYWxpemVyKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGluaXRpYWxpemVyXCIpO2ZvcihsZXQgbiBvZiB0LmluaXRpYWxpemVyKXtsZXQgcz1vLmdldChuLm5hbWUpO2lmKHM9PT12b2lkIDApe2xldCBpPW5ldyBSdDtpLnR5cGU9e3NoYXBlOntkaW1zOlZlLnRlbnNvckRpbXNGcm9tUHJvdG8obi5kaW1zKX0sdGVuc29yVHlwZTpWZS50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhuLmRhdGFUeXBlKX0scz10aGlzLl9hbGxEYXRhLnB1c2goaSktMSxvLnNldChuLm5hbWUscyl9dGhpcy5fYWxsRGF0YVtzXS5fZnJvbT0tMSx0aGlzLl9hbGxEYXRhW3NdLnRlbnNvcj1DZS5mcm9tUHJvdG8obil9Zm9yKGxldCBuPTA7bjx0aGlzLl9hbGxEYXRhLmxlbmd0aDtuKyspdGhpcy5fYWxsRGF0YVtuXS50ZW5zb3J8fCh0aGlzLl9hbGxJbnB1dEluZGljZXMucHVzaChuKSx0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2gocltuXSkpO2lmKCF0Lm91dHB1dCl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBvdXRwdXRcIik7Zm9yKGxldCBuIG9mIHQub3V0cHV0KXtpZihvLmhhcyhuLm5hbWUpKXRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBvdXRwdXQgbmFtZTogJHtuLm5hbWV9YCk7bGV0IHM9dGhpcy5fYWxsRGF0YS5wdXNoKG5ldyBSdChuKSktMTtvLnNldChuLm5hbWUscyksdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5wdXNoKHMpLHRoaXMuX2FsbE91dHB1dE5hbWVzLnB1c2gobi5uYW1lKX1pZighdC5ub2RlKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGVcIik7Zm9yKGxldCBuIG9mIHQubm9kZSl7aWYoIW4ubmFtZSlmb3IobGV0IGk9MDs7aSsrKXtsZXQgdT1gdW5uYW1lZF8ke24ub3BUeXBlfV8ke2l9YDtpZighZS5oYXModSkpe24ubmFtZT11O2JyZWFrfX1pZihlLmhhcyhuLm5hbWUpKXRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBub2RlIG5hbWU6ICR7bi5uYW1lfWApO2xldCBzPXRoaXMuX25vZGVzLnB1c2gobmV3IE9vKG4pKS0xO2Uuc2V0KG4ubmFtZSxzKX1mb3IobGV0IG49MDtuPHRoaXMuX25vZGVzLmxlbmd0aDtuKyspe2xldCBzPXRoaXMuX25vZGVzW25dLGk9dC5ub2RlW25dO2lmKCFpLm91dHB1dCl0aHJvdyBuZXcgRXJyb3IoYG1pc3Npbmcgb3V0cHV0IGZvciBub2RlOiAke2kubmFtZX1gKTtmb3IobGV0IHUgb2YgaS5vdXRwdXQpe2xldCBsPW8uZ2V0KHUpO2lmKHR5cGVvZiBsPlwidVwiJiYobD10aGlzLl9hbGxEYXRhLnB1c2gobmV3IFJ0KS0xLG8uc2V0KHUsbCkpLHMub3V0cHV0cy5wdXNoKGwpLHRoaXMuX2FsbERhdGFbbF0uX2Zyb20hPT12b2lkIDApdGhyb3cgbmV3IEVycm9yKGBtdWx0aXBsZSBub2RlcyBvdXRwdXQgdG8gb25lIGRhdGEgdmFsdWU6ICR7bH1gKTtpZih0aGlzLl9hbGxEYXRhW2xdLl9mcm9tPW4saS5vcFR5cGU9PT1cIkNvbnN0YW50XCIpe2lmKCFpLmF0dHJpYnV0ZXx8aS5hdHRyaWJ1dGUubGVuZ3RoIT09MXx8IWkuYXR0cmlidXRlWzBdLnQpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBhdHRyaWJ1dGVzIG9yIG1pc3NpbmcgdGVuc29yIHZhbHVlIGluIGF0dHJpYnV0ZXMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3JcIik7aWYoIWkub3V0cHV0fHxpLm91dHB1dC5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgb3V0cHV0IG9yIGluY29ycmVjdCBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvclwiKTtzLm91dHB1dHMucG9wKCkscy5leGVjdXRlTm9kZT0hMSx0aGlzLl9hbGxEYXRhW2xdLl9mcm9tPS0xLHRoaXMuX2FsbERhdGFbbF0udGVuc29yPUNlLmZyb21Qcm90byhpLmF0dHJpYnV0ZVswXS50KX19fWZvcihsZXQgbj0wO248dGhpcy5fbm9kZXMubGVuZ3RoO24rKyl7bGV0IHM9dGhpcy5fbm9kZXNbbl0saT10Lm5vZGVbbl07aWYoIWkuaW5wdXQpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGlucHV0IGZvciBub2RlOiAke2kubmFtZX1gKTtmb3IobGV0IHUgb2YgaS5pbnB1dCl7bGV0IGw9by5nZXQodSk7aWYodHlwZW9mIGw+XCJ1XCIpe2lmKHU9PT1cIlwiJiYoaS5pbnB1dC5sZW5ndGg9PT0zfHxpLmlucHV0Lmxlbmd0aD09PTQpJiZpLm9wVHlwZT09PVwiUmVzaXplXCIpY29udGludWU7dGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgaW5wdXQgJyR7dX0nIGZvciBub2RlOiAke2kubmFtZX1gKX1zLmlucHV0cy5wdXNoKGwpLHRoaXMuX2FsbERhdGFbbF0uX3RvLnB1c2gobil9fXJldHVybiEwfWJ1aWxkR3JhcGhGcm9tT3J0Rm9ybWF0KHQpe2xldCBvPW5ldyBNYXA7dGhpcy5fYWxsRGF0YT1bXSx0aGlzLl9hbGxJbnB1dEluZGljZXM9W10sdGhpcy5fYWxsSW5wdXROYW1lcz1bXSx0aGlzLl9hbGxPdXRwdXRJbmRpY2VzPVtdLHRoaXMuX2FsbE91dHB1dE5hbWVzPVtdLHRoaXMuX25vZGVzPVtdO2xldCBlPW5ldyBNYXAscj1bXTtmb3IobGV0IG49MDtuPHQuaW5wdXRzTGVuZ3RoKCk7bisrKXtsZXQgcz10LmlucHV0cyhuKTtpZihvLmhhcyhzKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgaW5wdXQgbmFtZTogJHtzfWApO2ZvcihsZXQgaT0wO2k8dC5ub2RlQXJnc0xlbmd0aCgpO2krKylpZih0Lm5vZGVBcmdzKGkpPy5uYW1lKCk9PT1zKXtsZXQgdT1uZXcgUnQ7aWYodC5ub2RlQXJncyhpKT8udHlwZSgpPy52YWx1ZVR5cGUoKSE9PV9vLlR5cGVJbmZvVmFsdWUudGVuc29yX3R5cGUpdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSB0eXBlIGZvciB0aGUgbm9kZUFyZy5cIik7bGV0IGY9dC5ub2RlQXJncyhpKS50eXBlKCkudmFsdWUobmV3IF9vLlRlbnNvclR5cGVBbmRTaGFwZSkscD1WZS50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhmLmVsZW1UeXBlKCkpLGQ9Zi5zaGFwZSgpLFQ9W107Zm9yKGxldCB3PTA7dzxkLmRpbUxlbmd0aCgpO3crKylULnB1c2gobnQubG9uZ1RvTnVtYmVyKGQuZGltKHcpLnZhbHVlKCkuZGltVmFsdWUoKSkpO3UudHlwZT17c2hhcGU6e2RpbXM6VH0sdGVuc29yVHlwZTpwfTtsZXQgdj10aGlzLl9hbGxEYXRhLnB1c2godSktMTtvLnNldChzLHYpLHIucHVzaChzKX19Zm9yKGxldCBuPTA7bjx0LmluaXRpYWxpemVyc0xlbmd0aCgpO24rKyl7bGV0IHM9dC5pbml0aWFsaXplcnMobiksaT1vLmdldChzLm5hbWUoKSk7aWYoaT09PXZvaWQgMCl7bGV0IHU9bmV3IFJ0LGw9VmUudGVuc29yRGltc0Zyb21PUlRGb3JtYXQocyksZj1WZS50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhzLmRhdGFUeXBlKCkpO3UudHlwZT17c2hhcGU6e2RpbXM6bH0sdGVuc29yVHlwZTpmfSxpPXRoaXMuX2FsbERhdGEucHVzaCh1KS0xLG8uc2V0KHMubmFtZSgpLGkpfXRoaXMuX2FsbERhdGFbaV0uX2Zyb209LTEsdGhpcy5fYWxsRGF0YVtpXS50ZW5zb3I9Q2UuZnJvbU9ydFRlbnNvcihzKX1mb3IobGV0IG49MDtuPHRoaXMuX2FsbERhdGEubGVuZ3RoO24rKyl0aGlzLl9hbGxEYXRhW25dLnRlbnNvcnx8KHRoaXMuX2FsbElucHV0SW5kaWNlcy5wdXNoKG4pLHRoaXMuX2FsbElucHV0TmFtZXMucHVzaChyW25dKSk7Zm9yKGxldCBuPTA7bjx0Lm91dHB1dHNMZW5ndGgoKTtuKyspe2xldCBzPXQub3V0cHV0cyhuKTtpZihvLmhhcyhzKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgb3V0cHV0IG5hbWU6ICR7c31gKTtsZXQgaT10aGlzLl9hbGxEYXRhLnB1c2gobmV3IFJ0KS0xO28uc2V0KHMsaSksdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5wdXNoKGkpLHRoaXMuX2FsbE91dHB1dE5hbWVzLnB1c2gocyl9aWYoIXQubm9kZXMpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBpbmZvcm1hdGlvbiBpbiBncmFwaDogbm9kZVwiKTtmb3IobGV0IG49MDtuPHQubm9kZXNMZW5ndGgoKTtuKyspe2xldCBzPXQubm9kZXMobiksaT1zLm5hbWUoKTtpZighaSlmb3IobGV0IGw9MDtpPWB1bm5hbWVkXyR7cy5vcFR5cGUoKX1fJHtsfWAsISFlLmhhcyhpKTtsKyspO2lmKGUuaGFzKGkpKXRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBub2RlIG5hbWU6ICR7aX1gKTtsZXQgdT10aGlzLl9ub2Rlcy5wdXNoKG5ldyBPbyhzLGkpKS0xO2Uuc2V0KGksdSl9Zm9yKGxldCBuPTA7bjx0aGlzLl9ub2Rlcy5sZW5ndGg7bisrKXtsZXQgcz10aGlzLl9ub2Rlc1tuXSxpPXQubm9kZXMobik7aWYoaT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYE5vIG5vZGUgZXhpc3RzIGF0IGluZGV4ICR7bn1gKTtpZihpPy5vdXRwdXRzTGVuZ3RoKCk9PT0wKXRocm93IG5ldyBFcnJvcihgbWlzc2luZyBvdXRwdXQgZm9yIG5vZGU6ICR7aS5uYW1lfWApO2ZvcihsZXQgdT0wO3U8aT8ub3V0cHV0c0xlbmd0aCgpO3UrKyl7bGV0IGw9aT8ub3V0cHV0cyh1KSxmPW8uZ2V0KGwpO2lmKHR5cGVvZiBmPlwidVwiJiYoZj10aGlzLl9hbGxEYXRhLnB1c2gobmV3IFJ0KS0xLG8uc2V0KGwsZikpLHMub3V0cHV0cy5wdXNoKGYpLHRoaXMuX2FsbERhdGFbZl0uX2Zyb20hPT12b2lkIDApdGhyb3cgbmV3IEVycm9yKGBtdWx0aXBsZSBub2RlcyBvdXRwdXQgdG8gb25lIGRhdGEgdmFsdWU6ICR7Zn1gKTtpZih0aGlzLl9hbGxEYXRhW2ZdLl9mcm9tPW4saS5vcFR5cGUoKT09PVwiQ29uc3RhbnRcIil7aWYoaS5hdHRyaWJ1dGVzTGVuZ3RoKCkhPT0xfHwhaS5hdHRyaWJ1dGVzKDApLnQoKSl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGF0dHJpYnV0ZXMgb3IgbWlzc2luZyB0ZW5zb3IgdmFsdWUgaW4gYXR0cmlidXRlcyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvclwiKTtpZihpLm91dHB1dHNMZW5ndGgoKSE9PTEpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBvdXRwdXQgb3IgaW5jb3JyZWN0IG51bWJlciBvZiBvdXRwdXRzIGZvciB0aGlzIENvbnN0YW50IG9wZXJhdG9yXCIpO3Mub3V0cHV0cy5wb3AoKSxzLmV4ZWN1dGVOb2RlPSExLHRoaXMuX2FsbERhdGFbZl0uX2Zyb209LTEsdGhpcy5fYWxsRGF0YVtmXS50ZW5zb3I9Q2UuZnJvbU9ydFRlbnNvcihpLmF0dHJpYnV0ZXMoMCkudCgpKX19fWZvcihsZXQgbj0wO248dGhpcy5fbm9kZXMubGVuZ3RoO24rKyl7bGV0IHM9dGhpcy5fbm9kZXNbbl0saT10Lm5vZGVzKG4pO2lmKGkuaW5wdXRzTGVuZ3RoKCk9PT0wKXRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCBmb3Igbm9kZTogJHtpLm5hbWV9YCk7Zm9yKGxldCB1PTA7dTxpLmlucHV0c0xlbmd0aCgpO3UrKyl7bGV0IGw9aS5pbnB1dHModSksZj1vLmdldChsKTtpZih0eXBlb2YgZj5cInVcIil0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBpbnB1dCAnJHtsfScgZm9yIG5vZGU6ICR7aS5uYW1lKCl9YCk7cy5pbnB1dHMucHVzaChmKSx0aGlzLl9hbGxEYXRhW2ZdLl90by5wdXNoKG4pfX19Y2hlY2tJc0FjeWNsaWMoKXtsZXQgdD1uZXcgU2V0O3RoaXMuX2FsbElucHV0SW5kaWNlcy5mb3JFYWNoKHI9Pnt0aGlzLl9hbGxEYXRhW3JdLl90by5mb3JFYWNoKHM9Pnt0LmFkZChzKX0pfSk7bGV0IG89QXJyYXkuZnJvbSh0KSxlPW5ldyBBcnJheSh0aGlzLl9ub2Rlcy5sZW5ndGgpLmZpbGwoXCJ3aGl0ZVwiKTtmb3IoO28ubGVuZ3RoPjA7KXtsZXQgcj1vLnBvcCgpO2Vbcl09PT1cImdyYXlcIj9lW3JdPVwiYmxhY2tcIjooby5wdXNoKHIpLGVbcl09XCJncmF5XCIsdGhpcy5fbm9kZXNbcl0ub3V0cHV0cy5mb3JFYWNoKG49PntsZXQgcz10aGlzLl9hbGxEYXRhW25dO2lmKHR5cGVvZiBzLnRlbnNvcjxcInVcIil0aHJvdyBuZXcgRXJyb3IoXCJub2RlIG91dHB1dHMgc2hvdWxkIG5vdCBiZSBpbml0aWFsaXplZFwiKTtpZihzLl9mcm9tIT09cil0aHJvdyBuZXcgRXJyb3IoXCJmcm9tIHByb3BlcnR5IG9mIHRoZSBWYWx1ZSBvYmplY3QgZG9lc24ndCBtYXRjaCBpbmRleCBvZiBOb2RlIGJlaW5nIHByb2Nlc3NlZFwiKTtzLl90by5mb3JFYWNoKGk9PntpZihlW2ldPT09XCJncmF5XCIpdGhyb3cgbmV3IEVycm9yKFwibW9kZWwgZ3JhcGggaXMgY3ljbGljXCIpO2VbaV09PT1cIndoaXRlXCImJm8ucHVzaChpKX0pfSkpfX10cmFuc2Zvcm1HcmFwaCh0KXt0aGlzLnJlbW92ZUFsbElkZW50aXR5Tm9kZXMoKSx0aGlzLnJlbW92ZUFsbERyb3BvdXROb2RlcygpLHRoaXMuZnVzZUNvbnZBY3RpdmF0aW9uTm9kZXMoKSx0JiZ0LnRyYW5zZm9ybUdyYXBoKHRoaXMpLHRoaXMuZmluYWxpemVHcmFwaCgpfWZpbmFsaXplR3JhcGgoKXtsZXQgdD0wLG89bmV3IEFycmF5KHRoaXMuX25vZGVzLmxlbmd0aCwwKSxlPTA7Zm9yKGxldCByPTA7cjx0aGlzLl9ub2Rlcy5sZW5ndGg7cisrKW9bcl09ZSx0aGlzLl9ub2Rlc1tyXS5leGVjdXRlTm9kZT8oZSE9PXImJih0aGlzLl9ub2Rlc1tlXT10aGlzLl9ub2Rlc1tyXSksZSsrKTp0aGlzLl9ub2Rlc1tyXS5vdXRwdXRzLmZvckVhY2gobj0+e3RoaXMuX2FsbERhdGFbbl0uX2Zyb209LTJ9KTt0aGlzLl9ub2Rlcy5zcGxpY2UoZSx0aGlzLl9ub2Rlcy5sZW5ndGgtZSk7Zm9yKGxldCByPTA7cjx0aGlzLl9hbGxEYXRhLmxlbmd0aDtyKyspe2xldCBuPXRoaXMuX2FsbERhdGFbcl07bi5fZnJvbSE9PXZvaWQgMCYmbi5fZnJvbSE9PS0xJiZuLl9mcm9tIT09LTImJihuLl9mcm9tPW9bbi5fZnJvbV0pO2ZvcihsZXQgcz0wO3M8bi5fdG8ubGVuZ3RoO3MrKylpZihuLl90b1tzXT49MCluLl90b1tzXT1vW24uX3RvW3NdXTtlbHNlIHRocm93IG5ldyBFcnJvcihcIlRyeWluZyB0byB1cGRhdGUgYSByZW1vdmVkIG5vZGVcIil9dD0wO2ZvcihsZXQgcj0wO3I8dGhpcy5fYWxsRGF0YS5sZW5ndGg7cisrKXtpZih0aGlzLl9hbGxEYXRhW3JdLmZyb209PT0tMiYmdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5pbmRleE9mKHIrdCk9PT0tMSl7dCsrLHRoaXMuX2FsbERhdGEuc3BsaWNlKHIsMSksci0tO2NvbnRpbnVlfWlmKHQ+MCl7bGV0IG49LTE7dGhpcy5fYWxsRGF0YVtyXS5mcm9tIT09dm9pZCAwJiZ0aGlzLl9hbGxEYXRhW3JdLmZyb20hPT0tMT8obj10aGlzLl9ub2Rlc1t0aGlzLl9hbGxEYXRhW3JdLmZyb21dLm91dHB1dHMuaW5kZXhPZihyK3QpLG4hPT0tMSYmKHRoaXMuX25vZGVzW3RoaXMuX2FsbERhdGFbcl0uZnJvbV0ub3V0cHV0c1tuXT1yKSk6KG49dGhpcy5fYWxsSW5wdXRJbmRpY2VzLmluZGV4T2Yocit0KSxuIT09LTEmJih0aGlzLl9hbGxJbnB1dEluZGljZXNbbl09cikpLHRoaXMuX2FsbERhdGFbcl0udG8uZm9yRWFjaChzPT57bj10aGlzLl9ub2Rlc1tzXS5pbnB1dHMuaW5kZXhPZihyK3QpLG4hPT0tMSYmKHRoaXMuX25vZGVzW3NdLmlucHV0c1tuXT1yKX0pLHRoaXMuX2FsbERhdGFbcl0udG8ubGVuZ3RoPT09MCYmKG49dGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5pbmRleE9mKHIrdCksbiE9PS0xJiYodGhpcy5fYWxsT3V0cHV0SW5kaWNlc1tuXT1yKSl9fX1kZWxldGVOb2RlKHQpe2xldCBvPXRoaXMuX25vZGVzW3RdO2lmKG8ub3V0cHV0cy5sZW5ndGg+MSl7Zm9yKGxldCBpPTE7aTxvLm91dHB1dHMubGVuZ3RoO2krKylpZih0aGlzLl9hbGxEYXRhW28ub3V0cHV0c1tpXV0udG8ubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBkZWxldGlvbiB3aXRoIG1vcmUgdGhhbiBvbmUgb3V0cHV0IGNvbm5lY3RlZCB0byBvdGhlciBub2RlcyBpcyBub3Qgc3VwcG9ydGVkLiBcIil9by5leGVjdXRlTm9kZT0hMTtsZXQgZT1vLmlucHV0c1swXSxyPW8ub3V0cHV0c1swXSxuPXRoaXMuX2FsbERhdGFbcl0udG87Zm9yKGxldCBpPTA7aTxvLmlucHV0cy5sZW5ndGg7aSsrKXtsZXQgdT10aGlzLl9hbGxEYXRhW28uaW5wdXRzW2ldXS50by5pbmRleE9mKHQpO2lmKHU9PT0tMSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgVmFsdWUgb2JqZWN0IGRvZXNuJ3QgaGF2ZSB0aGUgY3VycmVudCBOb2RlIGluIGl0J3MgJ3RvJyBwcm9wZXJ0eSBcIik7dGhpcy5fYWxsRGF0YVtvLmlucHV0c1tpXV0udG8uc3BsaWNlKHUsMSl9dGhpcy5fYWxsRGF0YVtyXS5fdG89W107bGV0IHM9dGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5pbmRleE9mKHIpO2lmKHMhPT0tMSYmKHRoaXMuX2FsbE91dHB1dEluZGljZXNbc109ZSksbiYmbi5sZW5ndGg+MClmb3IobGV0IGkgb2Ygbil7bGV0IHU9dGhpcy5fbm9kZXNbaV0uaW5wdXRzLmluZGV4T2Yocik7aWYodT09PS0xKXRocm93IG5ldyBFcnJvcihcIlRoZSBOb2RlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIG91dHB1dCBWYWx1ZSBpbiBpdCdzICdpbnB1dHMnIHByb3BlcnR5IFwiKTt0aGlzLl9ub2Rlc1tpXS5pbnB1dHNbdV09ZSx0aGlzLl9hbGxEYXRhW2VdLnRvLnB1c2goaSl9fXJlbW92ZUFsbERyb3BvdXROb2Rlcygpe2xldCB0PTA7Zm9yKGxldCBvIG9mIHRoaXMuX25vZGVzKXtpZihvLm9wVHlwZT09PVwiRHJvcG91dFwiKXtpZihvLmlucHV0cy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkRyb3BvdXQgbm9kZXMgc2hvdWxkIG9ubHkgY29udGFpbiBvbmUgaW5wdXQuIFwiKTtpZihvLm91dHB1dHMubGVuZ3RoIT09MSYmby5vdXRwdXRzLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiRHJvcG91dCBub2RlcyBzaG91bGQgY29udGFpbiBlaXRoZXIgMSBvciAyIG91dHB1dChzKVwiKTtpZihvLm91dHB1dHMubGVuZ3RoPT09MiYmdGhpcy5fYWxsRGF0YVtvLm91dHB1dHNbMV1dLl90by5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihcIkRyb3BvdXQgbm9kZXMncyBzZWNvbmQgb3V0cHV0IHNob3VsZCBub3QgYmUgcmVmZXJlbmNlZCBieSBvdGhlciBub2Rlc1wiKTt0aGlzLmRlbGV0ZU5vZGUodCl9dCsrfX1yZW1vdmVBbGxJZGVudGl0eU5vZGVzKCl7bGV0IHQ9MDtmb3IobGV0IG8gb2YgdGhpcy5fbm9kZXMpby5vcFR5cGU9PT1cIklkZW50aXR5XCImJnRoaXMuZGVsZXRlTm9kZSh0KSx0Kyt9aXNBY3RpdmF0aW9uKHQpe3N3aXRjaCh0Lm9wVHlwZSl7Y2FzZVwiUmVsdVwiOmNhc2VcIlNpZ21vaWRcIjpjYXNlXCJDbGlwXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVzZUNvbnZBY3RpdmF0aW9uTm9kZXMoKXtmb3IobGV0IHQgb2YgdGhpcy5fbm9kZXMpaWYodC5vcFR5cGU9PT1cIkNvbnZcIil7bGV0IG89dGhpcy5fYWxsRGF0YVt0Lm91dHB1dHNbMF1dLl90bztpZihvLmxlbmd0aD09PTEmJnRoaXMuaXNBY3RpdmF0aW9uKHRoaXMuX25vZGVzW29bMF1dKSl7bGV0IGU9dGhpcy5fbm9kZXNbb1swXV07aWYoZS5vcFR5cGU9PT1cIkNsaXBcIilpZihlLmlucHV0cy5sZW5ndGg9PT0xKXRyeXt0LmF0dHJpYnV0ZXMuc2V0KFwiYWN0aXZhdGlvbl9wYXJhbXNcIixcImZsb2F0c1wiLFtlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJtaW5cIiksZS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibWF4XCIpXSl9Y2F0Y2h7dC5hdHRyaWJ1dGVzLnNldChcImFjdGl2YXRpb25fcGFyYW1zXCIsXCJmbG9hdHNcIixbaHIsbXJdKX1lbHNlIGlmKGUuaW5wdXRzLmxlbmd0aD49MyYmdGhpcy5fYWxsRGF0YVtlLmlucHV0c1sxXV0udGVuc29yIT09dm9pZCAwJiZ0aGlzLl9hbGxEYXRhW2UuaW5wdXRzWzJdXS50ZW5zb3IhPT12b2lkIDApdC5hdHRyaWJ1dGVzLnNldChcImFjdGl2YXRpb25fcGFyYW1zXCIsXCJmbG9hdHNcIixbdGhpcy5fYWxsRGF0YVtlLmlucHV0c1sxXV0udGVuc29yLmZsb2F0RGF0YVswXSx0aGlzLl9hbGxEYXRhW2UuaW5wdXRzWzJdXS50ZW5zb3IuZmxvYXREYXRhWzBdXSk7ZWxzZSBjb250aW51ZTt0LmF0dHJpYnV0ZXMuc2V0KFwiYWN0aXZhdGlvblwiLFwic3RyaW5nXCIsZS5vcFR5cGUpLHRoaXMuZGVsZXRlTm9kZShvWzBdKX19fX19KTt2YXIgd3AsdGcsSW8sdnA9RSgoKT0+e1widXNlIHN0cmljdFwiO1duKCk7eHAoKTtubigpO3dwPUVyKCRyKCkpO2ZlKCk7dGc9Vy5leHBlcmltZW50YWwuZmJzLElvPWNsYXNze2NvbnN0cnVjdG9yKCl7fWxvYWQodCxvLGUpe2lmKCFlKXRyeXt0aGlzLmxvYWRGcm9tT25ueEZvcm1hdCh0LG8pO3JldHVybn1jYXRjaChyKXtpZihlIT09dm9pZCAwKXRocm93IHJ9dGhpcy5sb2FkRnJvbU9ydEZvcm1hdCh0LG8pfWxvYWRGcm9tT25ueEZvcm1hdCh0LG8pe2xldCBlPXdwLm9ubnguTW9kZWxQcm90by5kZWNvZGUodCk7aWYobnQubG9uZ1RvTnVtYmVyKGUuaXJWZXJzaW9uKTwzKXRocm93IG5ldyBFcnJvcihcIm9ubHkgc3VwcG9ydCBPTk5YIG1vZGVsIHdpdGggSVJfVkVSU0lPTj49M1wiKTt0aGlzLl9vcHNldHM9ZS5vcHNldEltcG9ydC5tYXAobj0+KHtkb21haW46bi5kb21haW4sdmVyc2lvbjpudC5sb25nVG9OdW1iZXIobi52ZXJzaW9uKX0pKSx0aGlzLl9ncmFwaD1aaS5mcm9tKGUuZ3JhcGgsbyl9bG9hZEZyb21PcnRGb3JtYXQodCxvKXtsZXQgZT1uZXcgTy5CeXRlQnVmZmVyKHQpLHI9dGcuSW5mZXJlbmNlU2Vzc2lvbi5nZXRSb290QXNJbmZlcmVuY2VTZXNzaW9uKGUpLm1vZGVsKCk7aWYobnQubG9uZ1RvTnVtYmVyKHIuaXJWZXJzaW9uKCkpPDMpdGhyb3cgbmV3IEVycm9yKFwib25seSBzdXBwb3J0IE9OTlggbW9kZWwgd2l0aCBJUl9WRVJTSU9OPj0zXCIpO3RoaXMuX29wc2V0cz1bXTtmb3IobGV0IHM9MDtzPHIub3BzZXRJbXBvcnRMZW5ndGgoKTtzKyspe2xldCBpPXIub3BzZXRJbXBvcnQocyk7dGhpcy5fb3BzZXRzLnB1c2goe2RvbWFpbjppPy5kb21haW4oKSx2ZXJzaW9uOm50LmxvbmdUb051bWJlcihpLnZlcnNpb24oKSl9KX10aGlzLl9ncmFwaD1aaS5mcm9tKHIuZ3JhcGgoKSxvKX1nZXQgZ3JhcGgoKXtyZXR1cm4gdGhpcy5fZ3JhcGh9Z2V0IG9wc2V0cygpe3JldHVybiB0aGlzLl9vcHNldHN9fX0pO3ZhciBTbyxfcD1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z3AoKTt5cCgpO2F0KCk7dnAoKTtTbz1jbGFzc3tjb25zdHJ1Y3Rvcih0PXt9KXt0aGlzLl9pbml0aWFsaXplZD0hMSx0aGlzLmJhY2tlbmRIaW50PXQuYmFja2VuZEhpbnQsdGhpcy5wcm9maWxlcj16bi5jcmVhdGUodC5wcm9maWxlciksdGhpcy5jb250ZXh0PXtwcm9maWxlcjp0aGlzLnByb2ZpbGVyLGdyYXBoSW5wdXRUeXBlczpbXSxncmFwaElucHV0RGltczpbXX19Z2V0IGlucHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0SW5wdXROYW1lcygpfWdldCBvdXRwdXROYW1lcygpe3JldHVybiB0aGlzLl9tb2RlbC5ncmFwaC5nZXRPdXRwdXROYW1lcygpfXN0YXJ0UHJvZmlsaW5nKCl7dGhpcy5wcm9maWxlci5zdGFydCgpfWVuZFByb2ZpbGluZygpe3RoaXMucHJvZmlsZXIuc3RvcCgpfWFzeW5jIGxvYWRNb2RlbCh0LG8sZSl7YXdhaXQgdGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIlNlc3Npb24ubG9hZE1vZGVsXCIsYXN5bmMoKT0+e2xldCByPWF3YWl0IFlpKHRoaXMuYmFja2VuZEhpbnQpO2lmKHRoaXMuc2Vzc2lvbkhhbmRsZXI9ci5jcmVhdGVTZXNzaW9uSGFuZGxlcih0aGlzLmNvbnRleHQpLHRoaXMuX21vZGVsPW5ldyBJbyx0eXBlb2YgdD09XCJzdHJpbmdcIil7bGV0IG49dC5lbmRzV2l0aChcIi5vcnRcIik7aWYodHlwZW9mIHByb2Nlc3M8XCJ1XCImJnByb2Nlc3MudmVyc2lvbnMmJnByb2Nlc3MudmVyc2lvbnMubm9kZSl7bGV0IHM9YXdhaXQodm9pZCAwKSh0KTt0aGlzLmluaXRpYWxpemUocyxuKX1lbHNle2xldCBpPWF3YWl0KGF3YWl0IGZldGNoKHQpKS5hcnJheUJ1ZmZlcigpO3RoaXMuaW5pdGlhbGl6ZShuZXcgVWludDhBcnJheShpKSxuKX19ZWxzZSBpZihBcnJheUJ1ZmZlci5pc1ZpZXcodCkpdGhpcy5pbml0aWFsaXplKHQpO2Vsc2V7bGV0IG49bmV3IFVpbnQ4QXJyYXkodCxvfHwwLGV8fHQuYnl0ZUxlbmd0aCk7dGhpcy5pbml0aWFsaXplKG4pfX0pfWluaXRpYWxpemUodCxvKXtpZih0aGlzLl9pbml0aWFsaXplZCl0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IGluaXRpYWxpemVkXCIpO3RoaXMucHJvZmlsZXIuZXZlbnQoXCJzZXNzaW9uXCIsXCJTZXNzaW9uLmluaXRpYWxpemVcIiwoKT0+e2xldCBlPXRoaXMuc2Vzc2lvbkhhbmRsZXIudHJhbnNmb3JtR3JhcGg/dGhpcy5zZXNzaW9uSGFuZGxlcjp2b2lkIDA7dGhpcy5fbW9kZWwubG9hZCh0LGUsbyksdGhpcy5zZXNzaW9uSGFuZGxlci5vbkdyYXBoSW5pdGlhbGl6ZWQmJnRoaXMuc2Vzc2lvbkhhbmRsZXIub25HcmFwaEluaXRpYWxpemVkKHRoaXMuX21vZGVsLmdyYXBoKSx0aGlzLmluaXRpYWxpemVPcHModGhpcy5fbW9kZWwuZ3JhcGgpLHRoaXMuX2V4ZWN1dGlvblBsYW49bmV3IHZvKHRoaXMuX21vZGVsLmdyYXBoLHRoaXMuX29wcyx0aGlzLnByb2ZpbGVyKX0pLHRoaXMuX2luaXRpYWxpemVkPSEwfWFzeW5jIHJ1bih0KXtpZighdGhpcy5faW5pdGlhbGl6ZWQpdGhyb3cgbmV3IEVycm9yKFwic2Vzc2lvbiBub3QgaW5pdGlhbGl6ZWQgeWV0XCIpO3JldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KFwic2Vzc2lvblwiLFwiU2Vzc2lvbi5ydW5cIixhc3luYygpPT57bGV0IG89dGhpcy5ub3JtYWxpemVBbmRWYWxpZGF0ZUlucHV0cyh0KSxlPWF3YWl0IHRoaXMuX2V4ZWN1dGlvblBsYW4uZXhlY3V0ZSh0aGlzLnNlc3Npb25IYW5kbGVyLG8pO3JldHVybiB0aGlzLmNyZWF0ZU91dHB1dChlKX0pfW5vcm1hbGl6ZUFuZFZhbGlkYXRlSW5wdXRzKHQpe2xldCBvPXRoaXMuX21vZGVsLmdyYXBoLmdldElucHV0TmFtZXMoKTtpZihBcnJheS5pc0FycmF5KHQpKXtpZih0Lmxlbmd0aCE9PW8ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW5jb3JyZWN0IGlucHV0IGFycmF5IGxlbmd0aDogZXhwZWN0ZWQgJHtvLmxlbmd0aH0gYnV0IGdvdCAke3QubGVuZ3RofWApfWVsc2V7aWYodC5zaXplIT09by5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbmNvcnJlY3QgaW5wdXQgbWFwIHNpemU6IGV4cGVjdGVkICR7by5sZW5ndGh9IGJ1dCBnb3QgJHt0LnNpemV9YCk7bGV0IGU9bmV3IEFycmF5KHQuc2l6ZSkscj0wO2ZvcihsZXQgbj0wO248by5sZW5ndGg7KytuKXtsZXQgcz10LmdldChvW25dKTtpZighcyl0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgaW5wdXQgdGVuc29yIGZvcjogJyR7bmFtZX0nYCk7ZVtyKytdPXN9dD1lfWlmKCF0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzfHx0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzLmxlbmd0aD09PTB8fCF0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dERpbXN8fHRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcy5sZW5ndGg9PT0wKXtsZXQgZT10aGlzLl9tb2RlbC5ncmFwaC5nZXRJbnB1dEluZGljZXMoKSxyPXRoaXMuX21vZGVsLmdyYXBoLmdldFZhbHVlcygpLG49bmV3IEFycmF5KGUubGVuZ3RoKTtmb3IobGV0IHM9MDtzPGUubGVuZ3RoOysrcyl7bGV0IGk9cltlW3NdXTtuW3NdPWkudHlwZS5zaGFwZS5kaW1zLHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMucHVzaChpLnR5cGUudGVuc29yVHlwZSksdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zLnB1c2godFtzXS5kaW1zKX10aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKG4sdCwhMCl9ZWxzZSB0aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcyx0LCExKTtyZXR1cm4gdGhpcy52YWxpZGF0ZUlucHV0VGVuc29yVHlwZXModGhpcy5jb250ZXh0LmdyYXBoSW5wdXRUeXBlcyx0KSx0fXZhbGlkYXRlSW5wdXRUZW5zb3JUeXBlcyh0LG8pe2ZvcihsZXQgZT0wO2U8by5sZW5ndGg7ZSsrKXtsZXQgcj10W2VdLG49b1tlXS50eXBlO2lmKHIhPT1uKXRocm93IG5ldyBFcnJvcihgaW5wdXQgdGVuc29yWyR7ZX1dIGNoZWNrIGZhaWxlZDogZXhwZWN0ZWQgdHlwZSAnJHtyfScgYnV0IGdvdCAke259YCl9fXZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHQsbyxlKXtmb3IobGV0IHI9MDtyPG8ubGVuZ3RoO3IrKyl7bGV0IG49dFtyXSxzPW9bcl0uZGltcztpZighdGhpcy5jb21wYXJlVGVuc29yRGltcyhuLHMsZSkpdGhyb3cgbmV3IEVycm9yKGBpbnB1dCB0ZW5zb3JbJHtyfV0gY2hlY2sgZmFpbGVkOiBleHBlY3RlZCBzaGFwZSAnWyR7bi5qb2luKFwiLFwiKX1dJyBidXQgZ290IFske3Muam9pbihcIixcIil9XWApfX1jb21wYXJlVGVuc29yRGltcyh0LG8sZSl7aWYodC5sZW5ndGghPT1vLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoOysrcilpZih0W3JdIT09b1tyXSYmKCFlfHx0W3JdIT09MCkpcmV0dXJuITE7cmV0dXJuITB9Y3JlYXRlT3V0cHV0KHQpe2xldCBvPXRoaXMuX21vZGVsLmdyYXBoLmdldE91dHB1dE5hbWVzKCk7aWYodC5sZW5ndGghPT1vLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBudW1iZXIgb2Ygb3V0cHV0cyBkbyBub3QgbWF0Y2ggbnVtYmVyIG9mIGdlbmVyYXRlZCBvdXRwdXRzXCIpO2xldCBlPW5ldyBNYXA7Zm9yKGxldCByPTA7cjxvLmxlbmd0aDsrK3IpZS5zZXQob1tyXSx0W3JdKTtyZXR1cm4gZX1pbml0aWFsaXplT3BzKHQpe2xldCBvPXQuZ2V0Tm9kZXMoKTt0aGlzLl9vcHM9bmV3IEFycmF5KG8ubGVuZ3RoKTtmb3IobGV0IGU9MDtlPG8ubGVuZ3RoO2UrKyl0aGlzLl9vcHNbZV09dGhpcy5zZXNzaW9uSGFuZGxlci5yZXNvbHZlKG9bZV0sdGhpcy5fbW9kZWwub3BzZXRzLHQpfX19KTt2YXIgQW8sT3A9RSgoKT0+e1widXNlIHN0cmljdFwiO1R0KCk7YnIoKTtBbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnNlc3Npb249dDt0aGlzLmlucHV0TmFtZXM9dGhpcy5zZXNzaW9uLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lcz10aGlzLnNlc3Npb24ub3V0cHV0TmFtZXN9YXN5bmMgZGlzcG9zZSgpe31hc3luYyBydW4odCxvLGUpe2xldCByPW5ldyBNYXA7Zm9yKGxldCBpIGluIHQpaWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxpKSl7bGV0IHU9dFtpXTtyLnNldChpLG5ldyBDZSh1LmRpbXMsdS50eXBlLHZvaWQgMCx2b2lkIDAsdS5kYXRhKSl9bGV0IG49YXdhaXQgdGhpcy5zZXNzaW9uLnJ1bihyKSxzPXt9O3JldHVybiBuLmZvckVhY2goKGksdSk9PntzW3VdPW5ldyBSZShpLnR5cGUsaS5kYXRhLGkuZGltcyl9KSxzfXN0YXJ0UHJvZmlsaW5nKCl7dGhpcy5zZXNzaW9uLnN0YXJ0UHJvZmlsaW5nKCl9ZW5kUHJvZmlsaW5nKCl7dGhpcy5zZXNzaW9uLmVuZFByb2ZpbGluZygpfX19KTt2YXIgSXA9e307UHIoSXAse29ubnhqc0JhY2tlbmQ6KCk9Pm5nfSk7dmFyIFFpLG5nLFNwPUUoKCk9PntcInVzZSBzdHJpY3RcIjtfcCgpO09wKCk7UWk9Y2xhc3N7YXN5bmMgaW5pdCgpe31hc3luYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcih0LG8pe2xldCBlPW5ldyBTbyhvKTtyZXR1cm4gdHlwZW9mIHQ9PVwic3RyaW5nXCI/YXdhaXQgZS5sb2FkTW9kZWwodCk6YXdhaXQgZS5sb2FkTW9kZWwodCksbmV3IEFvKGUpfX0sbmc9bmV3IFFpfSk7dmFyIGVhPXt9O1ByKGVhLHtjcmVhdGVSZWFkU3RyZWFtOigpPT5BcCxyZWFkRmlsZTooKT0+b2cscmVhZEZpbGVTeW5jOigpPT5pZ30pO3ZhciBvZyxpZyxBcCx0YT1FKCgpPT57b2c9dm9pZCAwLGlnPXZvaWQgMCxBcD12b2lkIDB9KTt2YXIgcmE9e307UHIocmEse2pvaW46KCk9PmFnfSk7dmFyIGFnLG5hPUUoKCk9PnthZz12b2lkIDB9KTt2YXIgRHA9bWUoKEVwLG9hKT0+e1widXNlIHN0cmljdFwiO3ZhciBQcD0oKCk9Pnt2YXIgYT10eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwO3JldHVybiB0eXBlb2YgX19maWxlbmFtZTxcInVcIiYmKGE9YXx8X19maWxlbmFtZSksZnVuY3Rpb24odD17fSl7dmFyIG89dCxlLHI7by5yZWFkeT1uZXcgUHJvbWlzZSgoYix4KT0+e2U9YixyPXh9KTt2YXIgbj1PYmplY3QuYXNzaWduKHt9LG8pLHM9XCIuL3RoaXMucHJvZ3JhbVwiLGk9dHlwZW9mIHdpbmRvdz09XCJvYmplY3RcIix1PXR5cGVvZiBpbXBvcnRTY3JpcHRzPT1cImZ1bmN0aW9uXCIsbD10eXBlb2YgcHJvY2Vzcz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnM9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PVwic3RyaW5nXCIsZj1cIlwiLHAsZCxUO2lmKGwpe3ZhciB2PSh0YSgpLG9yKGVhKSksdz0obmEoKSxvcihyYSkpO2Y9dT93LmRpcm5hbWUoZikrXCIvXCI6X19kaXJuYW1lK1wiL1wiLHA9KGIseCk9PihiPVN0KGIpP25ldyBVUkwoYik6dy5ub3JtYWxpemUoYiksdi5yZWFkRmlsZVN5bmMoYix4P3ZvaWQgMDpcInV0ZjhcIikpLFQ9Yj0+KGI9cChiLCEwKSxiLmJ1ZmZlcnx8KGI9bmV3IFVpbnQ4QXJyYXkoYikpLGIpLGQ9KGIseCxfLEQ9ITApPT57Yj1TdChiKT9uZXcgVVJMKGIpOncubm9ybWFsaXplKGIpLHYucmVhZEZpbGUoYixEP3ZvaWQgMDpcInV0ZjhcIiwoRyxYKT0+e0c/XyhHKTp4KEQ/WC5idWZmZXI6WCl9KX0sIW8udGhpc1Byb2dyYW0mJjE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKHM9cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSxvLmluc3BlY3Q9KCk9PlwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn1lbHNlKGl8fHUpJiYodT9mPXNlbGYubG9jYXRpb24uaHJlZjp0eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihmPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxhJiYoZj1hKSxmLmluZGV4T2YoXCJibG9iOlwiKSE9PTA/Zj1mLnN1YnN0cigwLGYucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6Zj1cIlwiLHA9Yj0+e3ZhciB4PW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4geC5vcGVuKFwiR0VUXCIsYiwhMSkseC5zZW5kKG51bGwpLHgucmVzcG9uc2VUZXh0fSx1JiYoVD1iPT57dmFyIHg9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB4Lm9wZW4oXCJHRVRcIixiLCExKSx4LnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIseC5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KHgucmVzcG9uc2UpfSksZD0oYix4LF8pPT57dmFyIEQ9bmV3IFhNTEh0dHBSZXF1ZXN0O0Qub3BlbihcIkdFVFwiLGIsITApLEQucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixELm9ubG9hZD0oKT0+e0Quc3RhdHVzPT0yMDB8fEQuc3RhdHVzPT0wJiZELnJlc3BvbnNlP3goRC5yZXNwb25zZSk6XygpfSxELm9uZXJyb3I9XyxELnNlbmQobnVsbCl9KTt2YXIgST1jb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLEw9Y29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO09iamVjdC5hc3NpZ24obyxuKSxuPW51bGwsdHlwZW9mIFdlYkFzc2VtYmx5IT1cIm9iamVjdFwiJiZ0ZShcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIEYsQz0hMSxZLGosTSxpZSxvdDtmdW5jdGlvbiBXZSgpe3ZhciBiPUYuYnVmZmVyO28uSEVBUDg9WT1uZXcgSW50OEFycmF5KGIpLG8uSEVBUDE2PW5ldyBJbnQxNkFycmF5KGIpLG8uSEVBUFU4PWo9bmV3IFVpbnQ4QXJyYXkoYiksby5IRUFQVTE2PW5ldyBVaW50MTZBcnJheShiKSxvLkhFQVAzMj1NPW5ldyBJbnQzMkFycmF5KGIpLG8uSEVBUFUzMj1pZT1uZXcgVWludDMyQXJyYXkoYiksby5IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkoYiksby5IRUFQRjY0PW90PW5ldyBGbG9hdDY0QXJyYXkoYil9dmFyIEZlPVtdLFY9W10sQWU9W10sSXQ9MCxtdD1udWxsLEJlPW51bGw7ZnVuY3Rpb24gdGUoYil7dGhyb3cgYj1cIkFib3J0ZWQoXCIrYitcIilcIixMKGIpLEM9ITAsYj1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKGIrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLHIoYiksYn12YXIgYnQ9Yj0+Yi5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKSxTdD1iPT5iLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpLEhlO2lmKEhlPVwib3J0LXdhc20ud2FzbVwiLCFidChIZSkpe3ZhciBBdD1IZTtIZT1vLmxvY2F0ZUZpbGU/by5sb2NhdGVGaWxlKEF0LGYpOmYrQXR9ZnVuY3Rpb24gd2UoYil7aWYoVClyZXR1cm4gVChiKTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1mdW5jdGlvbiBaZShiKXtpZihpfHx1KXtpZih0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIiYmIVN0KGIpKXJldHVybiBmZXRjaChiLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKHg9PntpZigheC5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnXCIrYitcIidcIjtyZXR1cm4geC5hcnJheUJ1ZmZlcigpfSkuY2F0Y2goKCk9PndlKGIpKTtpZihkKXJldHVybiBuZXcgUHJvbWlzZSgoeCxfKT0+e2QoYixEPT54KG5ldyBVaW50OEFycmF5KEQpKSxfKX0pfXJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT53ZShiKSl9ZnVuY3Rpb24gUXQoYix4LF8pe3JldHVybiBaZShiKS50aGVuKEQ9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKEQseCkpLnRoZW4oRD0+RCkudGhlbihfLEQ9PntMKGBmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAke0R9YCksdGUoRCl9KX1mdW5jdGlvbiBQdChiLHgpe3ZhciBfPUhlO3JldHVybiB0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmchPVwiZnVuY3Rpb25cInx8YnQoXyl8fFN0KF8pfHxsfHx0eXBlb2YgZmV0Y2ghPVwiZnVuY3Rpb25cIj9RdChfLGIseCk6ZmV0Y2goXyx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihEPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhELGIpLnRoZW4oeCxmdW5jdGlvbihHKXtyZXR1cm4gTChgd2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICR7R31gKSxMKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksUXQoXyxiLHgpfSkpfXZhciBndCx5dD17OTIwMDE2OihiLHgsXyxEKT0+e2lmKHR5cGVvZiBvPlwidVwifHwhby56YSlyZXR1cm4gMTtpZihiPXZlKGI+Pj4wKSxiLnN0YXJ0c1dpdGgoXCIuL1wiKSYmKGI9Yi5zdWJzdHJpbmcoMikpLGI9by56YS5nZXQoYiksIWIpcmV0dXJuIDI7aWYoeD4+Pj0wLF8+Pj49MCx4K18+Yi5ieXRlTGVuZ3RoKXJldHVybiAzO3RyeXtyZXR1cm4gai5zZXQoYi5zdWJhcnJheSh4LHgrXyksRD4+PjA+Pj4wKSwwfWNhdGNoe3JldHVybiA0fX19O2Z1bmN0aW9uIGVyKGIpe3RoaXMueGE9Yi0yNCx0aGlzLkhhPWZ1bmN0aW9uKHgpe2llW3RoaXMueGErND4+PjI+Pj4wXT14fSx0aGlzLkdhPWZ1bmN0aW9uKHgpe2llW3RoaXMueGErOD4+PjI+Pj4wXT14fSx0aGlzLkFhPWZ1bmN0aW9uKHgsXyl7dGhpcy5GYSgpLHRoaXMuSGEoeCksdGhpcy5HYShfKX0sdGhpcy5GYT1mdW5jdGlvbigpe2llW3RoaXMueGErMTY+Pj4yPj4+MF09MH19dmFyIFFlPTAsRXQ9MCxNdD10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDAsJGU9KGIseCxfKT0+e3g+Pj49MDt2YXIgRD14K187Zm9yKF89eDtiW19dJiYhKF8+PUQpOykrK187aWYoMTY8Xy14JiZiLmJ1ZmZlciYmTXQpcmV0dXJuIE10LmRlY29kZShiLnN1YmFycmF5KHgsXykpO2ZvcihEPVwiXCI7eDxfOyl7dmFyIEc9Ylt4KytdO2lmKEcmMTI4KXt2YXIgWD1iW3grK10mNjM7aWYoKEcmMjI0KT09MTkyKUQrPVN0cmluZy5mcm9tQ2hhckNvZGUoKEcmMzEpPDw2fFgpO2Vsc2V7dmFyIG5lPWJbeCsrXSY2MztHPShHJjI0MCk9PTIyND8oRyYxNSk8PDEyfFg8PDZ8bmU6KEcmNyk8PDE4fFg8PDEyfG5lPDw2fGJbeCsrXSY2Myw2NTUzNj5HP0QrPVN0cmluZy5mcm9tQ2hhckNvZGUoRyk6KEctPTY1NTM2LEQrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Rz4+MTAsNTYzMjB8RyYxMDIzKSl9fWVsc2UgRCs9U3RyaW5nLmZyb21DaGFyQ29kZShHKX1yZXR1cm4gRH0sdmU9KGIseCk9PihiPj4+PTApPyRlKGosYix4KTpcIlwiLHFlPWI9Pntmb3IodmFyIHg9MCxfPTA7XzxiLmxlbmd0aDsrK18pe3ZhciBEPWIuY2hhckNvZGVBdChfKTsxMjc+PUQ/eCsrOjIwNDc+PUQ/eCs9Mjo1NTI5Njw9RCYmNTczNDM+PUQ/KHgrPTQsKytfKTp4Kz0zfXJldHVybiB4fSxHdD0oYix4LF8sRCk9PntpZihfPj4+PTAsISgwPEQpKXJldHVybiAwO3ZhciBHPV87RD1fK0QtMTtmb3IodmFyIFg9MDtYPGIubGVuZ3RoOysrWCl7dmFyIG5lPWIuY2hhckNvZGVBdChYKTtpZig1NTI5Njw9bmUmJjU3MzQzPj1uZSl7dmFyIGtlPWIuY2hhckNvZGVBdCgrK1gpO25lPTY1NTM2KygobmUmMTAyMyk8PDEwKXxrZSYxMDIzfWlmKDEyNz49bmUpe2lmKF8+PUQpYnJlYWs7eFtfKys+Pj4wXT1uZX1lbHNle2lmKDIwNDc+PW5lKXtpZihfKzE+PUQpYnJlYWs7eFtfKys+Pj4wXT0xOTJ8bmU+PjZ9ZWxzZXtpZig2NTUzNT49bmUpe2lmKF8rMj49RClicmVhazt4W18rKz4+PjBdPTIyNHxuZT4+MTJ9ZWxzZXtpZihfKzM+PUQpYnJlYWs7eFtfKys+Pj4wXT0yNDB8bmU+PjE4LHhbXysrPj4+MF09MTI4fG5lPj4xMiY2M314W18rKz4+PjBdPTEyOHxuZT4+NiY2M314W18rKz4+PjBdPTEyOHxuZSY2M319cmV0dXJuIHhbXz4+PjBdPTAsXy1HfSxEdD1iPT5iJTQ9PT0wJiYoYiUxMDAhPT0wfHxiJTQwMD09PTApLGpyPVswLDMxLDYwLDkxLDEyMSwxNTIsMTgyLDIxMywyNDQsMjc0LDMwNSwzMzVdLHduPVswLDMxLDU5LDkwLDEyMCwxNTEsMTgxLDIxMiwyNDMsMjczLDMwNCwzMzRdLFV0PWI9Pnt2YXIgeD1xZShiKSsxLF89X24oeCk7cmV0dXJuIF8mJkd0KGIsaixfLHgpLF99LHZyPVtdLHF0PXt9LF9yPSgpPT57aWYoIU9yKXt2YXIgYj17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzoodHlwZW9mIG5hdmlnYXRvcj09XCJvYmplY3RcIiYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzpzfHxcIi4vdGhpcy5wcm9ncmFtXCJ9LHg7Zm9yKHggaW4gcXQpcXRbeF09PT12b2lkIDA/ZGVsZXRlIGJbeF06Ylt4XT1xdFt4XTt2YXIgXz1bXTtmb3IoeCBpbiBiKV8ucHVzaChgJHt4fT0ke2JbeF19YCk7T3I9X31yZXR1cm4gT3J9LE9yLHRyPVtudWxsLFtdLFtdXSxZcj1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLFhyPVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24gSXIoYil7dmFyIHg9QXJyYXkocWUoYikrMSk7cmV0dXJuIEd0KGIseCwwLHgubGVuZ3RoKSx4fWZ1bmN0aW9uIHZuKGIseCxfLEQpe2Z1bmN0aW9uIEcoQSxwZSxUZSl7Zm9yKEE9dHlwZW9mIEE9PVwibnVtYmVyXCI/QS50b1N0cmluZygpOkF8fFwiXCI7QS5sZW5ndGg8cGU7KUE9VGVbMF0rQTtyZXR1cm4gQX1mdW5jdGlvbiBYKEEscGUpe3JldHVybiBHKEEscGUsXCIwXCIpfWZ1bmN0aW9uIG5lKEEscGUpe2Z1bmN0aW9uIFRlKGVuKXtyZXR1cm4gMD5lbj8tMTowPGVuPzE6MH12YXIgTHQ7cmV0dXJuKEx0PVRlKEEuZ2V0RnVsbFllYXIoKS1wZS5nZXRGdWxsWWVhcigpKSk9PT0wJiYoTHQ9VGUoQS5nZXRNb250aCgpLXBlLmdldE1vbnRoKCkpKT09PTAmJihMdD1UZShBLmdldERhdGUoKS1wZS5nZXREYXRlKCkpKSxMdH1mdW5jdGlvbiBrZShBKXtzd2l0Y2goQS5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZShBLmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiBBO2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUoQS5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZShBLmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKEEuZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUoQS5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUoQS5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBZZShBKXt2YXIgcGU9QS50YTtmb3IoQT1uZXcgRGF0ZShuZXcgRGF0ZShBLnVhKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8cGU7KXt2YXIgVGU9QS5nZXRNb250aCgpLEx0PShEdChBLmdldEZ1bGxZZWFyKCkpP1lyOlhyKVtUZV07aWYocGU+THQtQS5nZXREYXRlKCkpcGUtPUx0LUEuZ2V0RGF0ZSgpKzEsQS5zZXREYXRlKDEpLDExPlRlP0Euc2V0TW9udGgoVGUrMSk6KEEuc2V0TW9udGgoMCksQS5zZXRGdWxsWWVhcihBLmdldEZ1bGxZZWFyKCkrMSkpO2Vsc2V7QS5zZXREYXRlKEEuZ2V0RGF0ZSgpK3BlKTticmVha319cmV0dXJuIFRlPW5ldyBEYXRlKEEuZ2V0RnVsbFllYXIoKSsxLDAsNCkscGU9a2UobmV3IERhdGUoQS5nZXRGdWxsWWVhcigpLDAsNCkpLFRlPWtlKFRlKSwwPj1uZShwZSxBKT8wPj1uZShUZSxBKT9BLmdldEZ1bGxZZWFyKCkrMTpBLmdldEZ1bGxZZWFyKCk6QS5nZXRGdWxsWWVhcigpLTF9Yj4+Pj0wLHg+Pj49MCxfPj4+PTAsRD4+Pj0wO3ZhciBVZT1pZVtEKzQwPj4+Mj4+PjBdO0Q9e0RhOk1bRD4+PjI+Pj4wXSxDYTpNW0QrND4+PjI+Pj4wXSx2YTpNW0QrOD4+PjI+Pj4wXSx5YTpNW0QrMTI+Pj4yPj4+MF0sd2E6TVtEKzE2Pj4+Mj4+PjBdLHVhOk1bRCsyMD4+PjI+Pj4wXSxvYTpNW0QrMjQ+Pj4yPj4+MF0sdGE6TVtEKzI4Pj4+Mj4+PjBdLElhOk1bRCszMj4+PjI+Pj4wXSxCYTpNW0QrMzY+Pj4yPj4+MF0sRWE6VWU/dmUoVWUpOlwiXCJ9LF89dmUoXyksVWU9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifTtmb3IodmFyIHplIGluIFVlKV89Xy5yZXBsYWNlKG5ldyBSZWdFeHAoemUsXCJnXCIpLFVlW3plXSk7dmFyIFpyPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksUXI9XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpO1VlPXtcIiVhXCI6QT0+WnJbQS5vYV0uc3Vic3RyaW5nKDAsMyksXCIlQVwiOkE9PlpyW0Eub2FdLFwiJWJcIjpBPT5RcltBLndhXS5zdWJzdHJpbmcoMCwzKSxcIiVCXCI6QT0+UXJbQS53YV0sXCIlQ1wiOkE9PlgoKEEudWErMTkwMCkvMTAwfDAsMiksXCIlZFwiOkE9PlgoQS55YSwyKSxcIiVlXCI6QT0+RyhBLnlhLDIsXCIgXCIpLFwiJWdcIjpBPT5ZZShBKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVHXCI6QT0+WWUoQSksXCIlSFwiOkE9PlgoQS52YSwyKSxcIiVJXCI6QT0+KEE9QS52YSxBPT0wP0E9MTI6MTI8QSYmKEEtPTEyKSxYKEEsMikpLFwiJWpcIjpBPT57Zm9yKHZhciBwZT0wLFRlPTA7VGU8PUEud2EtMTtwZSs9KER0KEEudWErMTkwMCk/WXI6WHIpW1RlKytdKTtyZXR1cm4gWChBLnlhK3BlLDMpfSxcIiVtXCI6QT0+WChBLndhKzEsMiksXCIlTVwiOkE9PlgoQS5DYSwyKSxcIiVuXCI6KCk9PmBcbmAsXCIlcFwiOkE9PjA8PUEudmEmJjEyPkEudmE/XCJBTVwiOlwiUE1cIixcIiVTXCI6QT0+WChBLkRhLDIpLFwiJXRcIjooKT0+XCJcdFwiLFwiJXVcIjpBPT5BLm9hfHw3LFwiJVVcIjpBPT5YKE1hdGguZmxvb3IoKEEudGErNy1BLm9hKS83KSwyKSxcIiVWXCI6QT0+e3ZhciBwZT1NYXRoLmZsb29yKChBLnRhKzctKEEub2ErNiklNykvNyk7aWYoMj49KEEub2ErMzcxLUEudGEtMiklNyYmcGUrKyxwZSlwZT09NTMmJihUZT0oQS5vYSszNzEtQS50YSklNyxUZT09NHx8VGU9PTMmJkR0KEEudWEpfHwocGU9MSkpO2Vsc2V7cGU9NTI7dmFyIFRlPShBLm9hKzctQS50YS0xKSU3OyhUZT09NHx8VGU9PTUmJkR0KEEudWElNDAwLTEpKSYmcGUrK31yZXR1cm4gWChwZSwyKX0sXCIld1wiOkE9PkEub2EsXCIlV1wiOkE9PlgoTWF0aC5mbG9vcigoQS50YSs3LShBLm9hKzYpJTcpLzcpLDIpLFwiJXlcIjpBPT4oQS51YSsxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVZXCI6QT0+QS51YSsxOTAwLFwiJXpcIjpBPT57QT1BLkJhO3ZhciBwZT0wPD1BO3JldHVybiBBPU1hdGguYWJzKEEpLzYwLChwZT9cIitcIjpcIi1cIikrKFwiMDAwMFwiKyhBLzYwKjEwMCtBJTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6QT0+QS5FYSxcIiUlXCI6KCk9PlwiJVwifSxfPV8ucmVwbGFjZSgvJSUvZyxcIlxcMFxcMFwiKTtmb3IoemUgaW4gVWUpXy5pbmNsdWRlcyh6ZSkmJihfPV8ucmVwbGFjZShuZXcgUmVnRXhwKHplLFwiZ1wiKSxVZVt6ZV0oRCkpKTtyZXR1cm4gXz1fLnJlcGxhY2UoL1xcMFxcMC9nLFwiJVwiKSx6ZT1JcihfKSx6ZS5sZW5ndGg+eD8wOihZLnNldCh6ZSxiPj4+MCksemUubGVuZ3RoLTEpfXZhciBoZT17YTpmdW5jdGlvbihiLHgsXyl7dGhyb3cgYj4+Pj0wLG5ldyBlcihiKS5BYSh4Pj4+MCxfPj4+MCksUWU9YixFdCsrLFFlfSxlOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LEg6ZnVuY3Rpb24oKXt9LHg6ZnVuY3Rpb24oKXt9LHo6ZnVuY3Rpb24oKXt9LEo6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sRjpmdW5jdGlvbigpe30sQTpmdW5jdGlvbigpe30sRTpmdW5jdGlvbigpe30sZzpmdW5jdGlvbigpe30seTpmdW5jdGlvbigpe30sdjpmdW5jdGlvbigpe30sRzpmdW5jdGlvbigpe30sdzpmdW5jdGlvbigpe30sazooKT0+MSxuOmZ1bmN0aW9uKGIseCxfKXtiPXgrMjA5NzE1Mj4+PjA8NDE5NDMwNS0hIWI/KGI+Pj4wKSs0Mjk0OTY3Mjk2Kng6TmFOLF8+Pj49MCxiPW5ldyBEYXRlKDFlMypiKSxNW18+Pj4yPj4+MF09Yi5nZXRVVENTZWNvbmRzKCksTVtfKzQ+Pj4yPj4+MF09Yi5nZXRVVENNaW51dGVzKCksTVtfKzg+Pj4yPj4+MF09Yi5nZXRVVENIb3VycygpLE1bXysxMj4+PjI+Pj4wXT1iLmdldFVUQ0RhdGUoKSxNW18rMTY+Pj4yPj4+MF09Yi5nZXRVVENNb250aCgpLE1bXysyMD4+PjI+Pj4wXT1iLmdldFVUQ0Z1bGxZZWFyKCktMTkwMCxNW18rMjQ+Pj4yPj4+MF09Yi5nZXRVVENEYXkoKSxNW18rMjg+Pj4yPj4+MF09KGIuZ2V0VGltZSgpLURhdGUuVVRDKGIuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDB9LG86ZnVuY3Rpb24oYix4LF8pe2I9eCsyMDk3MTUyPj4+MDw0MTk0MzA1LSEhYj8oYj4+PjApKzQyOTQ5NjcyOTYqeDpOYU4sXz4+Pj0wLGI9bmV3IERhdGUoMWUzKmIpLE1bXz4+PjI+Pj4wXT1iLmdldFNlY29uZHMoKSxNW18rND4+PjI+Pj4wXT1iLmdldE1pbnV0ZXMoKSxNW18rOD4+PjI+Pj4wXT1iLmdldEhvdXJzKCksTVtfKzEyPj4+Mj4+PjBdPWIuZ2V0RGF0ZSgpLE1bXysxNj4+PjI+Pj4wXT1iLmdldE1vbnRoKCksTVtfKzIwPj4+Mj4+PjBdPWIuZ2V0RnVsbFllYXIoKS0xOTAwLE1bXysyND4+PjI+Pj4wXT1iLmdldERheSgpLE1bXysyOD4+PjI+Pj4wXT0oRHQoYi5nZXRGdWxsWWVhcigpKT9qcjp3bilbYi5nZXRNb250aCgpXStiLmdldERhdGUoKS0xfDAsTVtfKzM2Pj4+Mj4+PjBdPS0oNjAqYi5nZXRUaW1lem9uZU9mZnNldCgpKSx4PW5ldyBEYXRlKGIuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIEQ9bmV3IERhdGUoYi5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtNW18rMzI+Pj4yPj4+MF09KHghPUQmJmIuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4oRCx4KSl8MH0scDpmdW5jdGlvbihiKXtiPj4+PTA7dmFyIHg9bmV3IERhdGUoTVtiKzIwPj4+Mj4+PjBdKzE5MDAsTVtiKzE2Pj4+Mj4+PjBdLE1bYisxMj4+PjI+Pj4wXSxNW2IrOD4+PjI+Pj4wXSxNW2IrND4+PjI+Pj4wXSxNW2I+Pj4yPj4+MF0sMCksXz1NW2IrMzI+Pj4yPj4+MF0sRD14LmdldFRpbWV6b25lT2Zmc2V0KCksRz1uZXcgRGF0ZSh4LmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLFg9bmV3IERhdGUoeC5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxuZT1NYXRoLm1pbihYLEcpO3JldHVybiAwPl8/TVtiKzMyPj4+Mj4+PjBdPSsoRyE9WCYmbmU9PUQpOjA8XyE9KG5lPT1EKSYmKEc9TWF0aC5tYXgoWCxHKSx4LnNldFRpbWUoeC5nZXRUaW1lKCkrNmU0KigoMDxfP25lOkcpLUQpKSksTVtiKzI0Pj4+Mj4+PjBdPXguZ2V0RGF5KCksTVtiKzI4Pj4+Mj4+PjBdPShEdCh4LmdldEZ1bGxZZWFyKCkpP2pyOnduKVt4LmdldE1vbnRoKCldK3guZ2V0RGF0ZSgpLTF8MCxNW2I+Pj4yPj4+MF09eC5nZXRTZWNvbmRzKCksTVtiKzQ+Pj4yPj4+MF09eC5nZXRNaW51dGVzKCksTVtiKzg+Pj4yPj4+MF09eC5nZXRIb3VycygpLE1bYisxMj4+PjI+Pj4wXT14LmdldERhdGUoKSxNW2IrMTY+Pj4yPj4+MF09eC5nZXRNb250aCgpLE1bYisyMD4+PjI+Pj4wXT14LmdldFllYXIoKSxiPXguZ2V0VGltZSgpLGlzTmFOKGIpPyhNW1NyKCk+Pj4yPj4+MF09NjEsYj0tMSk6Yi89MWUzLEtyKChndD1iLDE8PStNYXRoLmFicyhndCk/MDxndD8rTWF0aC5mbG9vcihndC80Mjk0OTY3Mjk2KT4+PjA6fn4rTWF0aC5jZWlsKChndC0rKH5+Z3Q+Pj4wKSkvNDI5NDk2NzI5Nik+Pj4wOjApKSxiPj4+MH0sbDpmdW5jdGlvbigpe3JldHVybi01Mn0sbTpmdW5jdGlvbigpe30sdDpmdW5jdGlvbihiLHgsXyl7ZnVuY3Rpb24gRChZZSl7cmV0dXJuKFllPVllLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLykpP1llWzFdOlwiR01UXCJ9Xz4+Pj0wO3ZhciBHPW5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSxYPW5ldyBEYXRlKEcsMCwxKSxuZT1uZXcgRGF0ZShHLDYsMSk7Rz1YLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGtlPW5lLmdldFRpbWV6b25lT2Zmc2V0KCk7aWVbYj4+PjA+Pj4yPj4+MF09NjAqTWF0aC5tYXgoRyxrZSksTVt4Pj4+MD4+PjI+Pj4wXT0rKEchPWtlKSxiPUQoWCkseD1EKG5lKSxiPVV0KGIpLHg9VXQoeCksa2U8Rz8oaWVbXz4+PjI+Pj4wXT1iLGllW18rND4+PjI+Pj4wXT14KTooaWVbXz4+PjI+Pj4wXT14LGllW18rND4+PjI+Pj4wXT1iKX0sZDooKT0+e3RlKFwiXCIpfSxCOmZ1bmN0aW9uKGIseCxfKXtiPj4+PTAseD4+Pj0wLF8+Pj49MCx2ci5sZW5ndGg9MDtmb3IodmFyIEQ7RD1qW3grKz4+PjBdOyl7dmFyIEc9RCE9MTA1O0cmPUQhPTExMixfKz1HJiZfJTg/NDowLHZyLnB1c2goRD09MTEyP2llW18+Pj4yPj4+MF06RD09MTA1P01bXz4+PjI+Pj4wXTpvdFtfPj4+Mz4+PjBdKSxfKz1HPzg6NH1yZXR1cm4geXRbYl0uYXBwbHkobnVsbCx2cil9LGg6KCk9PkRhdGUubm93KCksdTpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTAxNzYwfSxiOigpPT5wZXJmb3JtYW5jZS5ub3coKSxJOmZ1bmN0aW9uKGIseCxfKXtyZXR1cm4geD4+Pj0wLGouY29weVdpdGhpbihiPj4+MD4+PjAseD4+PjAseCsoXz4+PjApPj4+MCl9LHM6ZnVuY3Rpb24oYil7Yj4+Pj0wO3ZhciB4PWoubGVuZ3RoO2lmKDQyOTQ5MDE3NjA8YilyZXR1cm4hMTtmb3IodmFyIF89MTs0Pj1fO18qPTIpe3ZhciBEPXgqKDErLjIvXyk7RD1NYXRoLm1pbihELGIrMTAwNjYzMjk2KTt2YXIgRz1NYXRoO0Q9TWF0aC5tYXgoYixEKTtlOntHPShHLm1pbi5jYWxsKEcsNDI5NDkwMTc2MCxEKyg2NTUzNi1EJTY1NTM2KSU2NTUzNiktRi5idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNSkvNjU1MzY7dHJ5e0YuZ3JvdyhHKSxXZSgpO3ZhciBYPTE7YnJlYWsgZX1jYXRjaHt9WD12b2lkIDB9aWYoWClyZXR1cm4hMH1yZXR1cm4hMX0sQzpmdW5jdGlvbihiLHgpe2I+Pj49MCx4Pj4+PTA7dmFyIF89MDtyZXR1cm4gX3IoKS5mb3JFYWNoKChELEcpPT57dmFyIFg9eCtfO2ZvcihHPWllW2IrNCpHPj4+Mj4+PjBdPVgsWD0wO1g8RC5sZW5ndGg7KytYKVlbRysrPj4+MD4+PjBdPUQuY2hhckNvZGVBdChYKTtZW0c+Pj4wPj4+MF09MCxfKz1ELmxlbmd0aCsxfSksMH0sRDpmdW5jdGlvbihiLHgpe2I+Pj49MCx4Pj4+PTA7dmFyIF89X3IoKTtpZVtiPj4+Mj4+PjBdPV8ubGVuZ3RoO3ZhciBEPTA7cmV0dXJuIF8uZm9yRWFjaChHPT5EKz1HLmxlbmd0aCsxKSxpZVt4Pj4+Mj4+PjBdPUQsMH0sZjooKT0+NTIsajpmdW5jdGlvbigpe3JldHVybiA1Mn0scTpmdW5jdGlvbigpe3JldHVybiA3MH0saTpmdW5jdGlvbihiLHgsXyxEKXt4Pj4+PTAsXz4+Pj0wLEQ+Pj49MDtmb3IodmFyIEc9MCxYPTA7WDxfO1grKyl7dmFyIG5lPWllW3g+Pj4yPj4+MF0sa2U9aWVbeCs0Pj4+Mj4+PjBdO3grPTg7Zm9yKHZhciBZZT0wO1llPGtlO1llKyspe3ZhciBVZT1qW25lK1llPj4+MF0semU9dHJbYl07VWU9PT0wfHxVZT09PTEwPygoYj09PTE/STpMKSgkZSh6ZSwwKSksemUubGVuZ3RoPTApOnplLnB1c2goVWUpfUcrPWtlfXJldHVybiBpZVtEPj4+Mj4+PjBdPUcsMH0scjp2bixjOmZ1bmN0aW9uKGIseCxfLEQpe3JldHVybiB2bihiPj4+MCx4Pj4+MCxfPj4+MCxEPj4+MCl9fSxRPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihfKXtyZXR1cm4gUT1fLmV4cG9ydHMsUT1JbigpLEY9US5LLFdlKCksVi51bnNoaWZ0KFEuTCksSXQtLSxJdD09MCYmKG10IT09bnVsbCYmKGNsZWFySW50ZXJ2YWwobXQpLG10PW51bGwpLEJlJiYoXz1CZSxCZT1udWxsLF8oKSkpLFF9dmFyIHg9e2E6aGV9O2lmKEl0Kyssby5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBvLmluc3RhbnRpYXRlV2FzbSh4LGIpfWNhdGNoKF8pe0woYE1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6ICR7X31gKSxyKF8pfXJldHVybiBQdCh4LGZ1bmN0aW9uKF8pe2IoXy5pbnN0YW5jZSl9KS5jYXRjaChyKSx7fX0oKTtvLl9PcnRJbml0PShiLHgpPT4oby5fT3J0SW5pdD1RLk0pKGIseCksby5fT3J0R2V0TGFzdEVycm9yPShiLHgpPT4oby5fT3J0R2V0TGFzdEVycm9yPVEuTikoYix4KSxvLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz0oYix4LF8sRCxHLFgsbmUsa2UsWWUsVWUpPT4oby5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9US5PKShiLHgsXyxELEcsWCxuZSxrZSxZZSxVZSksby5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9KGIseCk9PihvLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj1RLlApKGIseCksby5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPShiLHgsXyk9PihvLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9US5RKShiLHgsXyksby5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PShiLHgsXyk9PihvLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9US5SKShiLHgsXyksby5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWI9PihvLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9US5TKShiKSxvLl9PcnRDcmVhdGVTZXNzaW9uPShiLHgsXyk9PihvLl9PcnRDcmVhdGVTZXNzaW9uPVEuVCkoYix4LF8pLG8uX09ydFJlbGVhc2VTZXNzaW9uPWI9PihvLl9PcnRSZWxlYXNlU2Vzc2lvbj1RLlUpKGIpLG8uX09ydEdldElucHV0T3V0cHV0Q291bnQ9KGIseCxfKT0+KG8uX09ydEdldElucHV0T3V0cHV0Q291bnQ9US5WKShiLHgsXyksby5fT3J0R2V0SW5wdXROYW1lPShiLHgpPT4oby5fT3J0R2V0SW5wdXROYW1lPVEuVykoYix4KSxvLl9PcnRHZXRPdXRwdXROYW1lPShiLHgpPT4oby5fT3J0R2V0T3V0cHV0TmFtZT1RLlgpKGIseCksby5fT3J0RnJlZT1iPT4oby5fT3J0RnJlZT1RLlkpKGIpLG8uX09ydENyZWF0ZVRlbnNvcj0oYix4LF8sRCxHLFgpPT4oby5fT3J0Q3JlYXRlVGVuc29yPVEuWikoYix4LF8sRCxHLFgpLG8uX09ydEdldFRlbnNvckRhdGE9KGIseCxfLEQsRyk9PihvLl9PcnRHZXRUZW5zb3JEYXRhPVEuXykoYix4LF8sRCxHKSxvLl9PcnRSZWxlYXNlVGVuc29yPWI9PihvLl9PcnRSZWxlYXNlVGVuc29yPVEuJCkoYiksby5fT3J0Q3JlYXRlUnVuT3B0aW9ucz0oYix4LF8sRCk9PihvLl9PcnRDcmVhdGVSdW5PcHRpb25zPVEuYWEpKGIseCxfLEQpLG8uX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PShiLHgsXyk9PihvLl9PcnRBZGRSdW5Db25maWdFbnRyeT1RLmJhKShiLHgsXyksby5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9Yj0+KG8uX09ydFJlbGVhc2VSdW5PcHRpb25zPVEuY2EpKGIpLG8uX09ydENyZWF0ZUJpbmRpbmc9Yj0+KG8uX09ydENyZWF0ZUJpbmRpbmc9US5kYSkoYiksby5fT3J0QmluZElucHV0PShiLHgsXyk9PihvLl9PcnRCaW5kSW5wdXQ9US5lYSkoYix4LF8pLG8uX09ydEJpbmRPdXRwdXQ9KGIseCxfLEQpPT4oby5fT3J0QmluZE91dHB1dD1RLmZhKShiLHgsXyxEKSxvLl9PcnRDbGVhckJvdW5kT3V0cHV0cz1iPT4oby5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9US5nYSkoYiksby5fT3J0UmVsZWFzZUJpbmRpbmc9Yj0+KG8uX09ydFJlbGVhc2VCaW5kaW5nPVEuaGEpKGIpLG8uX09ydFJ1bldpdGhCaW5kaW5nPShiLHgsXyxELEcpPT4oby5fT3J0UnVuV2l0aEJpbmRpbmc9US5pYSkoYix4LF8sRCxHKSxvLl9PcnRSdW49KGIseCxfLEQsRyxYLG5lLGtlKT0+KG8uX09ydFJ1bj1RLmphKShiLHgsXyxELEcsWCxuZSxrZSksby5fT3J0RW5kUHJvZmlsaW5nPWI9PihvLl9PcnRFbmRQcm9maWxpbmc9US5rYSkoYik7dmFyIFNyPSgpPT4oU3I9US5sYSkoKSxfbj1vLl9tYWxsb2M9Yj0+KF9uPW8uX21hbGxvYz1RLm1hKShiKTtvLl9mcmVlPWI9PihvLl9mcmVlPVEubmEpKGIpO3ZhciBLcj1iPT4oS3I9US5wYSkoYiksT249KCk9PihPbj1RLnFhKSgpLEo9Yj0+KEo9US5yYSkoYikscnI9Yj0+KHJyPVEuc2EpKGIpO2Z1bmN0aW9uIEluKCl7dmFyIGI9UTtiPU9iamVjdC5hc3NpZ24oe30sYik7dmFyIHg9RD0+KCk9PkQoKT4+PjAsXz1EPT5HPT5EKEcpPj4+MDtyZXR1cm4gYi5sYT14KGIubGEpLGIubWE9XyhiLm1hKSxiLnFhPXgoYi5xYSksYi5zYT1fKGIuc2EpLGJ9by5zdGFja0FsbG9jPXJyLG8uc3RhY2tTYXZlPU9uLG8uc3RhY2tSZXN0b3JlPUosby5VVEY4VG9TdHJpbmc9dmUsby5zdHJpbmdUb1VURjg9KGIseCxfKT0+R3QoYixqLHgsXyksby5sZW5ndGhCeXRlc1VURjg9cWU7dmFyIHp0O0JlPWZ1bmN0aW9uIGIoKXt6dHx8SnIoKSx6dHx8KEJlPWIpfTtmdW5jdGlvbiBKcigpe2lmKCEoMDxJdCkpe2lmKG8ucHJlUnVuKWZvcih0eXBlb2Ygby5wcmVSdW49PVwiZnVuY3Rpb25cIiYmKG8ucHJlUnVuPVtvLnByZVJ1bl0pO28ucHJlUnVuLmxlbmd0aDspe3ZhciBiPW8ucHJlUnVuLnNoaWZ0KCk7RmUudW5zaGlmdChiKX1mb3IoOzA8RmUubGVuZ3RoOylGZS5zaGlmdCgpKG8pO2lmKCEoMDxJdHx8enR8fCh6dD0hMCxvLmNhbGxlZFJ1bj0hMCxDKSkpe2Zvcig7MDxWLmxlbmd0aDspVi5zaGlmdCgpKG8pO2ZvcihlKG8pOzA8QWUubGVuZ3RoOylBZS5zaGlmdCgpKG8pfX19cmV0dXJuIEpyKCksdC5yZWFkeX19KSgpO3R5cGVvZiBFcD09XCJvYmplY3RcIiYmdHlwZW9mIG9hPT1cIm9iamVjdFwiP29hLmV4cG9ydHM9UHA6dHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kJiZkZWZpbmUoW10sKCk9PlBwKX0pO3ZhciBMcD1tZSgoKT0+e30pO3ZhciBGcD1tZSgoKT0+e30pO3ZhciBDcD17fTtQcihDcCx7Y3B1czooKT0+c2d9KTt2YXIgc2csJHA9RSgoKT0+e3NnPXZvaWQgMH0pO3ZhciBOcD1tZSgoQnAsaWEpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGtwPSgoKT0+e3ZhciBhPXR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDA7cmV0dXJuIHR5cGVvZiBfX2ZpbGVuYW1lPFwidVwiJiYoYT1hfHxfX2ZpbGVuYW1lKSxmdW5jdGlvbih0PXt9KXtmdW5jdGlvbiBvKCl7cmV0dXJuIEFlLmJ1ZmZlciE9dGUuYnVmZmVyJiZ3ZSgpLHRlfWZ1bmN0aW9uIGUoKXtyZXR1cm4gQWUuYnVmZmVyIT10ZS5idWZmZXImJndlKCksYnR9ZnVuY3Rpb24gcigpe3JldHVybiBBZS5idWZmZXIhPXRlLmJ1ZmZlciYmd2UoKSxTdH1mdW5jdGlvbiBuKCl7cmV0dXJuIEFlLmJ1ZmZlciE9dGUuYnVmZmVyJiZ3ZSgpLEhlfWZ1bmN0aW9uIHMoKXtyZXR1cm4gQWUuYnVmZmVyIT10ZS5idWZmZXImJndlKCksQXR9dmFyIGk9dCx1LGw7aS5yZWFkeT1uZXcgUHJvbWlzZSgoYyxoKT0+e3U9YyxsPWh9KTt2YXIgZj1PYmplY3QuYXNzaWduKHt9LGkpLHA9XCIuL3RoaXMucHJvZ3JhbVwiLGQ9KGMsaCk9Pnt0aHJvdyBofSxUPXR5cGVvZiB3aW5kb3c9PVwib2JqZWN0XCIsdj10eXBlb2YgaW1wb3J0U2NyaXB0cz09XCJmdW5jdGlvblwiLHc9dHlwZW9mIHByb2Nlc3M9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlPT1cInN0cmluZ1wiLEk9aS5FTlZJUk9OTUVOVF9JU19QVEhSRUFEfHwhMSxMPVwiXCI7ZnVuY3Rpb24gRihjKXtyZXR1cm4gaS5sb2NhdGVGaWxlP2kubG9jYXRlRmlsZShjLEwpOkwrY312YXIgQyxZLGo7aWYodyl7dmFyIE09KHRhKCksb3IoZWEpKSxpZT0obmEoKSxvcihyYSkpO0w9dj9pZS5kaXJuYW1lKEwpK1wiL1wiOl9fZGlybmFtZStcIi9cIixDPShoLGcpPT4oaD12ZShoKT9uZXcgVVJMKGgpOmllLm5vcm1hbGl6ZShoKSxNLnJlYWRGaWxlU3luYyhoLGc/dm9pZCAwOlwidXRmOFwiKSksaj1oPT4oaD1DKGgsITApLGguYnVmZmVyfHwoaD1uZXcgVWludDhBcnJheShoKSksaCksWT0oaCxnLFMsaz0hMCk9PntoPXZlKGgpP25ldyBVUkwoaCk6aWUubm9ybWFsaXplKGgpLE0ucmVhZEZpbGUoaCxrP3ZvaWQgMDpcInV0ZjhcIiwoQix6KT0+e0I/UyhCKTpnKGs/ei5idWZmZXI6eil9KX0sIWkudGhpc1Byb2dyYW0mJjE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKHA9cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSxkPShoLGcpPT57dGhyb3cgcHJvY2Vzcy5leGl0Q29kZT1oLGd9LGkuaW5zcGVjdD0oKT0+XCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwiO2xldCBjO3RyeXtjPUxwKCl9Y2F0Y2goaCl7dGhyb3cgY29uc29sZS5lcnJvcignVGhlIFwid29ya2VyX3RocmVhZHNcIiBtb2R1bGUgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIG5vZGUuanMgYnVpbGQgLSBwZXJoYXBzIGEgbmV3ZXIgdmVyc2lvbiBpcyBuZWVkZWQ/JyksaH1nbG9iYWwuV29ya2VyPWMuV29ya2VyfWVsc2UoVHx8dikmJih2P0w9c2VsZi5sb2NhdGlvbi5ocmVmOnR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKEw9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLHR5cGVvZiBhPFwidVwiJiZhJiYoTD1hKSxMLmluZGV4T2YoXCJibG9iOlwiKSE9PTA/TD1MLnN1YnN0cigwLEwucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6TD1cIlwiLHd8fChDPWM9Pnt2YXIgaD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGgub3BlbihcIkdFVFwiLGMsITEpLGguc2VuZChudWxsKSxoLnJlc3BvbnNlVGV4dH0sdiYmKGo9Yz0+e3ZhciBoPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gaC5vcGVuKFwiR0VUXCIsYywhMSksaC5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGguc2VuZChudWxsKSxuZXcgVWludDhBcnJheShoLnJlc3BvbnNlKX0pLFk9KGMsaCxnKT0+e3ZhciBTPW5ldyBYTUxIdHRwUmVxdWVzdDtTLm9wZW4oXCJHRVRcIixjLCEwKSxTLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsUy5vbmxvYWQ9KCk9PntTLnN0YXR1cz09MjAwfHxTLnN0YXR1cz09MCYmUy5yZXNwb25zZT9oKFMucmVzcG9uc2UpOmcoKX0sUy5vbmVycm9yPWcsUy5zZW5kKG51bGwpfSkpO3cmJnR5cGVvZiBwZXJmb3JtYW5jZT5cInVcIiYmKGdsb2JhbC5wZXJmb3JtYW5jZT1GcCgpLnBlcmZvcm1hbmNlKTt2YXIgb3Q9Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxXZT1jb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7dyYmKG90PSguLi5jKT0+TS53cml0ZVN5bmMoMSxjLmpvaW4oXCIgXCIpK2BcbmApLFdlPSguLi5jKT0+TS53cml0ZVN5bmMoMixjLmpvaW4oXCIgXCIpK2BcbmApKTt2YXIgRmU9b3QsVj1XZTtPYmplY3QuYXNzaWduKGksZiksZj1udWxsLHR5cGVvZiBXZWJBc3NlbWJseSE9XCJvYmplY3RcIiYmTXQoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciBBZSxJdCxtdD0hMSxCZSx0ZSxidCxTdCxIZSxBdDtmdW5jdGlvbiB3ZSgpe3ZhciBjPUFlLmJ1ZmZlcjtpLkhFQVA4PXRlPW5ldyBJbnQ4QXJyYXkoYyksaS5IRUFQMTY9bmV3IEludDE2QXJyYXkoYyksaS5IRUFQVTg9YnQ9bmV3IFVpbnQ4QXJyYXkoYyksaS5IRUFQVTE2PW5ldyBVaW50MTZBcnJheShjKSxpLkhFQVAzMj1TdD1uZXcgSW50MzJBcnJheShjKSxpLkhFQVBVMzI9SGU9bmV3IFVpbnQzMkFycmF5KGMpLGkuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KGMpLGkuSEVBUEY2ND1BdD1uZXcgRmxvYXQ2NEFycmF5KGMpfXZhciBaZT0xNjc3NzIxNjtpZihJKUFlPWkud2FzbU1lbW9yeTtlbHNlIGlmKGkud2FzbU1lbW9yeSlBZT1pLndhc21NZW1vcnk7ZWxzZSBpZihBZT1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOlplLzY1NTM2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSksIShBZS5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikpdGhyb3cgVihcInJlcXVlc3RlZCBhIHNoYXJlZCBXZWJBc3NlbWJseS5NZW1vcnkgYnV0IHRoZSByZXR1cm5lZCBidWZmZXIgaXMgbm90IGEgU2hhcmVkQXJyYXlCdWZmZXIsIGluZGljYXRpbmcgdGhhdCB3aGlsZSB0aGUgYnJvd3NlciBoYXMgU2hhcmVkQXJyYXlCdWZmZXIgaXQgZG9lcyBub3QgaGF2ZSBXZWJBc3NlbWJseSB0aHJlYWRzIHN1cHBvcnQgLSB5b3UgbWF5IG5lZWQgdG8gc2V0IGEgZmxhZ1wiKSx3JiZWKFwiKG9uIG5vZGUgeW91IG1heSBuZWVkOiAtLWV4cGVyaW1lbnRhbC13YXNtLXRocmVhZHMgLS1leHBlcmltZW50YWwtd2FzbS1idWxrLW1lbW9yeSBhbmQvb3IgcmVjZW50IHZlcnNpb24pXCIpLEVycm9yKFwiYmFkIG1lbW9yeVwiKTt3ZSgpLFplPUFlLmJ1ZmZlci5ieXRlTGVuZ3RoO3ZhciBRdD1bXSxQdD1bXSxndD1bXSx5dD0wLGVyPW51bGwsUWU9bnVsbDtmdW5jdGlvbiBFdCgpe2lmKHl0LS0seXQ9PTAmJihlciE9PW51bGwmJihjbGVhckludGVydmFsKGVyKSxlcj1udWxsKSxRZSkpe3ZhciBjPVFlO1FlPW51bGwsYygpfX1mdW5jdGlvbiBNdChjKXt0aHJvdyBjPVwiQWJvcnRlZChcIitjK1wiKVwiLFYoYyksbXQ9ITAsQmU9MSxjPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoYytcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksbChjKSxjfXZhciAkZT1jPT5jLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpLHZlPWM9PmMuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikscWU7cWU9XCJvcnQtd2FzbS10aHJlYWRlZC53YXNtXCIsJGUocWUpfHwocWU9RihxZSkpO2Z1bmN0aW9uIEd0KGMpe2lmKGopcmV0dXJuIGooYyk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9ZnVuY3Rpb24gRHQoYyl7aWYoVHx8dil7aWYodHlwZW9mIGZldGNoPT1cImZ1bmN0aW9uXCImJiF2ZShjKSlyZXR1cm4gZmV0Y2goYyx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihoPT57aWYoIWgub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiK2MrXCInXCI7cmV0dXJuIGguYXJyYXlCdWZmZXIoKX0pLmNhdGNoKCgpPT5HdChjKSk7aWYoWSlyZXR1cm4gbmV3IFByb21pc2UoKGgsZyk9PntZKGMsUz0+aChuZXcgVWludDhBcnJheShTKSksZyl9KX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+R3QoYykpfWZ1bmN0aW9uIGpyKGMsaCxnKXtyZXR1cm4gRHQoYykudGhlbihTPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZShTLGgpKS50aGVuKFM9PlMpLnRoZW4oZyxTPT57VihgZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJHtTfWApLE10KFMpfSl9ZnVuY3Rpb24gd24oYyxoKXt2YXIgZz1xZTtyZXR1cm4gdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nIT1cImZ1bmN0aW9uXCJ8fCRlKGcpfHx2ZShnKXx8d3x8dHlwZW9mIGZldGNoIT1cImZ1bmN0aW9uXCI/anIoZyxjLGgpOmZldGNoKGcse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oUz0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoUyxjKS50aGVuKGgsZnVuY3Rpb24oayl7cmV0dXJuIFYoYHdhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAke2t9YCksVihcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLGpyKGcsYyxoKX0pKX12YXIgVXQsdnI9ezkyMTM4ODooYyxoLGcsUyk9PntpZih0eXBlb2YgaT5cInVcInx8IWkuY2IpcmV0dXJuIDE7aWYoYz1JcihjPj4+MCksYy5zdGFydHNXaXRoKFwiLi9cIikmJihjPWMuc3Vic3RyaW5nKDIpKSxjPWkuY2IuZ2V0KGMpLCFjKXJldHVybiAyO2lmKGg+Pj49MCxnPj4+PTAsUz4+Pj0wLGgrZz5jLmJ5dGVMZW5ndGgpcmV0dXJuIDM7dHJ5e3JldHVybiBlKCkuc2V0KGMuc3ViYXJyYXkoaCxoK2cpLFM+Pj4wKSwwfWNhdGNoe3JldHVybiA0fX19O2Z1bmN0aW9uIHF0KGMpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9YFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtjfSlgLHRoaXMuc3RhdHVzPWN9dmFyIF9yPWM9PntjLnRlcm1pbmF0ZSgpLGMub25tZXNzYWdlPSgpPT57fX0sT3I9Yz0+e0ouUGEubGVuZ3RoPT0wJiYoS3IoKSxKLllhKEouUGFbMF0pKTt2YXIgaD1KLlBhLnBvcCgpO2lmKCFoKXJldHVybiA2O0ouUWEucHVzaChoKSxKLk1hW2MuT2FdPWgsaC5PYT1jLk9hO3ZhciBnPXtjbWQ6XCJydW5cIixzdGFydF9yb3V0aW5lOmMua2IsYXJnOmMuaGIscHRocmVhZF9wdHI6Yy5PYX07cmV0dXJuIHcmJmgudW5yZWYoKSxoLnBvc3RNZXNzYWdlKGcsYy5xYiksMH0sdHI9MCxZcj10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDAsWHI9KGMsaCxnKT0+e2g+Pj49MDt2YXIgUz1oK2c7Zm9yKGc9aDtjW2ddJiYhKGc+PVMpOykrK2c7aWYoMTY8Zy1oJiZjLmJ1ZmZlciYmWXIpcmV0dXJuIFlyLmRlY29kZShjLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyP2Muc2xpY2UoaCxnKTpjLnN1YmFycmF5KGgsZykpO2ZvcihTPVwiXCI7aDxnOyl7dmFyIGs9Y1toKytdO2lmKGsmMTI4KXt2YXIgQj1jW2grK10mNjM7aWYoKGsmMjI0KT09MTkyKVMrPVN0cmluZy5mcm9tQ2hhckNvZGUoKGsmMzEpPDw2fEIpO2Vsc2V7dmFyIHo9Y1toKytdJjYzO2s9KGsmMjQwKT09MjI0PyhrJjE1KTw8MTJ8Qjw8Nnx6OihrJjcpPDwxOHxCPDwxMnx6PDw2fGNbaCsrXSY2Myw2NTUzNj5rP1MrPVN0cmluZy5mcm9tQ2hhckNvZGUoayk6KGstPTY1NTM2LFMrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8az4+MTAsNTYzMjB8ayYxMDIzKSl9fWVsc2UgUys9U3RyaW5nLmZyb21DaGFyQ29kZShrKX1yZXR1cm4gU30sSXI9KGMsaCk9PihjPj4+PTApP1hyKGUoKSxjLGgpOlwiXCIsdm49Yz0+e3ZhciBoPVZvKCk7cmV0dXJuIGM9YygpLFBuKGgpLGN9O2Z1bmN0aW9uIGhlKGMsaCl7dmFyIGc9YXJndW1lbnRzLmxlbmd0aC0yLFM9YXJndW1lbnRzO3JldHVybiB2bigoKT0+e2Zvcih2YXIgaz1Xbyg4KmcpLEI9az4+PjMsej0wO3o8Zzt6Kyspe3ZhciBJZT1TWzIrel07cygpW0Irej4+PjBdPUllfXJldHVybiBOYShjLGcsayxoKX0pfWZ1bmN0aW9uIFEoYyl7aWYoSSlyZXR1cm4gaGUoMCwxLGMpO0JlPWMsMDx0cnx8KEoubGIoKSxpLm9uRXhpdD8uKGMpLG10PSEwKSxkKGMsbmV3IHF0KGMpKX12YXIgU3I9Yz0+e2lmKEJlPWMsSSl0aHJvdyBJbihjKSxcInVud2luZFwiO1EoYyl9O2Z1bmN0aW9uIF9uKCl7Zm9yKHZhciBjPWkubnVtVGhyZWFkcztjLS07KUtyKCk7UXQudW5zaGlmdCgoKT0+e3l0KyssT24oKCk9PkV0KCkpfSl9ZnVuY3Rpb24gS3IoKXt2YXIgYz1GKFwib3J0LXdhc20tdGhyZWFkZWQud29ya2VyLmpzXCIpO2M9bmV3IFdvcmtlcihjKSxKLlBhLnB1c2goYyl9ZnVuY3Rpb24gT24oYyl7ST9jKCk6UHJvbWlzZS5hbGwoSi5QYS5tYXAoSi5ZYSkpLnRoZW4oYyl9dmFyIEo9e1BhOltdLFFhOltdLGJiOltdLE1hOnt9LFdhKCl7ST8oSi5yZWNlaXZlT2JqZWN0VHJhbnNmZXI9Si5qYixKLnRocmVhZEluaXRUTFM9Si5hYixKLnNldEV4aXRTdGF0dXM9Si4kYSk6X24oKX0sJGE6Yz0+QmU9Yyx0YjpbXCIkdGVybWluYXRlV29ya2VyXCJdLGxiOigpPT57Zm9yKHZhciBjIG9mIEouUWEpX3IoYyk7Zm9yKGMgb2YgSi5QYSlfcihjKTtKLlBhPVtdLEouUWE9W10sSi5NYT1bXX0sWmE6Yz0+e3ZhciBoPWMuT2E7ZGVsZXRlIEouTWFbaF0sSi5QYS5wdXNoKGMpLEouUWEuc3BsaWNlKEouUWEuaW5kZXhPZihjKSwxKSxjLk9hPTAsVW8oaCl9LGpiKCl7fSxhYigpe0ouYmIuZm9yRWFjaChjPT5jKCkpfSxZYTpjPT5uZXcgUHJvbWlzZShoPT57Yy5vbm1lc3NhZ2U9Qj0+e0I9Qi5kYXRhO3ZhciB6PUIuY21kO2lmKEIudGFyZ2V0VGhyZWFkJiZCLnRhcmdldFRocmVhZCE9QW4oKSl7dmFyIEllPUouTWFbQi50YXJnZXRUaHJlYWRdO0llP0llLnBvc3RNZXNzYWdlKEIsQi50cmFuc2Zlckxpc3QpOlYoYEludGVybmFsIGVycm9yISBXb3JrZXIgc2VudCBhIG1lc3NhZ2UgXCIke3p9XCIgdG8gdGFyZ2V0IHB0aHJlYWQgJHtCLnRhcmdldFRocmVhZH0sIGJ1dCB0aGF0IHRocmVhZCBubyBsb25nZXIgZXhpc3RzIWApfWVsc2Ugej09PVwiY2hlY2tNYWlsYm94XCI/U24oKTp6PT09XCJzcGF3blRocmVhZFwiP09yKEIpOno9PT1cImNsZWFudXBUaHJlYWRcIj9KLlphKEouTWFbQi50aHJlYWRdKTp6PT09XCJraWxsVGhyZWFkXCI/KEI9Qi50aHJlYWQsej1KLk1hW0JdLGRlbGV0ZSBKLk1hW0JdLF9yKHopLFVvKEIpLEouUWEuc3BsaWNlKEouUWEuaW5kZXhPZih6KSwxKSx6Lk9hPTApOno9PT1cImNhbmNlbFRocmVhZFwiP0ouTWFbQi50aHJlYWRdLnBvc3RNZXNzYWdlKHtjbWQ6XCJjYW5jZWxcIn0pOno9PT1cImxvYWRlZFwiPyhjLmxvYWRlZD0hMCx3JiYhYy5PYSYmYy51bnJlZigpLGgoYykpOno9PT1cImFsZXJ0XCI/YWxlcnQoYFRocmVhZCAke0IudGhyZWFkSWR9OiAke0IudGV4dH1gKTpCLnRhcmdldD09PVwic2V0aW1tZWRpYXRlXCI/Yy5wb3N0TWVzc2FnZShCKTp6PT09XCJjYWxsSGFuZGxlclwiP2lbQi5oYW5kbGVyXSguLi5CLmFyZ3MpOnomJlYoYHdvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCAke3p9YCl9LGMub25lcnJvcj1CPT57dGhyb3cgVihgd29ya2VyIHNlbnQgYW4gZXJyb3IhICR7Qi5maWxlbmFtZX06JHtCLmxpbmVub306ICR7Qi5tZXNzYWdlfWApLEJ9LHcmJihjLm9uKFwibWVzc2FnZVwiLEI9PmMub25tZXNzYWdlKHtkYXRhOkJ9KSksYy5vbihcImVycm9yXCIsQj0+Yy5vbmVycm9yKEIpKSk7dmFyIGc9W10sUz1bXCJvbkV4aXRcIl0saztmb3IoayBvZiBTKWkuaGFzT3duUHJvcGVydHkoaykmJmcucHVzaChrKTtjLnBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkXCIsaGFuZGxlcnM6Zyx1cmxPckJsb2I6aS5tYWluU2NyaXB0VXJsT3JCbG9ifHxhLHdhc21NZW1vcnk6QWUsd2FzbU1vZHVsZTpJdH0pfSl9O2kuUFRocmVhZD1KO3ZhciBycj1jPT57Zm9yKDswPGMubGVuZ3RoOyljLnNoaWZ0KCkoaSl9O2kuZXN0YWJsaXNoU3RhY2tTcGFjZT0oKT0+e3ZhciBjPUFuKCksaD1uKClbYys1Mj4+PjI+Pj4wXTtjPW4oKVtjKzU2Pj4+Mj4+PjBdLEdhKGgsaC1jKSxQbihoKX07ZnVuY3Rpb24gSW4oYyl7aWYoSSlyZXR1cm4gaGUoMSwwLGMpO1NyKGMpfXZhciB6dD1bXSxKcjtpLmludm9rZUVudHJ5UG9pbnQ9KGMsaCk9Pnt2YXIgZz16dFtjXTtnfHwoYz49enQubGVuZ3RoJiYoenQubGVuZ3RoPWMrMSksenRbY109Zz1Kci5nZXQoYykpLGM9ZyhoKSwwPHRyP0ouJGEoYyk6em8oYyl9O2Z1bmN0aW9uIGIoYyl7dGhpcy5WYT1jLTI0LHRoaXMuZ2I9ZnVuY3Rpb24oaCl7bigpW3RoaXMuVmErND4+PjI+Pj4wXT1ofSx0aGlzLmZiPWZ1bmN0aW9uKGgpe24oKVt0aGlzLlZhKzg+Pj4yPj4+MF09aH0sdGhpcy5XYT1mdW5jdGlvbihoLGcpe3RoaXMuZWIoKSx0aGlzLmdiKGgpLHRoaXMuZmIoZyl9LHRoaXMuZWI9ZnVuY3Rpb24oKXtuKClbdGhpcy5WYSsxNj4+PjI+Pj4wXT0wfX12YXIgeD0wLF89MDtmdW5jdGlvbiBEKGMsaCxnLFMpe3JldHVybiBJP2hlKDIsMSxjLGgsZyxTKTpHKGMsaCxnLFMpfWZ1bmN0aW9uIEcoYyxoLGcsUyl7aWYoYz4+Pj0wLGg+Pj49MCxnPj4+PTAsUz4+Pj0wLHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj5cInVcIilyZXR1cm4gVihcIkN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBTaGFyZWRBcnJheUJ1ZmZlciwgcHRocmVhZHMgYXJlIG5vdCBhdmFpbGFibGUhXCIpLDY7dmFyIGs9W107cmV0dXJuIEkmJmsubGVuZ3RoPT09MD9EKGMsaCxnLFMpOihjPXtrYjpnLE9hOmMsaGI6UyxxYjprfSxJPyhjLnNiPVwic3Bhd25UaHJlYWRcIixwb3N0TWVzc2FnZShjLGspLDApOk9yKGMpKX1mdW5jdGlvbiBYKGMsaCxnKXtyZXR1cm4gST9oZSgzLDEsYyxoLGcpOjB9ZnVuY3Rpb24gbmUoYyxoKXtpZihJKXJldHVybiBoZSg0LDEsYyxoKX12YXIga2U9Yz0+e2Zvcih2YXIgaD0wLGc9MDtnPGMubGVuZ3RoOysrZyl7dmFyIFM9Yy5jaGFyQ29kZUF0KGcpOzEyNz49Uz9oKys6MjA0Nz49Uz9oKz0yOjU1Mjk2PD1TJiY1NzM0Mz49Uz8oaCs9NCwrK2cpOmgrPTN9cmV0dXJuIGh9LFllPShjLGgsZyxTKT0+e2lmKGc+Pj49MCwhKDA8UykpcmV0dXJuIDA7dmFyIGs9ZztTPWcrUy0xO2Zvcih2YXIgQj0wO0I8Yy5sZW5ndGg7KytCKXt2YXIgej1jLmNoYXJDb2RlQXQoQik7aWYoNTUyOTY8PXomJjU3MzQzPj16KXt2YXIgSWU9Yy5jaGFyQ29kZUF0KCsrQik7ej02NTUzNisoKHomMTAyMyk8PDEwKXxJZSYxMDIzfWlmKDEyNz49eil7aWYoZz49UylicmVhaztoW2crKz4+PjBdPXp9ZWxzZXtpZigyMDQ3Pj16KXtpZihnKzE+PVMpYnJlYWs7aFtnKys+Pj4wXT0xOTJ8ej4+Nn1lbHNle2lmKDY1NTM1Pj16KXtpZihnKzI+PVMpYnJlYWs7aFtnKys+Pj4wXT0yMjR8ej4+MTJ9ZWxzZXtpZihnKzM+PVMpYnJlYWs7aFtnKys+Pj4wXT0yNDB8ej4+MTgsaFtnKys+Pj4wXT0xMjh8ej4+MTImNjN9aFtnKys+Pj4wXT0xMjh8ej4+NiY2M31oW2crKz4+PjBdPTEyOHx6JjYzfX1yZXR1cm4gaFtnPj4+MF09MCxnLWt9LFVlPShjLGgsZyk9PlllKGMsZSgpLGgsZyk7ZnVuY3Rpb24gemUoYyxoKXtpZihJKXJldHVybiBoZSg1LDEsYyxoKX1mdW5jdGlvbiBacihjLGgsZyl7aWYoSSlyZXR1cm4gaGUoNiwxLGMsaCxnKX1mdW5jdGlvbiBRcihjLGgsZyl7cmV0dXJuIEk/aGUoNywxLGMsaCxnKTowfWZ1bmN0aW9uIEEoYyxoKXtpZihJKXJldHVybiBoZSg4LDEsYyxoKX1mdW5jdGlvbiBwZShjLGgsZyl7aWYoSSlyZXR1cm4gaGUoOSwxLGMsaCxnKX1mdW5jdGlvbiBUZShjLGgsZyxTKXtpZihJKXJldHVybiBoZSgxMCwxLGMsaCxnLFMpfWZ1bmN0aW9uIEx0KGMsaCxnLFMpe2lmKEkpcmV0dXJuIGhlKDExLDEsYyxoLGcsUyl9ZnVuY3Rpb24gZW4oYyxoLGcsUyl7aWYoSSlyZXR1cm4gaGUoMTIsMSxjLGgsZyxTKX1mdW5jdGlvbiBiYShjKXtpZihJKXJldHVybiBoZSgxMywxLGMpfWZ1bmN0aW9uIGdhKGMsaCl7aWYoSSlyZXR1cm4gaGUoMTQsMSxjLGgpfWZ1bmN0aW9uIHlhKGMsaCxnKXtpZihJKXJldHVybiBoZSgxNSwxLGMsaCxnKX1mdW5jdGlvbiBCbyhjKXtjPj4+PTAsdHlwZW9mIEF0b21pY3MucmI9PVwiZnVuY3Rpb25cIiYmKEF0b21pY3MucmIocigpLGM+Pj4yLGMpLnZhbHVlLnRoZW4oU24pLGMrPTEyOCxBdG9taWNzLnN0b3JlKHIoKSxjPj4+MiwxKSl9aS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX21haWxib3hfYXdhaXQ9Qm87dmFyIFNuPSgpPT57dmFyIGM9QW4oKTtpZihjJiYoQm8oYyksYz1SYSwhbXQpKXRyeXtpZihjKCksISgwPHRyKSl0cnl7ST96byhCZSk6U3IoQmUpfWNhdGNoKGgpe2ggaW5zdGFuY2VvZiBxdHx8aD09XCJ1bndpbmRcInx8ZCgxLGgpfX1jYXRjaChoKXtoIGluc3RhbmNlb2YgcXR8fGg9PVwidW53aW5kXCJ8fGQoMSxoKX19O2kuY2hlY2tNYWlsYm94PVNuO3ZhciBObz1bXSxBcj1jPT5jJTQ9PT0wJiYoYyUxMDAhPT0wfHxjJTQwMD09PTApLFRhPVswLDMxLDYwLDkxLDEyMSwxNTIsMTgyLDIxMywyNDQsMjc0LDMwNSwzMzVdLHhhPVswLDMxLDU5LDkwLDEyMCwxNTEsMTgxLDIxMiwyNDMsMjczLDMwNCwzMzRdO2Z1bmN0aW9uIHdhKGMsaCxnLFMsayxCLHosSWUpe3JldHVybiBJP2hlKDE2LDEsYyxoLGcsUyxrLEIseixJZSk6LTUyfWZ1bmN0aW9uIHZhKGMsaCxnLFMsayxCLHope2lmKEkpcmV0dXJuIGhlKDE3LDEsYyxoLGcsUyxrLEIseil9dmFyIF9hPWM9Pnt2YXIgaD1rZShjKSsxLGc9a2EoaCk7cmV0dXJuIGcmJlVlKGMsZyxoKSxnfSxSbz1bXSxNbz17fSxPYT0oKT0+e2lmKCFHbyl7dmFyIGM9e1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KHR5cGVvZiBuYXZpZ2F0b3I9PVwib2JqZWN0XCImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86cHx8XCIuL3RoaXMucHJvZ3JhbVwifSxoO2ZvcihoIGluIE1vKU1vW2hdPT09dm9pZCAwP2RlbGV0ZSBjW2hdOmNbaF09TW9baF07dmFyIGc9W107Zm9yKGggaW4gYylnLnB1c2goYCR7aH09JHtjW2hdfWApO0dvPWd9cmV0dXJuIEdvfSxHbztmdW5jdGlvbiBJYShjLGgpe2lmKEkpcmV0dXJuIGhlKDE4LDEsYyxoKTtjPj4+PTAsaD4+Pj0wO3ZhciBnPTA7cmV0dXJuIE9hKCkuZm9yRWFjaCgoUyxrKT0+e3ZhciBCPWgrZztmb3Ioaz1uKClbYys0Kms+Pj4yPj4+MF09QixCPTA7QjxTLmxlbmd0aDsrK0IpbygpW2srKz4+PjA+Pj4wXT1TLmNoYXJDb2RlQXQoQik7bygpW2s+Pj4wPj4+MF09MCxnKz1TLmxlbmd0aCsxfSksMH1mdW5jdGlvbiBTYShjLGgpe2lmKEkpcmV0dXJuIGhlKDE5LDEsYyxoKTtjPj4+PTAsaD4+Pj0wO3ZhciBnPU9hKCk7bigpW2M+Pj4yPj4+MF09Zy5sZW5ndGg7dmFyIFM9MDtyZXR1cm4gZy5mb3JFYWNoKGs9PlMrPWsubGVuZ3RoKzEpLG4oKVtoPj4+Mj4+PjBdPVMsMH1mdW5jdGlvbiBBYShjKXtyZXR1cm4gST9oZSgyMCwxLGMpOjUyfWZ1bmN0aW9uIFBhKGMsaCxnLFMpe3JldHVybiBJP2hlKDIxLDEsYyxoLGcsUyk6NTJ9ZnVuY3Rpb24gRWEoYyxoLGcsUyxrKXtyZXR1cm4gST9oZSgyMiwxLGMsaCxnLFMsayk6NzB9dmFyIHlkPVtudWxsLFtdLFtdXTtmdW5jdGlvbiBEYShjLGgsZyxTKXtpZihJKXJldHVybiBoZSgyMywxLGMsaCxnLFMpO2g+Pj49MCxnPj4+PTAsUz4+Pj0wO2Zvcih2YXIgaz0wLEI9MDtCPGc7QisrKXt2YXIgej1uKClbaD4+PjI+Pj4wXSxJZT1uKClbaCs0Pj4+Mj4+PjBdO2grPTg7Zm9yKHZhciBGdD0wO0Z0PEllO0Z0Kyspe3ZhciBOZT1lKClbeitGdD4+PjBdLGV0PXlkW2NdO05lPT09MHx8TmU9PT0xMD8oKGM9PT0xP0ZlOlYpKFhyKGV0LDApKSxldC5sZW5ndGg9MCk6ZXQucHVzaChOZSl9ays9SWV9cmV0dXJuIG4oKVtTPj4+Mj4+PjBdPWssMH12YXIgTGE9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxGYT1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIFRkKGMpe3ZhciBoPUFycmF5KGtlKGMpKzEpO3JldHVybiBZZShjLGgsMCxoLmxlbmd0aCksaH12YXIgeGQ9KGMsaCk9PntvKCkuc2V0KGMsaD4+PjApfTtmdW5jdGlvbiBDYShjLGgsZyxTKXtmdW5jdGlvbiBrKFAsZGUsU2Upe2ZvcihQPXR5cGVvZiBQPT1cIm51bWJlclwiP1AudG9TdHJpbmcoKTpQfHxcIlwiO1AubGVuZ3RoPGRlOylQPVNlWzBdK1A7cmV0dXJuIFB9ZnVuY3Rpb24gQihQLGRlKXtyZXR1cm4gayhQLGRlLFwiMFwiKX1mdW5jdGlvbiB6KFAsZGUpe2Z1bmN0aW9uIFNlKFdhKXtyZXR1cm4gMD5XYT8tMTowPFdhPzE6MH12YXIgbnI7cmV0dXJuKG5yPVNlKFAuZ2V0RnVsbFllYXIoKS1kZS5nZXRGdWxsWWVhcigpKSk9PT0wJiYobnI9U2UoUC5nZXRNb250aCgpLWRlLmdldE1vbnRoKCkpKT09PTAmJihucj1TZShQLmdldERhdGUoKS1kZS5nZXREYXRlKCkpKSxucn1mdW5jdGlvbiBJZShQKXtzd2l0Y2goUC5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZShQLmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiBQO2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUoUC5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZShQLmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKFAuZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUoUC5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUoUC5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBGdChQKXt2YXIgZGU9UC5SYTtmb3IoUD1uZXcgRGF0ZShuZXcgRGF0ZShQLlNhKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8ZGU7KXt2YXIgU2U9UC5nZXRNb250aCgpLG5yPShBcihQLmdldEZ1bGxZZWFyKCkpP0xhOkZhKVtTZV07aWYoZGU+bnItUC5nZXREYXRlKCkpZGUtPW5yLVAuZ2V0RGF0ZSgpKzEsUC5zZXREYXRlKDEpLDExPlNlP1Auc2V0TW9udGgoU2UrMSk6KFAuc2V0TW9udGgoMCksUC5zZXRGdWxsWWVhcihQLmdldEZ1bGxZZWFyKCkrMSkpO2Vsc2V7UC5zZXREYXRlKFAuZ2V0RGF0ZSgpK2RlKTticmVha319cmV0dXJuIFNlPW5ldyBEYXRlKFAuZ2V0RnVsbFllYXIoKSsxLDAsNCksZGU9SWUobmV3IERhdGUoUC5nZXRGdWxsWWVhcigpLDAsNCkpLFNlPUllKFNlKSwwPj16KGRlLFApPzA+PXooU2UsUCk/UC5nZXRGdWxsWWVhcigpKzE6UC5nZXRGdWxsWWVhcigpOlAuZ2V0RnVsbFllYXIoKS0xfWM+Pj49MCxoPj4+PTAsZz4+Pj0wLFM+Pj49MDt2YXIgTmU9bigpW1MrNDA+Pj4yPj4+MF07Uz17b2I6cigpW1M+Pj4yPj4+MF0sbmI6cigpW1MrND4+PjI+Pj4wXSxUYTpyKClbUys4Pj4+Mj4+PjBdLFhhOnIoKVtTKzEyPj4+Mj4+PjBdLFVhOnIoKVtTKzE2Pj4+Mj4+PjBdLFNhOnIoKVtTKzIwPj4+Mj4+PjBdLE5hOnIoKVtTKzI0Pj4+Mj4+PjBdLFJhOnIoKVtTKzI4Pj4+Mj4+PjBdLHViOnIoKVtTKzMyPj4+Mj4+PjBdLG1iOnIoKVtTKzM2Pj4+Mj4+PjBdLHBiOk5lP0lyKE5lKTpcIlwifSxnPUlyKGcpLE5lPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcIiVFY1wiOlwiJWNcIixcIiVFQ1wiOlwiJUNcIixcIiVFeFwiOlwiJW0vJWQvJXlcIixcIiVFWFwiOlwiJUg6JU06JVNcIixcIiVFeVwiOlwiJXlcIixcIiVFWVwiOlwiJVlcIixcIiVPZFwiOlwiJWRcIixcIiVPZVwiOlwiJWVcIixcIiVPSFwiOlwiJUhcIixcIiVPSVwiOlwiJUlcIixcIiVPbVwiOlwiJW1cIixcIiVPTVwiOlwiJU1cIixcIiVPU1wiOlwiJVNcIixcIiVPdVwiOlwiJXVcIixcIiVPVVwiOlwiJVVcIixcIiVPVlwiOlwiJVZcIixcIiVPd1wiOlwiJXdcIixcIiVPV1wiOlwiJVdcIixcIiVPeVwiOlwiJXlcIn07Zm9yKHZhciBldCBpbiBOZSlnPWcucmVwbGFjZShuZXcgUmVnRXhwKGV0LFwiZ1wiKSxOZVtldF0pO3ZhciB6YT1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLFZhPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtOZT17XCIlYVwiOlA9PnphW1AuTmFdLnN1YnN0cmluZygwLDMpLFwiJUFcIjpQPT56YVtQLk5hXSxcIiViXCI6UD0+VmFbUC5VYV0uc3Vic3RyaW5nKDAsMyksXCIlQlwiOlA9PlZhW1AuVWFdLFwiJUNcIjpQPT5CKChQLlNhKzE5MDApLzEwMHwwLDIpLFwiJWRcIjpQPT5CKFAuWGEsMiksXCIlZVwiOlA9PmsoUC5YYSwyLFwiIFwiKSxcIiVnXCI6UD0+RnQoUCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlR1wiOlA9PkZ0KFApLFwiJUhcIjpQPT5CKFAuVGEsMiksXCIlSVwiOlA9PihQPVAuVGEsUD09MD9QPTEyOjEyPFAmJihQLT0xMiksQihQLDIpKSxcIiVqXCI6UD0+e2Zvcih2YXIgZGU9MCxTZT0wO1NlPD1QLlVhLTE7ZGUrPShBcihQLlNhKzE5MDApP0xhOkZhKVtTZSsrXSk7cmV0dXJuIEIoUC5YYStkZSwzKX0sXCIlbVwiOlA9PkIoUC5VYSsxLDIpLFwiJU1cIjpQPT5CKFAubmIsMiksXCIlblwiOigpPT5gXG5gLFwiJXBcIjpQPT4wPD1QLlRhJiYxMj5QLlRhP1wiQU1cIjpcIlBNXCIsXCIlU1wiOlA9PkIoUC5vYiwyKSxcIiV0XCI6KCk9PlwiXHRcIixcIiV1XCI6UD0+UC5OYXx8NyxcIiVVXCI6UD0+QihNYXRoLmZsb29yKChQLlJhKzctUC5OYSkvNyksMiksXCIlVlwiOlA9Pnt2YXIgZGU9TWF0aC5mbG9vcigoUC5SYSs3LShQLk5hKzYpJTcpLzcpO2lmKDI+PShQLk5hKzM3MS1QLlJhLTIpJTcmJmRlKyssZGUpZGU9PTUzJiYoU2U9KFAuTmErMzcxLVAuUmEpJTcsU2U9PTR8fFNlPT0zJiZBcihQLlNhKXx8KGRlPTEpKTtlbHNle2RlPTUyO3ZhciBTZT0oUC5OYSs3LVAuUmEtMSklNzsoU2U9PTR8fFNlPT01JiZBcihQLlNhJTQwMC0xKSkmJmRlKyt9cmV0dXJuIEIoZGUsMil9LFwiJXdcIjpQPT5QLk5hLFwiJVdcIjpQPT5CKE1hdGguZmxvb3IoKFAuUmErNy0oUC5OYSs2KSU3KS83KSwyKSxcIiV5XCI6UD0+KFAuU2ErMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlWVwiOlA9PlAuU2ErMTkwMCxcIiV6XCI6UD0+e1A9UC5tYjt2YXIgZGU9MDw9UDtyZXR1cm4gUD1NYXRoLmFicyhQKS82MCwoZGU/XCIrXCI6XCItXCIpKyhcIjAwMDBcIisoUC82MCoxMDArUCU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOlA9PlAucGIsXCIlJVwiOigpPT5cIiVcIn0sZz1nLnJlcGxhY2UoLyUlL2csXCJcXDBcXDBcIik7Zm9yKGV0IGluIE5lKWcuaW5jbHVkZXMoZXQpJiYoZz1nLnJlcGxhY2UobmV3IFJlZ0V4cChldCxcImdcIiksTmVbZXRdKFMpKSk7cmV0dXJuIGc9Zy5yZXBsYWNlKC9cXDBcXDAvZyxcIiVcIiksZXQ9VGQoZyksZXQubGVuZ3RoPmg/MDooeGQoZXQsYyksZXQubGVuZ3RoLTEpfUouV2EoKTt2YXIgd2Q9W1EsSW4sRCxYLG5lLHplLFpyLFFyLEEscGUsVGUsTHQsZW4sYmEsZ2EseWEsd2EsdmEsSWEsU2EsQWEsUGEsRWEsRGFdLHZkPXtiOmZ1bmN0aW9uKGMsaCxnKXt0aHJvdyBjPj4+PTAsbmV3IGIoYykuV2EoaD4+PjAsZz4+PjApLHg9YyxfKysseH0sTDpmdW5jdGlvbihjKXtCYShjPj4+MCwhdiwxLCFULDEzMTA3MiwhMSksSi5hYigpfSxqOmZ1bmN0aW9uKGMpe2M+Pj49MCxJP3Bvc3RNZXNzYWdlKHtjbWQ6XCJjbGVhbnVwVGhyZWFkXCIsdGhyZWFkOmN9KTpKLlphKEouTWFbY10pfSxIOkcsaDpYLFM6bmUsRDp6ZSxGOlpyLFQ6UXIsUTpBLEo6cGUsUDpUZSxuOkx0LEU6ZW4sQjpiYSxSOmdhLEM6eWEscDooKT0+MSx6OmZ1bmN0aW9uKGMsaCl7Yz4+Pj0wLGM9PWg+Pj4wP3NldFRpbWVvdXQoKCk9PlNuKCkpOkk/cG9zdE1lc3NhZ2Uoe3RhcmdldFRocmVhZDpjLGNtZDpcImNoZWNrTWFpbGJveFwifSk6KGM9Si5NYVtjXSkmJmMucG9zdE1lc3NhZ2Uoe2NtZDpcImNoZWNrTWFpbGJveFwifSl9LEk6ZnVuY3Rpb24oYyxoLGcsUyl7aD4+Pj0wLE5vLmxlbmd0aD1nLFM9Uz4+PjA+Pj4zO2Zvcih2YXIgaz0wO2s8ZztrKyspTm9ba109cygpW1Mraz4+PjBdO3JldHVybiBjPTA+Yz92clstYy0xXTp3ZFtjXSxKLmliPWgsaD1jLmFwcGx5KG51bGwsTm8pLEouaWI9MCxofSxLOkJvLG86ZnVuY3Rpb24oYyl7dyYmSi5NYVtjPj4+MF0ucmVmKCl9LHM6ZnVuY3Rpb24oYyxoLGcpe2M9aCsyMDk3MTUyPj4+MDw0MTk0MzA1LSEhYz8oYz4+PjApKzQyOTQ5NjcyOTYqaDpOYU4sZz4+Pj0wLGM9bmV3IERhdGUoMWUzKmMpLHIoKVtnPj4+Mj4+PjBdPWMuZ2V0VVRDU2Vjb25kcygpLHIoKVtnKzQ+Pj4yPj4+MF09Yy5nZXRVVENNaW51dGVzKCkscigpW2crOD4+PjI+Pj4wXT1jLmdldFVUQ0hvdXJzKCkscigpW2crMTI+Pj4yPj4+MF09Yy5nZXRVVENEYXRlKCkscigpW2crMTY+Pj4yPj4+MF09Yy5nZXRVVENNb250aCgpLHIoKVtnKzIwPj4+Mj4+PjBdPWMuZ2V0VVRDRnVsbFllYXIoKS0xOTAwLHIoKVtnKzI0Pj4+Mj4+PjBdPWMuZ2V0VVRDRGF5KCksYz0oYy5nZXRUaW1lKCktRGF0ZS5VVEMoYy5nZXRVVENGdWxsWWVhcigpLDAsMSwwLDAsMCwwKSkvODY0ZTV8MCxyKClbZysyOD4+PjI+Pj4wXT1jfSx0OmZ1bmN0aW9uKGMsaCxnKXtjPWgrMjA5NzE1Mj4+PjA8NDE5NDMwNS0hIWM/KGM+Pj4wKSs0Mjk0OTY3Mjk2Kmg6TmFOLGc+Pj49MCxjPW5ldyBEYXRlKDFlMypjKSxyKClbZz4+PjI+Pj4wXT1jLmdldFNlY29uZHMoKSxyKClbZys0Pj4+Mj4+PjBdPWMuZ2V0TWludXRlcygpLHIoKVtnKzg+Pj4yPj4+MF09Yy5nZXRIb3VycygpLHIoKVtnKzEyPj4+Mj4+PjBdPWMuZ2V0RGF0ZSgpLHIoKVtnKzE2Pj4+Mj4+PjBdPWMuZ2V0TW9udGgoKSxyKClbZysyMD4+PjI+Pj4wXT1jLmdldEZ1bGxZZWFyKCktMTkwMCxyKClbZysyND4+PjI+Pj4wXT1jLmdldERheSgpLGg9KEFyKGMuZ2V0RnVsbFllYXIoKSk/VGE6eGEpW2MuZ2V0TW9udGgoKV0rYy5nZXREYXRlKCktMXwwLHIoKVtnKzI4Pj4+Mj4+PjBdPWgscigpW2crMzY+Pj4yPj4+MF09LSg2MCpjLmdldFRpbWV6b25lT2Zmc2V0KCkpLGg9bmV3IERhdGUoYy5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgUz1uZXcgRGF0ZShjLmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpO2M9KGghPVMmJmMuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4oUyxoKSl8MCxyKClbZyszMj4+PjI+Pj4wXT1jfSx1OmZ1bmN0aW9uKGMpe2M+Pj49MDt2YXIgaD1uZXcgRGF0ZShyKClbYysyMD4+PjI+Pj4wXSsxOTAwLHIoKVtjKzE2Pj4+Mj4+PjBdLHIoKVtjKzEyPj4+Mj4+PjBdLHIoKVtjKzg+Pj4yPj4+MF0scigpW2MrND4+PjI+Pj4wXSxyKClbYz4+PjI+Pj4wXSwwKSxnPXIoKVtjKzMyPj4+Mj4+PjBdLFM9aC5nZXRUaW1lem9uZU9mZnNldCgpLGs9bmV3IERhdGUoaC5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxCPW5ldyBEYXRlKGguZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCksej1NYXRoLm1pbihCLGspO3JldHVybiAwPmc/cigpW2MrMzI+Pj4yPj4+MF09KyhrIT1CJiZ6PT1TKTowPGchPSh6PT1TKSYmKGs9TWF0aC5tYXgoQixrKSxoLnNldFRpbWUoaC5nZXRUaW1lKCkrNmU0KigoMDxnP3o6ayktUykpKSxyKClbYysyND4+PjI+Pj4wXT1oLmdldERheSgpLGc9KEFyKGguZ2V0RnVsbFllYXIoKSk/VGE6eGEpW2guZ2V0TW9udGgoKV0raC5nZXREYXRlKCktMXwwLHIoKVtjKzI4Pj4+Mj4+PjBdPWcscigpW2M+Pj4yPj4+MF09aC5nZXRTZWNvbmRzKCkscigpW2MrND4+PjI+Pj4wXT1oLmdldE1pbnV0ZXMoKSxyKClbYys4Pj4+Mj4+PjBdPWguZ2V0SG91cnMoKSxyKClbYysxMj4+PjI+Pj4wXT1oLmdldERhdGUoKSxyKClbYysxNj4+PjI+Pj4wXT1oLmdldE1vbnRoKCkscigpW2MrMjA+Pj4yPj4+MF09aC5nZXRZZWFyKCksYz1oLmdldFRpbWUoKSxpc05hTihjKT8ocigpWyRhKCk+Pj4yPj4+MF09NjEsYz0tMSk6Yy89MWUzLE1hKChVdD1jLDE8PStNYXRoLmFicyhVdCk/MDxVdD8rTWF0aC5mbG9vcihVdC80Mjk0OTY3Mjk2KT4+PjA6fn4rTWF0aC5jZWlsKChVdC0rKH5+VXQ+Pj4wKSkvNDI5NDk2NzI5Nik+Pj4wOjApKSxjPj4+MH0scTp3YSxyOnZhLHk6ZnVuY3Rpb24oYyxoLGcpe2Z1bmN0aW9uIFMoTmUpe3JldHVybihOZT1OZS50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFwoKFtBLVphLXogXSspXFwpJC8pKT9OZVsxXTpcIkdNVFwifWM+Pj49MCxoPj4+PTAsZz4+Pj0wO3ZhciBrPW5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSxCPW5ldyBEYXRlKGssMCwxKSx6PW5ldyBEYXRlKGssNiwxKTtrPUIuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgSWU9ei5nZXRUaW1lem9uZU9mZnNldCgpLEZ0PU1hdGgubWF4KGssSWUpO24oKVtjPj4+Mj4+PjBdPTYwKkZ0LHIoKVtoPj4+Mj4+PjBdPSsoayE9SWUpLGM9UyhCKSxoPVMoeiksYz1fYShjKSxoPV9hKGgpLEllPGs/KG4oKVtnPj4+Mj4+PjBdPWMsbigpW2crND4+PjI+Pj4wXT1oKToobigpW2c+Pj4yPj4+MF09aCxuKClbZys0Pj4+Mj4+PjBdPWMpfSxjOigpPT57TXQoXCJcIil9LE86ZnVuY3Rpb24oYyxoLGcpe2M+Pj49MCxoPj4+PTAsZz4+Pj0wLFJvLmxlbmd0aD0wO2Zvcih2YXIgUztTPWUoKVtoKys+Pj4wXTspe3ZhciBrPVMhPTEwNTtrJj1TIT0xMTIsZys9ayYmZyU4PzQ6MCxSby5wdXNoKFM9PTExMj9uKClbZz4+PjI+Pj4wXTpTPT0xMDU/cigpW2c+Pj4yPj4+MF06cygpW2c+Pj4zPj4+MF0pLGcrPWs/ODo0fXJldHVybiB2cltjXS5hcHBseShudWxsLFJvKX0sazooKT0+e30saTooKT0+RGF0ZS5ub3coKSxVOigpPT57dGhyb3cgdHIrPTEsXCJ1bndpbmRcIn0sQTpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTAxNzYwfSxlOigpPT5wZXJmb3JtYW5jZS50aW1lT3JpZ2luK3BlcmZvcm1hbmNlLm5vdygpLGY6KCk9Pnc/KCRwKCksb3IoQ3ApKS5jcHVzKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5LHg6ZnVuY3Rpb24oYyl7Yz4+Pj0wO3ZhciBoPWUoKS5sZW5ndGg7aWYoYzw9aHx8NDI5NDkwMTc2MDxjKXJldHVybiExO2Zvcih2YXIgZz0xOzQ+PWc7Zyo9Mil7dmFyIFM9aCooMSsuMi9nKTtTPU1hdGgubWluKFMsYysxMDA2NjMyOTYpO3ZhciBrPU1hdGg7Uz1NYXRoLm1heChjLFMpO2U6e2s9KGsubWluLmNhbGwoayw0Mjk0OTAxNzYwLFMrKDY1NTM2LVMlNjU1MzYpJTY1NTM2KS1BZS5idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNSkvNjU1MzY7dHJ5e0FlLmdyb3coayksd2UoKTt2YXIgQj0xO2JyZWFrIGV9Y2F0Y2h7fUI9dm9pZCAwfWlmKEIpcmV0dXJuITB9cmV0dXJuITF9LE06SWEsTjpTYSxHOlNyLGc6QWEsbTpQYSx2OkVhLGw6RGEsYTpBZXx8aS53YXNtTWVtb3J5LHc6Q2EsZDpmdW5jdGlvbihjLGgsZyxTKXtyZXR1cm4gQ2EoYz4+PjAsaD4+PjAsZz4+PjAsUz4+PjApfX0sSz1mdW5jdGlvbigpe2Z1bmN0aW9uIGMoZyxTKXtyZXR1cm4gSz1nLmV4cG9ydHMsSz1fZCgpLEouYmIucHVzaChLLnphKSxKcj1LLkFhLFB0LnVuc2hpZnQoSy5WKSxJdD1TLEV0KCksS312YXIgaD17YTp2ZH07aWYoeXQrKyxpLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIGkuaW5zdGFudGlhdGVXYXNtKGgsYyl9Y2F0Y2goZyl7VihgTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogJHtnfWApLGwoZyl9cmV0dXJuIHduKGgsZnVuY3Rpb24oZyl7YyhnLmluc3RhbmNlLGcubW9kdWxlKX0pLmNhdGNoKGwpLHt9fSgpO2kuX09ydEluaXQ9KGMsaCk9PihpLl9PcnRJbml0PUsuVykoYyxoKSxpLl9PcnRHZXRMYXN0RXJyb3I9KGMsaCk9PihpLl9PcnRHZXRMYXN0RXJyb3I9Sy5YKShjLGgpLGkuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPShjLGgsZyxTLGssQix6LEllLEZ0LE5lKT0+KGkuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPUsuWSkoYyxoLGcsUyxrLEIseixJZSxGdCxOZSksaS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9KGMsaCk9PihpLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj1LLlopKGMsaCksaS5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPShjLGgsZyk9PihpLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9Sy5fKShjLGgsZyksaS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PShjLGgsZyk9PihpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9Sy4kKShjLGgsZyksaS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWM9PihpLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9Sy5hYSkoYyksaS5fT3J0Q3JlYXRlU2Vzc2lvbj0oYyxoLGcpPT4oaS5fT3J0Q3JlYXRlU2Vzc2lvbj1LLmJhKShjLGgsZyksaS5fT3J0UmVsZWFzZVNlc3Npb249Yz0+KGkuX09ydFJlbGVhc2VTZXNzaW9uPUsuY2EpKGMpLGkuX09ydEdldElucHV0T3V0cHV0Q291bnQ9KGMsaCxnKT0+KGkuX09ydEdldElucHV0T3V0cHV0Q291bnQ9Sy5kYSkoYyxoLGcpLGkuX09ydEdldElucHV0TmFtZT0oYyxoKT0+KGkuX09ydEdldElucHV0TmFtZT1LLmVhKShjLGgpLGkuX09ydEdldE91dHB1dE5hbWU9KGMsaCk9PihpLl9PcnRHZXRPdXRwdXROYW1lPUsuZmEpKGMsaCksaS5fT3J0RnJlZT1jPT4oaS5fT3J0RnJlZT1LLmdhKShjKSxpLl9PcnRDcmVhdGVUZW5zb3I9KGMsaCxnLFMsayxCKT0+KGkuX09ydENyZWF0ZVRlbnNvcj1LLmhhKShjLGgsZyxTLGssQiksaS5fT3J0R2V0VGVuc29yRGF0YT0oYyxoLGcsUyxrKT0+KGkuX09ydEdldFRlbnNvckRhdGE9Sy5pYSkoYyxoLGcsUyxrKSxpLl9PcnRSZWxlYXNlVGVuc29yPWM9PihpLl9PcnRSZWxlYXNlVGVuc29yPUsuamEpKGMpLGkuX09ydENyZWF0ZVJ1bk9wdGlvbnM9KGMsaCxnLFMpPT4oaS5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1LLmthKShjLGgsZyxTKSxpLl9PcnRBZGRSdW5Db25maWdFbnRyeT0oYyxoLGcpPT4oaS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9Sy5sYSkoYyxoLGcpLGkuX09ydFJlbGVhc2VSdW5PcHRpb25zPWM9PihpLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1LLm1hKShjKSxpLl9PcnRDcmVhdGVCaW5kaW5nPWM9PihpLl9PcnRDcmVhdGVCaW5kaW5nPUsubmEpKGMpLGkuX09ydEJpbmRJbnB1dD0oYyxoLGcpPT4oaS5fT3J0QmluZElucHV0PUsub2EpKGMsaCxnKSxpLl9PcnRCaW5kT3V0cHV0PShjLGgsZyxTKT0+KGkuX09ydEJpbmRPdXRwdXQ9Sy5wYSkoYyxoLGcsUyksaS5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9Yz0+KGkuX09ydENsZWFyQm91bmRPdXRwdXRzPUsucWEpKGMpLGkuX09ydFJlbGVhc2VCaW5kaW5nPWM9PihpLl9PcnRSZWxlYXNlQmluZGluZz1LLnJhKShjKSxpLl9PcnRSdW5XaXRoQmluZGluZz0oYyxoLGcsUyxrKT0+KGkuX09ydFJ1bldpdGhCaW5kaW5nPUsuc2EpKGMsaCxnLFMsayksaS5fT3J0UnVuPShjLGgsZyxTLGssQix6LEllKT0+KGkuX09ydFJ1bj1LLnRhKShjLGgsZyxTLGssQix6LEllKSxpLl9PcnRFbmRQcm9maWxpbmc9Yz0+KGkuX09ydEVuZFByb2ZpbGluZz1LLnVhKShjKTt2YXIgJGE9KCk9PigkYT1LLnZhKSgpLEFuPWkuX3B0aHJlYWRfc2VsZj0oKT0+KEFuPWkuX3B0aHJlYWRfc2VsZj1LLndhKSgpLGthPWkuX21hbGxvYz1jPT4oa2E9aS5fbWFsbG9jPUsueGEpKGMpO2kuX2ZyZWU9Yz0+KGkuX2ZyZWU9Sy55YSkoYyksaS5fX2Vtc2NyaXB0ZW5fdGxzX2luaXQ9KCk9PihpLl9fZW1zY3JpcHRlbl90bHNfaW5pdD1LLnphKSgpO3ZhciBCYT1pLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD0oYyxoLGcsUyxrLEIpPT4oQmE9aS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQ9Sy5CYSkoYyxoLGcsUyxrLEIpO2kuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPSgpPT4oaS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9Sy5DYSkoKTt2YXIgTmE9KGMsaCxnLFMpPT4oTmE9Sy5EYSkoYyxoLGcsUyksVW89Yz0+KFVvPUsuRWEpKGMpLHpvPWkuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0PWM9Pih6bz1pLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD1LLkZhKShjKSxSYT0oKT0+KFJhPUsuR2EpKCksTWE9Yz0+KE1hPUsuSGEpKGMpLEdhPShjLGgpPT4oR2E9Sy5JYSkoYyxoKSxWbz0oKT0+KFZvPUsuSmEpKCksUG49Yz0+KFBuPUsuS2EpKGMpLFdvPWM9PihXbz1LLkxhKShjKTtmdW5jdGlvbiBfZCgpe3ZhciBjPUs7Yz1PYmplY3QuYXNzaWduKHt9LGMpO3ZhciBoPVM9PigpPT5TKCk+Pj4wLGc9Uz0+az0+UyhrKT4+PjA7cmV0dXJuIGMudmE9aChjLnZhKSxjLndhPWgoYy53YSksYy54YT1nKGMueGEpLGMuZW1zY3JpcHRlbl9tYWluX3J1bnRpbWVfdGhyZWFkX2lkPWgoYy5lbXNjcmlwdGVuX21haW5fcnVudGltZV90aHJlYWRfaWQpLGMuSmE9aChjLkphKSxjLkxhPWcoYy5MYSksY31pLndhc21NZW1vcnk9QWUsaS5zdGFja0FsbG9jPVdvLGkuc3RhY2tTYXZlPVZvLGkuc3RhY2tSZXN0b3JlPVBuLGkua2VlcFJ1bnRpbWVBbGl2ZT0oKT0+MDx0cixpLlVURjhUb1N0cmluZz1JcixpLnN0cmluZ1RvVVRGOD1VZSxpLmxlbmd0aEJ5dGVzVVRGOD1rZSxpLkV4aXRTdGF0dXM9cXQsaS5QVGhyZWFkPUo7dmFyIEVuO1FlPWZ1bmN0aW9uIGMoKXtFbnx8VWEoKSxFbnx8KFFlPWMpfTtmdW5jdGlvbiBVYSgpe2lmKCEoMDx5dCkpaWYoSSl1KGkpLEl8fHJyKFB0KSxzdGFydFdvcmtlcihpKTtlbHNle2lmKGkucHJlUnVuKWZvcih0eXBlb2YgaS5wcmVSdW49PVwiZnVuY3Rpb25cIiYmKGkucHJlUnVuPVtpLnByZVJ1bl0pO2kucHJlUnVuLmxlbmd0aDspUXQudW5zaGlmdChpLnByZVJ1bi5zaGlmdCgpKTtycihRdCksMDx5dHx8RW58fChFbj0hMCxpLmNhbGxlZFJ1bj0hMCxtdHx8KEl8fHJyKFB0KSx1KGkpLEl8fHJyKGd0KSkpfX1yZXR1cm4gVWEoKSx0LnJlYWR5fX0pKCk7dHlwZW9mIEJwPT1cIm9iamVjdFwiJiZ0eXBlb2YgaWE9PVwib2JqZWN0XCI/aWEuZXhwb3J0cz1rcDp0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQmJmRlZmluZShbXSwoKT0+a3ApfSk7dmFyIFJwPW1lKCh1Tyx1Zyk9Pnt1Zy5leHBvcnRzPSdcInVzZSBzdHJpY3RcIjt2YXIgTW9kdWxlPXt9LEVOVklST05NRU5UX0lTX05PREU9dHlwZW9mIHByb2Nlc3M9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlPT1cInN0cmluZ1wiO2lmKEVOVklST05NRU5UX0lTX05PREUpe3ZhciBub2RlV29ya2VyVGhyZWFkcz1yZXF1aXJlKFwid29ya2VyX3RocmVhZHNcIikscGFyZW50UG9ydD1ub2RlV29ya2VyVGhyZWFkcy5wYXJlbnRQb3J0O3BhcmVudFBvcnQub24oXCJtZXNzYWdlXCIsZT0+b25tZXNzYWdlKHtkYXRhOmV9KSk7dmFyIGZzPXJlcXVpcmUoXCJmc1wiKSx2bT1yZXF1aXJlKFwidm1cIik7T2JqZWN0LmFzc2lnbihnbG9iYWwse3NlbGY6Z2xvYmFsLHJlcXVpcmUsTW9kdWxlLGxvY2F0aW9uOntocmVmOl9fZmlsZW5hbWV9LFdvcmtlcjpub2RlV29ya2VyVGhyZWFkcy5Xb3JrZXIsaW1wb3J0U2NyaXB0czplPT52bS5ydW5JblRoaXNDb250ZXh0KGZzLnJlYWRGaWxlU3luYyhlLFwidXRmOFwiKSx7ZmlsZW5hbWU6ZX0pLHBvc3RNZXNzYWdlOmU9PnBhcmVudFBvcnQucG9zdE1lc3NhZ2UoZSkscGVyZm9ybWFuY2U6Z2xvYmFsLnBlcmZvcm1hbmNlfHx7bm93OkRhdGUubm93fX0pfXZhciBpbml0aWFsaXplZEpTPSExO2Z1bmN0aW9uIHRocmVhZFByaW50RXJyKCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtpZihFTlZJUk9OTUVOVF9JU19OT0RFKXtmcy53cml0ZVN5bmMoMixlK2BcXG5gKTtyZXR1cm59Y29uc29sZS5lcnJvcihlKX1mdW5jdGlvbiB0aHJlYWRBbGVydCgpe3ZhciBlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIiBcIik7cG9zdE1lc3NhZ2Uoe2NtZDpcImFsZXJ0XCIsdGV4dDplLHRocmVhZElkOk1vZHVsZS5fcHRocmVhZF9zZWxmKCl9KX12YXIgZXJyPXRocmVhZFByaW50RXJyO3NlbGYuYWxlcnQ9dGhyZWFkQWxlcnQsTW9kdWxlLmluc3RhbnRpYXRlV2FzbT0oZSx0KT0+e3ZhciBhPU1vZHVsZS53YXNtTW9kdWxlO01vZHVsZS53YXNtTW9kdWxlPW51bGw7dmFyIHI9bmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKGEsZSk7cmV0dXJuIHQocil9LHNlbGYub251bmhhbmRsZWRyZWplY3Rpb249ZT0+e3Rocm93IGUucmVhc29ufHxlfTtmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKGUpe3RyeXtpZihlLmRhdGEuY21kPT09XCJsb2FkXCIpe2xldCBhPVtdO3NlbGYub25tZXNzYWdlPXI9PmEucHVzaChyKSxzZWxmLnN0YXJ0V29ya2VyPXI9PntNb2R1bGU9cixwb3N0TWVzc2FnZSh7Y21kOlwibG9hZGVkXCJ9KTtmb3IobGV0IHMgb2YgYSloYW5kbGVNZXNzYWdlKHMpO3NlbGYub25tZXNzYWdlPWhhbmRsZU1lc3NhZ2V9LE1vZHVsZS53YXNtTW9kdWxlPWUuZGF0YS53YXNtTW9kdWxlO2Zvcihjb25zdCByIG9mIGUuZGF0YS5oYW5kbGVycylNb2R1bGVbcl09KC4uLnMpPT57cG9zdE1lc3NhZ2Uoe2NtZDpcImNhbGxIYW5kbGVyXCIsaGFuZGxlcjpyLGFyZ3M6c30pfTtpZihNb2R1bGUud2FzbU1lbW9yeT1lLmRhdGEud2FzbU1lbW9yeSxNb2R1bGUuYnVmZmVyPU1vZHVsZS53YXNtTWVtb3J5LmJ1ZmZlcixNb2R1bGUuRU5WSVJPTk1FTlRfSVNfUFRIUkVBRD0hMCx0eXBlb2YgZS5kYXRhLnVybE9yQmxvYj09XCJzdHJpbmdcIilpbXBvcnRTY3JpcHRzKGUuZGF0YS51cmxPckJsb2IpO2Vsc2V7dmFyIHQ9VVJMLmNyZWF0ZU9iamVjdFVSTChlLmRhdGEudXJsT3JCbG9iKTtpbXBvcnRTY3JpcHRzKHQpLFVSTC5yZXZva2VPYmplY3RVUkwodCl9b3J0V2FzbVRocmVhZGVkKE1vZHVsZSl9ZWxzZSBpZihlLmRhdGEuY21kPT09XCJydW5cIil7TW9kdWxlLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdChlLmRhdGEucHRocmVhZF9wdHIsMCwwLDEpLE1vZHVsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX21haWxib3hfYXdhaXQoZS5kYXRhLnB0aHJlYWRfcHRyKSxNb2R1bGUuZXN0YWJsaXNoU3RhY2tTcGFjZSgpLE1vZHVsZS5QVGhyZWFkLnJlY2VpdmVPYmplY3RUcmFuc2ZlcihlLmRhdGEpLE1vZHVsZS5QVGhyZWFkLnRocmVhZEluaXRUTFMoKSxpbml0aWFsaXplZEpTfHwoaW5pdGlhbGl6ZWRKUz0hMCk7dHJ5e01vZHVsZS5pbnZva2VFbnRyeVBvaW50KGUuZGF0YS5zdGFydF9yb3V0aW5lLGUuZGF0YS5hcmcpfWNhdGNoKGEpe2lmKGEhPVwidW53aW5kXCIpdGhyb3cgYX19ZWxzZSBlLmRhdGEuY21kPT09XCJjYW5jZWxcIj9Nb2R1bGUuX3B0aHJlYWRfc2VsZigpJiZNb2R1bGUuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0KC0xKTplLmRhdGEudGFyZ2V0PT09XCJzZXRpbW1lZGlhdGVcInx8KGUuZGF0YS5jbWQ9PT1cImNoZWNrTWFpbGJveFwiP2luaXRpYWxpemVkSlMmJk1vZHVsZS5jaGVja01haWxib3goKTplLmRhdGEuY21kJiYoZXJyKGB3b3JrZXIuanMgcmVjZWl2ZWQgdW5rbm93biBjb21tYW5kICR7ZS5kYXRhLmNtZH1gKSxlcnIoZS5kYXRhKSkpfWNhdGNoKGEpe3Rocm93IE1vZHVsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ/LigpLGF9fXNlbGYub25tZXNzYWdlPWhhbmRsZU1lc3NhZ2U7XFxuJ30pO3ZhciBHcCxsZyxhYSxzYSxQbyxNcCxmZyxjZyxwZyxVcCxMZSxWcj1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7R3A9RHAoKTtsZz1OcCgpLHNhPSExLFBvPSExLE1wPSExLGZnPWE9PntpZihhPT09MSlyZXR1cm4hMTtpZih0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI+XCJ1XCIpcmV0dXJuIHR5cGVvZiBzZWxmPFwidVwiJiYhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkJiZjb25zb2xlLndhcm4oXCJlbnYud2FzbS5udW1UaHJlYWRzIGlzIHNldCB0byBcIithK1wiLCBidXQgdGhpcyB3aWxsIG5vdCB3b3JrIHVubGVzcyB5b3UgZW5hYmxlIGNyb3NzT3JpZ2luSXNvbGF0ZWQgbW9kZS4gU2VlIGh0dHBzOi8vd2ViLmRldi9jcm9zcy1vcmlnaW4taXNvbGF0aW9uLWd1aWRlLyBmb3IgbW9yZSBpbmZvLlwiKSwhMTt0eXBlb2YgcHJvY2VzczxcInVcIiYmcHJvY2Vzcy52ZXJzaW9ucyYmcHJvY2Vzcy52ZXJzaW9ucy5ub2RlJiZjb25zb2xlLndhcm4oXCJlbnYud2FzbS5udW1UaHJlYWRzIGlzIHNldCB0byBcIithK1wiLCBob3dldmVyLCBjdXJyZW50bHkgb25ueHJ1bnRpbWUtd2ViIGRvZXMgbm90IHN1cHBvcnQgbXVsdGktdGhyZWFkcyBpbiBOb2RlLmpzLiBQbGVhc2UgY29uc2lkZXIgdXNpbmcgb25ueHJ1bnRpbWUtbm9kZSBmb3IgcGVyZm9ybWFuY2UgY3JpdGljYWwgc2NlbmFyaW9zLlwiKTt0cnl7cmV0dXJuIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbDxcInVcIiYmbmV3IE1lc3NhZ2VDaGFubmVsKCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpfWNhdGNoe3JldHVybiExfX0sY2c9KCk9Pnt0cnl7cmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCwxMCwzMCwxLDI4LDAsNjUsMCwyNTMsMTUsMjUzLDEyLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMjUzLDE4NiwxLDI2LDExXSkpfWNhdGNoe3JldHVybiExfX0scGc9KGEsdCk9PmE/dD9cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbVwiOlwib3J0LXdhc20tc2ltZC53YXNtXCI6dD9cIm9ydC13YXNtLXRocmVhZGVkLndhc21cIjpcIm9ydC13YXNtLndhc21cIixVcD1hc3luYyBhPT57aWYoc2EpcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2lmKFBvKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZGV0ZWN0ZWQuXCIpO2lmKE1wKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBmYWlsZWQuXCIpO1BvPSEwO2xldCB0PWEuaW5pdFRpbWVvdXQsbz1hLm51bVRocmVhZHMsZT1hLnNpbWQscj1mZyhvKSxuPWUmJmNnKCkscz1hLndhc21QYXRocyxpPXR5cGVvZiBzPT1cInN0cmluZ1wiP3M6dm9pZCAwLHU9cGcobixyKSxsPXR5cGVvZiBzPT1cIm9iamVjdFwiP3NbdV06dm9pZCAwLGY9ITEscD1bXTtpZih0PjAmJnAucHVzaChuZXcgUHJvbWlzZShkPT57c2V0VGltZW91dCgoKT0+e2Y9ITAsZCgpfSx0KX0pKSxwLnB1c2gobmV3IFByb21pc2UoKGQsVCk9PntsZXQgdj1yP2xnOkdwLHc9e2xvY2F0ZUZpbGU6KEksTCk9PnImJkkuZW5kc1dpdGgoXCIud29ya2VyLmpzXCIpJiZ0eXBlb2YgQmxvYjxcInVcIj9VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtScCgpXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSkpOkkuZW5kc1dpdGgoXCIud2FzbVwiKT9sfHwoaT8/TCkrdTpMK0l9O2lmKHIpaWYody5udW1UaHJlYWRzPW8sdHlwZW9mIEJsb2I+XCJ1XCIpdy5tYWluU2NyaXB0VXJsT3JCbG9iPSh2b2lkIDApKF9fZGlybmFtZSxcIm9ydC13YXNtLXRocmVhZGVkLmpzXCIpO2Vsc2V7bGV0IEk9YHZhciBvcnRXYXNtVGhyZWFkZWQ9JHt2LnRvU3RyaW5nKCl9O2A7dy5tYWluU2NyaXB0VXJsT3JCbG9iPW5ldyBCbG9iKFtJXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSl9dih3KS50aGVuKEk9PntQbz0hMSxzYT0hMCxhYT1JLGQoKX0sST0+e1BvPSExLE1wPSEwLFQoSSl9KX0pKSxhd2FpdCBQcm9taXNlLnJhY2UocCksZil0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHt0fW1zYCl9LExlPSgpPT57aWYoc2EmJmFhKXJldHVybiBhYTt0aHJvdyBuZXcgRXJyb3IoXCJXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LlwiKX19KTt2YXIgX2UseW4sT2UsRW89RSgoKT0+e1widXNlIHN0cmljdFwiO1ZyKCk7X2U9KGEsdCk9PntsZXQgbz1MZSgpLGU9by5sZW5ndGhCeXRlc1VURjgoYSkrMSxyPW8uX21hbGxvYyhlKTtyZXR1cm4gby5zdHJpbmdUb1VURjgoYSxyLGUpLHQucHVzaChyKSxyfSx5bj0oYSx0LG8sZSk9PntpZih0eXBlb2YgYT09XCJvYmplY3RcIiYmYSE9PW51bGwpe2lmKG8uaGFzKGEpKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zXCIpO28uYWRkKGEpfU9iamVjdC5lbnRyaWVzKGEpLmZvckVhY2goKFtyLG5dKT0+e2xldCBzPXQ/dCtyOnI7aWYodHlwZW9mIG49PVwib2JqZWN0XCIpeW4obixzK1wiLlwiLG8sZSk7ZWxzZSBpZih0eXBlb2Ygbj09XCJzdHJpbmdcInx8dHlwZW9mIG49PVwibnVtYmVyXCIpZShzLG4udG9TdHJpbmcoKSk7ZWxzZSBpZih0eXBlb2Ygbj09XCJib29sZWFuXCIpZShzLG4/XCIxXCI6XCIwXCIpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6ICR7dHlwZW9mIG59YCl9KX0sT2U9YT0+e2xldCB0PUxlKCksbz10LnN0YWNrU2F2ZSgpO3RyeXtsZXQgZT10LnN0YWNrQWxsb2MoOCk7dC5fT3J0R2V0TGFzdEVycm9yKGUsZSs0KTtsZXQgcj10LkhFQVAzMltlLzRdLG49dC5IRUFQVTMyW2UvNCsxXSxzPW4/dC5VVEY4VG9TdHJpbmcobik6XCJcIjt0aHJvdyBuZXcgRXJyb3IoYCR7YX0gRVJST1JfQ09ERTogJHtyfSwgRVJST1JfTUVTU0FHRTogJHtzfWApfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUobyl9fX0pO3ZhciB6cCxWcD1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VnIoKTtFbygpO3pwPWE9PntsZXQgdD1MZSgpLG89MCxlPVtdLHI9YXx8e307dHJ5e2lmKGE/LmxvZ1NldmVyaXR5TGV2ZWw9PT12b2lkIDApci5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZih0eXBlb2YgYS5sb2dTZXZlcml0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihhLmxvZ1NldmVyaXR5TGV2ZWwpfHxhLmxvZ1NldmVyaXR5TGV2ZWw8MHx8YS5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHthLmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYoYT8ubG9nVmVyYm9zaXR5TGV2ZWw9PT12b2lkIDApci5sb2dWZXJib3NpdHlMZXZlbD0wO2Vsc2UgaWYodHlwZW9mIGEubG9nVmVyYm9zaXR5TGV2ZWwhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGEubG9nVmVyYm9zaXR5TGV2ZWwpKXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7YS5sb2dWZXJib3NpdHlMZXZlbH1gKTthPy50ZXJtaW5hdGU9PT12b2lkIDAmJihyLnRlcm1pbmF0ZT0hMSk7bGV0IG49MDtyZXR1cm4gYT8udGFnIT09dm9pZCAwJiYobj1fZShhLnRhZyxlKSksbz10Ll9PcnRDcmVhdGVSdW5PcHRpb25zKHIubG9nU2V2ZXJpdHlMZXZlbCxyLmxvZ1ZlcmJvc2l0eUxldmVsLCEhci50ZXJtaW5hdGUsbiksbz09PTAmJk9lKFwiQ2FuJ3QgY3JlYXRlIHJ1biBvcHRpb25zLlwiKSxhPy5leHRyYSE9PXZvaWQgMCYmeW4oYS5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LChzLGkpPT57bGV0IHU9X2UocyxlKSxsPV9lKGksZSk7dC5fT3J0QWRkUnVuQ29uZmlnRW50cnkobyx1LGwpIT09MCYmT2UoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7c30gLSAke2l9LmApfSksW28sZV19Y2F0Y2gobil7dGhyb3cgbyE9PTAmJnQuX09ydFJlbGVhc2VSdW5PcHRpb25zKG8pLGUuZm9yRWFjaChzPT50Ll9mcmVlKHMpKSxufX19KTt2YXIgZGcsaGcsbWcsYmcsV3AsSHA9RSgoKT0+e1widXNlIHN0cmljdFwiO1ZyKCk7RW8oKTtkZz1hPT57c3dpdGNoKGEpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2F9YCl9fSxoZz1hPT57c3dpdGNoKGEpe2Nhc2VcInNlcXVlbnRpYWxcIjpyZXR1cm4gMDtjYXNlXCJwYXJhbGxlbFwiOnJldHVybiAxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHthfWApfX0sbWc9YT0+e2EuZXh0cmF8fChhLmV4dHJhPXt9KSxhLmV4dHJhLnNlc3Npb258fChhLmV4dHJhLnNlc3Npb249e30pO2xldCB0PWEuZXh0cmEuc2Vzc2lvbjt0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fCh0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpLGEuZXhlY3V0aW9uUHJvdmlkZXJzJiZhLmV4ZWN1dGlvblByb3ZpZGVycy5zb21lKG89Pih0eXBlb2Ygbz09XCJzdHJpbmdcIj9vOm8ubmFtZSk9PT1cIndlYmdwdVwiKSYmKGEuZW5hYmxlTWVtUGF0dGVybj0hMSl9LGJnPShhLHQsbyk9Pntmb3IobGV0IGUgb2YgdCl7bGV0IHI9dHlwZW9mIGU9PVwic3RyaW5nXCI/ZTplLm5hbWU7c3dpdGNoKHIpe2Nhc2VcIndlYm5uXCI6aWYocj1cIldFQk5OXCIsdHlwZW9mIGUhPVwic3RyaW5nXCIpe2xldCBzPWU7aWYocz8uZGV2aWNlVHlwZSl7bGV0IGk9X2UoXCJkZXZpY2VUeXBlXCIsbyksdT1fZShzLmRldmljZVR5cGUsbyk7TGUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGEsaSx1KSE9PTAmJk9lKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ2RldmljZVR5cGUnIC0gJHtzLmRldmljZVR5cGV9LmApfWlmKHM/Lm51bVRocmVhZHMpe2xldCBpPXMubnVtVGhyZWFkczsodHlwZW9mIGkhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGkpfHxpPDApJiYoaT0wKTtsZXQgdT1fZShcIm51bVRocmVhZHNcIixvKSxsPV9lKGkudG9TdHJpbmcoKSxvKTtMZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoYSx1LGwpIT09MCYmT2UoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnbnVtVGhyZWFkcycgLSAke3MubnVtVGhyZWFkc30uYCl9aWYocz8ucG93ZXJQcmVmZXJlbmNlKXtsZXQgaT1fZShcInBvd2VyUHJlZmVyZW5jZVwiLG8pLHU9X2Uocy5wb3dlclByZWZlcmVuY2Usbyk7TGUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGEsaSx1KSE9PTAmJk9lKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ3Bvd2VyUHJlZmVyZW5jZScgLSAke3MucG93ZXJQcmVmZXJlbmNlfS5gKX19YnJlYWs7Y2FzZVwid2ViZ3B1XCI6aWYocj1cIkpTXCIsdHlwZW9mIGUhPVwic3RyaW5nXCIpe2xldCBzPWU7aWYocz8ucHJlZmVycmVkTGF5b3V0KXtpZihzLnByZWZlcnJlZExheW91dCE9PVwiTkNIV1wiJiZzLnByZWZlcnJlZExheW91dCE9PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihgcHJlZmVycmVkTGF5b3V0IG11c3QgYmUgZWl0aGVyICdOQ0hXJyBvciAnTkhXQyc6ICR7cy5wcmVmZXJyZWRMYXlvdXR9YCk7bGV0IGk9X2UoXCJwcmVmZXJyZWRMYXlvdXRcIixvKSx1PV9lKHMucHJlZmVycmVkTGF5b3V0LG8pO0xlKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShhLGksdSkhPT0wJiZPZShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdwcmVmZXJyZWRMYXlvdXQnIC0gJHtzLnByZWZlcnJlZExheW91dH0uYCl9fWJyZWFrO2Nhc2VcIndhc21cIjpjYXNlXCJjcHVcIjpjb250aW51ZTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7cn1gKX1sZXQgbj1fZShyLG8pO0xlKCkuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyKGEsbikhPT0wJiZPZShgQ2FuJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtyfS5gKX19LFdwPWE9PntsZXQgdD1MZSgpLG89MCxlPVtdLHI9YXx8e307bWcocik7dHJ5e2xldCBuPWRnKHIuZ3JhcGhPcHRpbWl6YXRpb25MZXZlbD8/XCJhbGxcIikscz1oZyhyLmV4ZWN1dGlvbk1vZGU/P1wic2VxdWVudGlhbFwiKSxpPXR5cGVvZiByLmxvZ0lkPT1cInN0cmluZ1wiP19lKHIubG9nSWQsZSk6MCx1PXIubG9nU2V2ZXJpdHlMZXZlbD8/MjtpZighTnVtYmVyLmlzSW50ZWdlcih1KXx8dTwwfHx1PjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt1fWApO2xldCBsPXIubG9nVmVyYm9zaXR5TGV2ZWw/PzA7aWYoIU51bWJlci5pc0ludGVnZXIobCl8fGw8MHx8bD40KXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7bH1gKTtsZXQgZj10eXBlb2Ygci5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoPT1cInN0cmluZ1wiP19lKHIub3B0aW1pemVkTW9kZWxGaWxlUGF0aCxlKTowO2lmKG89dC5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnMobiwhIXIuZW5hYmxlQ3B1TWVtQXJlbmEsISFyLmVuYWJsZU1lbVBhdHRlcm4scywhIXIuZW5hYmxlUHJvZmlsaW5nLDAsaSx1LGwsZiksbz09PTAmJk9lKFwiQ2FuJ3QgY3JlYXRlIHNlc3Npb24gb3B0aW9ucy5cIiksci5leGVjdXRpb25Qcm92aWRlcnMmJmJnKG8sci5leGVjdXRpb25Qcm92aWRlcnMsZSksci5lbmFibGVHcmFwaENhcHR1cmUhPT12b2lkIDApe2lmKHR5cGVvZiByLmVuYWJsZUdyYXBoQ2FwdHVyZSE9XCJib29sZWFuXCIpdGhyb3cgbmV3IEVycm9yKGBlbmFibGVHcmFwaENhcHR1cmUgbXVzdCBiZSBhIGJvb2xlYW4gdmFsdWU6ICR7ci5lbmFibGVHcmFwaENhcHR1cmV9YCk7bGV0IHA9X2UoXCJlbmFibGVHcmFwaENhcHR1cmVcIixlKSxkPV9lKHIuZW5hYmxlR3JhcGhDYXB0dXJlLnRvU3RyaW5nKCksZSk7dC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KG8scCxkKSE9PTAmJk9lKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ2VuYWJsZUdyYXBoQ2FwdHVyZScgLSAke3IuZW5hYmxlR3JhcGhDYXB0dXJlfS5gKX1pZihyLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpZm9yKGxldFtwLGRdb2YgT2JqZWN0LmVudHJpZXMoci5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKSl7aWYodHlwZW9mIHAhPVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSBuYW1lIG11c3QgYmUgYSBzdHJpbmc6ICR7cH1gKTtpZih0eXBlb2YgZCE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoZCl8fGQ8MCl0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIHZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcjogJHtkfWApO2xldCBUPV9lKHAsZSk7dC5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlKG8sVCxkKSE9PTAmJk9lKGBDYW4ndCBzZXQgYSBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZTogJHtwfSAtICR7ZH0uYCl9cmV0dXJuIHIuZXh0cmEhPT12b2lkIDAmJnluKHIuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwocCxkKT0+e2xldCBUPV9lKHAsZSksdj1fZShkLGUpO3QuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShvLFQsdikhPT0wJiZPZShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7cH0gLSAke2R9LmApfSksW28sZV19Y2F0Y2gobil7dGhyb3cgbyE9PTAmJnQuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhvKSxlLmZvckVhY2gocz0+dC5fZnJlZShzKSksbn19fSk7dmFyIHVhLHFwLGxhLGpwLFlwLERvLFhwLGZhPUUoKCk9PntcInVzZSBzdHJpY3RcIjt1YT1hPT57c3dpdGNoKGEpe2Nhc2VcImludDhcIjpyZXR1cm4gMztjYXNlXCJ1aW50OFwiOnJldHVybiAyO2Nhc2VcImJvb2xcIjpyZXR1cm4gOTtjYXNlXCJpbnQxNlwiOnJldHVybiA1O2Nhc2VcInVpbnQxNlwiOnJldHVybiA0O2Nhc2VcImludDMyXCI6cmV0dXJuIDY7Y2FzZVwidWludDMyXCI6cmV0dXJuIDEyO2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gMTA7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiAxO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gMTE7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIDg7Y2FzZVwiaW50NjRcIjpyZXR1cm4gNztjYXNlXCJ1aW50NjRcIjpyZXR1cm4gMTM7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHthfWApfX0scXA9YT0+e3N3aXRjaChhKXtjYXNlIDM6cmV0dXJuXCJpbnQ4XCI7Y2FzZSAyOnJldHVyblwidWludDhcIjtjYXNlIDk6cmV0dXJuXCJib29sXCI7Y2FzZSA1OnJldHVyblwiaW50MTZcIjtjYXNlIDQ6cmV0dXJuXCJ1aW50MTZcIjtjYXNlIDY6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgMTI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIDEwOnJldHVyblwiZmxvYXQxNlwiO2Nhc2UgMTpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIDExOnJldHVyblwiZmxvYXQ2NFwiO2Nhc2UgODpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgNzpyZXR1cm5cImludDY0XCI7Y2FzZSAxMzpyZXR1cm5cInVpbnQ2NFwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7YX1gKX19LGxhPWE9Plt2b2lkIDAsNCwxLDEsMiwyLDQsOCx2b2lkIDAsMSwyLDgsNCw4LHZvaWQgMCx2b2lkIDAsdm9pZCAwXVthXSxqcD1hPT57c3dpdGNoKGEpe2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gdHlwZW9mIEZsb2F0MTZBcnJheTxcInVcIiYmRmxvYXQxNkFycmF5LmZyb20/RmxvYXQxNkFycmF5OlVpbnQxNkFycmF5O2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwidWludDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImludDE2XCI6cmV0dXJuIEludDE2QXJyYXk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gSW50MzJBcnJheTtjYXNlXCJib29sXCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke2F9YCl9fSxZcD1hPT57c3dpdGNoKGEpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm4gMDtjYXNlXCJpbmZvXCI6cmV0dXJuIDE7Y2FzZVwid2FybmluZ1wiOnJldHVybiAyO2Nhc2VcImVycm9yXCI6cmV0dXJuIDM7Y2FzZVwiZmF0YWxcIjpyZXR1cm4gNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHthfWApfX0sRG89YT0+YT09PVwiZmxvYXQzMlwifHxhPT09XCJmbG9hdDE2XCJ8fGE9PT1cImludDMyXCJ8fGE9PT1cImludDY0XCJ8fGE9PT1cInVpbnQzMlwifHxhPT09XCJ1aW50OFwifHxhPT09XCJib29sXCIsWHA9YT0+e3N3aXRjaChhKXtjYXNlXCJub25lXCI6cmV0dXJuIDA7Y2FzZVwiY3B1XCI6cmV0dXJuIDE7Y2FzZVwiY3B1LXBpbm5lZFwiOnJldHVybiAyO2Nhc2VcInRleHR1cmVcIjpyZXR1cm4gMztjYXNlXCJncHUtYnVmZmVyXCI6cmV0dXJuIDQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgbG9jYXRpb246ICR7YX1gKX19fSk7dmFyIFRuLGNhPUUoKCk9PntcInVzZSBzdHJpY3RcIjtUbj1hc3luYyBhPT57aWYodHlwZW9mIGE9PVwic3RyaW5nXCIpaWYodHlwZW9mIHByb2Nlc3M8XCJ1XCImJnByb2Nlc3MudmVyc2lvbnMmJnByb2Nlc3MudmVyc2lvbnMubm9kZSl0cnl7cmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0KHZvaWQgMCkoYSkpfWNhdGNoKHQpe2lmKHQuY29kZT09PVwiRVJSX0ZTX0ZJTEVfVE9PX0xBUkdFXCIpe2xldCBvPSh2b2lkIDApKGEpLGU9W107Zm9yIGF3YWl0KGxldCByIG9mIG8pZS5wdXNoKHIpO3JldHVybiBuZXcgVWludDhBcnJheShCdWZmZXIuY29uY2F0KGUpKX10aHJvdyB0fWVsc2V7bGV0IHQ9YXdhaXQgZmV0Y2goYSk7aWYoIXQub2spdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7YX1gKTtsZXQgbz10LmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIiksZT1vP3BhcnNlSW50KG8sMTApOjA7aWYoZTwxMDczNzQxODI0KXJldHVybiBuZXcgVWludDhBcnJheShhd2FpdCB0LmFycmF5QnVmZmVyKCkpO3tpZighdC5ib2R5KXRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2F9LCBubyByZXNwb25zZSBib2R5LmApO2xldCByPXQuYm9keS5nZXRSZWFkZXIoKSxuO3RyeXtuPW5ldyBBcnJheUJ1ZmZlcihlKX1jYXRjaChpKXtpZihpIGluc3RhbmNlb2YgUmFuZ2VFcnJvcil7bGV0IHU9TWF0aC5jZWlsKGUvNjU1MzYpO249bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDp1LG1heGltdW06dX0pLmJ1ZmZlcn1lbHNlIHRocm93IGl9bGV0IHM9MDtmb3IoOzspe2xldHtkb25lOmksdmFsdWU6dX09YXdhaXQgci5yZWFkKCk7aWYoaSlicmVhaztsZXQgbD11LmJ5dGVMZW5ndGg7bmV3IFVpbnQ4QXJyYXkobixzLGwpLnNldCh1KSxzKz1sfXJldHVybiBuZXcgVWludDhBcnJheShuLDAsZSl9fWVsc2UgcmV0dXJuIGEgaW5zdGFuY2VvZiBCbG9iP25ldyBVaW50OEFycmF5KGF3YWl0IGEuYXJyYXlCdWZmZXIoKSk6YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/YTpuZXcgVWludDhBcnJheShhKX19KTt2YXIgZ2csSnAsWnAsV3IseWcscGEsUXAsZWQsS3AsdGQscmQsbmQsb2Q9RSgoKT0+e1widXNlIHN0cmljdFwiO1ZwKCk7SHAoKTtmYSgpO1ZyKCk7RW8oKTtjYSgpO2dnPShhLHQpPT57TGUoKS5fT3J0SW5pdChhLHQpIT09MCYmT2UoXCJDYW4ndCBpbml0aWFsaXplIG9ubnhydW50aW1lLlwiKX0sSnA9YXN5bmMgYT0+e2dnKGEud2FzbS5udW1UaHJlYWRzLFlwKGEubG9nTGV2ZWwpKX0sWnA9YXN5bmMoYSx0KT0+e30sV3I9bmV3IE1hcCx5Zz1hPT57bGV0IHQ9TGUoKSxvPXQuc3RhY2tTYXZlKCk7dHJ5e2xldCBlPXQuc3RhY2tBbGxvYyg4KTtyZXR1cm4gdC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudChhLGUsZSs0KSE9PTAmJk9lKFwiQ2FuJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LlwiKSxbdC5IRUFQMzJbZS80XSx0LkhFQVAzMltlLzQrMV1dfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUobyl9fSxwYT1hPT57bGV0IHQ9TGUoKSxvPXQuX21hbGxvYyhhLmJ5dGVMZW5ndGgpO2lmKG89PT0wKXRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHthLmJ5dGVMZW5ndGh9LmApO3JldHVybiB0LkhFQVBVOC5zZXQoYSxvKSxbbyxhLmJ5dGVMZW5ndGhdfSxRcD1hc3luYyhhLHQpPT57bGV0IG8sZSxyPUxlKCk7QXJyYXkuaXNBcnJheShhKT9bbyxlXT1hOmEuYnVmZmVyPT09ci5IRUFQVTguYnVmZmVyP1tvLGVdPVthLmJ5dGVPZmZzZXQsYS5ieXRlTGVuZ3RoXTpbbyxlXT1wYShhKTtsZXQgbj0wLHM9MCxpPTAsdT1bXSxsPVtdLGY9W107dHJ5e2lmKFtzLHVdPVdwKHQpLHQ/LmV4dGVybmFsRGF0YSYmci5tb3VudEV4dGVybmFsRGF0YSl7bGV0IEY9W107Zm9yKGxldCBDIG9mIHQuZXh0ZXJuYWxEYXRhKXtsZXQgWT10eXBlb2YgQz09XCJzdHJpbmdcIj9DOkMucGF0aDtGLnB1c2goVG4odHlwZW9mIEM9PVwic3RyaW5nXCI/QzpDLmRhdGEpLnRoZW4oaj0+e3IubW91bnRFeHRlcm5hbERhdGEoWSxqKX0pKX1hd2FpdCBQcm9taXNlLmFsbChGKX1uPWF3YWl0IHIuX09ydENyZWF0ZVNlc3Npb24obyxlLHMpLG49PT0wJiZPZShcIkNhbid0IGNyZWF0ZSBhIHNlc3Npb24uXCIpO2xldFtwLGRdPXlnKG4pLFQ9ISF0Py5lbmFibGVHcmFwaENhcHR1cmUsdj1bXSx3PVtdLEk9W107Zm9yKGxldCBGPTA7RjxwO0YrKyl7bGV0IEM9ci5fT3J0R2V0SW5wdXROYW1lKG4sRik7Qz09PTAmJk9lKFwiQ2FuJ3QgZ2V0IGFuIGlucHV0IG5hbWUuXCIpLGwucHVzaChDKSx2LnB1c2goci5VVEY4VG9TdHJpbmcoQykpfWZvcihsZXQgRj0wO0Y8ZDtGKyspe2xldCBDPXIuX09ydEdldE91dHB1dE5hbWUobixGKTtDPT09MCYmT2UoXCJDYW4ndCBnZXQgYW4gb3V0cHV0IG5hbWUuXCIpLGYucHVzaChDKTtsZXQgWT1yLlVURjhUb1N0cmluZyhDKTt3LnB1c2goWSl9bGV0IEw9bnVsbDtyZXR1cm4gV3Iuc2V0KG4sW24sbCxmLEwsVCwhMV0pLFtuLHYsd119Y2F0Y2gocCl7dGhyb3cgbC5mb3JFYWNoKGQ9PnIuX09ydEZyZWUoZCkpLGYuZm9yRWFjaChkPT5yLl9PcnRGcmVlKGQpKSxpIT09MCYmci5fT3J0UmVsZWFzZUJpbmRpbmcoaSksbiE9PTAmJnIuX09ydFJlbGVhc2VTZXNzaW9uKG4pLHB9ZmluYWxseXtyLl9mcmVlKG8pLHMhPT0wJiZyLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMocyksdS5mb3JFYWNoKHA9PnIuX2ZyZWUocCkpLHIudW5tb3VudEV4dGVybmFsRGF0YT8uKCl9fSxlZD1hPT57bGV0IHQ9TGUoKSxvPVdyLmdldChhKTtpZighbyl0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWxlYXNlIHNlc3Npb24uIGludmFsaWQgc2Vzc2lvbiBpZDogJHthfWApO2xldFtlLHIsbixzLGldPW87cyYmKGkmJnQuX09ydENsZWFyQm91bmRPdXRwdXRzKHMuaGFuZGxlKSx0Ll9PcnRSZWxlYXNlQmluZGluZyhzLmhhbmRsZSkpLHQuanNlcE9uUmVsZWFzZVNlc3Npb24/LihhKSxyLmZvckVhY2godT0+dC5fT3J0RnJlZSh1KSksbi5mb3JFYWNoKHU9PnQuX09ydEZyZWUodSkpLHQuX09ydFJlbGVhc2VTZXNzaW9uKGUpLFdyLmRlbGV0ZShhKX0sS3A9KGEsdCxvLGUscixuPSExKT0+e2lmKCFhKXt0LnB1c2goMCk7cmV0dXJufWxldCBzPUxlKCksaT1hWzBdLHU9YVsxXSxsPWFbM10sZixwO2lmKGk9PT1cInN0cmluZ1wiJiZsPT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS5cIik7aWYobiYmbCE9PVwiZ3B1LWJ1ZmZlclwiKXRocm93IG5ldyBFcnJvcihgRXh0ZXJuYWwgYnVmZmVyIG11c3QgYmUgcHJvdmlkZWQgZm9yIGlucHV0L291dHB1dCBpbmRleCAke3J9IHdoZW4gZW5hYmxlR3JhcGhDYXB0dXJlIGlzIHRydWUuYCk7aWYobD09PVwiZ3B1LWJ1ZmZlclwiKXtsZXQgdj1hWzJdLmdwdUJ1ZmZlcix3PWxhKHVhKGkpKTtwPXUucmVkdWNlKChMLEYpPT5MKkYsMSkqdztsZXQgST1zLmpzZXBSZWdpc3RlckJ1ZmZlcjtpZighSSl0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO2Y9SShlLHIsdixwKX1lbHNle2xldCB2PWFbMl07aWYoQXJyYXkuaXNBcnJheSh2KSl7cD00KnYubGVuZ3RoLGY9cy5fbWFsbG9jKHApLG8ucHVzaChmKTtsZXQgdz1mLzQ7Zm9yKGxldCBJPTA7STx2Lmxlbmd0aDtJKyspe2lmKHR5cGVvZiB2W0ldIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7SX0gaXMgbm90IGEgc3RyaW5nYCk7cy5IRUFQVTMyW3crK109X2UodltJXSxvKX19ZWxzZSBwPXYuYnl0ZUxlbmd0aCxmPXMuX21hbGxvYyhwKSxvLnB1c2goZikscy5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KHYuYnVmZmVyLHYuYnl0ZU9mZnNldCxwKSxmKX1sZXQgZD1zLnN0YWNrU2F2ZSgpLFQ9cy5zdGFja0FsbG9jKDQqdS5sZW5ndGgpO3RyeXtsZXQgdj1ULzQ7dS5mb3JFYWNoKEk9PnMuSEVBUDMyW3YrK109SSk7bGV0IHc9cy5fT3J0Q3JlYXRlVGVuc29yKHVhKGkpLGYscCxULHUubGVuZ3RoLFhwKGwpKTt3PT09MCYmT2UoYENhbid0IGNyZWF0ZSB0ZW5zb3IgZm9yIGlucHV0L291dHB1dC4gc2Vzc2lvbj0ke2V9LCBpbmRleD0ke3J9LmApLHQucHVzaCh3KX1maW5hbGx5e3Muc3RhY2tSZXN0b3JlKGQpfX0sdGQ9YXN5bmMoYSx0LG8sZSxyLG4pPT57bGV0IHM9TGUoKSxpPVdyLmdldChhKTtpZighaSl0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBydW4gaW5mZXJlbmNlLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7YX1gKTtsZXQgdT1pWzBdLGw9aVsxXSxmPWlbMl0scD1pWzNdLGQ9aVs0XSxUPWlbNV0sdj10Lmxlbmd0aCx3PWUubGVuZ3RoLEk9MCxMPVtdLEY9W10sQz1bXSxZPVtdLGo9cy5zdGFja1NhdmUoKSxNPXMuc3RhY2tBbGxvYyh2KjQpLGllPXMuc3RhY2tBbGxvYyh2KjQpLG90PXMuc3RhY2tBbGxvYyh3KjQpLFdlPXMuc3RhY2tBbGxvYyh3KjQpO3RyeXtbSSxMXT16cChuKTtmb3IobGV0IHRlPTA7dGU8djt0ZSsrKUtwKG9bdGVdLEYsWSxhLHRbdGVdLGQpO2ZvcihsZXQgdGU9MDt0ZTx3O3RlKyspS3Aoclt0ZV0sQyxZLGEsditlW3RlXSxkKTtsZXQgRmU9TS80LFY9aWUvNCxBZT1vdC80LEl0PVdlLzQ7Zm9yKGxldCB0ZT0wO3RlPHY7dGUrKylzLkhFQVBVMzJbRmUrK109Rlt0ZV0scy5IRUFQVTMyW1YrK109bFt0W3RlXV07Zm9yKGxldCB0ZT0wO3RlPHc7dGUrKylzLkhFQVBVMzJbQWUrK109Q1t0ZV0scy5IRUFQVTMyW0l0KytdPWZbZVt0ZV1dO3MuanNlcE9uUnVuU3RhcnQ/Lih1KTtsZXQgbXQ7bXQ9YXdhaXQgcy5fT3J0UnVuKHUsaWUsTSx2LFdlLHcsb3QsSSksbXQhPT0wJiZPZShcImZhaWxlZCB0byBjYWxsIE9ydFJ1bigpLlwiKTtsZXQgQmU9W107Zm9yKGxldCB0ZT0wO3RlPHc7dGUrKyl7bGV0IGJ0PXMuSEVBUFUzMltvdC80K3RlXTtpZihidD09PUNbdGVdKXtCZS5wdXNoKHJbdGVdKTtjb250aW51ZX1sZXQgU3Q9cy5zdGFja1NhdmUoKSxIZT1zLnN0YWNrQWxsb2MoNCo0KSxBdD0hMSx3ZSxaZT0wO3RyeXtzLl9PcnRHZXRUZW5zb3JEYXRhKGJ0LEhlLEhlKzQsSGUrOCxIZSsxMikhPT0wJiZPZShgQ2FuJ3QgYWNjZXNzIG91dHB1dCB0ZW5zb3IgZGF0YSBvbiBpbmRleCAke3RlfS5gKTtsZXQgUHQ9SGUvNCxndD1zLkhFQVBVMzJbUHQrK107WmU9cy5IRUFQVTMyW1B0KytdO2xldCB5dD1zLkhFQVBVMzJbUHQrK10sZXI9cy5IRUFQVTMyW1B0KytdLFFlPVtdO2ZvcihsZXQgJGU9MDskZTxlcjskZSsrKVFlLnB1c2gocy5IRUFQVTMyW3l0LzQrJGVdKTtzLl9PcnRGcmVlKHl0KTtsZXQgRXQ9UWUucmVkdWNlKCgkZSx2ZSk9PiRlKnZlLDEpO3dlPXFwKGd0KTtsZXQgTXQ9cD8ub3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW2VbdGVdXTtpZih3ZT09PVwic3RyaW5nXCIpe2lmKE10PT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS5cIik7bGV0ICRlPVtdLHZlPVplLzQ7Zm9yKGxldCBxZT0wO3FlPEV0O3FlKyspe2xldCBHdD1zLkhFQVBVMzJbdmUrK10sRHQ9cWU9PT1FdC0xP3ZvaWQgMDpzLkhFQVBVMzJbdmVdLUd0OyRlLnB1c2gocy5VVEY4VG9TdHJpbmcoR3QsRHQpKX1CZS5wdXNoKFt3ZSxRZSwkZSxcImNwdVwiXSl9ZWxzZSBpZihNdD09PVwiZ3B1LWJ1ZmZlclwiJiZFdD4wKXtsZXQgJGU9cy5qc2VwR2V0QnVmZmVyO2lmKCEkZSl0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7bGV0IHZlPSRlKFplKSxxZT1sYShndCk7aWYocWU9PT12b2lkIDB8fCFEbyh3ZSkpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7d2V9YCk7QXQ9ITAsQmUucHVzaChbd2UsUWUse2dwdUJ1ZmZlcjp2ZSxkb3dubG9hZDpzLmpzZXBDcmVhdGVEb3dubG9hZGVyKHZlLEV0KnFlLHdlKSxkaXNwb3NlOigpPT57cy5fT3J0UmVsZWFzZVRlbnNvcihidCl9fSxcImdwdS1idWZmZXJcIl0pfWVsc2V7bGV0ICRlPWpwKHdlKSx2ZT1uZXcgJGUoRXQpO25ldyBVaW50OEFycmF5KHZlLmJ1ZmZlcix2ZS5ieXRlT2Zmc2V0LHZlLmJ5dGVMZW5ndGgpLnNldChzLkhFQVBVOC5zdWJhcnJheShaZSxaZSt2ZS5ieXRlTGVuZ3RoKSksQmUucHVzaChbd2UsUWUsdmUsXCJjcHVcIl0pfX1maW5hbGx5e3Muc3RhY2tSZXN0b3JlKFN0KSx3ZT09PVwic3RyaW5nXCImJlplJiZzLl9mcmVlKFplKSxBdHx8cy5fT3J0UmVsZWFzZVRlbnNvcihidCl9fXJldHVybiBwJiYhZCYmKHMuX09ydENsZWFyQm91bmRPdXRwdXRzKHAuaGFuZGxlKSxXci5zZXQoYSxbdSxsLGYscCxkLCExXSkpLEJlfWZpbmFsbHl7cy5zdGFja1Jlc3RvcmUoaiksRi5mb3JFYWNoKEZlPT5zLl9PcnRSZWxlYXNlVGVuc29yKEZlKSksQy5mb3JFYWNoKEZlPT5zLl9PcnRSZWxlYXNlVGVuc29yKEZlKSksWS5mb3JFYWNoKEZlPT5zLl9mcmVlKEZlKSksSSE9PTAmJnMuX09ydFJlbGVhc2VSdW5PcHRpb25zKEkpLEwuZm9yRWFjaChGZT0+cy5fZnJlZShGZSkpfX0scmQ9YT0+e2xldCB0PUxlKCksbz1Xci5nZXQoYSk7aWYoIW8pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2xldCBlPW9bMF0scj10Ll9PcnRFbmRQcm9maWxpbmcoZSk7cj09PTAmJk9lKFwiQ2FuJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lLlwiKSx0Ll9PcnRGcmVlKHIpfSxuZD1hPT57bGV0IHQ9W107Zm9yKGxldCBvIG9mIGEpe2xldCBlPW9bMl07IUFycmF5LmlzQXJyYXkoZSkmJlwiYnVmZmVyXCJpbiBlJiZ0LnB1c2goZS5idWZmZXIpfXJldHVybiB0fX0pO3ZhciBpZD1tZSgoQU8seGcpPT57eGcuZXhwb3J0cz0nLyohXFxuICogT05OWCBSdW50aW1lIFdlYiB2MS4xNy4zXFxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXFxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxcbiAqL1xcblwidXNlIHN0cmljdFwiOygoKT0+e3ZhciBFdD1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIEpyPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7dmFyIFhyPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO3ZhciBRcj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBTdD0odSxjKT0+KCk9Pih1JiYoYz11KHU9MCkpLGMpO3ZhciB0dD0odSxjKT0+KCk9PihjfHx1KChjPXtleHBvcnRzOnt9fSkuZXhwb3J0cyxjKSxjLmV4cG9ydHMpLEF0PSh1LGMpPT57Zm9yKHZhciBhIGluIGMpRXQodSxhLHtnZXQ6Y1thXSxlbnVtZXJhYmxlOiEwfSl9LFpyPSh1LGMsYSxoKT0+e2lmKGMmJnR5cGVvZiBjPT1cIm9iamVjdFwifHx0eXBlb2YgYz09XCJmdW5jdGlvblwiKWZvcihsZXQgZiBvZiBYcihjKSkhUXIuY2FsbCh1LGYpJiZmIT09YSYmRXQodSxmLHtnZXQ6KCk9PmNbZl0sZW51bWVyYWJsZTohKGg9SnIoYyxmKSl8fGguZW51bWVyYWJsZX0pO3JldHVybiB1fTt2YXIgcnQ9dT0+WnIoRXQoe30sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdSk7dmFyIFR0PXt9O0F0KFR0LHtjcmVhdGVSZWFkU3RyZWFtOigpPT5kcixyZWFkRmlsZTooKT0+S3IscmVhZEZpbGVTeW5jOigpPT5lbn0pO3ZhciBLcixlbixkcixNdD1TdCgoKT0+e0tyPXZvaWQgMCxlbj12b2lkIDAsZHI9dm9pZCAwfSk7dmFyIEN0PXt9O0F0KEN0LHtqb2luOigpPT50bn0pO3ZhciB0bixEdD1TdCgoKT0+e3RuPXZvaWQgMH0pO3ZhciBncj10dCgobXIsRnQpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHByPSgoKT0+e3ZhciB1PXR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDA7cmV0dXJuIHR5cGVvZiBfX2ZpbGVuYW1lPFwidVwiJiYodT11fHxfX2ZpbGVuYW1lKSxmdW5jdGlvbihjPXt9KXt2YXIgYT1jLGgsZjthLnJlYWR5PW5ldyBQcm9taXNlKChyLG8pPT57aD1yLGY9b30pO3ZhciB3PU9iamVjdC5hc3NpZ24oe30sYSksZz1cIi4vdGhpcy5wcm9ncmFtXCIsaT10eXBlb2Ygd2luZG93PT1cIm9iamVjdFwiLEU9dHlwZW9mIGltcG9ydFNjcmlwdHM9PVwiZnVuY3Rpb25cIixQPXR5cGVvZiBwcm9jZXNzPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZT09XCJzdHJpbmdcIixVPVwiXCIsRCx4LEs7aWYoUCl7dmFyIFI9KE10KCkscnQoVHQpKSxJPShEdCgpLHJ0KEN0KSk7VT1FP0kuZGlybmFtZShVKStcIi9cIjpfX2Rpcm5hbWUrXCIvXCIsRD0ocixvKT0+KHI9dmUocik/bmV3IFVSTChyKTpJLm5vcm1hbGl6ZShyKSxSLnJlYWRGaWxlU3luYyhyLG8/dm9pZCAwOlwidXRmOFwiKSksSz1yPT4ocj1EKHIsITApLHIuYnVmZmVyfHwocj1uZXcgVWludDhBcnJheShyKSkscikseD0ocixvLHMsbT0hMCk9PntyPXZlKHIpP25ldyBVUkwocik6SS5ub3JtYWxpemUociksUi5yZWFkRmlsZShyLG0/dm9pZCAwOlwidXRmOFwiLChPLEEpPT57Tz9zKE8pOm8obT9BLmJ1ZmZlcjpBKX0pfSwhYS50aGlzUHJvZ3JhbSYmMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYoZz1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXFxcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSxhLmluc3BlY3Q9KCk9PlwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn1lbHNlKGl8fEUpJiYoRT9VPXNlbGYubG9jYXRpb24uaHJlZjp0eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihVPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSx1JiYoVT11KSxVLmluZGV4T2YoXCJibG9iOlwiKSE9PTA/VT1VLnN1YnN0cigwLFUucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6VT1cIlwiLEQ9cj0+e3ZhciBvPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gby5vcGVuKFwiR0VUXCIsciwhMSksby5zZW5kKG51bGwpLG8ucmVzcG9uc2VUZXh0fSxFJiYoSz1yPT57dmFyIG89bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBvLm9wZW4oXCJHRVRcIixyLCExKSxvLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsby5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KG8ucmVzcG9uc2UpfSkseD0ocixvLHMpPT57dmFyIG09bmV3IFhNTEh0dHBSZXF1ZXN0O20ub3BlbihcIkdFVFwiLHIsITApLG0ucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixtLm9ubG9hZD0oKT0+e20uc3RhdHVzPT0yMDB8fG0uc3RhdHVzPT0wJiZtLnJlc3BvbnNlP28obS5yZXNwb25zZSk6cygpfSxtLm9uZXJyb3I9cyxtLnNlbmQobnVsbCl9KTt2YXIgdj1jb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLGs9Y29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO09iamVjdC5hc3NpZ24oYSx3KSx3PW51bGwsdHlwZW9mIFdlYkFzc2VtYmx5IT1cIm9iamVjdFwiJiZGKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgVyxIPSExLHNlLGVlLFMsaixDZTtmdW5jdGlvbiBVZSgpe3ZhciByPVcuYnVmZmVyO2EuSEVBUDg9c2U9bmV3IEludDhBcnJheShyKSxhLkhFQVAxNj1uZXcgSW50MTZBcnJheShyKSxhLkhFQVBVOD1lZT1uZXcgVWludDhBcnJheShyKSxhLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KHIpLGEuSEVBUDMyPVM9bmV3IEludDMyQXJyYXkociksYS5IRUFQVTMyPWo9bmV3IFVpbnQzMkFycmF5KHIpLGEuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KHIpLGEuSEVBUEY2ND1DZT1uZXcgRmxvYXQ2NEFycmF5KHIpfXZhciBjZT1bXSxuZT1bXSxRPVtdLE9lPTAsaGU9bnVsbCxhZT1udWxsO2Z1bmN0aW9uIEYocil7dGhyb3cgcj1cIkFib3J0ZWQoXCIrcitcIilcIixrKHIpLEg9ITAscj1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHIrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLGYocikscn12YXIgeWU9cj0+ci5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKSx2ZT1yPT5yLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpLGZlO2lmKGZlPVwib3J0LXdhc20ud2FzbVwiLCF5ZShmZSkpe3ZhciBfZT1mZTtmZT1hLmxvY2F0ZUZpbGU/YS5sb2NhdGVGaWxlKF9lLFUpOlUrX2V9ZnVuY3Rpb24gWShyKXtpZihLKXJldHVybiBLKHIpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWZ1bmN0aW9uIHBlKHIpe2lmKGl8fEUpe2lmKHR5cGVvZiBmZXRjaD09XCJmdW5jdGlvblwiJiYhdmUocikpcmV0dXJuIGZldGNoKHIse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4obz0+e2lmKCFvLm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0IFxcJ1wiK3IrXCJcXCdcIjtyZXR1cm4gby5hcnJheUJ1ZmZlcigpfSkuY2F0Y2goKCk9PlkocikpO2lmKHgpcmV0dXJuIG5ldyBQcm9taXNlKChvLHMpPT57eChyLG09Pm8obmV3IFVpbnQ4QXJyYXkobSkpLHMpfSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PlkocikpfWZ1bmN0aW9uIEllKHIsbyxzKXtyZXR1cm4gcGUocikudGhlbihtPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZShtLG8pKS50aGVuKG09Pm0pLnRoZW4ocyxtPT57ayhgZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJHttfWApLEYobSl9KX1mdW5jdGlvbiBFZShyLG8pe3ZhciBzPWZlO3JldHVybiB0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmchPVwiZnVuY3Rpb25cInx8eWUocyl8fHZlKHMpfHxQfHx0eXBlb2YgZmV0Y2ghPVwiZnVuY3Rpb25cIj9JZShzLHIsbyk6ZmV0Y2gocyx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihtPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhtLHIpLnRoZW4obyxmdW5jdGlvbihPKXtyZXR1cm4gayhgd2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICR7T31gKSxrKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksSWUocyxyLG8pfSkpfXZhciBiZSx3ZT17OTIwMDE2OihyLG8scyxtKT0+e2lmKHR5cGVvZiBhPlwidVwifHwhYS56YSlyZXR1cm4gMTtpZihyPXoocj4+PjApLHIuc3RhcnRzV2l0aChcIi4vXCIpJiYocj1yLnN1YnN0cmluZygyKSkscj1hLnphLmdldChyKSwhcilyZXR1cm4gMjtpZihvPj4+PTAscz4+Pj0wLG8rcz5yLmJ5dGVMZW5ndGgpcmV0dXJuIDM7dHJ5e3JldHVybiBlZS5zZXQoci5zdWJhcnJheShvLG8rcyksbT4+PjA+Pj4wKSwwfWNhdGNoe3JldHVybiA0fX19O2Z1bmN0aW9uIExlKHIpe3RoaXMueGE9ci0yNCx0aGlzLkhhPWZ1bmN0aW9uKG8pe2pbdGhpcy54YSs0Pj4+Mj4+PjBdPW99LHRoaXMuR2E9ZnVuY3Rpb24obyl7alt0aGlzLnhhKzg+Pj4yPj4+MF09b30sdGhpcy5BYT1mdW5jdGlvbihvLHMpe3RoaXMuRmEoKSx0aGlzLkhhKG8pLHRoaXMuR2Eocyl9LHRoaXMuRmE9ZnVuY3Rpb24oKXtqW3RoaXMueGErMTY+Pj4yPj4+MF09MH19dmFyIG1lPTAsU2U9MCxEZT10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDAsdGU9KHIsbyxzKT0+e28+Pj49MDt2YXIgbT1vK3M7Zm9yKHM9bztyW3NdJiYhKHM+PW0pOykrK3M7aWYoMTY8cy1vJiZyLmJ1ZmZlciYmRGUpcmV0dXJuIERlLmRlY29kZShyLnN1YmFycmF5KG8scykpO2ZvcihtPVwiXCI7bzxzOyl7dmFyIE89cltvKytdO2lmKE8mMTI4KXt2YXIgQT1yW28rK10mNjM7aWYoKE8mMjI0KT09MTkyKW0rPVN0cmluZy5mcm9tQ2hhckNvZGUoKE8mMzEpPDw2fEEpO2Vsc2V7dmFyIEw9cltvKytdJjYzO089KE8mMjQwKT09MjI0PyhPJjE1KTw8MTJ8QTw8NnxMOihPJjcpPDwxOHxBPDwxMnxMPDw2fHJbbysrXSY2Myw2NTUzNj5PP20rPVN0cmluZy5mcm9tQ2hhckNvZGUoTyk6KE8tPTY1NTM2LG0rPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Tz4+MTAsNTYzMjB8TyYxMDIzKSl9fWVsc2UgbSs9U3RyaW5nLmZyb21DaGFyQ29kZShPKX1yZXR1cm4gbX0sej0ocixvKT0+KHI+Pj49MCk/dGUoZWUscixvKTpcIlwiLGxlPXI9Pntmb3IodmFyIG89MCxzPTA7czxyLmxlbmd0aDsrK3Mpe3ZhciBtPXIuY2hhckNvZGVBdChzKTsxMjc+PW0/bysrOjIwNDc+PW0/bys9Mjo1NTI5Njw9bSYmNTczNDM+PW0/KG8rPTQsKytzKTpvKz0zfXJldHVybiBvfSxGZT0ocixvLHMsbSk9PntpZihzPj4+PTAsISgwPG0pKXJldHVybiAwO3ZhciBPPXM7bT1zK20tMTtmb3IodmFyIEE9MDtBPHIubGVuZ3RoOysrQSl7dmFyIEw9ci5jaGFyQ29kZUF0KEEpO2lmKDU1Mjk2PD1MJiY1NzM0Mz49TCl7dmFyIHJlPXIuY2hhckNvZGVBdCgrK0EpO0w9NjU1MzYrKChMJjEwMjMpPDwxMCl8cmUmMTAyM31pZigxMjc+PUwpe2lmKHM+PW0pYnJlYWs7b1tzKys+Pj4wXT1MfWVsc2V7aWYoMjA0Nz49TCl7aWYocysxPj1tKWJyZWFrO29bcysrPj4+MF09MTkyfEw+PjZ9ZWxzZXtpZig2NTUzNT49TCl7aWYocysyPj1tKWJyZWFrO29bcysrPj4+MF09MjI0fEw+PjEyfWVsc2V7aWYocyszPj1tKWJyZWFrO29bcysrPj4+MF09MjQwfEw+PjE4LG9bcysrPj4+MF09MTI4fEw+PjEyJjYzfW9bcysrPj4+MF09MTI4fEw+PjYmNjN9b1tzKys+Pj4wXT0xMjh8TCY2M319cmV0dXJuIG9bcz4+PjBdPTAscy1PfSxBZT1yPT5yJTQ9PT0wJiYociUxMDAhPT0wfHxyJTQwMD09PTApLHFlPVswLDMxLDYwLDkxLDEyMSwxNTIsMTgyLDIxMywyNDQsMjc0LDMwNSwzMzVdLGF0PVswLDMxLDU5LDkwLDEyMCwxNTEsMTgxLDIxMiwyNDMsMjczLDMwNCwzMzRdLHhlPXI9Pnt2YXIgbz1sZShyKSsxLHM9c3Qobyk7cmV0dXJuIHMmJkZlKHIsZWUscyxvKSxzfSxOZT1bXSxSZT17fSxIZT0oKT0+e2lmKCFHZSl7dmFyIHI9e1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KHR5cGVvZiBuYXZpZ2F0b3I9PVwib2JqZWN0XCImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86Z3x8XCIuL3RoaXMucHJvZ3JhbVwifSxvO2ZvcihvIGluIFJlKVJlW29dPT09dm9pZCAwP2RlbGV0ZSByW29dOnJbb109UmVbb107dmFyIHM9W107Zm9yKG8gaW4gcilzLnB1c2goYCR7b309JHtyW29dfWApO0dlPXN9cmV0dXJuIEdlfSxHZSxCZT1bbnVsbCxbXSxbXV0sVmU9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxKZT1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uICRlKHIpe3ZhciBvPUFycmF5KGxlKHIpKzEpO3JldHVybiBGZShyLG8sMCxvLmxlbmd0aCksb31mdW5jdGlvbiBvdChyLG8scyxtKXtmdW5jdGlvbiBPKGQsQiwkKXtmb3IoZD10eXBlb2YgZD09XCJudW1iZXJcIj9kLnRvU3RyaW5nKCk6ZHx8XCJcIjtkLmxlbmd0aDxCOylkPSRbMF0rZDtyZXR1cm4gZH1mdW5jdGlvbiBBKGQsQil7cmV0dXJuIE8oZCxCLFwiMFwiKX1mdW5jdGlvbiBMKGQsQil7ZnVuY3Rpb24gJChldCl7cmV0dXJuIDA+ZXQ/LTE6MDxldD8xOjB9dmFyIFRlO3JldHVybihUZT0kKGQuZ2V0RnVsbFllYXIoKS1CLmdldEZ1bGxZZWFyKCkpKT09PTAmJihUZT0kKGQuZ2V0TW9udGgoKS1CLmdldE1vbnRoKCkpKT09PTAmJihUZT0kKGQuZ2V0RGF0ZSgpLUIuZ2V0RGF0ZSgpKSksVGV9ZnVuY3Rpb24gcmUoZCl7c3dpdGNoKGQuZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gZDtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gZGUoZCl7dmFyIEI9ZC50YTtmb3IoZD1uZXcgRGF0ZShuZXcgRGF0ZShkLnVhKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8Qjspe3ZhciAkPWQuZ2V0TW9udGgoKSxUZT0oQWUoZC5nZXRGdWxsWWVhcigpKT9WZTpKZSlbJF07aWYoQj5UZS1kLmdldERhdGUoKSlCLT1UZS1kLmdldERhdGUoKSsxLGQuc2V0RGF0ZSgxKSwxMT4kP2Quc2V0TW9udGgoJCsxKTooZC5zZXRNb250aCgwKSxkLnNldEZ1bGxZZWFyKGQuZ2V0RnVsbFllYXIoKSsxKSk7ZWxzZXtkLnNldERhdGUoZC5nZXREYXRlKCkrQik7YnJlYWt9fXJldHVybiAkPW5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSsxLDAsNCksQj1yZShuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksMCw0KSksJD1yZSgkKSwwPj1MKEIsZCk/MD49TCgkLGQpP2QuZ2V0RnVsbFllYXIoKSsxOmQuZ2V0RnVsbFllYXIoKTpkLmdldEZ1bGxZZWFyKCktMX1yPj4+PTAsbz4+Pj0wLHM+Pj49MCxtPj4+PTA7dmFyIGllPWpbbSs0MD4+PjI+Pj4wXTttPXtEYTpTW20+Pj4yPj4+MF0sQ2E6U1ttKzQ+Pj4yPj4+MF0sdmE6U1ttKzg+Pj4yPj4+MF0seWE6U1ttKzEyPj4+Mj4+PjBdLHdhOlNbbSsxNj4+PjI+Pj4wXSx1YTpTW20rMjA+Pj4yPj4+MF0sb2E6U1ttKzI0Pj4+Mj4+PjBdLHRhOlNbbSsyOD4+PjI+Pj4wXSxJYTpTW20rMzI+Pj4yPj4+MF0sQmE6U1ttKzM2Pj4+Mj4+PjBdLEVhOmllP3ooaWUpOlwiXCJ9LHM9eihzKSxpZT17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9O2Zvcih2YXIgdWUgaW4gaWUpcz1zLnJlcGxhY2UobmV3IFJlZ0V4cCh1ZSxcImdcIiksaWVbdWVdKTt2YXIgWmU9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxLZT1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7aWU9e1wiJWFcIjpkPT5aZVtkLm9hXS5zdWJzdHJpbmcoMCwzKSxcIiVBXCI6ZD0+WmVbZC5vYV0sXCIlYlwiOmQ9PktlW2Qud2FdLnN1YnN0cmluZygwLDMpLFwiJUJcIjpkPT5LZVtkLndhXSxcIiVDXCI6ZD0+QSgoZC51YSsxOTAwKS8xMDB8MCwyKSxcIiVkXCI6ZD0+QShkLnlhLDIpLFwiJWVcIjpkPT5PKGQueWEsMixcIiBcIiksXCIlZ1wiOmQ9PmRlKGQpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJUdcIjpkPT5kZShkKSxcIiVIXCI6ZD0+QShkLnZhLDIpLFwiJUlcIjpkPT4oZD1kLnZhLGQ9PTA/ZD0xMjoxMjxkJiYoZC09MTIpLEEoZCwyKSksXCIlalwiOmQ9Pntmb3IodmFyIEI9MCwkPTA7JDw9ZC53YS0xO0IrPShBZShkLnVhKzE5MDApP1ZlOkplKVskKytdKTtyZXR1cm4gQShkLnlhK0IsMyl9LFwiJW1cIjpkPT5BKGQud2ErMSwyKSxcIiVNXCI6ZD0+QShkLkNhLDIpLFwiJW5cIjooKT0+YFxcbmAsXCIlcFwiOmQ9PjA8PWQudmEmJjEyPmQudmE/XCJBTVwiOlwiUE1cIixcIiVTXCI6ZD0+QShkLkRhLDIpLFwiJXRcIjooKT0+XCJcdFwiLFwiJXVcIjpkPT5kLm9hfHw3LFwiJVVcIjpkPT5BKE1hdGguZmxvb3IoKGQudGErNy1kLm9hKS83KSwyKSxcIiVWXCI6ZD0+e3ZhciBCPU1hdGguZmxvb3IoKGQudGErNy0oZC5vYSs2KSU3KS83KTtpZigyPj0oZC5vYSszNzEtZC50YS0yKSU3JiZCKyssQilCPT01MyYmKCQ9KGQub2ErMzcxLWQudGEpJTcsJD09NHx8JD09MyYmQWUoZC51YSl8fChCPTEpKTtlbHNle0I9NTI7dmFyICQ9KGQub2ErNy1kLnRhLTEpJTc7KCQ9PTR8fCQ9PTUmJkFlKGQudWElNDAwLTEpKSYmQisrfXJldHVybiBBKEIsMil9LFwiJXdcIjpkPT5kLm9hLFwiJVdcIjpkPT5BKE1hdGguZmxvb3IoKGQudGErNy0oZC5vYSs2KSU3KS83KSwyKSxcIiV5XCI6ZD0+KGQudWErMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlWVwiOmQ9PmQudWErMTkwMCxcIiV6XCI6ZD0+e2Q9ZC5CYTt2YXIgQj0wPD1kO3JldHVybiBkPU1hdGguYWJzKGQpLzYwLChCP1wiK1wiOlwiLVwiKSsoXCIwMDAwXCIrKGQvNjAqMTAwK2QlNjApKS5zbGljZSgtNCl9LFwiJVpcIjpkPT5kLkVhLFwiJSVcIjooKT0+XCIlXCJ9LHM9cy5yZXBsYWNlKC8lJS9nLFwiXFxcXDBcXFxcMFwiKTtmb3IodWUgaW4gaWUpcy5pbmNsdWRlcyh1ZSkmJihzPXMucmVwbGFjZShuZXcgUmVnRXhwKHVlLFwiZ1wiKSxpZVt1ZV0obSkpKTtyZXR1cm4gcz1zLnJlcGxhY2UoL1xcXFwwXFxcXDAvZyxcIiVcIiksdWU9JGUocyksdWUubGVuZ3RoPm8/MDooc2Uuc2V0KHVlLHI+Pj4wKSx1ZS5sZW5ndGgtMSl9dmFyIEc9e2E6ZnVuY3Rpb24ocixvLHMpe3Rocm93IHI+Pj49MCxuZXcgTGUocikuQWEobz4+PjAscz4+PjApLG1lPXIsU2UrKyxtZX0sZTpmdW5jdGlvbigpe3JldHVybiAwfSxIOmZ1bmN0aW9uKCl7fSx4OmZ1bmN0aW9uKCl7fSx6OmZ1bmN0aW9uKCl7fSxKOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LEY6ZnVuY3Rpb24oKXt9LEE6ZnVuY3Rpb24oKXt9LEU6ZnVuY3Rpb24oKXt9LGc6ZnVuY3Rpb24oKXt9LHk6ZnVuY3Rpb24oKXt9LHY6ZnVuY3Rpb24oKXt9LEc6ZnVuY3Rpb24oKXt9LHc6ZnVuY3Rpb24oKXt9LGs6KCk9PjEsbjpmdW5jdGlvbihyLG8scyl7cj1vKzIwOTcxNTI+Pj4wPDQxOTQzMDUtISFyPyhyPj4+MCkrNDI5NDk2NzI5NipvOk5hTixzPj4+PTAscj1uZXcgRGF0ZSgxZTMqciksU1tzPj4+Mj4+PjBdPXIuZ2V0VVRDU2Vjb25kcygpLFNbcys0Pj4+Mj4+PjBdPXIuZ2V0VVRDTWludXRlcygpLFNbcys4Pj4+Mj4+PjBdPXIuZ2V0VVRDSG91cnMoKSxTW3MrMTI+Pj4yPj4+MF09ci5nZXRVVENEYXRlKCksU1tzKzE2Pj4+Mj4+PjBdPXIuZ2V0VVRDTW9udGgoKSxTW3MrMjA+Pj4yPj4+MF09ci5nZXRVVENGdWxsWWVhcigpLTE5MDAsU1tzKzI0Pj4+Mj4+PjBdPXIuZ2V0VVRDRGF5KCksU1tzKzI4Pj4+Mj4+PjBdPShyLmdldFRpbWUoKS1EYXRlLlVUQyhyLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwfSxvOmZ1bmN0aW9uKHIsbyxzKXtyPW8rMjA5NzE1Mj4+PjA8NDE5NDMwNS0hIXI/KHI+Pj4wKSs0Mjk0OTY3Mjk2Km86TmFOLHM+Pj49MCxyPW5ldyBEYXRlKDFlMypyKSxTW3M+Pj4yPj4+MF09ci5nZXRTZWNvbmRzKCksU1tzKzQ+Pj4yPj4+MF09ci5nZXRNaW51dGVzKCksU1tzKzg+Pj4yPj4+MF09ci5nZXRIb3VycygpLFNbcysxMj4+PjI+Pj4wXT1yLmdldERhdGUoKSxTW3MrMTY+Pj4yPj4+MF09ci5nZXRNb250aCgpLFNbcysyMD4+PjI+Pj4wXT1yLmdldEZ1bGxZZWFyKCktMTkwMCxTW3MrMjQ+Pj4yPj4+MF09ci5nZXREYXkoKSxTW3MrMjg+Pj4yPj4+MF09KEFlKHIuZ2V0RnVsbFllYXIoKSk/cWU6YXQpW3IuZ2V0TW9udGgoKV0rci5nZXREYXRlKCktMXwwLFNbcyszNj4+PjI+Pj4wXT0tKDYwKnIuZ2V0VGltZXpvbmVPZmZzZXQoKSksbz1uZXcgRGF0ZShyLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBtPW5ldyBEYXRlKHIuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7U1tzKzMyPj4+Mj4+PjBdPShvIT1tJiZyLmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKG0sbykpfDB9LHA6ZnVuY3Rpb24ocil7cj4+Pj0wO3ZhciBvPW5ldyBEYXRlKFNbcisyMD4+PjI+Pj4wXSsxOTAwLFNbcisxNj4+PjI+Pj4wXSxTW3IrMTI+Pj4yPj4+MF0sU1tyKzg+Pj4yPj4+MF0sU1tyKzQ+Pj4yPj4+MF0sU1tyPj4+Mj4+PjBdLDApLHM9U1tyKzMyPj4+Mj4+PjBdLG09by5nZXRUaW1lem9uZU9mZnNldCgpLE89bmV3IERhdGUoby5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxBPW5ldyBEYXRlKG8uZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCksTD1NYXRoLm1pbihBLE8pO3JldHVybiAwPnM/U1tyKzMyPj4+Mj4+PjBdPSsoTyE9QSYmTD09bSk6MDxzIT0oTD09bSkmJihPPU1hdGgubWF4KEEsTyksby5zZXRUaW1lKG8uZ2V0VGltZSgpKzZlNCooKDA8cz9MOk8pLW0pKSksU1tyKzI0Pj4+Mj4+PjBdPW8uZ2V0RGF5KCksU1tyKzI4Pj4+Mj4+PjBdPShBZShvLmdldEZ1bGxZZWFyKCkpP3FlOmF0KVtvLmdldE1vbnRoKCldK28uZ2V0RGF0ZSgpLTF8MCxTW3I+Pj4yPj4+MF09by5nZXRTZWNvbmRzKCksU1tyKzQ+Pj4yPj4+MF09by5nZXRNaW51dGVzKCksU1tyKzg+Pj4yPj4+MF09by5nZXRIb3VycygpLFNbcisxMj4+PjI+Pj4wXT1vLmdldERhdGUoKSxTW3IrMTY+Pj4yPj4+MF09by5nZXRNb250aCgpLFNbcisyMD4+PjI+Pj4wXT1vLmdldFllYXIoKSxyPW8uZ2V0VGltZSgpLGlzTmFOKHIpPyhTW2plKCk+Pj4yPj4+MF09NjEscj0tMSk6ci89MWUzLFhlKChiZT1yLDE8PStNYXRoLmFicyhiZSk/MDxiZT8rTWF0aC5mbG9vcihiZS80Mjk0OTY3Mjk2KT4+PjA6fn4rTWF0aC5jZWlsKChiZS0rKH5+YmU+Pj4wKSkvNDI5NDk2NzI5Nik+Pj4wOjApKSxyPj4+MH0sbDpmdW5jdGlvbigpe3JldHVybi01Mn0sbTpmdW5jdGlvbigpe30sdDpmdW5jdGlvbihyLG8scyl7ZnVuY3Rpb24gbShkZSl7cmV0dXJuKGRlPWRlLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXFxcKChbQS1aYS16IF0rKVxcXFwpJC8pKT9kZVsxXTpcIkdNVFwifXM+Pj49MDt2YXIgTz1uZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksQT1uZXcgRGF0ZShPLDAsMSksTD1uZXcgRGF0ZShPLDYsMSk7Tz1BLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHJlPUwuZ2V0VGltZXpvbmVPZmZzZXQoKTtqW3I+Pj4wPj4+Mj4+PjBdPTYwKk1hdGgubWF4KE8scmUpLFNbbz4+PjA+Pj4yPj4+MF09KyhPIT1yZSkscj1tKEEpLG89bShMKSxyPXhlKHIpLG89eGUobykscmU8Tz8oaltzPj4+Mj4+PjBdPXIsaltzKzQ+Pj4yPj4+MF09byk6KGpbcz4+PjI+Pj4wXT1vLGpbcys0Pj4+Mj4+PjBdPXIpfSxkOigpPT57RihcIlwiKX0sQjpmdW5jdGlvbihyLG8scyl7cj4+Pj0wLG8+Pj49MCxzPj4+PTAsTmUubGVuZ3RoPTA7Zm9yKHZhciBtO209ZWVbbysrPj4+MF07KXt2YXIgTz1tIT0xMDU7TyY9bSE9MTEyLHMrPU8mJnMlOD80OjAsTmUucHVzaChtPT0xMTI/altzPj4+Mj4+PjBdOm09PTEwNT9TW3M+Pj4yPj4+MF06Q2Vbcz4+PjM+Pj4wXSkscys9Tz84OjR9cmV0dXJuIHdlW3JdLmFwcGx5KG51bGwsTmUpfSxoOigpPT5EYXRlLm5vdygpLHU6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sYjooKT0+cGVyZm9ybWFuY2Uubm93KCksSTpmdW5jdGlvbihyLG8scyl7cmV0dXJuIG8+Pj49MCxlZS5jb3B5V2l0aGluKHI+Pj4wPj4+MCxvPj4+MCxvKyhzPj4+MCk+Pj4wKX0sczpmdW5jdGlvbihyKXtyPj4+PTA7dmFyIG89ZWUubGVuZ3RoO2lmKDQyOTQ5MDE3NjA8cilyZXR1cm4hMTtmb3IodmFyIHM9MTs0Pj1zO3MqPTIpe3ZhciBtPW8qKDErLjIvcyk7bT1NYXRoLm1pbihtLHIrMTAwNjYzMjk2KTt2YXIgTz1NYXRoO209TWF0aC5tYXgocixtKTtlOntPPShPLm1pbi5jYWxsKE8sNDI5NDkwMTc2MCxtKyg2NTUzNi1tJTY1NTM2KSU2NTUzNiktVy5idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNSkvNjU1MzY7dHJ5e1cuZ3JvdyhPKSxVZSgpO3ZhciBBPTE7YnJlYWsgZX1jYXRjaHt9QT12b2lkIDB9aWYoQSlyZXR1cm4hMH1yZXR1cm4hMX0sQzpmdW5jdGlvbihyLG8pe3I+Pj49MCxvPj4+PTA7dmFyIHM9MDtyZXR1cm4gSGUoKS5mb3JFYWNoKChtLE8pPT57dmFyIEE9bytzO2ZvcihPPWpbcis0Kk8+Pj4yPj4+MF09QSxBPTA7QTxtLmxlbmd0aDsrK0Epc2VbTysrPj4+MD4+PjBdPW0uY2hhckNvZGVBdChBKTtzZVtPPj4+MD4+PjBdPTAscys9bS5sZW5ndGgrMX0pLDB9LEQ6ZnVuY3Rpb24ocixvKXtyPj4+PTAsbz4+Pj0wO3ZhciBzPUhlKCk7altyPj4+Mj4+PjBdPXMubGVuZ3RoO3ZhciBtPTA7cmV0dXJuIHMuZm9yRWFjaChPPT5tKz1PLmxlbmd0aCsxKSxqW28+Pj4yPj4+MF09bSwwfSxmOigpPT41MixqOmZ1bmN0aW9uKCl7cmV0dXJuIDUyfSxxOmZ1bmN0aW9uKCl7cmV0dXJuIDcwfSxpOmZ1bmN0aW9uKHIsbyxzLG0pe28+Pj49MCxzPj4+PTAsbT4+Pj0wO2Zvcih2YXIgTz0wLEE9MDtBPHM7QSsrKXt2YXIgTD1qW28+Pj4yPj4+MF0scmU9altvKzQ+Pj4yPj4+MF07bys9ODtmb3IodmFyIGRlPTA7ZGU8cmU7ZGUrKyl7dmFyIGllPWVlW0wrZGU+Pj4wXSx1ZT1CZVtyXTtpZT09PTB8fGllPT09MTA/KChyPT09MT92OmspKHRlKHVlLDApKSx1ZS5sZW5ndGg9MCk6dWUucHVzaChpZSl9Tys9cmV9cmV0dXJuIGpbbT4+PjI+Pj4wXT1PLDB9LHI6b3QsYzpmdW5jdGlvbihyLG8scyxtKXtyZXR1cm4gb3Qocj4+PjAsbz4+PjAscz4+PjAsbT4+PjApfX0sQz1mdW5jdGlvbigpe2Z1bmN0aW9uIHIocyl7cmV0dXJuIEM9cy5leHBvcnRzLEM9dXQoKSxXPUMuSyxVZSgpLG5lLnVuc2hpZnQoQy5MKSxPZS0tLE9lPT0wJiYoaGUhPT1udWxsJiYoY2xlYXJJbnRlcnZhbChoZSksaGU9bnVsbCksYWUmJihzPWFlLGFlPW51bGwscygpKSksQ312YXIgbz17YTpHfTtpZihPZSsrLGEuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gYS5pbnN0YW50aWF0ZVdhc20obyxyKX1jYXRjaChzKXtrKGBNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAke3N9YCksZihzKX1yZXR1cm4gRWUobyxmdW5jdGlvbihzKXtyKHMuaW5zdGFuY2UpfSkuY2F0Y2goZikse319KCk7YS5fT3J0SW5pdD0ocixvKT0+KGEuX09ydEluaXQ9Qy5NKShyLG8pLGEuX09ydEdldExhc3RFcnJvcj0ocixvKT0+KGEuX09ydEdldExhc3RFcnJvcj1DLk4pKHIsbyksYS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9KHIsbyxzLG0sTyxBLEwscmUsZGUsaWUpPT4oYS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9Qy5PKShyLG8scyxtLE8sQSxMLHJlLGRlLGllKSxhLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj0ocixvKT0+KGEuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPUMuUCkocixvKSxhLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9KHIsbyxzKT0+KGEuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT1DLlEpKHIsbyxzKSxhLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9KHIsbyxzKT0+KGEuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1DLlIpKHIsbyxzKSxhLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9cj0+KGEuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1DLlMpKHIpLGEuX09ydENyZWF0ZVNlc3Npb249KHIsbyxzKT0+KGEuX09ydENyZWF0ZVNlc3Npb249Qy5UKShyLG8scyksYS5fT3J0UmVsZWFzZVNlc3Npb249cj0+KGEuX09ydFJlbGVhc2VTZXNzaW9uPUMuVSkociksYS5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD0ocixvLHMpPT4oYS5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD1DLlYpKHIsbyxzKSxhLl9PcnRHZXRJbnB1dE5hbWU9KHIsbyk9PihhLl9PcnRHZXRJbnB1dE5hbWU9Qy5XKShyLG8pLGEuX09ydEdldE91dHB1dE5hbWU9KHIsbyk9PihhLl9PcnRHZXRPdXRwdXROYW1lPUMuWCkocixvKSxhLl9PcnRGcmVlPXI9PihhLl9PcnRGcmVlPUMuWSkociksYS5fT3J0Q3JlYXRlVGVuc29yPShyLG8scyxtLE8sQSk9PihhLl9PcnRDcmVhdGVUZW5zb3I9Qy5aKShyLG8scyxtLE8sQSksYS5fT3J0R2V0VGVuc29yRGF0YT0ocixvLHMsbSxPKT0+KGEuX09ydEdldFRlbnNvckRhdGE9Qy5fKShyLG8scyxtLE8pLGEuX09ydFJlbGVhc2VUZW5zb3I9cj0+KGEuX09ydFJlbGVhc2VUZW5zb3I9Qy4kKShyKSxhLl9PcnRDcmVhdGVSdW5PcHRpb25zPShyLG8scyxtKT0+KGEuX09ydENyZWF0ZVJ1bk9wdGlvbnM9Qy5hYSkocixvLHMsbSksYS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9KHIsbyxzKT0+KGEuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PUMuYmEpKHIsbyxzKSxhLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1yPT4oYS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9Qy5jYSkociksYS5fT3J0Q3JlYXRlQmluZGluZz1yPT4oYS5fT3J0Q3JlYXRlQmluZGluZz1DLmRhKShyKSxhLl9PcnRCaW5kSW5wdXQ9KHIsbyxzKT0+KGEuX09ydEJpbmRJbnB1dD1DLmVhKShyLG8scyksYS5fT3J0QmluZE91dHB1dD0ocixvLHMsbSk9PihhLl9PcnRCaW5kT3V0cHV0PUMuZmEpKHIsbyxzLG0pLGEuX09ydENsZWFyQm91bmRPdXRwdXRzPXI9PihhLl9PcnRDbGVhckJvdW5kT3V0cHV0cz1DLmdhKShyKSxhLl9PcnRSZWxlYXNlQmluZGluZz1yPT4oYS5fT3J0UmVsZWFzZUJpbmRpbmc9Qy5oYSkociksYS5fT3J0UnVuV2l0aEJpbmRpbmc9KHIsbyxzLG0sTyk9PihhLl9PcnRSdW5XaXRoQmluZGluZz1DLmlhKShyLG8scyxtLE8pLGEuX09ydFJ1bj0ocixvLHMsbSxPLEEsTCxyZSk9PihhLl9PcnRSdW49Qy5qYSkocixvLHMsbSxPLEEsTCxyZSksYS5fT3J0RW5kUHJvZmlsaW5nPXI9PihhLl9PcnRFbmRQcm9maWxpbmc9Qy5rYSkocik7dmFyIGplPSgpPT4oamU9Qy5sYSkoKSxzdD1hLl9tYWxsb2M9cj0+KHN0PWEuX21hbGxvYz1DLm1hKShyKTthLl9mcmVlPXI9PihhLl9mcmVlPUMubmEpKHIpO3ZhciBYZT1yPT4oWGU9Qy5wYSkociksaXQ9KCk9PihpdD1DLnFhKSgpLE09cj0+KE09Qy5yYSkociksa2U9cj0+KGtlPUMuc2EpKHIpO2Z1bmN0aW9uIHV0KCl7dmFyIHI9QztyPU9iamVjdC5hc3NpZ24oe30scik7dmFyIG89bT0+KCk9Pm0oKT4+PjAscz1tPT5PPT5tKE8pPj4+MDtyZXR1cm4gci5sYT1vKHIubGEpLHIubWE9cyhyLm1hKSxyLnFhPW8oci5xYSksci5zYT1zKHIuc2EpLHJ9YS5zdGFja0FsbG9jPWtlLGEuc3RhY2tTYXZlPWl0LGEuc3RhY2tSZXN0b3JlPU0sYS5VVEY4VG9TdHJpbmc9eixhLnN0cmluZ1RvVVRGOD0ocixvLHMpPT5GZShyLGVlLG8scyksYS5sZW5ndGhCeXRlc1VURjg9bGU7dmFyIFBlO2FlPWZ1bmN0aW9uIHIoKXtQZXx8UWUoKSxQZXx8KGFlPXIpfTtmdW5jdGlvbiBRZSgpe2lmKCEoMDxPZSkpe2lmKGEucHJlUnVuKWZvcih0eXBlb2YgYS5wcmVSdW49PVwiZnVuY3Rpb25cIiYmKGEucHJlUnVuPVthLnByZVJ1bl0pO2EucHJlUnVuLmxlbmd0aDspe3ZhciByPWEucHJlUnVuLnNoaWZ0KCk7Y2UudW5zaGlmdChyKX1mb3IoOzA8Y2UubGVuZ3RoOyljZS5zaGlmdCgpKGEpO2lmKCEoMDxPZXx8UGV8fChQZT0hMCxhLmNhbGxlZFJ1bj0hMCxIKSkpe2Zvcig7MDxuZS5sZW5ndGg7KW5lLnNoaWZ0KCkoYSk7Zm9yKGgoYSk7MDxRLmxlbmd0aDspUS5zaGlmdCgpKGEpfX19cmV0dXJuIFFlKCksYy5yZWFkeX19KSgpO3R5cGVvZiBtcj09XCJvYmplY3RcIiYmdHlwZW9mIEZ0PT1cIm9iamVjdFwiP0Z0LmV4cG9ydHM9cHI6dHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kJiZkZWZpbmUoW10sKCk9PnByKX0pO3ZhciBocj10dCgoKT0+e30pO3ZhciB5cj10dCgoKT0+e30pO3ZhciBicj17fTtBdChicix7Y3B1czooKT0+cm59KTt2YXIgcm4sd3I9U3QoKCk9Pntybj12b2lkIDB9KTt2YXIgX3I9dHQoKHZyLHh0KT0+e1widXNlIHN0cmljdFwiO3ZhciBPcj0oKCk9Pnt2YXIgdT10eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwO3JldHVybiB0eXBlb2YgX19maWxlbmFtZTxcInVcIiYmKHU9dXx8X19maWxlbmFtZSksZnVuY3Rpb24oYz17fSl7ZnVuY3Rpb24gYSgpe3JldHVybiBRLmJ1ZmZlciE9Ri5idWZmZXImJlkoKSxGfWZ1bmN0aW9uIGgoKXtyZXR1cm4gUS5idWZmZXIhPUYuYnVmZmVyJiZZKCkseWV9ZnVuY3Rpb24gZigpe3JldHVybiBRLmJ1ZmZlciE9Ri5idWZmZXImJlkoKSx2ZX1mdW5jdGlvbiB3KCl7cmV0dXJuIFEuYnVmZmVyIT1GLmJ1ZmZlciYmWSgpLGZlfWZ1bmN0aW9uIGcoKXtyZXR1cm4gUS5idWZmZXIhPUYuYnVmZmVyJiZZKCksX2V9dmFyIGk9YyxFLFA7aS5yZWFkeT1uZXcgUHJvbWlzZSgoZSx0KT0+e0U9ZSxQPXR9KTt2YXIgVT1PYmplY3QuYXNzaWduKHt9LGkpLEQ9XCIuL3RoaXMucHJvZ3JhbVwiLHg9KGUsdCk9Pnt0aHJvdyB0fSxLPXR5cGVvZiB3aW5kb3c9PVwib2JqZWN0XCIsUj10eXBlb2YgaW1wb3J0U2NyaXB0cz09XCJmdW5jdGlvblwiLEk9dHlwZW9mIHByb2Nlc3M9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlPT1cInN0cmluZ1wiLHY9aS5FTlZJUk9OTUVOVF9JU19QVEhSRUFEfHwhMSxrPVwiXCI7ZnVuY3Rpb24gVyhlKXtyZXR1cm4gaS5sb2NhdGVGaWxlP2kubG9jYXRlRmlsZShlLGspOmsrZX12YXIgSCxzZSxlZTtpZihJKXt2YXIgUz0oTXQoKSxydChUdCkpLGo9KER0KCkscnQoQ3QpKTtrPVI/ai5kaXJuYW1lKGspK1wiL1wiOl9fZGlybmFtZStcIi9cIixIPSh0LG4pPT4odD16KHQpP25ldyBVUkwodCk6ai5ub3JtYWxpemUodCksUy5yZWFkRmlsZVN5bmModCxuP3ZvaWQgMDpcInV0ZjhcIikpLGVlPXQ9Pih0PUgodCwhMCksdC5idWZmZXJ8fCh0PW5ldyBVaW50OEFycmF5KHQpKSx0KSxzZT0odCxuLGwseT0hMCk9Pnt0PXoodCk/bmV3IFVSTCh0KTpqLm5vcm1hbGl6ZSh0KSxTLnJlYWRGaWxlKHQseT92b2lkIDA6XCJ1dGY4XCIsKGIsXyk9PntiP2woYik6bih5P18uYnVmZmVyOl8pfSl9LCFpLnRoaXNQcm9ncmFtJiYxPHByb2Nlc3MuYXJndi5sZW5ndGgmJihEPXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLHg9KHQsbik9Pnt0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPXQsbn0saS5pbnNwZWN0PSgpPT5cIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdXCI7bGV0IGU7dHJ5e2U9aHIoKX1jYXRjaCh0KXt0aHJvdyBjb25zb2xlLmVycm9yKFxcJ1RoZSBcIndvcmtlcl90aHJlYWRzXCIgbW9kdWxlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBub2RlLmpzIGJ1aWxkIC0gcGVyaGFwcyBhIG5ld2VyIHZlcnNpb24gaXMgbmVlZGVkP1xcJyksdH1nbG9iYWwuV29ya2VyPWUuV29ya2VyfWVsc2UoS3x8UikmJihSP2s9c2VsZi5sb2NhdGlvbi5ocmVmOnR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKGs9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLHR5cGVvZiB1PFwidVwiJiZ1JiYoaz11KSxrLmluZGV4T2YoXCJibG9iOlwiKSE9PTA/az1rLnN1YnN0cigwLGsucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6az1cIlwiLEl8fChIPWU9Pnt2YXIgdD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHQub3BlbihcIkdFVFwiLGUsITEpLHQuc2VuZChudWxsKSx0LnJlc3BvbnNlVGV4dH0sUiYmKGVlPWU9Pnt2YXIgdD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHQub3BlbihcIkdFVFwiLGUsITEpLHQucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIix0LnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkodC5yZXNwb25zZSl9KSxzZT0oZSx0LG4pPT57dmFyIGw9bmV3IFhNTEh0dHBSZXF1ZXN0O2wub3BlbihcIkdFVFwiLGUsITApLGwucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixsLm9ubG9hZD0oKT0+e2wuc3RhdHVzPT0yMDB8fGwuc3RhdHVzPT0wJiZsLnJlc3BvbnNlP3QobC5yZXNwb25zZSk6bigpfSxsLm9uZXJyb3I9bixsLnNlbmQobnVsbCl9KSk7SSYmdHlwZW9mIHBlcmZvcm1hbmNlPlwidVwiJiYoZ2xvYmFsLnBlcmZvcm1hbmNlPXlyKCkucGVyZm9ybWFuY2UpO3ZhciBDZT1jb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFVlPWNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtJJiYoQ2U9KC4uLmUpPT5TLndyaXRlU3luYygxLGUuam9pbihcIiBcIikrYFxcbmApLFVlPSguLi5lKT0+Uy53cml0ZVN5bmMoMixlLmpvaW4oXCIgXCIpK2BcXG5gKSk7dmFyIGNlPUNlLG5lPVVlO09iamVjdC5hc3NpZ24oaSxVKSxVPW51bGwsdHlwZW9mIFdlYkFzc2VtYmx5IT1cIm9iamVjdFwiJiZEZShcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIFEsT2UsaGU9ITEsYWUsRix5ZSx2ZSxmZSxfZTtmdW5jdGlvbiBZKCl7dmFyIGU9US5idWZmZXI7aS5IRUFQOD1GPW5ldyBJbnQ4QXJyYXkoZSksaS5IRUFQMTY9bmV3IEludDE2QXJyYXkoZSksaS5IRUFQVTg9eWU9bmV3IFVpbnQ4QXJyYXkoZSksaS5IRUFQVTE2PW5ldyBVaW50MTZBcnJheShlKSxpLkhFQVAzMj12ZT1uZXcgSW50MzJBcnJheShlKSxpLkhFQVBVMzI9ZmU9bmV3IFVpbnQzMkFycmF5KGUpLGkuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KGUpLGkuSEVBUEY2ND1fZT1uZXcgRmxvYXQ2NEFycmF5KGUpfXZhciBwZT0xNjc3NzIxNjtpZih2KVE9aS53YXNtTWVtb3J5O2Vsc2UgaWYoaS53YXNtTWVtb3J5KVE9aS53YXNtTWVtb3J5O2Vsc2UgaWYoUT1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOnBlLzY1NTM2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSksIShRLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSl0aHJvdyBuZShcInJlcXVlc3RlZCBhIHNoYXJlZCBXZWJBc3NlbWJseS5NZW1vcnkgYnV0IHRoZSByZXR1cm5lZCBidWZmZXIgaXMgbm90IGEgU2hhcmVkQXJyYXlCdWZmZXIsIGluZGljYXRpbmcgdGhhdCB3aGlsZSB0aGUgYnJvd3NlciBoYXMgU2hhcmVkQXJyYXlCdWZmZXIgaXQgZG9lcyBub3QgaGF2ZSBXZWJBc3NlbWJseSB0aHJlYWRzIHN1cHBvcnQgLSB5b3UgbWF5IG5lZWQgdG8gc2V0IGEgZmxhZ1wiKSxJJiZuZShcIihvbiBub2RlIHlvdSBtYXkgbmVlZDogLS1leHBlcmltZW50YWwtd2FzbS10aHJlYWRzIC0tZXhwZXJpbWVudGFsLXdhc20tYnVsay1tZW1vcnkgYW5kL29yIHJlY2VudCB2ZXJzaW9uKVwiKSxFcnJvcihcImJhZCBtZW1vcnlcIik7WSgpLHBlPVEuYnVmZmVyLmJ5dGVMZW5ndGg7dmFyIEllPVtdLEVlPVtdLGJlPVtdLHdlPTAsTGU9bnVsbCxtZT1udWxsO2Z1bmN0aW9uIFNlKCl7aWYod2UtLSx3ZT09MCYmKExlIT09bnVsbCYmKGNsZWFySW50ZXJ2YWwoTGUpLExlPW51bGwpLG1lKSl7dmFyIGU9bWU7bWU9bnVsbCxlKCl9fWZ1bmN0aW9uIERlKGUpe3Rocm93IGU9XCJBYm9ydGVkKFwiK2UrXCIpXCIsbmUoZSksaGU9ITAsYWU9MSxlPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoZStcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksUChlKSxlfXZhciB0ZT1lPT5lLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpLHo9ZT0+ZS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSxsZTtsZT1cIm9ydC13YXNtLXRocmVhZGVkLndhc21cIix0ZShsZSl8fChsZT1XKGxlKSk7ZnVuY3Rpb24gRmUoZSl7aWYoZWUpcmV0dXJuIGVlKGUpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWZ1bmN0aW9uIEFlKGUpe2lmKEt8fFIpe2lmKHR5cGVvZiBmZXRjaD09XCJmdW5jdGlvblwiJiYheihlKSlyZXR1cm4gZmV0Y2goZSx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbih0PT57aWYoIXQub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgXFwnXCIrZStcIlxcJ1wiO3JldHVybiB0LmFycmF5QnVmZmVyKCl9KS5jYXRjaCgoKT0+RmUoZSkpO2lmKHNlKXJldHVybiBuZXcgUHJvbWlzZSgodCxuKT0+e3NlKGUsbD0+dChuZXcgVWludDhBcnJheShsKSksbil9KX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+RmUoZSkpfWZ1bmN0aW9uIHFlKGUsdCxuKXtyZXR1cm4gQWUoZSkudGhlbihsPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZShsLHQpKS50aGVuKGw9PmwpLnRoZW4obixsPT57bmUoYGZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICR7bH1gKSxEZShsKX0pfWZ1bmN0aW9uIGF0KGUsdCl7dmFyIG49bGU7cmV0dXJuIHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyE9XCJmdW5jdGlvblwifHx0ZShuKXx8eihuKXx8SXx8dHlwZW9mIGZldGNoIT1cImZ1bmN0aW9uXCI/cWUobixlLHQpOmZldGNoKG4se2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4obD0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcobCxlKS50aGVuKHQsZnVuY3Rpb24oeSl7cmV0dXJuIG5lKGB3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogJHt5fWApLG5lKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIikscWUobixlLHQpfSkpfXZhciB4ZSxOZT17OTIxMzg4OihlLHQsbixsKT0+e2lmKHR5cGVvZiBpPlwidVwifHwhaS5jYilyZXR1cm4gMTtpZihlPSRlKGU+Pj4wKSxlLnN0YXJ0c1dpdGgoXCIuL1wiKSYmKGU9ZS5zdWJzdHJpbmcoMikpLGU9aS5jYi5nZXQoZSksIWUpcmV0dXJuIDI7aWYodD4+Pj0wLG4+Pj49MCxsPj4+PTAsdCtuPmUuYnl0ZUxlbmd0aClyZXR1cm4gMzt0cnl7cmV0dXJuIGgoKS5zZXQoZS5zdWJhcnJheSh0LHQrbiksbD4+PjApLDB9Y2F0Y2h7cmV0dXJuIDR9fX07ZnVuY3Rpb24gUmUoZSl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiLHRoaXMubWVzc2FnZT1gUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgke2V9KWAsdGhpcy5zdGF0dXM9ZX12YXIgSGU9ZT0+e2UudGVybWluYXRlKCksZS5vbm1lc3NhZ2U9KCk9Pnt9fSxHZT1lPT57TS5QYS5sZW5ndGg9PTAmJihYZSgpLE0uWWEoTS5QYVswXSkpO3ZhciB0PU0uUGEucG9wKCk7aWYoIXQpcmV0dXJuIDY7TS5RYS5wdXNoKHQpLE0uTWFbZS5PYV09dCx0Lk9hPWUuT2E7dmFyIG49e2NtZDpcInJ1blwiLHN0YXJ0X3JvdXRpbmU6ZS5rYixhcmc6ZS5oYixwdGhyZWFkX3B0cjplLk9hfTtyZXR1cm4gSSYmdC51bnJlZigpLHQucG9zdE1lc3NhZ2UobixlLnFiKSwwfSxCZT0wLFZlPXR5cGVvZiBUZXh0RGVjb2RlcjxcInVcIj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMCxKZT0oZSx0LG4pPT57dD4+Pj0wO3ZhciBsPXQrbjtmb3Iobj10O2Vbbl0mJiEobj49bCk7KSsrbjtpZigxNjxuLXQmJmUuYnVmZmVyJiZWZSlyZXR1cm4gVmUuZGVjb2RlKGUuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXI/ZS5zbGljZSh0LG4pOmUuc3ViYXJyYXkodCxuKSk7Zm9yKGw9XCJcIjt0PG47KXt2YXIgeT1lW3QrK107aWYoeSYxMjgpe3ZhciBiPWVbdCsrXSY2MztpZigoeSYyMjQpPT0xOTIpbCs9U3RyaW5nLmZyb21DaGFyQ29kZSgoeSYzMSk8PDZ8Yik7ZWxzZXt2YXIgXz1lW3QrK10mNjM7eT0oeSYyNDApPT0yMjQ/KHkmMTUpPDwxMnxiPDw2fF86KHkmNyk8PDE4fGI8PDEyfF88PDZ8ZVt0KytdJjYzLDY1NTM2Pnk/bCs9U3RyaW5nLmZyb21DaGFyQ29kZSh5KTooeS09NjU1MzYsbCs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5Nnx5Pj4xMCw1NjMyMHx5JjEwMjMpKX19ZWxzZSBsKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHkpfXJldHVybiBsfSwkZT0oZSx0KT0+KGU+Pj49MCk/SmUoaCgpLGUsdCk6XCJcIixvdD1lPT57dmFyIHQ9dnQoKTtyZXR1cm4gZT1lKCksY3QodCksZX07ZnVuY3Rpb24gRyhlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGgtMixsPWFyZ3VtZW50cztyZXR1cm4gb3QoKCk9Pntmb3IodmFyIHk9X3QoOCpuKSxiPXk+Pj4zLF89MDtfPG47XysrKXt2YXIgSj1sWzIrX107ZygpW2IrXz4+PjBdPUp9cmV0dXJuIGFyKGUsbix5LHQpfSl9ZnVuY3Rpb24gQyhlKXtpZih2KXJldHVybiBHKDAsMSxlKTthZT1lLDA8QmV8fChNLmxiKCksaS5vbkV4aXQ/LihlKSxoZT0hMCkseChlLG5ldyBSZShlKSl9dmFyIGplPWU9PntpZihhZT1lLHYpdGhyb3cgdXQoZSksXCJ1bndpbmRcIjtDKGUpfTtmdW5jdGlvbiBzdCgpe2Zvcih2YXIgZT1pLm51bVRocmVhZHM7ZS0tOylYZSgpO0llLnVuc2hpZnQoKCk9Pnt3ZSsrLGl0KCgpPT5TZSgpKX0pfWZ1bmN0aW9uIFhlKCl7dmFyIGU9VyhcIm9ydC13YXNtLXRocmVhZGVkLndvcmtlci5qc1wiKTtlPW5ldyBXb3JrZXIoZSksTS5QYS5wdXNoKGUpfWZ1bmN0aW9uIGl0KGUpe3Y/ZSgpOlByb21pc2UuYWxsKE0uUGEubWFwKE0uWWEpKS50aGVuKGUpfXZhciBNPXtQYTpbXSxRYTpbXSxiYjpbXSxNYTp7fSxXYSgpe3Y/KE0ucmVjZWl2ZU9iamVjdFRyYW5zZmVyPU0uamIsTS50aHJlYWRJbml0VExTPU0uYWIsTS5zZXRFeGl0U3RhdHVzPU0uJGEpOnN0KCl9LCRhOmU9PmFlPWUsdGI6W1wiJHRlcm1pbmF0ZVdvcmtlclwiXSxsYjooKT0+e2Zvcih2YXIgZSBvZiBNLlFhKUhlKGUpO2ZvcihlIG9mIE0uUGEpSGUoZSk7TS5QYT1bXSxNLlFhPVtdLE0uTWE9W119LFphOmU9Pnt2YXIgdD1lLk9hO2RlbGV0ZSBNLk1hW3RdLE0uUGEucHVzaChlKSxNLlFhLnNwbGljZShNLlFhLmluZGV4T2YoZSksMSksZS5PYT0wLHd0KHQpfSxqYigpe30sYWIoKXtNLmJiLmZvckVhY2goZT0+ZSgpKX0sWWE6ZT0+bmV3IFByb21pc2UodD0+e2Uub25tZXNzYWdlPWI9PntiPWIuZGF0YTt2YXIgXz1iLmNtZDtpZihiLnRhcmdldFRocmVhZCYmYi50YXJnZXRUaHJlYWQhPWx0KCkpe3ZhciBKPU0uTWFbYi50YXJnZXRUaHJlYWRdO0o/Si5wb3N0TWVzc2FnZShiLGIudHJhbnNmZXJMaXN0KTpuZShgSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIiR7X31cIiB0byB0YXJnZXQgcHRocmVhZCAke2IudGFyZ2V0VGhyZWFkfSwgYnV0IHRoYXQgdGhyZWFkIG5vIGxvbmdlciBleGlzdHMhYCl9ZWxzZSBfPT09XCJjaGVja01haWxib3hcIj9mdCgpOl89PT1cInNwYXduVGhyZWFkXCI/R2UoYik6Xz09PVwiY2xlYW51cFRocmVhZFwiP00uWmEoTS5NYVtiLnRocmVhZF0pOl89PT1cImtpbGxUaHJlYWRcIj8oYj1iLnRocmVhZCxfPU0uTWFbYl0sZGVsZXRlIE0uTWFbYl0sSGUoXyksd3QoYiksTS5RYS5zcGxpY2UoTS5RYS5pbmRleE9mKF8pLDEpLF8uT2E9MCk6Xz09PVwiY2FuY2VsVGhyZWFkXCI/TS5NYVtiLnRocmVhZF0ucG9zdE1lc3NhZ2Uoe2NtZDpcImNhbmNlbFwifSk6Xz09PVwibG9hZGVkXCI/KGUubG9hZGVkPSEwLEkmJiFlLk9hJiZlLnVucmVmKCksdChlKSk6Xz09PVwiYWxlcnRcIj9hbGVydChgVGhyZWFkICR7Yi50aHJlYWRJZH06ICR7Yi50ZXh0fWApOmIudGFyZ2V0PT09XCJzZXRpbW1lZGlhdGVcIj9lLnBvc3RNZXNzYWdlKGIpOl89PT1cImNhbGxIYW5kbGVyXCI/aVtiLmhhbmRsZXJdKC4uLmIuYXJncyk6XyYmbmUoYHdvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCAke199YCl9LGUub25lcnJvcj1iPT57dGhyb3cgbmUoYHdvcmtlciBzZW50IGFuIGVycm9yISAke2IuZmlsZW5hbWV9OiR7Yi5saW5lbm99OiAke2IubWVzc2FnZX1gKSxifSxJJiYoZS5vbihcIm1lc3NhZ2VcIixiPT5lLm9ubWVzc2FnZSh7ZGF0YTpifSkpLGUub24oXCJlcnJvclwiLGI9PmUub25lcnJvcihiKSkpO3ZhciBuPVtdLGw9W1wib25FeGl0XCJdLHk7Zm9yKHkgb2YgbClpLmhhc093blByb3BlcnR5KHkpJiZuLnB1c2goeSk7ZS5wb3N0TWVzc2FnZSh7Y21kOlwibG9hZFwiLGhhbmRsZXJzOm4sdXJsT3JCbG9iOmkubWFpblNjcmlwdFVybE9yQmxvYnx8dSx3YXNtTWVtb3J5OlEsd2FzbU1vZHVsZTpPZX0pfSl9O2kuUFRocmVhZD1NO3ZhciBrZT1lPT57Zm9yKDswPGUubGVuZ3RoOyllLnNoaWZ0KCkoaSl9O2kuZXN0YWJsaXNoU3RhY2tTcGFjZT0oKT0+e3ZhciBlPWx0KCksdD13KClbZSs1Mj4+PjI+Pj4wXTtlPXcoKVtlKzU2Pj4+Mj4+PjBdLGlyKHQsdC1lKSxjdCh0KX07ZnVuY3Rpb24gdXQoZSl7aWYodilyZXR1cm4gRygxLDAsZSk7amUoZSl9dmFyIFBlPVtdLFFlO2kuaW52b2tlRW50cnlQb2ludD0oZSx0KT0+e3ZhciBuPVBlW2VdO258fChlPj1QZS5sZW5ndGgmJihQZS5sZW5ndGg9ZSsxKSxQZVtlXT1uPVFlLmdldChlKSksZT1uKHQpLDA8QmU/TS4kYShlKTpPdChlKX07ZnVuY3Rpb24gcihlKXt0aGlzLlZhPWUtMjQsdGhpcy5nYj1mdW5jdGlvbih0KXt3KClbdGhpcy5WYSs0Pj4+Mj4+PjBdPXR9LHRoaXMuZmI9ZnVuY3Rpb24odCl7dygpW3RoaXMuVmErOD4+PjI+Pj4wXT10fSx0aGlzLldhPWZ1bmN0aW9uKHQsbil7dGhpcy5lYigpLHRoaXMuZ2IodCksdGhpcy5mYihuKX0sdGhpcy5lYj1mdW5jdGlvbigpe3coKVt0aGlzLlZhKzE2Pj4+Mj4+PjBdPTB9fXZhciBvPTAscz0wO2Z1bmN0aW9uIG0oZSx0LG4sbCl7cmV0dXJuIHY/RygyLDEsZSx0LG4sbCk6TyhlLHQsbixsKX1mdW5jdGlvbiBPKGUsdCxuLGwpe2lmKGU+Pj49MCx0Pj4+PTAsbj4+Pj0wLGw+Pj49MCx0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI+XCJ1XCIpcmV0dXJuIG5lKFwiQ3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFNoYXJlZEFycmF5QnVmZmVyLCBwdGhyZWFkcyBhcmUgbm90IGF2YWlsYWJsZSFcIiksNjt2YXIgeT1bXTtyZXR1cm4gdiYmeS5sZW5ndGg9PT0wP20oZSx0LG4sbCk6KGU9e2tiOm4sT2E6ZSxoYjpsLHFiOnl9LHY/KGUuc2I9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKGUseSksMCk6R2UoZSkpfWZ1bmN0aW9uIEEoZSx0LG4pe3JldHVybiB2P0coMywxLGUsdCxuKTowfWZ1bmN0aW9uIEwoZSx0KXtpZih2KXJldHVybiBHKDQsMSxlLHQpfXZhciByZT1lPT57Zm9yKHZhciB0PTAsbj0wO248ZS5sZW5ndGg7KytuKXt2YXIgbD1lLmNoYXJDb2RlQXQobik7MTI3Pj1sP3QrKzoyMDQ3Pj1sP3QrPTI6NTUyOTY8PWwmJjU3MzQzPj1sPyh0Kz00LCsrbik6dCs9M31yZXR1cm4gdH0sZGU9KGUsdCxuLGwpPT57aWYobj4+Pj0wLCEoMDxsKSlyZXR1cm4gMDt2YXIgeT1uO2w9bitsLTE7Zm9yKHZhciBiPTA7YjxlLmxlbmd0aDsrK2Ipe3ZhciBfPWUuY2hhckNvZGVBdChiKTtpZig1NTI5Njw9XyYmNTczNDM+PV8pe3ZhciBKPWUuY2hhckNvZGVBdCgrK2IpO189NjU1MzYrKChfJjEwMjMpPDwxMCl8SiYxMDIzfWlmKDEyNz49Xyl7aWYobj49bClicmVhazt0W24rKz4+PjBdPV99ZWxzZXtpZigyMDQ3Pj1fKXtpZihuKzE+PWwpYnJlYWs7dFtuKys+Pj4wXT0xOTJ8Xz4+Nn1lbHNle2lmKDY1NTM1Pj1fKXtpZihuKzI+PWwpYnJlYWs7dFtuKys+Pj4wXT0yMjR8Xz4+MTJ9ZWxzZXtpZihuKzM+PWwpYnJlYWs7dFtuKys+Pj4wXT0yNDB8Xz4+MTgsdFtuKys+Pj4wXT0xMjh8Xz4+MTImNjN9dFtuKys+Pj4wXT0xMjh8Xz4+NiY2M310W24rKz4+PjBdPTEyOHxfJjYzfX1yZXR1cm4gdFtuPj4+MF09MCxuLXl9LGllPShlLHQsbik9PmRlKGUsaCgpLHQsbik7ZnVuY3Rpb24gdWUoZSx0KXtpZih2KXJldHVybiBHKDUsMSxlLHQpfWZ1bmN0aW9uIFplKGUsdCxuKXtpZih2KXJldHVybiBHKDYsMSxlLHQsbil9ZnVuY3Rpb24gS2UoZSx0LG4pe3JldHVybiB2P0coNywxLGUsdCxuKTowfWZ1bmN0aW9uIGQoZSx0KXtpZih2KXJldHVybiBHKDgsMSxlLHQpfWZ1bmN0aW9uIEIoZSx0LG4pe2lmKHYpcmV0dXJuIEcoOSwxLGUsdCxuKX1mdW5jdGlvbiAkKGUsdCxuLGwpe2lmKHYpcmV0dXJuIEcoMTAsMSxlLHQsbixsKX1mdW5jdGlvbiBUZShlLHQsbixsKXtpZih2KXJldHVybiBHKDExLDEsZSx0LG4sbCl9ZnVuY3Rpb24gZXQoZSx0LG4sbCl7aWYodilyZXR1cm4gRygxMiwxLGUsdCxuLGwpfWZ1bmN0aW9uIEJ0KGUpe2lmKHYpcmV0dXJuIEcoMTMsMSxlKX1mdW5jdGlvbiBrdChlLHQpe2lmKHYpcmV0dXJuIEcoMTQsMSxlLHQpfWZ1bmN0aW9uIFd0KGUsdCxuKXtpZih2KXJldHVybiBHKDE1LDEsZSx0LG4pfWZ1bmN0aW9uIG10KGUpe2U+Pj49MCx0eXBlb2YgQXRvbWljcy5yYj09XCJmdW5jdGlvblwiJiYoQXRvbWljcy5yYihmKCksZT4+PjIsZSkudmFsdWUudGhlbihmdCksZSs9MTI4LEF0b21pY3Muc3RvcmUoZigpLGU+Pj4yLDEpKX1pLl9fZW1zY3JpcHRlbl90aHJlYWRfbWFpbGJveF9hd2FpdD1tdDt2YXIgZnQ9KCk9Pnt2YXIgZT1sdCgpO2lmKGUmJihtdChlKSxlPW9yLCFoZSkpdHJ5e2lmKGUoKSwhKDA8QmUpKXRyeXt2P090KGFlKTpqZShhZSl9Y2F0Y2godCl7dCBpbnN0YW5jZW9mIFJlfHx0PT1cInVud2luZFwifHx4KDEsdCl9fWNhdGNoKHQpe3QgaW5zdGFuY2VvZiBSZXx8dD09XCJ1bndpbmRcInx8eCgxLHQpfX07aS5jaGVja01haWxib3g9ZnQ7dmFyIGd0PVtdLFllPWU9PmUlND09PTAmJihlJTEwMCE9PTB8fGUlNDAwPT09MCksTnQ9WzAsMzEsNjAsOTEsMTIxLDE1MiwxODIsMjEzLDI0NCwyNzQsMzA1LDMzNV0sSHQ9WzAsMzEsNTksOTAsMTIwLDE1MSwxODEsMjEyLDI0MywyNzMsMzA0LDMzNF07ZnVuY3Rpb24gR3QoZSx0LG4sbCx5LGIsXyxKKXtyZXR1cm4gdj9HKDE2LDEsZSx0LG4sbCx5LGIsXyxKKTotNTJ9ZnVuY3Rpb24gJHQoZSx0LG4sbCx5LGIsXyl7aWYodilyZXR1cm4gRygxNywxLGUsdCxuLGwseSxiLF8pfXZhciBqdD1lPT57dmFyIHQ9cmUoZSkrMSxuPXJyKHQpO3JldHVybiBuJiZpZShlLG4sdCksbn0saHQ9W10seXQ9e30sWXQ9KCk9PntpZighYnQpe3ZhciBlPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOih0eXBlb2YgbmF2aWdhdG9yPT1cIm9iamVjdFwiJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOkR8fFwiLi90aGlzLnByb2dyYW1cIn0sdDtmb3IodCBpbiB5dCl5dFt0XT09PXZvaWQgMD9kZWxldGUgZVt0XTplW3RdPXl0W3RdO3ZhciBuPVtdO2Zvcih0IGluIGUpbi5wdXNoKGAke3R9PSR7ZVt0XX1gKTtidD1ufXJldHVybiBidH0sYnQ7ZnVuY3Rpb24genQoZSx0KXtpZih2KXJldHVybiBHKDE4LDEsZSx0KTtlPj4+PTAsdD4+Pj0wO3ZhciBuPTA7cmV0dXJuIFl0KCkuZm9yRWFjaCgobCx5KT0+e3ZhciBiPXQrbjtmb3IoeT13KClbZSs0Knk+Pj4yPj4+MF09YixiPTA7YjxsLmxlbmd0aDsrK2IpYSgpW3krKz4+PjA+Pj4wXT1sLmNoYXJDb2RlQXQoYik7YSgpW3k+Pj4wPj4+MF09MCxuKz1sLmxlbmd0aCsxfSksMH1mdW5jdGlvbiBxdChlLHQpe2lmKHYpcmV0dXJuIEcoMTksMSxlLHQpO2U+Pj49MCx0Pj4+PTA7dmFyIG49WXQoKTt3KClbZT4+PjI+Pj4wXT1uLmxlbmd0aDt2YXIgbD0wO3JldHVybiBuLmZvckVhY2goeT0+bCs9eS5sZW5ndGgrMSksdygpW3Q+Pj4yPj4+MF09bCwwfWZ1bmN0aW9uIFZ0KGUpe3JldHVybiB2P0coMjAsMSxlKTo1Mn1mdW5jdGlvbiBKdChlLHQsbixsKXtyZXR1cm4gdj9HKDIxLDEsZSx0LG4sbCk6NTJ9ZnVuY3Rpb24gWHQoZSx0LG4sbCx5KXtyZXR1cm4gdj9HKDIyLDEsZSx0LG4sbCx5KTo3MH12YXIgJHI9W251bGwsW10sW11dO2Z1bmN0aW9uIFF0KGUsdCxuLGwpe2lmKHYpcmV0dXJuIEcoMjMsMSxlLHQsbixsKTt0Pj4+PTAsbj4+Pj0wLGw+Pj49MDtmb3IodmFyIHk9MCxiPTA7YjxuO2IrKyl7dmFyIF89dygpW3Q+Pj4yPj4+MF0sSj13KClbdCs0Pj4+Mj4+PjBdO3QrPTg7Zm9yKHZhciBNZT0wO01lPEo7TWUrKyl7dmFyIG9lPWgoKVtfK01lPj4+MF0sZ2U9JHJbZV07b2U9PT0wfHxvZT09PTEwPygoZT09PTE/Y2U6bmUpKEplKGdlLDApKSxnZS5sZW5ndGg9MCk6Z2UucHVzaChvZSl9eSs9Sn1yZXR1cm4gdygpW2w+Pj4yPj4+MF09eSwwfXZhciBadD1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLEt0PVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24ganIoZSl7dmFyIHQ9QXJyYXkocmUoZSkrMSk7cmV0dXJuIGRlKGUsdCwwLHQubGVuZ3RoKSx0fXZhciBZcj0oZSx0KT0+e2EoKS5zZXQoZSx0Pj4+MCl9O2Z1bmN0aW9uIGVyKGUsdCxuLGwpe2Z1bmN0aW9uIHkocCxOLFgpe2ZvcihwPXR5cGVvZiBwPT1cIm51bWJlclwiP3AudG9TdHJpbmcoKTpwfHxcIlwiO3AubGVuZ3RoPE47KXA9WFswXStwO3JldHVybiBwfWZ1bmN0aW9uIGIocCxOKXtyZXR1cm4geShwLE4sXCIwXCIpfWZ1bmN0aW9uIF8ocCxOKXtmdW5jdGlvbiBYKGNyKXtyZXR1cm4gMD5jcj8tMTowPGNyPzE6MH12YXIgV2U7cmV0dXJuKFdlPVgocC5nZXRGdWxsWWVhcigpLU4uZ2V0RnVsbFllYXIoKSkpPT09MCYmKFdlPVgocC5nZXRNb250aCgpLU4uZ2V0TW9udGgoKSkpPT09MCYmKFdlPVgocC5nZXREYXRlKCktTi5nZXREYXRlKCkpKSxXZX1mdW5jdGlvbiBKKHApe3N3aXRjaChwLmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKHAuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIHA7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZShwLmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKHAuZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUocC5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZShwLmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZShwLmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIE1lKHApe3ZhciBOPXAuUmE7Zm9yKHA9bmV3IERhdGUobmV3IERhdGUocC5TYSsxOTAwLDAsMSkuZ2V0VGltZSgpKTswPE47KXt2YXIgWD1wLmdldE1vbnRoKCksV2U9KFllKHAuZ2V0RnVsbFllYXIoKSk/WnQ6S3QpW1hdO2lmKE4+V2UtcC5nZXREYXRlKCkpTi09V2UtcC5nZXREYXRlKCkrMSxwLnNldERhdGUoMSksMTE+WD9wLnNldE1vbnRoKFgrMSk6KHAuc2V0TW9udGgoMCkscC5zZXRGdWxsWWVhcihwLmdldEZ1bGxZZWFyKCkrMSkpO2Vsc2V7cC5zZXREYXRlKHAuZ2V0RGF0ZSgpK04pO2JyZWFrfX1yZXR1cm4gWD1uZXcgRGF0ZShwLmdldEZ1bGxZZWFyKCkrMSwwLDQpLE49SihuZXcgRGF0ZShwLmdldEZ1bGxZZWFyKCksMCw0KSksWD1KKFgpLDA+PV8oTixwKT8wPj1fKFgscCk/cC5nZXRGdWxsWWVhcigpKzE6cC5nZXRGdWxsWWVhcigpOnAuZ2V0RnVsbFllYXIoKS0xfWU+Pj49MCx0Pj4+PTAsbj4+Pj0wLGw+Pj49MDt2YXIgb2U9dygpW2wrNDA+Pj4yPj4+MF07bD17b2I6ZigpW2w+Pj4yPj4+MF0sbmI6ZigpW2wrND4+PjI+Pj4wXSxUYTpmKClbbCs4Pj4+Mj4+PjBdLFhhOmYoKVtsKzEyPj4+Mj4+PjBdLFVhOmYoKVtsKzE2Pj4+Mj4+PjBdLFNhOmYoKVtsKzIwPj4+Mj4+PjBdLE5hOmYoKVtsKzI0Pj4+Mj4+PjBdLFJhOmYoKVtsKzI4Pj4+Mj4+PjBdLHViOmYoKVtsKzMyPj4+Mj4+PjBdLG1iOmYoKVtsKzM2Pj4+Mj4+PjBdLHBiOm9lPyRlKG9lKTpcIlwifSxuPSRlKG4pLG9lPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcIiVFY1wiOlwiJWNcIixcIiVFQ1wiOlwiJUNcIixcIiVFeFwiOlwiJW0vJWQvJXlcIixcIiVFWFwiOlwiJUg6JU06JVNcIixcIiVFeVwiOlwiJXlcIixcIiVFWVwiOlwiJVlcIixcIiVPZFwiOlwiJWRcIixcIiVPZVwiOlwiJWVcIixcIiVPSFwiOlwiJUhcIixcIiVPSVwiOlwiJUlcIixcIiVPbVwiOlwiJW1cIixcIiVPTVwiOlwiJU1cIixcIiVPU1wiOlwiJVNcIixcIiVPdVwiOlwiJXVcIixcIiVPVVwiOlwiJVVcIixcIiVPVlwiOlwiJVZcIixcIiVPd1wiOlwiJXdcIixcIiVPV1wiOlwiJVdcIixcIiVPeVwiOlwiJXlcIn07Zm9yKHZhciBnZSBpbiBvZSluPW4ucmVwbGFjZShuZXcgUmVnRXhwKGdlLFwiZ1wiKSxvZVtnZV0pO3ZhciBmcj1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLGxyPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtvZT17XCIlYVwiOnA9PmZyW3AuTmFdLnN1YnN0cmluZygwLDMpLFwiJUFcIjpwPT5mcltwLk5hXSxcIiViXCI6cD0+bHJbcC5VYV0uc3Vic3RyaW5nKDAsMyksXCIlQlwiOnA9PmxyW3AuVWFdLFwiJUNcIjpwPT5iKChwLlNhKzE5MDApLzEwMHwwLDIpLFwiJWRcIjpwPT5iKHAuWGEsMiksXCIlZVwiOnA9PnkocC5YYSwyLFwiIFwiKSxcIiVnXCI6cD0+TWUocCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlR1wiOnA9Pk1lKHApLFwiJUhcIjpwPT5iKHAuVGEsMiksXCIlSVwiOnA9PihwPXAuVGEscD09MD9wPTEyOjEyPHAmJihwLT0xMiksYihwLDIpKSxcIiVqXCI6cD0+e2Zvcih2YXIgTj0wLFg9MDtYPD1wLlVhLTE7Tis9KFllKHAuU2ErMTkwMCk/WnQ6S3QpW1grK10pO3JldHVybiBiKHAuWGErTiwzKX0sXCIlbVwiOnA9PmIocC5VYSsxLDIpLFwiJU1cIjpwPT5iKHAubmIsMiksXCIlblwiOigpPT5gXFxuYCxcIiVwXCI6cD0+MDw9cC5UYSYmMTI+cC5UYT9cIkFNXCI6XCJQTVwiLFwiJVNcIjpwPT5iKHAub2IsMiksXCIldFwiOigpPT5cIlx0XCIsXCIldVwiOnA9PnAuTmF8fDcsXCIlVVwiOnA9PmIoTWF0aC5mbG9vcigocC5SYSs3LXAuTmEpLzcpLDIpLFwiJVZcIjpwPT57dmFyIE49TWF0aC5mbG9vcigocC5SYSs3LShwLk5hKzYpJTcpLzcpO2lmKDI+PShwLk5hKzM3MS1wLlJhLTIpJTcmJk4rKyxOKU49PTUzJiYoWD0ocC5OYSszNzEtcC5SYSklNyxYPT00fHxYPT0zJiZZZShwLlNhKXx8KE49MSkpO2Vsc2V7Tj01Mjt2YXIgWD0ocC5OYSs3LXAuUmEtMSklNzsoWD09NHx8WD09NSYmWWUocC5TYSU0MDAtMSkpJiZOKyt9cmV0dXJuIGIoTiwyKX0sXCIld1wiOnA9PnAuTmEsXCIlV1wiOnA9PmIoTWF0aC5mbG9vcigocC5SYSs3LShwLk5hKzYpJTcpLzcpLDIpLFwiJXlcIjpwPT4ocC5TYSsxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVZXCI6cD0+cC5TYSsxOTAwLFwiJXpcIjpwPT57cD1wLm1iO3ZhciBOPTA8PXA7cmV0dXJuIHA9TWF0aC5hYnMocCkvNjAsKE4/XCIrXCI6XCItXCIpKyhcIjAwMDBcIisocC82MCoxMDArcCU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOnA9PnAucGIsXCIlJVwiOigpPT5cIiVcIn0sbj1uLnJlcGxhY2UoLyUlL2csXCJcXFxcMFxcXFwwXCIpO2ZvcihnZSBpbiBvZSluLmluY2x1ZGVzKGdlKSYmKG49bi5yZXBsYWNlKG5ldyBSZWdFeHAoZ2UsXCJnXCIpLG9lW2dlXShsKSkpO3JldHVybiBuPW4ucmVwbGFjZSgvXFxcXDBcXFxcMC9nLFwiJVwiKSxnZT1qcihuKSxnZS5sZW5ndGg+dD8wOihZcihnZSxlKSxnZS5sZW5ndGgtMSl9TS5XYSgpO3ZhciB6cj1bQyx1dCxtLEEsTCx1ZSxaZSxLZSxkLEIsJCxUZSxldCxCdCxrdCxXdCxHdCwkdCx6dCxxdCxWdCxKdCxYdCxRdF0scXI9e2I6ZnVuY3Rpb24oZSx0LG4pe3Rocm93IGU+Pj49MCxuZXcgcihlKS5XYSh0Pj4+MCxuPj4+MCksbz1lLHMrKyxvfSxMOmZ1bmN0aW9uKGUpe25yKGU+Pj4wLCFSLDEsIUssMTMxMDcyLCExKSxNLmFiKCl9LGo6ZnVuY3Rpb24oZSl7ZT4+Pj0wLHY/cG9zdE1lc3NhZ2Uoe2NtZDpcImNsZWFudXBUaHJlYWRcIix0aHJlYWQ6ZX0pOk0uWmEoTS5NYVtlXSl9LEg6TyxoOkEsUzpMLEQ6dWUsRjpaZSxUOktlLFE6ZCxKOkIsUDokLG46VGUsRTpldCxCOkJ0LFI6a3QsQzpXdCxwOigpPT4xLHo6ZnVuY3Rpb24oZSx0KXtlPj4+PTAsZT09dD4+PjA/c2V0VGltZW91dCgoKT0+ZnQoKSk6dj9wb3N0TWVzc2FnZSh7dGFyZ2V0VGhyZWFkOmUsY21kOlwiY2hlY2tNYWlsYm94XCJ9KTooZT1NLk1hW2VdKSYmZS5wb3N0TWVzc2FnZSh7Y21kOlwiY2hlY2tNYWlsYm94XCJ9KX0sSTpmdW5jdGlvbihlLHQsbixsKXt0Pj4+PTAsZ3QubGVuZ3RoPW4sbD1sPj4+MD4+PjM7Zm9yKHZhciB5PTA7eTxuO3krKylndFt5XT1nKClbbCt5Pj4+MF07cmV0dXJuIGU9MD5lP05lWy1lLTFdOnpyW2VdLE0uaWI9dCx0PWUuYXBwbHkobnVsbCxndCksTS5pYj0wLHR9LEs6bXQsbzpmdW5jdGlvbihlKXtJJiZNLk1hW2U+Pj4wXS5yZWYoKX0sczpmdW5jdGlvbihlLHQsbil7ZT10KzIwOTcxNTI+Pj4wPDQxOTQzMDUtISFlPyhlPj4+MCkrNDI5NDk2NzI5Nip0Ok5hTixuPj4+PTAsZT1uZXcgRGF0ZSgxZTMqZSksZigpW24+Pj4yPj4+MF09ZS5nZXRVVENTZWNvbmRzKCksZigpW24rND4+PjI+Pj4wXT1lLmdldFVUQ01pbnV0ZXMoKSxmKClbbis4Pj4+Mj4+PjBdPWUuZ2V0VVRDSG91cnMoKSxmKClbbisxMj4+PjI+Pj4wXT1lLmdldFVUQ0RhdGUoKSxmKClbbisxNj4+PjI+Pj4wXT1lLmdldFVUQ01vbnRoKCksZigpW24rMjA+Pj4yPj4+MF09ZS5nZXRVVENGdWxsWWVhcigpLTE5MDAsZigpW24rMjQ+Pj4yPj4+MF09ZS5nZXRVVENEYXkoKSxlPShlLmdldFRpbWUoKS1EYXRlLlVUQyhlLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwLGYoKVtuKzI4Pj4+Mj4+PjBdPWV9LHQ6ZnVuY3Rpb24oZSx0LG4pe2U9dCsyMDk3MTUyPj4+MDw0MTk0MzA1LSEhZT8oZT4+PjApKzQyOTQ5NjcyOTYqdDpOYU4sbj4+Pj0wLGU9bmV3IERhdGUoMWUzKmUpLGYoKVtuPj4+Mj4+PjBdPWUuZ2V0U2Vjb25kcygpLGYoKVtuKzQ+Pj4yPj4+MF09ZS5nZXRNaW51dGVzKCksZigpW24rOD4+PjI+Pj4wXT1lLmdldEhvdXJzKCksZigpW24rMTI+Pj4yPj4+MF09ZS5nZXREYXRlKCksZigpW24rMTY+Pj4yPj4+MF09ZS5nZXRNb250aCgpLGYoKVtuKzIwPj4+Mj4+PjBdPWUuZ2V0RnVsbFllYXIoKS0xOTAwLGYoKVtuKzI0Pj4+Mj4+PjBdPWUuZ2V0RGF5KCksdD0oWWUoZS5nZXRGdWxsWWVhcigpKT9OdDpIdClbZS5nZXRNb250aCgpXStlLmdldERhdGUoKS0xfDAsZigpW24rMjg+Pj4yPj4+MF09dCxmKClbbiszNj4+PjI+Pj4wXT0tKDYwKmUuZ2V0VGltZXpvbmVPZmZzZXQoKSksdD1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBsPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7ZT0odCE9bCYmZS5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbihsLHQpKXwwLGYoKVtuKzMyPj4+Mj4+PjBdPWV9LHU6ZnVuY3Rpb24oZSl7ZT4+Pj0wO3ZhciB0PW5ldyBEYXRlKGYoKVtlKzIwPj4+Mj4+PjBdKzE5MDAsZigpW2UrMTY+Pj4yPj4+MF0sZigpW2UrMTI+Pj4yPj4+MF0sZigpW2UrOD4+PjI+Pj4wXSxmKClbZSs0Pj4+Mj4+PjBdLGYoKVtlPj4+Mj4+PjBdLDApLG49ZigpW2UrMzI+Pj4yPj4+MF0sbD10LmdldFRpbWV6b25lT2Zmc2V0KCkseT1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLGI9bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxfPU1hdGgubWluKGIseSk7cmV0dXJuIDA+bj9mKClbZSszMj4+PjI+Pj4wXT0rKHkhPWImJl89PWwpOjA8biE9KF89PWwpJiYoeT1NYXRoLm1heChiLHkpLHQuc2V0VGltZSh0LmdldFRpbWUoKSs2ZTQqKCgwPG4/Xzp5KS1sKSkpLGYoKVtlKzI0Pj4+Mj4+PjBdPXQuZ2V0RGF5KCksbj0oWWUodC5nZXRGdWxsWWVhcigpKT9OdDpIdClbdC5nZXRNb250aCgpXSt0LmdldERhdGUoKS0xfDAsZigpW2UrMjg+Pj4yPj4+MF09bixmKClbZT4+PjI+Pj4wXT10LmdldFNlY29uZHMoKSxmKClbZSs0Pj4+Mj4+PjBdPXQuZ2V0TWludXRlcygpLGYoKVtlKzg+Pj4yPj4+MF09dC5nZXRIb3VycygpLGYoKVtlKzEyPj4+Mj4+PjBdPXQuZ2V0RGF0ZSgpLGYoKVtlKzE2Pj4+Mj4+PjBdPXQuZ2V0TW9udGgoKSxmKClbZSsyMD4+PjI+Pj4wXT10LmdldFllYXIoKSxlPXQuZ2V0VGltZSgpLGlzTmFOKGUpPyhmKClbdHIoKT4+PjI+Pj4wXT02MSxlPS0xKTplLz0xZTMsc3IoKHhlPWUsMTw9K01hdGguYWJzKHhlKT8wPHhlPytNYXRoLmZsb29yKHhlLzQyOTQ5NjcyOTYpPj4+MDp+fitNYXRoLmNlaWwoKHhlLSsofn54ZT4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCkpLGU+Pj4wfSxxOkd0LHI6JHQseTpmdW5jdGlvbihlLHQsbil7ZnVuY3Rpb24gbChvZSl7cmV0dXJuKG9lPW9lLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXFxcKChbQS1aYS16IF0rKVxcXFwpJC8pKT9vZVsxXTpcIkdNVFwifWU+Pj49MCx0Pj4+PTAsbj4+Pj0wO3ZhciB5PW5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSxiPW5ldyBEYXRlKHksMCwxKSxfPW5ldyBEYXRlKHksNiwxKTt5PWIuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgSj1fLmdldFRpbWV6b25lT2Zmc2V0KCksTWU9TWF0aC5tYXgoeSxKKTt3KClbZT4+PjI+Pj4wXT02MCpNZSxmKClbdD4+PjI+Pj4wXT0rKHkhPUopLGU9bChiKSx0PWwoXyksZT1qdChlKSx0PWp0KHQpLEo8eT8odygpW24+Pj4yPj4+MF09ZSx3KClbbis0Pj4+Mj4+PjBdPXQpOih3KClbbj4+PjI+Pj4wXT10LHcoKVtuKzQ+Pj4yPj4+MF09ZSl9LGM6KCk9PntEZShcIlwiKX0sTzpmdW5jdGlvbihlLHQsbil7ZT4+Pj0wLHQ+Pj49MCxuPj4+PTAsaHQubGVuZ3RoPTA7Zm9yKHZhciBsO2w9aCgpW3QrKz4+PjBdOyl7dmFyIHk9bCE9MTA1O3kmPWwhPTExMixuKz15JiZuJTg/NDowLGh0LnB1c2gobD09MTEyP3coKVtuPj4+Mj4+PjBdOmw9PTEwNT9mKClbbj4+PjI+Pj4wXTpnKClbbj4+PjM+Pj4wXSksbis9eT84OjR9cmV0dXJuIE5lW2VdLmFwcGx5KG51bGwsaHQpfSxrOigpPT57fSxpOigpPT5EYXRlLm5vdygpLFU6KCk9Pnt0aHJvdyBCZSs9MSxcInVud2luZFwifSxBOmZ1bmN0aW9uKCl7cmV0dXJuIDQyOTQ5MDE3NjB9LGU6KCk9PnBlcmZvcm1hbmNlLnRpbWVPcmlnaW4rcGVyZm9ybWFuY2Uubm93KCksZjooKT0+ST8od3IoKSxydChicikpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kseDpmdW5jdGlvbihlKXtlPj4+PTA7dmFyIHQ9aCgpLmxlbmd0aDtpZihlPD10fHw0Mjk0OTAxNzYwPGUpcmV0dXJuITE7Zm9yKHZhciBuPTE7ND49bjtuKj0yKXt2YXIgbD10KigxKy4yL24pO2w9TWF0aC5taW4obCxlKzEwMDY2MzI5Nik7dmFyIHk9TWF0aDtsPU1hdGgubWF4KGUsbCk7ZTp7eT0oeS5taW4uY2FsbCh5LDQyOTQ5MDE3NjAsbCsoNjU1MzYtbCU2NTUzNiklNjU1MzYpLVEuYnVmZmVyLmJ5dGVMZW5ndGgrNjU1MzUpLzY1NTM2O3RyeXtRLmdyb3coeSksWSgpO3ZhciBiPTE7YnJlYWsgZX1jYXRjaHt9Yj12b2lkIDB9aWYoYilyZXR1cm4hMH1yZXR1cm4hMX0sTTp6dCxOOnF0LEc6amUsZzpWdCxtOkp0LHY6WHQsbDpRdCxhOlF8fGkud2FzbU1lbW9yeSx3OmVyLGQ6ZnVuY3Rpb24oZSx0LG4sbCl7cmV0dXJuIGVyKGU+Pj4wLHQ+Pj4wLG4+Pj4wLGw+Pj4wKX19LFQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKG4sbCl7cmV0dXJuIFQ9bi5leHBvcnRzLFQ9VnIoKSxNLmJiLnB1c2goVC56YSksUWU9VC5BYSxFZS51bnNoaWZ0KFQuViksT2U9bCxTZSgpLFR9dmFyIHQ9e2E6cXJ9O2lmKHdlKyssaS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBpLmluc3RhbnRpYXRlV2FzbSh0LGUpfWNhdGNoKG4pe25lKGBNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAke259YCksUChuKX1yZXR1cm4gYXQodCxmdW5jdGlvbihuKXtlKG4uaW5zdGFuY2Usbi5tb2R1bGUpfSkuY2F0Y2goUCkse319KCk7aS5fT3J0SW5pdD0oZSx0KT0+KGkuX09ydEluaXQ9VC5XKShlLHQpLGkuX09ydEdldExhc3RFcnJvcj0oZSx0KT0+KGkuX09ydEdldExhc3RFcnJvcj1ULlgpKGUsdCksaS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9KGUsdCxuLGwseSxiLF8sSixNZSxvZSk9PihpLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1ULlkpKGUsdCxuLGwseSxiLF8sSixNZSxvZSksaS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9KGUsdCk9PihpLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj1ULlopKGUsdCksaS5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPShlLHQsbik9PihpLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9VC5fKShlLHQsbiksaS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PShlLHQsbik9PihpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9VC4kKShlLHQsbiksaS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWU9PihpLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9VC5hYSkoZSksaS5fT3J0Q3JlYXRlU2Vzc2lvbj0oZSx0LG4pPT4oaS5fT3J0Q3JlYXRlU2Vzc2lvbj1ULmJhKShlLHQsbiksaS5fT3J0UmVsZWFzZVNlc3Npb249ZT0+KGkuX09ydFJlbGVhc2VTZXNzaW9uPVQuY2EpKGUpLGkuX09ydEdldElucHV0T3V0cHV0Q291bnQ9KGUsdCxuKT0+KGkuX09ydEdldElucHV0T3V0cHV0Q291bnQ9VC5kYSkoZSx0LG4pLGkuX09ydEdldElucHV0TmFtZT0oZSx0KT0+KGkuX09ydEdldElucHV0TmFtZT1ULmVhKShlLHQpLGkuX09ydEdldE91dHB1dE5hbWU9KGUsdCk9PihpLl9PcnRHZXRPdXRwdXROYW1lPVQuZmEpKGUsdCksaS5fT3J0RnJlZT1lPT4oaS5fT3J0RnJlZT1ULmdhKShlKSxpLl9PcnRDcmVhdGVUZW5zb3I9KGUsdCxuLGwseSxiKT0+KGkuX09ydENyZWF0ZVRlbnNvcj1ULmhhKShlLHQsbixsLHksYiksaS5fT3J0R2V0VGVuc29yRGF0YT0oZSx0LG4sbCx5KT0+KGkuX09ydEdldFRlbnNvckRhdGE9VC5pYSkoZSx0LG4sbCx5KSxpLl9PcnRSZWxlYXNlVGVuc29yPWU9PihpLl9PcnRSZWxlYXNlVGVuc29yPVQuamEpKGUpLGkuX09ydENyZWF0ZVJ1bk9wdGlvbnM9KGUsdCxuLGwpPT4oaS5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1ULmthKShlLHQsbixsKSxpLl9PcnRBZGRSdW5Db25maWdFbnRyeT0oZSx0LG4pPT4oaS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9VC5sYSkoZSx0LG4pLGkuX09ydFJlbGVhc2VSdW5PcHRpb25zPWU9PihpLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1ULm1hKShlKSxpLl9PcnRDcmVhdGVCaW5kaW5nPWU9PihpLl9PcnRDcmVhdGVCaW5kaW5nPVQubmEpKGUpLGkuX09ydEJpbmRJbnB1dD0oZSx0LG4pPT4oaS5fT3J0QmluZElucHV0PVQub2EpKGUsdCxuKSxpLl9PcnRCaW5kT3V0cHV0PShlLHQsbixsKT0+KGkuX09ydEJpbmRPdXRwdXQ9VC5wYSkoZSx0LG4sbCksaS5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9ZT0+KGkuX09ydENsZWFyQm91bmRPdXRwdXRzPVQucWEpKGUpLGkuX09ydFJlbGVhc2VCaW5kaW5nPWU9PihpLl9PcnRSZWxlYXNlQmluZGluZz1ULnJhKShlKSxpLl9PcnRSdW5XaXRoQmluZGluZz0oZSx0LG4sbCx5KT0+KGkuX09ydFJ1bldpdGhCaW5kaW5nPVQuc2EpKGUsdCxuLGwseSksaS5fT3J0UnVuPShlLHQsbixsLHksYixfLEopPT4oaS5fT3J0UnVuPVQudGEpKGUsdCxuLGwseSxiLF8sSiksaS5fT3J0RW5kUHJvZmlsaW5nPWU9PihpLl9PcnRFbmRQcm9maWxpbmc9VC51YSkoZSk7dmFyIHRyPSgpPT4odHI9VC52YSkoKSxsdD1pLl9wdGhyZWFkX3NlbGY9KCk9PihsdD1pLl9wdGhyZWFkX3NlbGY9VC53YSkoKSxycj1pLl9tYWxsb2M9ZT0+KHJyPWkuX21hbGxvYz1ULnhhKShlKTtpLl9mcmVlPWU9PihpLl9mcmVlPVQueWEpKGUpLGkuX19lbXNjcmlwdGVuX3Rsc19pbml0PSgpPT4oaS5fX2Vtc2NyaXB0ZW5fdGxzX2luaXQ9VC56YSkoKTt2YXIgbnI9aS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQ9KGUsdCxuLGwseSxiKT0+KG5yPWkuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PVQuQmEpKGUsdCxuLGwseSxiKTtpLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZD0oKT0+KGkuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPVQuQ2EpKCk7dmFyIGFyPShlLHQsbixsKT0+KGFyPVQuRGEpKGUsdCxuLGwpLHd0PWU9Pih3dD1ULkVhKShlKSxPdD1pLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD1lPT4oT3Q9aS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9VC5GYSkoZSksb3I9KCk9Pihvcj1ULkdhKSgpLHNyPWU9Pihzcj1ULkhhKShlKSxpcj0oZSx0KT0+KGlyPVQuSWEpKGUsdCksdnQ9KCk9Pih2dD1ULkphKSgpLGN0PWU9PihjdD1ULkthKShlKSxfdD1lPT4oX3Q9VC5MYSkoZSk7ZnVuY3Rpb24gVnIoKXt2YXIgZT1UO2U9T2JqZWN0LmFzc2lnbih7fSxlKTt2YXIgdD1sPT4oKT0+bCgpPj4+MCxuPWw9Pnk9PmwoeSk+Pj4wO3JldHVybiBlLnZhPXQoZS52YSksZS53YT10KGUud2EpLGUueGE9bihlLnhhKSxlLmVtc2NyaXB0ZW5fbWFpbl9ydW50aW1lX3RocmVhZF9pZD10KGUuZW1zY3JpcHRlbl9tYWluX3J1bnRpbWVfdGhyZWFkX2lkKSxlLkphPXQoZS5KYSksZS5MYT1uKGUuTGEpLGV9aS53YXNtTWVtb3J5PVEsaS5zdGFja0FsbG9jPV90LGkuc3RhY2tTYXZlPXZ0LGkuc3RhY2tSZXN0b3JlPWN0LGkua2VlcFJ1bnRpbWVBbGl2ZT0oKT0+MDxCZSxpLlVURjhUb1N0cmluZz0kZSxpLnN0cmluZ1RvVVRGOD1pZSxpLmxlbmd0aEJ5dGVzVVRGOD1yZSxpLkV4aXRTdGF0dXM9UmUsaS5QVGhyZWFkPU07dmFyIGR0O21lPWZ1bmN0aW9uIGUoKXtkdHx8dXIoKSxkdHx8KG1lPWUpfTtmdW5jdGlvbiB1cigpe2lmKCEoMDx3ZSkpaWYodilFKGkpLHZ8fGtlKEVlKSxzdGFydFdvcmtlcihpKTtlbHNle2lmKGkucHJlUnVuKWZvcih0eXBlb2YgaS5wcmVSdW49PVwiZnVuY3Rpb25cIiYmKGkucHJlUnVuPVtpLnByZVJ1bl0pO2kucHJlUnVuLmxlbmd0aDspSWUudW5zaGlmdChpLnByZVJ1bi5zaGlmdCgpKTtrZShJZSksMDx3ZXx8ZHR8fChkdD0hMCxpLmNhbGxlZFJ1bj0hMCxoZXx8KHZ8fGtlKEVlKSxFKGkpLHZ8fGtlKGJlKSkpfX1yZXR1cm4gdXIoKSxjLnJlYWR5fX0pKCk7dHlwZW9mIHZyPT1cIm9iamVjdFwiJiZ0eXBlb2YgeHQ9PVwib2JqZWN0XCI/eHQuZXhwb3J0cz1Pcjp0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQmJmRlZmluZShbXSwoKT0+T3IpfSk7dmFyIEVyPXR0KChPbixubik9Pntubi5leHBvcnRzPVxcJ1widXNlIHN0cmljdFwiO3ZhciBNb2R1bGU9e30sRU5WSVJPTk1FTlRfSVNfTk9ERT10eXBlb2YgcHJvY2Vzcz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnM9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PVwic3RyaW5nXCI7aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7dmFyIG5vZGVXb3JrZXJUaHJlYWRzPXJlcXVpcmUoXCJ3b3JrZXJfdGhyZWFkc1wiKSxwYXJlbnRQb3J0PW5vZGVXb3JrZXJUaHJlYWRzLnBhcmVudFBvcnQ7cGFyZW50UG9ydC5vbihcIm1lc3NhZ2VcIixlPT5vbm1lc3NhZ2Uoe2RhdGE6ZX0pKTt2YXIgZnM9cmVxdWlyZShcImZzXCIpLHZtPXJlcXVpcmUoXCJ2bVwiKTtPYmplY3QuYXNzaWduKGdsb2JhbCx7c2VsZjpnbG9iYWwscmVxdWlyZSxNb2R1bGUsbG9jYXRpb246e2hyZWY6X19maWxlbmFtZX0sV29ya2VyOm5vZGVXb3JrZXJUaHJlYWRzLldvcmtlcixpbXBvcnRTY3JpcHRzOmU9PnZtLnJ1bkluVGhpc0NvbnRleHQoZnMucmVhZEZpbGVTeW5jKGUsXCJ1dGY4XCIpLHtmaWxlbmFtZTplfSkscG9zdE1lc3NhZ2U6ZT0+cGFyZW50UG9ydC5wb3N0TWVzc2FnZShlKSxwZXJmb3JtYW5jZTpnbG9iYWwucGVyZm9ybWFuY2V8fHtub3c6RGF0ZS5ub3d9fSl9dmFyIGluaXRpYWxpemVkSlM9ITE7ZnVuY3Rpb24gdGhyZWFkUHJpbnRFcnIoKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO2lmKEVOVklST05NRU5UX0lTX05PREUpe2ZzLndyaXRlU3luYygyLGUrYFxcXFxuYCk7cmV0dXJufWNvbnNvbGUuZXJyb3IoZSl9ZnVuY3Rpb24gdGhyZWFkQWxlcnQoKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO3Bvc3RNZXNzYWdlKHtjbWQ6XCJhbGVydFwiLHRleHQ6ZSx0aHJlYWRJZDpNb2R1bGUuX3B0aHJlYWRfc2VsZigpfSl9dmFyIGVycj10aHJlYWRQcmludEVycjtzZWxmLmFsZXJ0PXRocmVhZEFsZXJ0LE1vZHVsZS5pbnN0YW50aWF0ZVdhc209KGUsdCk9Pnt2YXIgYT1Nb2R1bGUud2FzbU1vZHVsZTtNb2R1bGUud2FzbU1vZHVsZT1udWxsO3ZhciByPW5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShhLGUpO3JldHVybiB0KHIpfSxzZWxmLm9udW5oYW5kbGVkcmVqZWN0aW9uPWU9Pnt0aHJvdyBlLnJlYXNvbnx8ZX07ZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShlKXt0cnl7aWYoZS5kYXRhLmNtZD09PVwibG9hZFwiKXtsZXQgYT1bXTtzZWxmLm9ubWVzc2FnZT1yPT5hLnB1c2gociksc2VsZi5zdGFydFdvcmtlcj1yPT57TW9kdWxlPXIscG9zdE1lc3NhZ2Uoe2NtZDpcImxvYWRlZFwifSk7Zm9yKGxldCBzIG9mIGEpaGFuZGxlTWVzc2FnZShzKTtzZWxmLm9ubWVzc2FnZT1oYW5kbGVNZXNzYWdlfSxNb2R1bGUud2FzbU1vZHVsZT1lLmRhdGEud2FzbU1vZHVsZTtmb3IoY29uc3QgciBvZiBlLmRhdGEuaGFuZGxlcnMpTW9kdWxlW3JdPSguLi5zKT0+e3Bvc3RNZXNzYWdlKHtjbWQ6XCJjYWxsSGFuZGxlclwiLGhhbmRsZXI6cixhcmdzOnN9KX07aWYoTW9kdWxlLndhc21NZW1vcnk9ZS5kYXRhLndhc21NZW1vcnksTW9kdWxlLmJ1ZmZlcj1Nb2R1bGUud2FzbU1lbW9yeS5idWZmZXIsTW9kdWxlLkVOVklST05NRU5UX0lTX1BUSFJFQUQ9ITAsdHlwZW9mIGUuZGF0YS51cmxPckJsb2I9PVwic3RyaW5nXCIpaW1wb3J0U2NyaXB0cyhlLmRhdGEudXJsT3JCbG9iKTtlbHNle3ZhciB0PVVSTC5jcmVhdGVPYmplY3RVUkwoZS5kYXRhLnVybE9yQmxvYik7aW1wb3J0U2NyaXB0cyh0KSxVUkwucmV2b2tlT2JqZWN0VVJMKHQpfW9ydFdhc21UaHJlYWRlZChNb2R1bGUpfWVsc2UgaWYoZS5kYXRhLmNtZD09PVwicnVuXCIpe01vZHVsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQoZS5kYXRhLnB0aHJlYWRfcHRyLDAsMCwxKSxNb2R1bGUuX19lbXNjcmlwdGVuX3RocmVhZF9tYWlsYm94X2F3YWl0KGUuZGF0YS5wdGhyZWFkX3B0ciksTW9kdWxlLmVzdGFibGlzaFN0YWNrU3BhY2UoKSxNb2R1bGUuUFRocmVhZC5yZWNlaXZlT2JqZWN0VHJhbnNmZXIoZS5kYXRhKSxNb2R1bGUuUFRocmVhZC50aHJlYWRJbml0VExTKCksaW5pdGlhbGl6ZWRKU3x8KGluaXRpYWxpemVkSlM9ITApO3RyeXtNb2R1bGUuaW52b2tlRW50cnlQb2ludChlLmRhdGEuc3RhcnRfcm91dGluZSxlLmRhdGEuYXJnKX1jYXRjaChhKXtpZihhIT1cInVud2luZFwiKXRocm93IGF9fWVsc2UgZS5kYXRhLmNtZD09PVwiY2FuY2VsXCI/TW9kdWxlLl9wdGhyZWFkX3NlbGYoKSYmTW9kdWxlLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdCgtMSk6ZS5kYXRhLnRhcmdldD09PVwic2V0aW1tZWRpYXRlXCJ8fChlLmRhdGEuY21kPT09XCJjaGVja01haWxib3hcIj9pbml0aWFsaXplZEpTJiZNb2R1bGUuY2hlY2tNYWlsYm94KCk6ZS5kYXRhLmNtZCYmKGVycihgd29ya2VyLmpzIHJlY2VpdmVkIHVua25vd24gY29tbWFuZCAke2UuZGF0YS5jbWR9YCksZXJyKGUuZGF0YSkpKX1jYXRjaChhKXt0aHJvdyBNb2R1bGUuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPy4oKSxhfX1zZWxmLm9ubWVzc2FnZT1oYW5kbGVNZXNzYWdlO1xcXFxuXFwnfSk7dmFyIEFyO0FyPWdyKCk7dmFyIGFuPV9yKCksUHQsVXQ9ITEscHQ9ITEsU3I9ITEsb249dT0+e2lmKHU9PT0xKXJldHVybiExO2lmKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj5cInVcIilyZXR1cm4gdHlwZW9mIHNlbGY8XCJ1XCImJiFzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWQmJmNvbnNvbGUud2FybihcImVudi53YXNtLm51bVRocmVhZHMgaXMgc2V0IHRvIFwiK3UrXCIsIGJ1dCB0aGlzIHdpbGwgbm90IHdvcmsgdW5sZXNzIHlvdSBlbmFibGUgY3Jvc3NPcmlnaW5Jc29sYXRlZCBtb2RlLiBTZWUgaHR0cHM6Ly93ZWIuZGV2L2Nyb3NzLW9yaWdpbi1pc29sYXRpb24tZ3VpZGUvIGZvciBtb3JlIGluZm8uXCIpLCExO3R5cGVvZiBwcm9jZXNzPFwidVwiJiZwcm9jZXNzLnZlcnNpb25zJiZwcm9jZXNzLnZlcnNpb25zLm5vZGUmJmNvbnNvbGUud2FybihcImVudi53YXNtLm51bVRocmVhZHMgaXMgc2V0IHRvIFwiK3UrXCIsIGhvd2V2ZXIsIGN1cnJlbnRseSBvbm54cnVudGltZS13ZWIgZG9lcyBub3Qgc3VwcG9ydCBtdWx0aS10aHJlYWRzIGluIE5vZGUuanMuIFBsZWFzZSBjb25zaWRlciB1c2luZyBvbm54cnVudGltZS1ub2RlIGZvciBwZXJmb3JtYW5jZSBjcml0aWNhbCBzY2VuYXJpb3MuXCIpO3RyeXtyZXR1cm4gdHlwZW9mIE1lc3NhZ2VDaGFubmVsPFwidVwiJiZuZXcgTWVzc2FnZUNoYW5uZWwoKS5wb3J0MS5wb3N0TWVzc2FnZShuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMSkpLFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCw1LDQsMSwzLDEsMSwxMCwxMSwxLDksMCw2NSwwLDI1NCwxNiwyLDAsMjYsMTFdKSl9Y2F0Y2h7cmV0dXJuITF9fSxzbj0oKT0+e3RyeXtyZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDMwLDEsMjgsMCw2NSwwLDI1MywxNSwyNTMsMTIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyNTMsMTg2LDEsMjYsMTFdKSl9Y2F0Y2h7cmV0dXJuITF9fSx1bj0odSxjKT0+dT9jP1wib3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtXCI6XCJvcnQtd2FzbS1zaW1kLndhc21cIjpjP1wib3J0LXdhc20tdGhyZWFkZWQud2FzbVwiOlwib3J0LXdhc20ud2FzbVwiLFRyPWFzeW5jIHU9PntpZihVdClyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7aWYocHQpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gXFwnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KClcXCcgZGV0ZWN0ZWQuXCIpO2lmKFNyKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gXFwnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KClcXCcgZmFpbGVkLlwiKTtwdD0hMDtsZXQgYz11LmluaXRUaW1lb3V0LGE9dS5udW1UaHJlYWRzLGg9dS5zaW1kLGY9b24oYSksdz1oJiZzbigpLGc9dS53YXNtUGF0aHMsaT10eXBlb2YgZz09XCJzdHJpbmdcIj9nOnZvaWQgMCxFPXVuKHcsZiksUD10eXBlb2YgZz09XCJvYmplY3RcIj9nW0VdOnZvaWQgMCxVPSExLEQ9W107aWYoYz4wJiZELnB1c2gobmV3IFByb21pc2UoeD0+e3NldFRpbWVvdXQoKCk9PntVPSEwLHgoKX0sYyl9KSksRC5wdXNoKG5ldyBQcm9taXNlKCh4LEspPT57bGV0IFI9Zj9hbjpBcixJPXtsb2NhdGVGaWxlOih2LGspPT5mJiZ2LmVuZHNXaXRoKFwiLndvcmtlci5qc1wiKSYmdHlwZW9mIEJsb2I8XCJ1XCI/VVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbRXIoKV0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pKTp2LmVuZHNXaXRoKFwiLndhc21cIik/UHx8KGk/P2spK0U6ayt2fTtpZihmKWlmKEkubnVtVGhyZWFkcz1hLHR5cGVvZiBCbG9iPlwidVwiKUkubWFpblNjcmlwdFVybE9yQmxvYj0odm9pZCAwKShfX2Rpcm5hbWUsXCJvcnQtd2FzbS10aHJlYWRlZC5qc1wiKTtlbHNle2xldCB2PWB2YXIgb3J0V2FzbVRocmVhZGVkPSR7Ui50b1N0cmluZygpfTtgO0kubWFpblNjcmlwdFVybE9yQmxvYj1uZXcgQmxvYihbdl0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pfVIoSSkudGhlbih2PT57cHQ9ITEsVXQ9ITAsUHQ9dix4KCl9LHY9PntwdD0hMSxTcj0hMCxLKHYpfSl9KSksYXdhaXQgUHJvbWlzZS5yYWNlKEQpLFUpdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7Y31tc2ApfSxaPSgpPT57aWYoVXQmJlB0KXJldHVybiBQdDt0aHJvdyBuZXcgRXJyb3IoXCJXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LlwiKX07dmFyIHE9KHUsYyk9PntsZXQgYT1aKCksaD1hLmxlbmd0aEJ5dGVzVVRGOCh1KSsxLGY9YS5fbWFsbG9jKGgpO3JldHVybiBhLnN0cmluZ1RvVVRGOCh1LGYsaCksYy5wdXNoKGYpLGZ9LG50PSh1LGMsYSxoKT0+e2lmKHR5cGVvZiB1PT1cIm9iamVjdFwiJiZ1IT09bnVsbCl7aWYoYS5oYXModSkpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnNcIik7YS5hZGQodSl9T2JqZWN0LmVudHJpZXModSkuZm9yRWFjaCgoW2Ysd10pPT57bGV0IGc9Yz9jK2Y6ZjtpZih0eXBlb2Ygdz09XCJvYmplY3RcIiludCh3LGcrXCIuXCIsYSxoKTtlbHNlIGlmKHR5cGVvZiB3PT1cInN0cmluZ1wifHx0eXBlb2Ygdz09XCJudW1iZXJcIiloKGcsdy50b1N0cmluZygpKTtlbHNlIGlmKHR5cGVvZiB3PT1cImJvb2xlYW5cIiloKGcsdz9cIjFcIjpcIjBcIik7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiAke3R5cGVvZiB3fWApfSl9LFY9dT0+e2xldCBjPVooKSxhPWMuc3RhY2tTYXZlKCk7dHJ5e2xldCBoPWMuc3RhY2tBbGxvYyg4KTtjLl9PcnRHZXRMYXN0RXJyb3IoaCxoKzQpO2xldCBmPWMuSEVBUDMyW2gvNF0sdz1jLkhFQVBVMzJbaC80KzFdLGc9dz9jLlVURjhUb1N0cmluZyh3KTpcIlwiO3Rocm93IG5ldyBFcnJvcihgJHt1fSBFUlJPUl9DT0RFOiAke2Z9LCBFUlJPUl9NRVNTQUdFOiAke2d9YCl9ZmluYWxseXtjLnN0YWNrUmVzdG9yZShhKX19O3ZhciBNcj11PT57bGV0IGM9WigpLGE9MCxoPVtdLGY9dXx8e307dHJ5e2lmKHU/LmxvZ1NldmVyaXR5TGV2ZWw9PT12b2lkIDApZi5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZih0eXBlb2YgdS5sb2dTZXZlcml0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcih1LmxvZ1NldmVyaXR5TGV2ZWwpfHx1LmxvZ1NldmVyaXR5TGV2ZWw8MHx8dS5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt1LmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYodT8ubG9nVmVyYm9zaXR5TGV2ZWw9PT12b2lkIDApZi5sb2dWZXJib3NpdHlMZXZlbD0wO2Vsc2UgaWYodHlwZW9mIHUubG9nVmVyYm9zaXR5TGV2ZWwhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKHUubG9nVmVyYm9zaXR5TGV2ZWwpKXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7dS5sb2dWZXJib3NpdHlMZXZlbH1gKTt1Py50ZXJtaW5hdGU9PT12b2lkIDAmJihmLnRlcm1pbmF0ZT0hMSk7bGV0IHc9MDtyZXR1cm4gdT8udGFnIT09dm9pZCAwJiYodz1xKHUudGFnLGgpKSxhPWMuX09ydENyZWF0ZVJ1bk9wdGlvbnMoZi5sb2dTZXZlcml0eUxldmVsLGYubG9nVmVyYm9zaXR5TGV2ZWwsISFmLnRlcm1pbmF0ZSx3KSxhPT09MCYmVihcIkNhblxcJ3QgY3JlYXRlIHJ1biBvcHRpb25zLlwiKSx1Py5leHRyYSE9PXZvaWQgMCYmbnQodS5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LChnLGkpPT57bGV0IEU9cShnLGgpLFA9cShpLGgpO2MuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KGEsRSxQKSE9PTAmJlYoYENhblxcJ3Qgc2V0IGEgcnVuIGNvbmZpZyBlbnRyeTogJHtnfSAtICR7aX0uYCl9KSxbYSxoXX1jYXRjaCh3KXt0aHJvdyBhIT09MCYmYy5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMoYSksaC5mb3JFYWNoKGc9PmMuX2ZyZWUoZykpLHd9fTt2YXIgZm49dT0+e3N3aXRjaCh1KXtjYXNlXCJkaXNhYmxlZFwiOnJldHVybiAwO2Nhc2VcImJhc2ljXCI6cmV0dXJuIDE7Y2FzZVwiZXh0ZW5kZWRcIjpyZXR1cm4gMjtjYXNlXCJhbGxcIjpyZXR1cm4gOTk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGdyYXBoIG9wdGltaXphdGlvbiBsZXZlbDogJHt1fWApfX0sbG49dT0+e3N3aXRjaCh1KXtjYXNlXCJzZXF1ZW50aWFsXCI6cmV0dXJuIDA7Y2FzZVwicGFyYWxsZWxcIjpyZXR1cm4gMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7dX1gKX19LGNuPXU9Pnt1LmV4dHJhfHwodS5leHRyYT17fSksdS5leHRyYS5zZXNzaW9ufHwodS5leHRyYS5zZXNzaW9uPXt9KTtsZXQgYz11LmV4dHJhLnNlc3Npb247Yy51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5fHwoYy51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5PVwiMVwiKSx1LmV4ZWN1dGlvblByb3ZpZGVycyYmdS5leGVjdXRpb25Qcm92aWRlcnMuc29tZShhPT4odHlwZW9mIGE9PVwic3RyaW5nXCI/YTphLm5hbWUpPT09XCJ3ZWJncHVcIikmJih1LmVuYWJsZU1lbVBhdHRlcm49ITEpfSxkbj0odSxjLGEpPT57Zm9yKGxldCBoIG9mIGMpe2xldCBmPXR5cGVvZiBoPT1cInN0cmluZ1wiP2g6aC5uYW1lO3N3aXRjaChmKXtjYXNlXCJ3ZWJublwiOmlmKGY9XCJXRUJOTlwiLHR5cGVvZiBoIT1cInN0cmluZ1wiKXtsZXQgZz1oO2lmKGc/LmRldmljZVR5cGUpe2xldCBpPXEoXCJkZXZpY2VUeXBlXCIsYSksRT1xKGcuZGV2aWNlVHlwZSxhKTtaKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeSh1LGksRSkhPT0wJiZWKGBDYW5cXCd0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiBcXCdkZXZpY2VUeXBlXFwnIC0gJHtnLmRldmljZVR5cGV9LmApfWlmKGc/Lm51bVRocmVhZHMpe2xldCBpPWcubnVtVGhyZWFkczsodHlwZW9mIGkhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGkpfHxpPDApJiYoaT0wKTtsZXQgRT1xKFwibnVtVGhyZWFkc1wiLGEpLFA9cShpLnRvU3RyaW5nKCksYSk7WigpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkodSxFLFApIT09MCYmVihgQ2FuXFwndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogXFwnbnVtVGhyZWFkc1xcJyAtICR7Zy5udW1UaHJlYWRzfS5gKX1pZihnPy5wb3dlclByZWZlcmVuY2Upe2xldCBpPXEoXCJwb3dlclByZWZlcmVuY2VcIixhKSxFPXEoZy5wb3dlclByZWZlcmVuY2UsYSk7WigpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkodSxpLEUpIT09MCYmVihgQ2FuXFwndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogXFwncG93ZXJQcmVmZXJlbmNlXFwnIC0gJHtnLnBvd2VyUHJlZmVyZW5jZX0uYCl9fWJyZWFrO2Nhc2VcIndlYmdwdVwiOmlmKGY9XCJKU1wiLHR5cGVvZiBoIT1cInN0cmluZ1wiKXtsZXQgZz1oO2lmKGc/LnByZWZlcnJlZExheW91dCl7aWYoZy5wcmVmZXJyZWRMYXlvdXQhPT1cIk5DSFdcIiYmZy5wcmVmZXJyZWRMYXlvdXQhPT1cIk5IV0NcIil0aHJvdyBuZXcgRXJyb3IoYHByZWZlcnJlZExheW91dCBtdXN0IGJlIGVpdGhlciBcXCdOQ0hXXFwnIG9yIFxcJ05IV0NcXCc6ICR7Zy5wcmVmZXJyZWRMYXlvdXR9YCk7bGV0IGk9cShcInByZWZlcnJlZExheW91dFwiLGEpLEU9cShnLnByZWZlcnJlZExheW91dCxhKTtaKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeSh1LGksRSkhPT0wJiZWKGBDYW5cXCd0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiBcXCdwcmVmZXJyZWRMYXlvdXRcXCcgLSAke2cucHJlZmVycmVkTGF5b3V0fS5gKX19YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtmfWApfWxldCB3PXEoZixhKTtaKCkuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyKHUsdykhPT0wJiZWKGBDYW5cXCd0IGFwcGVuZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7Zn0uYCl9fSxDcj11PT57bGV0IGM9WigpLGE9MCxoPVtdLGY9dXx8e307Y24oZik7dHJ5e2xldCB3PWZuKGYuZ3JhcGhPcHRpbWl6YXRpb25MZXZlbD8/XCJhbGxcIiksZz1sbihmLmV4ZWN1dGlvbk1vZGU/P1wic2VxdWVudGlhbFwiKSxpPXR5cGVvZiBmLmxvZ0lkPT1cInN0cmluZ1wiP3EoZi5sb2dJZCxoKTowLEU9Zi5sb2dTZXZlcml0eUxldmVsPz8yO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKEUpfHxFPDB8fEU+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke0V9YCk7bGV0IFA9Zi5sb2dWZXJib3NpdHlMZXZlbD8/MDtpZighTnVtYmVyLmlzSW50ZWdlcihQKXx8UDwwfHxQPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtQfWApO2xldCBVPXR5cGVvZiBmLm9wdGltaXplZE1vZGVsRmlsZVBhdGg9PVwic3RyaW5nXCI/cShmLm9wdGltaXplZE1vZGVsRmlsZVBhdGgsaCk6MDtpZihhPWMuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKHcsISFmLmVuYWJsZUNwdU1lbUFyZW5hLCEhZi5lbmFibGVNZW1QYXR0ZXJuLGcsISFmLmVuYWJsZVByb2ZpbGluZywwLGksRSxQLFUpLGE9PT0wJiZWKFwiQ2FuXFwndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zLlwiKSxmLmV4ZWN1dGlvblByb3ZpZGVycyYmZG4oYSxmLmV4ZWN1dGlvblByb3ZpZGVycyxoKSxmLmVuYWJsZUdyYXBoQ2FwdHVyZSE9PXZvaWQgMCl7aWYodHlwZW9mIGYuZW5hYmxlR3JhcGhDYXB0dXJlIT1cImJvb2xlYW5cIil0aHJvdyBuZXcgRXJyb3IoYGVuYWJsZUdyYXBoQ2FwdHVyZSBtdXN0IGJlIGEgYm9vbGVhbiB2YWx1ZTogJHtmLmVuYWJsZUdyYXBoQ2FwdHVyZX1gKTtsZXQgRD1xKFwiZW5hYmxlR3JhcGhDYXB0dXJlXCIsaCkseD1xKGYuZW5hYmxlR3JhcGhDYXB0dXJlLnRvU3RyaW5nKCksaCk7Yy5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGEsRCx4KSE9PTAmJlYoYENhblxcJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6IFxcJ2VuYWJsZUdyYXBoQ2FwdHVyZVxcJyAtICR7Zi5lbmFibGVHcmFwaENhcHR1cmV9LmApfWlmKGYuZnJlZURpbWVuc2lvbk92ZXJyaWRlcylmb3IobGV0W0QseF1vZiBPYmplY3QuZW50cmllcyhmLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpKXtpZih0eXBlb2YgRCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIG5hbWUgbXVzdCBiZSBhIHN0cmluZzogJHtEfWApO2lmKHR5cGVvZiB4IT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcih4KXx8eDwwKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgdmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyOiAke3h9YCk7bGV0IEs9cShELGgpO2MuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZShhLEsseCkhPT0wJiZWKGBDYW5cXCd0IHNldCBhIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlOiAke0R9IC0gJHt4fS5gKX1yZXR1cm4gZi5leHRyYSE9PXZvaWQgMCYmbnQoZi5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LChELHgpPT57bGV0IEs9cShELGgpLFI9cSh4LGgpO2MuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShhLEssUikhPT0wJiZWKGBDYW5cXCd0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke0R9IC0gJHt4fS5gKX0pLFthLGhdfWNhdGNoKHcpe3Rocm93IGEhPT0wJiZjLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMoYSksaC5mb3JFYWNoKGc9PmMuX2ZyZWUoZykpLHd9fTt2YXIgUnQ9dT0+e3N3aXRjaCh1KXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIDEwO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gMTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIDExO2Nhc2VcInN0cmluZ1wiOnJldHVybiA4O2Nhc2VcImludDY0XCI6cmV0dXJuIDc7Y2FzZVwidWludDY0XCI6cmV0dXJuIDEzO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dX1gKX19LERyPXU9Pntzd2l0Y2godSl7Y2FzZSAzOnJldHVyblwiaW50OFwiO2Nhc2UgMjpyZXR1cm5cInVpbnQ4XCI7Y2FzZSA5OnJldHVyblwiYm9vbFwiO2Nhc2UgNTpyZXR1cm5cImludDE2XCI7Y2FzZSA0OnJldHVyblwidWludDE2XCI7Y2FzZSA2OnJldHVyblwiaW50MzJcIjtjYXNlIDEyOnJldHVyblwidWludDMyXCI7Y2FzZSAxMDpyZXR1cm5cImZsb2F0MTZcIjtjYXNlIDE6cmV0dXJuXCJmbG9hdDMyXCI7Y2FzZSAxMTpyZXR1cm5cImZsb2F0NjRcIjtjYXNlIDg6cmV0dXJuXCJzdHJpbmdcIjtjYXNlIDc6cmV0dXJuXCJpbnQ2NFwiO2Nhc2UgMTM6cmV0dXJuXCJ1aW50NjRcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3V9YCl9fSxJdD11PT5bdm9pZCAwLDQsMSwxLDIsMiw0LDgsdm9pZCAwLDEsMiw4LDQsOCx2b2lkIDAsdm9pZCAwLHZvaWQgMF1bdV0sRnI9dT0+e3N3aXRjaCh1KXtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIHR5cGVvZiBGbG9hdDE2QXJyYXk8XCJ1XCImJkZsb2F0MTZBcnJheS5mcm9tP0Zsb2F0MTZBcnJheTpVaW50MTZBcnJheTtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJ1aW50OFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImludDhcIjpyZXR1cm4gSW50OEFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcImludDMyXCI6cmV0dXJuIEludDMyQXJyYXk7Y2FzZVwiYm9vbFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gRmxvYXQ2NEFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJpbnQ2NFwiOnJldHVybiBCaWdJbnQ2NEFycmF5O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBCaWdVaW50NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZTogJHt1fWApfX0seHI9dT0+e3N3aXRjaCh1KXtjYXNlXCJ2ZXJib3NlXCI6cmV0dXJuIDA7Y2FzZVwiaW5mb1wiOnJldHVybiAxO2Nhc2VcIndhcm5pbmdcIjpyZXR1cm4gMjtjYXNlXCJlcnJvclwiOnJldHVybiAzO2Nhc2VcImZhdGFsXCI6cmV0dXJuIDQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7dX1gKX19LFByPXU9PnU9PT1cImZsb2F0MzJcInx8dT09PVwiZmxvYXQxNlwifHx1PT09XCJpbnQzMlwifHx1PT09XCJpbnQ2NFwifHx1PT09XCJ1aW50MzJcInx8dT09PVwidWludDhcInx8dT09PVwiYm9vbFwiLFVyPXU9Pntzd2l0Y2godSl7Y2FzZVwibm9uZVwiOnJldHVybiAwO2Nhc2VcImNwdVwiOnJldHVybiAxO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gMjtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIDM7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiA0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIGxvY2F0aW9uOiAke3V9YCl9fTt2YXIgUnI9YXN5bmMgdT0+e2lmKHR5cGVvZiB1PT1cInN0cmluZ1wiKWlmKHR5cGVvZiBwcm9jZXNzPFwidVwiJiZwcm9jZXNzLnZlcnNpb25zJiZwcm9jZXNzLnZlcnNpb25zLm5vZGUpdHJ5e3JldHVybiBuZXcgVWludDhBcnJheShhd2FpdCh2b2lkIDApKHUpKX1jYXRjaChjKXtpZihjLmNvZGU9PT1cIkVSUl9GU19GSUxFX1RPT19MQVJHRVwiKXtsZXQgYT0odm9pZCAwKSh1KSxoPVtdO2ZvciBhd2FpdChsZXQgZiBvZiBhKWgucHVzaChmKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmNvbmNhdChoKSl9dGhyb3cgY31lbHNle2xldCBjPWF3YWl0IGZldGNoKHUpO2lmKCFjLm9rKXRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke3V9YCk7bGV0IGE9Yy5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpLGg9YT9wYXJzZUludChhLDEwKTowO2lmKGg8MTA3Mzc0MTgyNClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgYy5hcnJheUJ1ZmZlcigpKTt7aWYoIWMuYm9keSl0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHt1fSwgbm8gcmVzcG9uc2UgYm9keS5gKTtsZXQgZj1jLmJvZHkuZ2V0UmVhZGVyKCksdzt0cnl7dz1uZXcgQXJyYXlCdWZmZXIoaCl9Y2F0Y2goaSl7aWYoaSBpbnN0YW5jZW9mIFJhbmdlRXJyb3Ipe2xldCBFPU1hdGguY2VpbChoLzY1NTM2KTt3PW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6RSxtYXhpbXVtOkV9KS5idWZmZXJ9ZWxzZSB0aHJvdyBpfWxldCBnPTA7Zm9yKDs7KXtsZXR7ZG9uZTppLHZhbHVlOkV9PWF3YWl0IGYucmVhZCgpO2lmKGkpYnJlYWs7bGV0IFA9RS5ieXRlTGVuZ3RoO25ldyBVaW50OEFycmF5KHcsZyxQKS5zZXQoRSksZys9UH1yZXR1cm4gbmV3IFVpbnQ4QXJyYXkodywwLGgpfX1lbHNlIHJldHVybiB1IGluc3RhbmNlb2YgQmxvYj9uZXcgVWludDhBcnJheShhd2FpdCB1LmFycmF5QnVmZmVyKCkpOnUgaW5zdGFuY2VvZiBVaW50OEFycmF5P3U6bmV3IFVpbnQ4QXJyYXkodSl9O3ZhciBwbj0odSxjKT0+e1ooKS5fT3J0SW5pdCh1LGMpIT09MCYmVihcIkNhblxcJ3QgaW5pdGlhbGl6ZSBvbm54cnVudGltZS5cIil9LExyPWFzeW5jIHU9Pntwbih1Lndhc20ubnVtVGhyZWFkcyx4cih1LmxvZ0xldmVsKSl9LEJyPWFzeW5jKHUsYyk9Pnt9LHplPW5ldyBNYXAsbW49dT0+e2xldCBjPVooKSxhPWMuc3RhY2tTYXZlKCk7dHJ5e2xldCBoPWMuc3RhY2tBbGxvYyg4KTtyZXR1cm4gYy5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudCh1LGgsaCs0KSE9PTAmJlYoXCJDYW5cXCd0IGdldCBzZXNzaW9uIGlucHV0L291dHB1dCBjb3VudC5cIiksW2MuSEVBUDMyW2gvNF0sYy5IRUFQMzJbaC80KzFdXX1maW5hbGx5e2Muc3RhY2tSZXN0b3JlKGEpfX0sTHQ9dT0+e2xldCBjPVooKSxhPWMuX21hbGxvYyh1LmJ5dGVMZW5ndGgpO2lmKGE9PT0wKXRocm93IG5ldyBFcnJvcihgQ2FuXFwndCBjcmVhdGUgYSBzZXNzaW9uLiBmYWlsZWQgdG8gYWxsb2NhdGUgYSBidWZmZXIgb2Ygc2l6ZSAke3UuYnl0ZUxlbmd0aH0uYCk7cmV0dXJuIGMuSEVBUFU4LnNldCh1LGEpLFthLHUuYnl0ZUxlbmd0aF19LGtyPWFzeW5jKHUsYyk9PntsZXQgYSxoLGY9WigpO0FycmF5LmlzQXJyYXkodSk/W2EsaF09dTp1LmJ1ZmZlcj09PWYuSEVBUFU4LmJ1ZmZlcj9bYSxoXT1bdS5ieXRlT2Zmc2V0LHUuYnl0ZUxlbmd0aF06W2EsaF09THQodSk7bGV0IHc9MCxnPTAsaT0wLEU9W10sUD1bXSxVPVtdO3RyeXtpZihbZyxFXT1DcihjKSxjPy5leHRlcm5hbERhdGEmJmYubW91bnRFeHRlcm5hbERhdGEpe2xldCBXPVtdO2ZvcihsZXQgSCBvZiBjLmV4dGVybmFsRGF0YSl7bGV0IHNlPXR5cGVvZiBIPT1cInN0cmluZ1wiP0g6SC5wYXRoO1cucHVzaChScih0eXBlb2YgSD09XCJzdHJpbmdcIj9IOkguZGF0YSkudGhlbihlZT0+e2YubW91bnRFeHRlcm5hbERhdGEoc2UsZWUpfSkpfWF3YWl0IFByb21pc2UuYWxsKFcpfXc9YXdhaXQgZi5fT3J0Q3JlYXRlU2Vzc2lvbihhLGgsZyksdz09PTAmJlYoXCJDYW5cXCd0IGNyZWF0ZSBhIHNlc3Npb24uXCIpO2xldFtELHhdPW1uKHcpLEs9ISFjPy5lbmFibGVHcmFwaENhcHR1cmUsUj1bXSxJPVtdLHY9W107Zm9yKGxldCBXPTA7VzxEO1crKyl7bGV0IEg9Zi5fT3J0R2V0SW5wdXROYW1lKHcsVyk7SD09PTAmJlYoXCJDYW5cXCd0IGdldCBhbiBpbnB1dCBuYW1lLlwiKSxQLnB1c2goSCksUi5wdXNoKGYuVVRGOFRvU3RyaW5nKEgpKX1mb3IobGV0IFc9MDtXPHg7VysrKXtsZXQgSD1mLl9PcnRHZXRPdXRwdXROYW1lKHcsVyk7SD09PTAmJlYoXCJDYW5cXCd0IGdldCBhbiBvdXRwdXQgbmFtZS5cIiksVS5wdXNoKEgpO2xldCBzZT1mLlVURjhUb1N0cmluZyhIKTtJLnB1c2goc2UpfWxldCBrPW51bGw7cmV0dXJuIHplLnNldCh3LFt3LFAsVSxrLEssITFdKSxbdyxSLEldfWNhdGNoKEQpe3Rocm93IFAuZm9yRWFjaCh4PT5mLl9PcnRGcmVlKHgpKSxVLmZvckVhY2goeD0+Zi5fT3J0RnJlZSh4KSksaSE9PTAmJmYuX09ydFJlbGVhc2VCaW5kaW5nKGkpLHchPT0wJiZmLl9PcnRSZWxlYXNlU2Vzc2lvbih3KSxEfWZpbmFsbHl7Zi5fZnJlZShhKSxnIT09MCYmZi5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKGcpLEUuZm9yRWFjaChEPT5mLl9mcmVlKEQpKSxmLnVubW91bnRFeHRlcm5hbERhdGE/LigpfX0sV3I9dT0+e2xldCBjPVooKSxhPXplLmdldCh1KTtpZighYSl0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWxlYXNlIHNlc3Npb24uIGludmFsaWQgc2Vzc2lvbiBpZDogJHt1fWApO2xldFtoLGYsdyxnLGldPWE7ZyYmKGkmJmMuX09ydENsZWFyQm91bmRPdXRwdXRzKGcuaGFuZGxlKSxjLl9PcnRSZWxlYXNlQmluZGluZyhnLmhhbmRsZSkpLGMuanNlcE9uUmVsZWFzZVNlc3Npb24/Lih1KSxmLmZvckVhY2goRT0+Yy5fT3J0RnJlZShFKSksdy5mb3JFYWNoKEU9PmMuX09ydEZyZWUoRSkpLGMuX09ydFJlbGVhc2VTZXNzaW9uKGgpLHplLmRlbGV0ZSh1KX0sSXI9KHUsYyxhLGgsZix3PSExKT0+e2lmKCF1KXtjLnB1c2goMCk7cmV0dXJufWxldCBnPVooKSxpPXVbMF0sRT11WzFdLFA9dVszXSxVLEQ7aWYoaT09PVwic3RyaW5nXCImJlA9PT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtpZih3JiZQIT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKGBFeHRlcm5hbCBidWZmZXIgbXVzdCBiZSBwcm92aWRlZCBmb3IgaW5wdXQvb3V0cHV0IGluZGV4ICR7Zn0gd2hlbiBlbmFibGVHcmFwaENhcHR1cmUgaXMgdHJ1ZS5gKTtpZihQPT09XCJncHUtYnVmZmVyXCIpe2xldCBSPXVbMl0uZ3B1QnVmZmVyLEk9SXQoUnQoaSkpO0Q9RS5yZWR1Y2UoKGssVyk9PmsqVywxKSpJO2xldCB2PWcuanNlcFJlZ2lzdGVyQnVmZmVyO2lmKCF2KXRocm93IG5ldyBFcnJvcihcXCdUZW5zb3IgbG9jYXRpb24gXCJncHUtYnVmZmVyXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYkdQVS5cXCcpO1U9dihoLGYsUixEKX1lbHNle2xldCBSPXVbMl07aWYoQXJyYXkuaXNBcnJheShSKSl7RD00KlIubGVuZ3RoLFU9Zy5fbWFsbG9jKEQpLGEucHVzaChVKTtsZXQgST1VLzQ7Zm9yKGxldCB2PTA7djxSLmxlbmd0aDt2Kyspe2lmKHR5cGVvZiBSW3ZdIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7dn0gaXMgbm90IGEgc3RyaW5nYCk7Zy5IRUFQVTMyW0krK109cShSW3ZdLGEpfX1lbHNlIEQ9Ui5ieXRlTGVuZ3RoLFU9Zy5fbWFsbG9jKEQpLGEucHVzaChVKSxnLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoUi5idWZmZXIsUi5ieXRlT2Zmc2V0LEQpLFUpfWxldCB4PWcuc3RhY2tTYXZlKCksSz1nLnN0YWNrQWxsb2MoNCpFLmxlbmd0aCk7dHJ5e2xldCBSPUsvNDtFLmZvckVhY2godj0+Zy5IRUFQMzJbUisrXT12KTtsZXQgST1nLl9PcnRDcmVhdGVUZW5zb3IoUnQoaSksVSxELEssRS5sZW5ndGgsVXIoUCkpO0k9PT0wJiZWKGBDYW5cXCd0IGNyZWF0ZSB0ZW5zb3IgZm9yIGlucHV0L291dHB1dC4gc2Vzc2lvbj0ke2h9LCBpbmRleD0ke2Z9LmApLGMucHVzaChJKX1maW5hbGx5e2cuc3RhY2tSZXN0b3JlKHgpfX0sTnI9YXN5bmModSxjLGEsaCxmLHcpPT57bGV0IGc9WigpLGk9emUuZ2V0KHUpO2lmKCFpKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJ1biBpbmZlcmVuY2UuIGludmFsaWQgc2Vzc2lvbiBpZDogJHt1fWApO2xldCBFPWlbMF0sUD1pWzFdLFU9aVsyXSxEPWlbM10seD1pWzRdLEs9aVs1XSxSPWMubGVuZ3RoLEk9aC5sZW5ndGgsdj0wLGs9W10sVz1bXSxIPVtdLHNlPVtdLGVlPWcuc3RhY2tTYXZlKCksUz1nLnN0YWNrQWxsb2MoUio0KSxqPWcuc3RhY2tBbGxvYyhSKjQpLENlPWcuc3RhY2tBbGxvYyhJKjQpLFVlPWcuc3RhY2tBbGxvYyhJKjQpO3RyeXtbdixrXT1Ncih3KTtmb3IobGV0IEY9MDtGPFI7RisrKUlyKGFbRl0sVyxzZSx1LGNbRl0seCk7Zm9yKGxldCBGPTA7RjxJO0YrKylJcihmW0ZdLEgsc2UsdSxSK2hbRl0seCk7bGV0IGNlPVMvNCxuZT1qLzQsUT1DZS80LE9lPVVlLzQ7Zm9yKGxldCBGPTA7RjxSO0YrKylnLkhFQVBVMzJbY2UrK109V1tGXSxnLkhFQVBVMzJbbmUrK109UFtjW0ZdXTtmb3IobGV0IEY9MDtGPEk7RisrKWcuSEVBUFUzMltRKytdPUhbRl0sZy5IRUFQVTMyW09lKytdPVVbaFtGXV07Zy5qc2VwT25SdW5TdGFydD8uKEUpO2xldCBoZTtoZT1hd2FpdCBnLl9PcnRSdW4oRSxqLFMsUixVZSxJLENlLHYpLGhlIT09MCYmVihcImZhaWxlZCB0byBjYWxsIE9ydFJ1bigpLlwiKTtsZXQgYWU9W107Zm9yKGxldCBGPTA7RjxJO0YrKyl7bGV0IHllPWcuSEVBUFUzMltDZS80K0ZdO2lmKHllPT09SFtGXSl7YWUucHVzaChmW0ZdKTtjb250aW51ZX1sZXQgdmU9Zy5zdGFja1NhdmUoKSxmZT1nLnN0YWNrQWxsb2MoNCo0KSxfZT0hMSxZLHBlPTA7dHJ5e2cuX09ydEdldFRlbnNvckRhdGEoeWUsZmUsZmUrNCxmZSs4LGZlKzEyKSE9PTAmJlYoYENhblxcJ3QgYWNjZXNzIG91dHB1dCB0ZW5zb3IgZGF0YSBvbiBpbmRleCAke0Z9LmApO2xldCBFZT1mZS80LGJlPWcuSEVBUFUzMltFZSsrXTtwZT1nLkhFQVBVMzJbRWUrK107bGV0IHdlPWcuSEVBUFUzMltFZSsrXSxMZT1nLkhFQVBVMzJbRWUrK10sbWU9W107Zm9yKGxldCB0ZT0wO3RlPExlO3RlKyspbWUucHVzaChnLkhFQVBVMzJbd2UvNCt0ZV0pO2cuX09ydEZyZWUod2UpO2xldCBTZT1tZS5yZWR1Y2UoKHRlLHopPT50ZSp6LDEpO1k9RHIoYmUpO2xldCBEZT1EPy5vdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbaFtGXV07aWYoWT09PVwic3RyaW5nXCIpe2lmKERlPT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS5cIik7bGV0IHRlPVtdLHo9cGUvNDtmb3IobGV0IGxlPTA7bGU8U2U7bGUrKyl7bGV0IEZlPWcuSEVBUFUzMlt6KytdLEFlPWxlPT09U2UtMT92b2lkIDA6Zy5IRUFQVTMyW3pdLUZlO3RlLnB1c2goZy5VVEY4VG9TdHJpbmcoRmUsQWUpKX1hZS5wdXNoKFtZLG1lLHRlLFwiY3B1XCJdKX1lbHNlIGlmKERlPT09XCJncHUtYnVmZmVyXCImJlNlPjApe2xldCB0ZT1nLmpzZXBHZXRCdWZmZXI7aWYoIXRlKXRocm93IG5ldyBFcnJvcihcXCdwcmVmZXJyZWRMb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLlxcJyk7bGV0IHo9dGUocGUpLGxlPUl0KGJlKTtpZihsZT09PXZvaWQgMHx8IVByKFkpKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke1l9YCk7X2U9ITAsYWUucHVzaChbWSxtZSx7Z3B1QnVmZmVyOnosZG93bmxvYWQ6Zy5qc2VwQ3JlYXRlRG93bmxvYWRlcih6LFNlKmxlLFkpLGRpc3Bvc2U6KCk9PntnLl9PcnRSZWxlYXNlVGVuc29yKHllKX19LFwiZ3B1LWJ1ZmZlclwiXSl9ZWxzZXtsZXQgdGU9RnIoWSksej1uZXcgdGUoU2UpO25ldyBVaW50OEFycmF5KHouYnVmZmVyLHouYnl0ZU9mZnNldCx6LmJ5dGVMZW5ndGgpLnNldChnLkhFQVBVOC5zdWJhcnJheShwZSxwZSt6LmJ5dGVMZW5ndGgpKSxhZS5wdXNoKFtZLG1lLHosXCJjcHVcIl0pfX1maW5hbGx5e2cuc3RhY2tSZXN0b3JlKHZlKSxZPT09XCJzdHJpbmdcIiYmcGUmJmcuX2ZyZWUocGUpLF9lfHxnLl9PcnRSZWxlYXNlVGVuc29yKHllKX19cmV0dXJuIEQmJiF4JiYoZy5fT3J0Q2xlYXJCb3VuZE91dHB1dHMoRC5oYW5kbGUpLHplLnNldCh1LFtFLFAsVSxELHgsITFdKSksYWV9ZmluYWxseXtnLnN0YWNrUmVzdG9yZShlZSksVy5mb3JFYWNoKGNlPT5nLl9PcnRSZWxlYXNlVGVuc29yKGNlKSksSC5mb3JFYWNoKGNlPT5nLl9PcnRSZWxlYXNlVGVuc29yKGNlKSksc2UuZm9yRWFjaChjZT0+Zy5fZnJlZShjZSkpLHYhPT0wJiZnLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyh2KSxrLmZvckVhY2goY2U9PmcuX2ZyZWUoY2UpKX19LEhyPXU9PntsZXQgYz1aKCksYT16ZS5nZXQodSk7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2xldCBoPWFbMF0sZj1jLl9PcnRFbmRQcm9maWxpbmcoaCk7Zj09PTAmJlYoXCJDYW5cXCd0IGdldCBhbiBwcm9maWxlIGZpbGUgbmFtZS5cIiksYy5fT3J0RnJlZShmKX0sR3I9dT0+e2xldCBjPVtdO2ZvcihsZXQgYSBvZiB1KXtsZXQgaD1hWzJdOyFBcnJheS5pc0FycmF5KGgpJiZcImJ1ZmZlclwiaW4gaCYmYy5wdXNoKGguYnVmZmVyKX1yZXR1cm4gY307c2VsZi5vbm1lc3NhZ2U9dT0+e2xldHt0eXBlOmMsaW46YX09dS5kYXRhO3RyeXtzd2l0Y2goYyl7Y2FzZVwiaW5pdC13YXNtXCI6VHIoYS53YXNtKS50aGVuKCgpPT57THIoYSkudGhlbigoKT0+e3Bvc3RNZXNzYWdlKHt0eXBlOmN9KX0saD0+e3Bvc3RNZXNzYWdlKHt0eXBlOmMsZXJyOmh9KX0pfSxoPT57cG9zdE1lc3NhZ2Uoe3R5cGU6YyxlcnI6aH0pfSk7YnJlYWs7Y2FzZVwiaW5pdC1lcFwiOntsZXR7ZXBOYW1lOmgsZW52OmZ9PWE7QnIoZixoKS50aGVuKCgpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6Y30pfSx3PT57cG9zdE1lc3NhZ2Uoe3R5cGU6YyxlcnI6d30pfSk7YnJlYWt9Y2FzZVwiY29weS1mcm9tXCI6e2xldHtidWZmZXI6aH09YSxmPUx0KGgpO3Bvc3RNZXNzYWdlKHt0eXBlOmMsb3V0OmZ9KTticmVha31jYXNlXCJjcmVhdGVcIjp7bGV0e21vZGVsOmgsb3B0aW9uczpmfT1hO2tyKGgsZikudGhlbih3PT57cG9zdE1lc3NhZ2Uoe3R5cGU6YyxvdXQ6d30pfSx3PT57cG9zdE1lc3NhZ2Uoe3R5cGU6YyxlcnI6d30pfSk7YnJlYWt9Y2FzZVwicmVsZWFzZVwiOldyKGEpLHBvc3RNZXNzYWdlKHt0eXBlOmN9KTticmVhaztjYXNlXCJydW5cIjp7bGV0e3Nlc3Npb25JZDpoLGlucHV0SW5kaWNlczpmLGlucHV0czp3LG91dHB1dEluZGljZXM6ZyxvcHRpb25zOml9PWE7TnIoaCxmLHcsZyxuZXcgQXJyYXkoZy5sZW5ndGgpLmZpbGwobnVsbCksaSkudGhlbihFPT57RS5zb21lKFA9PlBbM10hPT1cImNwdVwiKT9wb3N0TWVzc2FnZSh7dHlwZTpjLGVycjpcIlByb3h5IGRvZXMgbm90IHN1cHBvcnQgbm9uLWNwdSB0ZW5zb3IgbG9jYXRpb24uXCJ9KTpwb3N0TWVzc2FnZSh7dHlwZTpjLG91dDpFfSxHcihbLi4udywuLi5FXSkpfSxFPT57cG9zdE1lc3NhZ2Uoe3R5cGU6YyxlcnI6RX0pfSk7YnJlYWt9Y2FzZVwiZW5kLXByb2ZpbGluZ1wiOkhyKGEpLHBvc3RNZXNzYWdlKHt0eXBlOmN9KTticmVhaztkZWZhdWx0On19Y2F0Y2goaCl7cG9zdE1lc3NhZ2Uoe3R5cGU6YyxlcnI6aH0pfX07fSkoKTtcXG4nfSk7dmFyIHdyLGh0LHhuLEZvLENvLGRhLGhhLEhyLHFyLHdnLExvLGFkLHNkLHVkLGxkLGZkLGNkLHBkLG1hPUUoKCk9PntcInVzZSBzdHJpY3RcIjtUdCgpO29kKCk7VnIoKTt3cj0oKT0+ISFaLndhc20ucHJveHkmJnR5cGVvZiBkb2N1bWVudDxcInVcIix4bj0hMSxGbz0hMSxDbz0hMSxoYT1uZXcgTWFwLEhyPShhLHQpPT57bGV0IG89aGEuZ2V0KGEpO28/by5wdXNoKHQpOmhhLnNldChhLFt0XSl9LHFyPSgpPT57aWYoeG58fCFGb3x8Q298fCFodCl0aHJvdyBuZXcgRXJyb3IoXCJ3b3JrZXIgbm90IHJlYWR5XCIpfSx3Zz1hPT57c3dpdGNoKGEuZGF0YS50eXBlKXtjYXNlXCJpbml0LXdhc21cIjp4bj0hMSxhLmRhdGEuZXJyPyhDbz0hMCxkYVsxXShhLmRhdGEuZXJyKSk6KEZvPSEwLGRhWzBdKCkpO2JyZWFrO2Nhc2VcImluaXQtZXBcIjpjYXNlXCJjb3B5LWZyb21cIjpjYXNlXCJjcmVhdGVcIjpjYXNlXCJyZWxlYXNlXCI6Y2FzZVwicnVuXCI6Y2FzZVwiZW5kLXByb2ZpbGluZ1wiOntsZXQgdD1oYS5nZXQoYS5kYXRhLnR5cGUpO2EuZGF0YS5lcnI/dC5zaGlmdCgpWzFdKGEuZGF0YS5lcnIpOnQuc2hpZnQoKVswXShhLmRhdGEub3V0KTticmVha31kZWZhdWx0On19LExvPXR5cGVvZiBkb2N1bWVudDxcInVcIj9kb2N1bWVudD8uY3VycmVudFNjcmlwdD8uc3JjOnZvaWQgMCxhZD1hc3luYygpPT57aWYoIUZvKXtpZih4bil0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdFdhc20oKScgZGV0ZWN0ZWQuXCIpO2lmKENvKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRXYXNtKCknIGZhaWxlZC5cIik7aWYoeG49ITAsd3IoKSlyZXR1cm4gWi53YXNtLndhc21QYXRocz09PXZvaWQgMCYmTG8mJkxvLmluZGV4T2YoXCJibG9iOlwiKSE9PTAmJihaLndhc20ud2FzbVBhdGhzPUxvLnN1YnN0cigwLCtMby5sYXN0SW5kZXhPZihcIi9cIikrMSkpLG5ldyBQcm9taXNlKChhLHQpPT57aHQ/LnRlcm1pbmF0ZSgpO2xldCBvPVVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2lkKCldLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSk7aHQ9bmV3IFdvcmtlcihvLHtuYW1lOlwib3J0LXdhc20tcHJveHktd29ya2VyXCJ9KSxodC5vbmVycm9yPXI9PnQociksaHQub25tZXNzYWdlPXdnLFVSTC5yZXZva2VPYmplY3RVUkwobyksZGE9W2EsdF07bGV0IGU9e3R5cGU6XCJpbml0LXdhc21cIixpbjpafTtodC5wb3N0TWVzc2FnZShlKX0pO3RyeXthd2FpdCBVcChaLndhc20pLGF3YWl0IEpwKFopLEZvPSEwfWNhdGNoKGEpe3Rocm93IENvPSEwLGF9ZmluYWxseXt4bj0hMX19fSxzZD1hc3luYyBhPT57aWYod3IoKSlyZXR1cm4gcXIoKSxuZXcgUHJvbWlzZSgodCxvKT0+e0hyKFwiaW5pdC1lcFwiLFt0LG9dKTtsZXQgZT17dHlwZTpcImluaXQtZXBcIixpbjp7ZXBOYW1lOmEsZW52Olp9fTtodC5wb3N0TWVzc2FnZShlKX0pO2F3YWl0IFpwKFosYSl9LHVkPWFzeW5jIGE9PndyKCk/KHFyKCksbmV3IFByb21pc2UoKHQsbyk9PntIcihcImNvcHktZnJvbVwiLFt0LG9dKTtsZXQgZT17dHlwZTpcImNvcHktZnJvbVwiLGluOntidWZmZXI6YX19O2h0LnBvc3RNZXNzYWdlKGUsW2EuYnVmZmVyXSl9KSk6cGEoYSksbGQ9YXN5bmMoYSx0KT0+e2lmKHdyKCkpe2lmKHQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uKXRocm93IG5ldyBFcnJvcignc2Vzc2lvbiBvcHRpb24gXCJwcmVmZXJyZWRPdXRwdXRMb2NhdGlvblwiIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LicpO3JldHVybiBxcigpLG5ldyBQcm9taXNlKChvLGUpPT57SHIoXCJjcmVhdGVcIixbbyxlXSk7bGV0IHI9e3R5cGU6XCJjcmVhdGVcIixpbjp7bW9kZWw6YSxvcHRpb25zOnsuLi50fX19LG49W107YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkmJm4ucHVzaChhLmJ1ZmZlciksaHQucG9zdE1lc3NhZ2UocixuKX0pfWVsc2UgcmV0dXJuIFFwKGEsdCl9LGZkPWFzeW5jIGE9PntpZih3cigpKXJldHVybiBxcigpLG5ldyBQcm9taXNlKCh0LG8pPT57SHIoXCJyZWxlYXNlXCIsW3Qsb10pO2xldCBlPXt0eXBlOlwicmVsZWFzZVwiLGluOmF9O2h0LnBvc3RNZXNzYWdlKGUpfSk7ZWQoYSl9LGNkPWFzeW5jKGEsdCxvLGUscixuKT0+e2lmKHdyKCkpe2lmKG8uc29tZShzPT5zWzNdIT09XCJjcHVcIikpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29yIG9uIEdQVSBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS5cIik7aWYoci5zb21lKHM9PnMpKXRocm93IG5ldyBFcnJvcihcInByZS1hbGxvY2F0ZWQgb3V0cHV0IHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS5cIik7cmV0dXJuIHFyKCksbmV3IFByb21pc2UoKHMsaSk9PntIcihcInJ1blwiLFtzLGldKTtsZXQgdT1vLGw9e3R5cGU6XCJydW5cIixpbjp7c2Vzc2lvbklkOmEsaW5wdXRJbmRpY2VzOnQsaW5wdXRzOnUsb3V0cHV0SW5kaWNlczplLG9wdGlvbnM6bn19O2h0LnBvc3RNZXNzYWdlKGwsbmQodSkpfSl9ZWxzZSByZXR1cm4gdGQoYSx0LG8sZSxyLG4pfSxwZD1hc3luYyBhPT57aWYod3IoKSlyZXR1cm4gcXIoKSxuZXcgUHJvbWlzZSgodCxvKT0+e0hyKFwiZW5kLXByb2ZpbGluZ1wiLFt0LG9dKTtsZXQgZT17dHlwZTpcImVuZC1wcm9maWxpbmdcIixpbjphfTtodC5wb3N0TWVzc2FnZShlKX0pO3JkKGEpfX0pO3ZhciBkZCx2ZywkbyxoZD1FKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VHQoKTttYSgpO2ZhKCk7Y2EoKTtkZD0oYSx0KT0+e3N3aXRjaChhLmxvY2F0aW9uKXtjYXNlXCJjcHVcIjpyZXR1cm5bYS50eXBlLGEuZGltcyxhLmRhdGEsXCJjcHVcIl07Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVyblthLnR5cGUsYS5kaW1zLHtncHVCdWZmZXI6YS5ncHVCdWZmZXJ9LFwiZ3B1LWJ1ZmZlclwiXTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke2EubG9jYXRpb259IGZvciAke3QoKX1gKX19LHZnPWE9Pntzd2l0Y2goYVszXSl7Y2FzZVwiY3B1XCI6cmV0dXJuIG5ldyBSZShhWzBdLGFbMl0sYVsxXSk7Y2FzZVwiZ3B1LWJ1ZmZlclwiOntsZXQgdD1hWzBdO2lmKCFEbyh0KSl0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R9IGZvciBkZXNlcmlhbGl6aW5nIEdQVSB0ZW5zb3JgKTtsZXR7Z3B1QnVmZmVyOm8sZG93bmxvYWQ6ZSxkaXNwb3NlOnJ9PWFbMl07cmV0dXJuIFJlLmZyb21HcHVCdWZmZXIobyx7ZGF0YVR5cGU6dCxkaW1zOmFbMV0sZG93bmxvYWQ6ZSxkaXNwb3NlOnJ9KX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke2FbM119YCl9fSwkbz1jbGFzc3thc3luYyBmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeSh0KXtyZXR1cm4gdWQoYXdhaXQgVG4odCkpfWFzeW5jIGxvYWRNb2RlbCh0LG8pe3NyKCk7bGV0IGU7dHlwZW9mIHQ9PVwic3RyaW5nXCI/dHlwZW9mIHByb2Nlc3M8XCJ1XCImJnByb2Nlc3MudmVyc2lvbnMmJnByb2Nlc3MudmVyc2lvbnMubm9kZT9lPWF3YWl0IFRuKHQpOmU9YXdhaXQgdGhpcy5mZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeSh0KTplPXQsW3RoaXMuc2Vzc2lvbklkLHRoaXMuaW5wdXROYW1lcyx0aGlzLm91dHB1dE5hbWVzXT1hd2FpdCBsZChlLG8pLHVyKCl9YXN5bmMgZGlzcG9zZSgpe3JldHVybiBmZCh0aGlzLnNlc3Npb25JZCl9YXN5bmMgcnVuKHQsbyxlKXtzcigpO2xldCByPVtdLG49W107T2JqZWN0LmVudHJpZXModCkuZm9yRWFjaChkPT57bGV0IFQ9ZFswXSx2PWRbMV0sdz10aGlzLmlucHV0TmFtZXMuaW5kZXhPZihUKTtpZih3PT09LTEpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlucHV0ICcke1R9J2ApO3IucHVzaCh2KSxuLnB1c2godyl9KTtsZXQgcz1bXSxpPVtdO09iamVjdC5lbnRyaWVzKG8pLmZvckVhY2goZD0+e2xldCBUPWRbMF0sdj1kWzFdLHc9dGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKFQpO2lmKHc9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3V0cHV0ICcke1R9J2ApO3MucHVzaCh2KSxpLnB1c2godyl9KTtsZXQgdT1yLm1hcCgoZCxUKT0+ZGQoZCwoKT0+YGlucHV0IFwiJHt0aGlzLmlucHV0TmFtZXNbbltUXV19XCJgKSksbD1zLm1hcCgoZCxUKT0+ZD9kZChkLCgpPT5gb3V0cHV0IFwiJHt0aGlzLm91dHB1dE5hbWVzW2lbVF1dfVwiYCk6bnVsbCksZj1hd2FpdCBjZCh0aGlzLnNlc3Npb25JZCxuLHUsaSxsLGUpLHA9e307Zm9yKGxldCBkPTA7ZDxmLmxlbmd0aDtkKyspcFt0aGlzLm91dHB1dE5hbWVzW2lbZF1dXT1zW2RdPz92ZyhmW2RdKTtyZXR1cm4gdXIoKSxwfXN0YXJ0UHJvZmlsaW5nKCl7fWVuZFByb2ZpbGluZygpe3BkKHRoaXMuc2Vzc2lvbklkKX19fSk7dmFyIF9nLGtvLG1kPUUoKCk9PntcInVzZSBzdHJpY3RcIjtUdCgpO21hKCk7aGQoKTtfZz0oKT0+e2lmKCh0eXBlb2YgWi53YXNtLmluaXRUaW1lb3V0IT1cIm51bWJlclwifHxaLndhc20uaW5pdFRpbWVvdXQ8MCkmJihaLndhc20uaW5pdFRpbWVvdXQ9MCksdHlwZW9mIFoud2FzbS5zaW1kIT1cImJvb2xlYW5cIiYmKFoud2FzbS5zaW1kPSEwKSx0eXBlb2YgWi53YXNtLnByb3h5IT1cImJvb2xlYW5cIiYmKFoud2FzbS5wcm94eT0hMSksdHlwZW9mIFoud2FzbS50cmFjZSE9XCJib29sZWFuXCImJihaLndhc20udHJhY2U9ITEpLHR5cGVvZiBaLndhc20ubnVtVGhyZWFkcyE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoWi53YXNtLm51bVRocmVhZHMpfHxaLndhc20ubnVtVGhyZWFkczw9MCl7KHR5cGVvZiBzZWxmPFwidVwiJiYhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkfHx0eXBlb2YgcHJvY2VzczxcInVcIiYmcHJvY2Vzcy52ZXJzaW9ucyYmcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKSYmKFoud2FzbS5udW1UaHJlYWRzPTEpO2xldCBhPXR5cGVvZiBuYXZpZ2F0b3I+XCJ1XCI/KHZvaWQgMCkoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7Wi53YXNtLm51bVRocmVhZHM9TWF0aC5taW4oNCxNYXRoLmNlaWwoKGF8fDEpLzIpKX19LGtvPWNsYXNze2FzeW5jIGluaXQodCl7X2coKSxhd2FpdCBhZCgpLGF3YWl0IHNkKHQpfWFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKHQsbyl7bGV0IGU9bmV3ICRvO3JldHVybiBhd2FpdCBlLmxvYWRNb2RlbCh0LG8pLFByb21pc2UucmVzb2x2ZShlKX19fSk7dmFyIGJkPXt9O1ByKGJkLHt3YXNtQmFja2VuZDooKT0+T2d9KTt2YXIgT2csZ2Q9RSgoKT0+e1widXNlIHN0cmljdFwiO21kKCk7T2c9bmV3IGtvfSk7VHQoKTtUdCgpO1R0KCk7dmFyIHdzPVwiMS4xNy4zXCI7dmFyIFhPPVlvO3tsZXQgYT0oU3AoKSxvcihJcCkpLm9ubnhqc0JhY2tlbmQ7RHIoXCJ3ZWJnbFwiLGEsLTEwKX17bGV0IGE9KGdkKCksb3IoYmQpKS53YXNtQmFja2VuZDtEcihcImNwdVwiLGEsMTApLERyKFwid2FzbVwiLGEsMTApfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShaLnZlcnNpb25zLFwid2ViXCIse3ZhbHVlOndzLGVudW1lcmFibGU6ITB9KTtleHBvcnR7RGQgYXMgSW5mZXJlbmNlU2Vzc2lvbixjcyBhcyBUUkFDRSxzciBhcyBUUkFDRV9GVU5DX0JFR0lOLHVyIGFzIFRSQUNFX0ZVTkNfRU5ELFJlIGFzIFRlbnNvcixGZCBhcyBUcmFpbmluZ1Nlc3Npb24sWE8gYXMgZGVmYXVsdCxaIGFzIGVudixEciBhcyByZWdpc3RlckJhY2tlbmR9O1xuLyohIEJ1bmRsZWQgbGljZW5zZSBpbmZvcm1hdGlvbjpcblxubG9uZy9pbmRleC5qczpcbiAgKCoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCAyMDA5IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9yc1xuICAgKiBDb3B5cmlnaHQgMjAyMCBEYW5pZWwgV2lydHogLyBUaGUgbG9uZy5qcyBBdXRob3JzLlxuICAgKlxuICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgKlxuICAgKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAqXG4gICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICpcbiAgICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAgICopXG4qL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3J0Lm1pbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/onnxruntime-web/dist/esm/ort.min.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tailwind-merge/dist/bundle-mjs.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/tailwind-merge/dist/bundle-mjs.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createTailwindMerge: function() { return /* binding */ createTailwindMerge; },\n/* harmony export */   extendTailwindMerge: function() { return /* binding */ extendTailwindMerge; },\n/* harmony export */   fromTheme: function() { return /* binding */ fromTheme; },\n/* harmony export */   getDefaultConfig: function() { return /* binding */ getDefaultConfig; },\n/* harmony export */   mergeConfigs: function() { return /* binding */ mergeConfigs; },\n/* harmony export */   twJoin: function() { return /* binding */ twJoin; },\n/* harmony export */   twMerge: function() { return /* binding */ twMerge; },\n/* harmony export */   validators: function() { return /* binding */ validators; }\n/* harmony export */ });\nconst CLASS_PART_SEPARATOR = '-';\nfunction createClassUtils(config) {\n  const classMap = createClassMap(config);\n  const {\n    conflictingClassGroups,\n    conflictingClassGroupModifiers\n  } = config;\n  function getClassGroupId(className) {\n    const classParts = className.split(CLASS_PART_SEPARATOR);\n    // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.\n    if (classParts[0] === '' && classParts.length !== 1) {\n      classParts.shift();\n    }\n    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);\n  }\n  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {\n    const conflicts = conflictingClassGroups[classGroupId] || [];\n    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {\n      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];\n    }\n    return conflicts;\n  }\n  return {\n    getClassGroupId,\n    getConflictingClassGroupIds\n  };\n}\nfunction getGroupRecursive(classParts, classPartObject) {\n  if (classParts.length === 0) {\n    return classPartObject.classGroupId;\n  }\n  const currentClassPart = classParts[0];\n  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);\n  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : undefined;\n  if (classGroupFromNextClassPart) {\n    return classGroupFromNextClassPart;\n  }\n  if (classPartObject.validators.length === 0) {\n    return undefined;\n  }\n  const classRest = classParts.join(CLASS_PART_SEPARATOR);\n  return classPartObject.validators.find(({\n    validator\n  }) => validator(classRest))?.classGroupId;\n}\nconst arbitraryPropertyRegex = /^\\[(.+)\\]$/;\nfunction getGroupIdForArbitraryProperty(className) {\n  if (arbitraryPropertyRegex.test(className)) {\n    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];\n    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(':'));\n    if (property) {\n      // I use two dots here because one dot is used as prefix for class groups in plugins\n      return 'arbitrary..' + property;\n    }\n  }\n}\n/**\n * Exported for testing only\n */\nfunction createClassMap(config) {\n  const {\n    theme,\n    prefix\n  } = config;\n  const classMap = {\n    nextPart: new Map(),\n    validators: []\n  };\n  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);\n  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {\n    processClassesRecursively(classGroup, classMap, classGroupId, theme);\n  });\n  return classMap;\n}\nfunction processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {\n  classGroup.forEach(classDefinition => {\n    if (typeof classDefinition === 'string') {\n      const classPartObjectToEdit = classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition);\n      classPartObjectToEdit.classGroupId = classGroupId;\n      return;\n    }\n    if (typeof classDefinition === 'function') {\n      if (isThemeGetter(classDefinition)) {\n        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);\n        return;\n      }\n      classPartObject.validators.push({\n        validator: classDefinition,\n        classGroupId\n      });\n      return;\n    }\n    Object.entries(classDefinition).forEach(([key, classGroup]) => {\n      processClassesRecursively(classGroup, getPart(classPartObject, key), classGroupId, theme);\n    });\n  });\n}\nfunction getPart(classPartObject, path) {\n  let currentClassPartObject = classPartObject;\n  path.split(CLASS_PART_SEPARATOR).forEach(pathPart => {\n    if (!currentClassPartObject.nextPart.has(pathPart)) {\n      currentClassPartObject.nextPart.set(pathPart, {\n        nextPart: new Map(),\n        validators: []\n      });\n    }\n    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);\n  });\n  return currentClassPartObject;\n}\nfunction isThemeGetter(func) {\n  return func.isThemeGetter;\n}\nfunction getPrefixedClassGroupEntries(classGroupEntries, prefix) {\n  if (!prefix) {\n    return classGroupEntries;\n  }\n  return classGroupEntries.map(([classGroupId, classGroup]) => {\n    const prefixedClassGroup = classGroup.map(classDefinition => {\n      if (typeof classDefinition === 'string') {\n        return prefix + classDefinition;\n      }\n      if (typeof classDefinition === 'object') {\n        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));\n      }\n      return classDefinition;\n    });\n    return [classGroupId, prefixedClassGroup];\n  });\n}\n\n// LRU cache inspired from hashlru (https://github.com/dominictarr/hashlru/blob/v1.0.4/index.js) but object replaced with Map to improve performance\nfunction createLruCache(maxCacheSize) {\n  if (maxCacheSize < 1) {\n    return {\n      get: () => undefined,\n      set: () => {}\n    };\n  }\n  let cacheSize = 0;\n  let cache = new Map();\n  let previousCache = new Map();\n  function update(key, value) {\n    cache.set(key, value);\n    cacheSize++;\n    if (cacheSize > maxCacheSize) {\n      cacheSize = 0;\n      previousCache = cache;\n      cache = new Map();\n    }\n  }\n  return {\n    get(key) {\n      let value = cache.get(key);\n      if (value !== undefined) {\n        return value;\n      }\n      if ((value = previousCache.get(key)) !== undefined) {\n        update(key, value);\n        return value;\n      }\n    },\n    set(key, value) {\n      if (cache.has(key)) {\n        cache.set(key, value);\n      } else {\n        update(key, value);\n      }\n    }\n  };\n}\nconst IMPORTANT_MODIFIER = '!';\nfunction createSplitModifiers(config) {\n  const separator = config.separator;\n  const isSeparatorSingleCharacter = separator.length === 1;\n  const firstSeparatorCharacter = separator[0];\n  const separatorLength = separator.length;\n  // splitModifiers inspired by https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js\n  return function splitModifiers(className) {\n    const modifiers = [];\n    let bracketDepth = 0;\n    let modifierStart = 0;\n    let postfixModifierPosition;\n    for (let index = 0; index < className.length; index++) {\n      let currentCharacter = className[index];\n      if (bracketDepth === 0) {\n        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index, index + separatorLength) === separator)) {\n          modifiers.push(className.slice(modifierStart, index));\n          modifierStart = index + separatorLength;\n          continue;\n        }\n        if (currentCharacter === '/') {\n          postfixModifierPosition = index;\n          continue;\n        }\n      }\n      if (currentCharacter === '[') {\n        bracketDepth++;\n      } else if (currentCharacter === ']') {\n        bracketDepth--;\n      }\n    }\n    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);\n    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);\n    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;\n    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : undefined;\n    return {\n      modifiers,\n      hasImportantModifier,\n      baseClassName,\n      maybePostfixModifierPosition\n    };\n  };\n}\n/**\n * Sorts modifiers according to following schema:\n * - Predefined modifiers are sorted alphabetically\n * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it\n */\nfunction sortModifiers(modifiers) {\n  if (modifiers.length <= 1) {\n    return modifiers;\n  }\n  const sortedModifiers = [];\n  let unsortedModifiers = [];\n  modifiers.forEach(modifier => {\n    const isArbitraryVariant = modifier[0] === '[';\n    if (isArbitraryVariant) {\n      sortedModifiers.push(...unsortedModifiers.sort(), modifier);\n      unsortedModifiers = [];\n    } else {\n      unsortedModifiers.push(modifier);\n    }\n  });\n  sortedModifiers.push(...unsortedModifiers.sort());\n  return sortedModifiers;\n}\nfunction createConfigUtils(config) {\n  return {\n    cache: createLruCache(config.cacheSize),\n    splitModifiers: createSplitModifiers(config),\n    ...createClassUtils(config)\n  };\n}\nconst SPLIT_CLASSES_REGEX = /\\s+/;\nfunction mergeClassList(classList, configUtils) {\n  const {\n    splitModifiers,\n    getClassGroupId,\n    getConflictingClassGroupIds\n  } = configUtils;\n  /**\n   * Set of classGroupIds in following format:\n   * `{importantModifier}{variantModifiers}{classGroupId}`\n   * @example 'float'\n   * @example 'hover:focus:bg-color'\n   * @example 'md:!pr'\n   */\n  const classGroupsInConflict = new Set();\n  return classList.trim().split(SPLIT_CLASSES_REGEX).map(originalClassName => {\n    const {\n      modifiers,\n      hasImportantModifier,\n      baseClassName,\n      maybePostfixModifierPosition\n    } = splitModifiers(originalClassName);\n    let classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);\n    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);\n    if (!classGroupId) {\n      if (!maybePostfixModifierPosition) {\n        return {\n          isTailwindClass: false,\n          originalClassName\n        };\n      }\n      classGroupId = getClassGroupId(baseClassName);\n      if (!classGroupId) {\n        return {\n          isTailwindClass: false,\n          originalClassName\n        };\n      }\n      hasPostfixModifier = false;\n    }\n    const variantModifier = sortModifiers(modifiers).join(':');\n    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;\n    return {\n      isTailwindClass: true,\n      modifierId,\n      classGroupId,\n      originalClassName,\n      hasPostfixModifier\n    };\n  }).reverse()\n  // Last class in conflict wins, so we need to filter conflicting classes in reverse order.\n  .filter(parsed => {\n    if (!parsed.isTailwindClass) {\n      return true;\n    }\n    const {\n      modifierId,\n      classGroupId,\n      hasPostfixModifier\n    } = parsed;\n    const classId = modifierId + classGroupId;\n    if (classGroupsInConflict.has(classId)) {\n      return false;\n    }\n    classGroupsInConflict.add(classId);\n    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach(group => classGroupsInConflict.add(modifierId + group));\n    return true;\n  }).reverse().map(parsed => parsed.originalClassName).join(' ');\n}\n\n/**\n * The code in this file is copied from https://github.com/lukeed/clsx and modified to suit the needs of tailwind-merge better.\n *\n * Specifically:\n * - Runtime code from https://github.com/lukeed/clsx/blob/v1.2.1/src/index.js\n * - TypeScript types from https://github.com/lukeed/clsx/blob/v1.2.1/clsx.d.ts\n *\n * Original code has MIT license: Copyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)\n */\nfunction twJoin() {\n  let index = 0;\n  let argument;\n  let resolvedValue;\n  let string = '';\n  while (index < arguments.length) {\n    if (argument = arguments[index++]) {\n      if (resolvedValue = toValue(argument)) {\n        string && (string += ' ');\n        string += resolvedValue;\n      }\n    }\n  }\n  return string;\n}\nfunction toValue(mix) {\n  if (typeof mix === 'string') {\n    return mix;\n  }\n  let resolvedValue;\n  let string = '';\n  for (let k = 0; k < mix.length; k++) {\n    if (mix[k]) {\n      if (resolvedValue = toValue(mix[k])) {\n        string && (string += ' ');\n        string += resolvedValue;\n      }\n    }\n  }\n  return string;\n}\nfunction createTailwindMerge(createConfigFirst, ...createConfigRest) {\n  let configUtils;\n  let cacheGet;\n  let cacheSet;\n  let functionToCall = initTailwindMerge;\n  function initTailwindMerge(classList) {\n    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());\n    configUtils = createConfigUtils(config);\n    cacheGet = configUtils.cache.get;\n    cacheSet = configUtils.cache.set;\n    functionToCall = tailwindMerge;\n    return tailwindMerge(classList);\n  }\n  function tailwindMerge(classList) {\n    const cachedResult = cacheGet(classList);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    const result = mergeClassList(classList, configUtils);\n    cacheSet(classList, result);\n    return result;\n  }\n  return function callTailwindMerge() {\n    return functionToCall(twJoin.apply(null, arguments));\n  };\n}\nfunction fromTheme(key) {\n  const themeGetter = theme => theme[key] || [];\n  themeGetter.isThemeGetter = true;\n  return themeGetter;\n}\nconst arbitraryValueRegex = /^\\[(?:([a-z-]+):)?(.+)\\]$/i;\nconst fractionRegex = /^\\d+\\/\\d+$/;\nconst stringLengths = /*#__PURE__*/new Set(['px', 'full', 'screen']);\nconst tshirtUnitRegex = /^(\\d+(\\.\\d+)?)?(xs|sm|md|lg|xl)$/;\nconst lengthUnitRegex = /\\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\\b(calc|min|max|clamp)\\(.+\\)|^0$/;\nconst colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\\(.+\\)$/;\n// Shadow always begins with x and y offset separated by underscore optionally prepended by inset\nconst shadowRegex = /^(inset_)?-?((\\d+)?\\.?(\\d+)[a-z]+|0)_-?((\\d+)?\\.?(\\d+)[a-z]+|0)/;\nconst imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\\(.+\\)$/;\nfunction isLength(value) {\n  return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);\n}\nfunction isArbitraryLength(value) {\n  return getIsArbitraryValue(value, 'length', isLengthOnly);\n}\nfunction isNumber(value) {\n  return Boolean(value) && !Number.isNaN(Number(value));\n}\nfunction isArbitraryNumber(value) {\n  return getIsArbitraryValue(value, 'number', isNumber);\n}\nfunction isInteger(value) {\n  return Boolean(value) && Number.isInteger(Number(value));\n}\nfunction isPercent(value) {\n  return value.endsWith('%') && isNumber(value.slice(0, -1));\n}\nfunction isArbitraryValue(value) {\n  return arbitraryValueRegex.test(value);\n}\nfunction isTshirtSize(value) {\n  return tshirtUnitRegex.test(value);\n}\nconst sizeLabels = /*#__PURE__*/new Set(['length', 'size', 'percentage']);\nfunction isArbitrarySize(value) {\n  return getIsArbitraryValue(value, sizeLabels, isNever);\n}\nfunction isArbitraryPosition(value) {\n  return getIsArbitraryValue(value, 'position', isNever);\n}\nconst imageLabels = /*#__PURE__*/new Set(['image', 'url']);\nfunction isArbitraryImage(value) {\n  return getIsArbitraryValue(value, imageLabels, isImage);\n}\nfunction isArbitraryShadow(value) {\n  return getIsArbitraryValue(value, '', isShadow);\n}\nfunction isAny() {\n  return true;\n}\nfunction getIsArbitraryValue(value, label, testValue) {\n  const result = arbitraryValueRegex.exec(value);\n  if (result) {\n    if (result[1]) {\n      return typeof label === 'string' ? result[1] === label : label.has(result[1]);\n    }\n    return testValue(result[2]);\n  }\n  return false;\n}\nfunction isLengthOnly(value) {\n  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.\n  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.\n  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.\n  return lengthUnitRegex.test(value) && !colorFunctionRegex.test(value);\n}\nfunction isNever() {\n  return false;\n}\nfunction isShadow(value) {\n  return shadowRegex.test(value);\n}\nfunction isImage(value) {\n  return imageRegex.test(value);\n}\nconst validators = /*#__PURE__*/Object.defineProperty({\n  __proto__: null,\n  isAny,\n  isArbitraryImage,\n  isArbitraryLength,\n  isArbitraryNumber,\n  isArbitraryPosition,\n  isArbitraryShadow,\n  isArbitrarySize,\n  isArbitraryValue,\n  isInteger,\n  isLength,\n  isNumber,\n  isPercent,\n  isTshirtSize\n}, Symbol.toStringTag, {\n  value: 'Module'\n});\nfunction getDefaultConfig() {\n  const colors = fromTheme('colors');\n  const spacing = fromTheme('spacing');\n  const blur = fromTheme('blur');\n  const brightness = fromTheme('brightness');\n  const borderColor = fromTheme('borderColor');\n  const borderRadius = fromTheme('borderRadius');\n  const borderSpacing = fromTheme('borderSpacing');\n  const borderWidth = fromTheme('borderWidth');\n  const contrast = fromTheme('contrast');\n  const grayscale = fromTheme('grayscale');\n  const hueRotate = fromTheme('hueRotate');\n  const invert = fromTheme('invert');\n  const gap = fromTheme('gap');\n  const gradientColorStops = fromTheme('gradientColorStops');\n  const gradientColorStopPositions = fromTheme('gradientColorStopPositions');\n  const inset = fromTheme('inset');\n  const margin = fromTheme('margin');\n  const opacity = fromTheme('opacity');\n  const padding = fromTheme('padding');\n  const saturate = fromTheme('saturate');\n  const scale = fromTheme('scale');\n  const sepia = fromTheme('sepia');\n  const skew = fromTheme('skew');\n  const space = fromTheme('space');\n  const translate = fromTheme('translate');\n  const getOverscroll = () => ['auto', 'contain', 'none'];\n  const getOverflow = () => ['auto', 'hidden', 'clip', 'visible', 'scroll'];\n  const getSpacingWithAutoAndArbitrary = () => ['auto', isArbitraryValue, spacing];\n  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];\n  const getLengthWithEmptyAndArbitrary = () => ['', isLength, isArbitraryLength];\n  const getNumberWithAutoAndArbitrary = () => ['auto', isNumber, isArbitraryValue];\n  const getPositions = () => ['bottom', 'center', 'left', 'left-bottom', 'left-top', 'right', 'right-bottom', 'right-top', 'top'];\n  const getLineStyles = () => ['solid', 'dashed', 'dotted', 'double', 'none'];\n  const getBlendModes = () => ['normal', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity', 'plus-lighter'];\n  const getAlign = () => ['start', 'end', 'center', 'between', 'around', 'evenly', 'stretch'];\n  const getZeroAndEmpty = () => ['', '0', isArbitraryValue];\n  const getBreaks = () => ['auto', 'avoid', 'all', 'avoid-page', 'page', 'left', 'right', 'column'];\n  const getNumber = () => [isNumber, isArbitraryNumber];\n  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];\n  return {\n    cacheSize: 500,\n    separator: ':',\n    theme: {\n      colors: [isAny],\n      spacing: [isLength, isArbitraryLength],\n      blur: ['none', '', isTshirtSize, isArbitraryValue],\n      brightness: getNumber(),\n      borderColor: [colors],\n      borderRadius: ['none', '', 'full', isTshirtSize, isArbitraryValue],\n      borderSpacing: getSpacingWithArbitrary(),\n      borderWidth: getLengthWithEmptyAndArbitrary(),\n      contrast: getNumber(),\n      grayscale: getZeroAndEmpty(),\n      hueRotate: getNumberAndArbitrary(),\n      invert: getZeroAndEmpty(),\n      gap: getSpacingWithArbitrary(),\n      gradientColorStops: [colors],\n      gradientColorStopPositions: [isPercent, isArbitraryLength],\n      inset: getSpacingWithAutoAndArbitrary(),\n      margin: getSpacingWithAutoAndArbitrary(),\n      opacity: getNumber(),\n      padding: getSpacingWithArbitrary(),\n      saturate: getNumber(),\n      scale: getNumber(),\n      sepia: getZeroAndEmpty(),\n      skew: getNumberAndArbitrary(),\n      space: getSpacingWithArbitrary(),\n      translate: getSpacingWithArbitrary()\n    },\n    classGroups: {\n      // Layout\n      /**\n       * Aspect Ratio\n       * @see https://tailwindcss.com/docs/aspect-ratio\n       */\n      aspect: [{\n        aspect: ['auto', 'square', 'video', isArbitraryValue]\n      }],\n      /**\n       * Container\n       * @see https://tailwindcss.com/docs/container\n       */\n      container: ['container'],\n      /**\n       * Columns\n       * @see https://tailwindcss.com/docs/columns\n       */\n      columns: [{\n        columns: [isTshirtSize]\n      }],\n      /**\n       * Break After\n       * @see https://tailwindcss.com/docs/break-after\n       */\n      'break-after': [{\n        'break-after': getBreaks()\n      }],\n      /**\n       * Break Before\n       * @see https://tailwindcss.com/docs/break-before\n       */\n      'break-before': [{\n        'break-before': getBreaks()\n      }],\n      /**\n       * Break Inside\n       * @see https://tailwindcss.com/docs/break-inside\n       */\n      'break-inside': [{\n        'break-inside': ['auto', 'avoid', 'avoid-page', 'avoid-column']\n      }],\n      /**\n       * Box Decoration Break\n       * @see https://tailwindcss.com/docs/box-decoration-break\n       */\n      'box-decoration': [{\n        'box-decoration': ['slice', 'clone']\n      }],\n      /**\n       * Box Sizing\n       * @see https://tailwindcss.com/docs/box-sizing\n       */\n      box: [{\n        box: ['border', 'content']\n      }],\n      /**\n       * Display\n       * @see https://tailwindcss.com/docs/display\n       */\n      display: ['block', 'inline-block', 'inline', 'flex', 'inline-flex', 'table', 'inline-table', 'table-caption', 'table-cell', 'table-column', 'table-column-group', 'table-footer-group', 'table-header-group', 'table-row-group', 'table-row', 'flow-root', 'grid', 'inline-grid', 'contents', 'list-item', 'hidden'],\n      /**\n       * Floats\n       * @see https://tailwindcss.com/docs/float\n       */\n      float: [{\n        float: ['right', 'left', 'none', 'start', 'end']\n      }],\n      /**\n       * Clear\n       * @see https://tailwindcss.com/docs/clear\n       */\n      clear: [{\n        clear: ['left', 'right', 'both', 'none', 'start', 'end']\n      }],\n      /**\n       * Isolation\n       * @see https://tailwindcss.com/docs/isolation\n       */\n      isolation: ['isolate', 'isolation-auto'],\n      /**\n       * Object Fit\n       * @see https://tailwindcss.com/docs/object-fit\n       */\n      'object-fit': [{\n        object: ['contain', 'cover', 'fill', 'none', 'scale-down']\n      }],\n      /**\n       * Object Position\n       * @see https://tailwindcss.com/docs/object-position\n       */\n      'object-position': [{\n        object: [...getPositions(), isArbitraryValue]\n      }],\n      /**\n       * Overflow\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      overflow: [{\n        overflow: getOverflow()\n      }],\n      /**\n       * Overflow X\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      'overflow-x': [{\n        'overflow-x': getOverflow()\n      }],\n      /**\n       * Overflow Y\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      'overflow-y': [{\n        'overflow-y': getOverflow()\n      }],\n      /**\n       * Overscroll Behavior\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      overscroll: [{\n        overscroll: getOverscroll()\n      }],\n      /**\n       * Overscroll Behavior X\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      'overscroll-x': [{\n        'overscroll-x': getOverscroll()\n      }],\n      /**\n       * Overscroll Behavior Y\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      'overscroll-y': [{\n        'overscroll-y': getOverscroll()\n      }],\n      /**\n       * Position\n       * @see https://tailwindcss.com/docs/position\n       */\n      position: ['static', 'fixed', 'absolute', 'relative', 'sticky'],\n      /**\n       * Top / Right / Bottom / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      inset: [{\n        inset: [inset]\n      }],\n      /**\n       * Right / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      'inset-x': [{\n        'inset-x': [inset]\n      }],\n      /**\n       * Top / Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      'inset-y': [{\n        'inset-y': [inset]\n      }],\n      /**\n       * Start\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      start: [{\n        start: [inset]\n      }],\n      /**\n       * End\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      end: [{\n        end: [inset]\n      }],\n      /**\n       * Top\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      top: [{\n        top: [inset]\n      }],\n      /**\n       * Right\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      right: [{\n        right: [inset]\n      }],\n      /**\n       * Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      bottom: [{\n        bottom: [inset]\n      }],\n      /**\n       * Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      left: [{\n        left: [inset]\n      }],\n      /**\n       * Visibility\n       * @see https://tailwindcss.com/docs/visibility\n       */\n      visibility: ['visible', 'invisible', 'collapse'],\n      /**\n       * Z-Index\n       * @see https://tailwindcss.com/docs/z-index\n       */\n      z: [{\n        z: ['auto', isInteger, isArbitraryValue]\n      }],\n      // Flexbox and Grid\n      /**\n       * Flex Basis\n       * @see https://tailwindcss.com/docs/flex-basis\n       */\n      basis: [{\n        basis: getSpacingWithAutoAndArbitrary()\n      }],\n      /**\n       * Flex Direction\n       * @see https://tailwindcss.com/docs/flex-direction\n       */\n      'flex-direction': [{\n        flex: ['row', 'row-reverse', 'col', 'col-reverse']\n      }],\n      /**\n       * Flex Wrap\n       * @see https://tailwindcss.com/docs/flex-wrap\n       */\n      'flex-wrap': [{\n        flex: ['wrap', 'wrap-reverse', 'nowrap']\n      }],\n      /**\n       * Flex\n       * @see https://tailwindcss.com/docs/flex\n       */\n      flex: [{\n        flex: ['1', 'auto', 'initial', 'none', isArbitraryValue]\n      }],\n      /**\n       * Flex Grow\n       * @see https://tailwindcss.com/docs/flex-grow\n       */\n      grow: [{\n        grow: getZeroAndEmpty()\n      }],\n      /**\n       * Flex Shrink\n       * @see https://tailwindcss.com/docs/flex-shrink\n       */\n      shrink: [{\n        shrink: getZeroAndEmpty()\n      }],\n      /**\n       * Order\n       * @see https://tailwindcss.com/docs/order\n       */\n      order: [{\n        order: ['first', 'last', 'none', isInteger, isArbitraryValue]\n      }],\n      /**\n       * Grid Template Columns\n       * @see https://tailwindcss.com/docs/grid-template-columns\n       */\n      'grid-cols': [{\n        'grid-cols': [isAny]\n      }],\n      /**\n       * Grid Column Start / End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      'col-start-end': [{\n        col: ['auto', {\n          span: ['full', isInteger, isArbitraryValue]\n        }, isArbitraryValue]\n      }],\n      /**\n       * Grid Column Start\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      'col-start': [{\n        'col-start': getNumberWithAutoAndArbitrary()\n      }],\n      /**\n       * Grid Column End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      'col-end': [{\n        'col-end': getNumberWithAutoAndArbitrary()\n      }],\n      /**\n       * Grid Template Rows\n       * @see https://tailwindcss.com/docs/grid-template-rows\n       */\n      'grid-rows': [{\n        'grid-rows': [isAny]\n      }],\n      /**\n       * Grid Row Start / End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      'row-start-end': [{\n        row: ['auto', {\n          span: [isInteger, isArbitraryValue]\n        }, isArbitraryValue]\n      }],\n      /**\n       * Grid Row Start\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      'row-start': [{\n        'row-start': getNumberWithAutoAndArbitrary()\n      }],\n      /**\n       * Grid Row End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      'row-end': [{\n        'row-end': getNumberWithAutoAndArbitrary()\n      }],\n      /**\n       * Grid Auto Flow\n       * @see https://tailwindcss.com/docs/grid-auto-flow\n       */\n      'grid-flow': [{\n        'grid-flow': ['row', 'col', 'dense', 'row-dense', 'col-dense']\n      }],\n      /**\n       * Grid Auto Columns\n       * @see https://tailwindcss.com/docs/grid-auto-columns\n       */\n      'auto-cols': [{\n        'auto-cols': ['auto', 'min', 'max', 'fr', isArbitraryValue]\n      }],\n      /**\n       * Grid Auto Rows\n       * @see https://tailwindcss.com/docs/grid-auto-rows\n       */\n      'auto-rows': [{\n        'auto-rows': ['auto', 'min', 'max', 'fr', isArbitraryValue]\n      }],\n      /**\n       * Gap\n       * @see https://tailwindcss.com/docs/gap\n       */\n      gap: [{\n        gap: [gap]\n      }],\n      /**\n       * Gap X\n       * @see https://tailwindcss.com/docs/gap\n       */\n      'gap-x': [{\n        'gap-x': [gap]\n      }],\n      /**\n       * Gap Y\n       * @see https://tailwindcss.com/docs/gap\n       */\n      'gap-y': [{\n        'gap-y': [gap]\n      }],\n      /**\n       * Justify Content\n       * @see https://tailwindcss.com/docs/justify-content\n       */\n      'justify-content': [{\n        justify: ['normal', ...getAlign()]\n      }],\n      /**\n       * Justify Items\n       * @see https://tailwindcss.com/docs/justify-items\n       */\n      'justify-items': [{\n        'justify-items': ['start', 'end', 'center', 'stretch']\n      }],\n      /**\n       * Justify Self\n       * @see https://tailwindcss.com/docs/justify-self\n       */\n      'justify-self': [{\n        'justify-self': ['auto', 'start', 'end', 'center', 'stretch']\n      }],\n      /**\n       * Align Content\n       * @see https://tailwindcss.com/docs/align-content\n       */\n      'align-content': [{\n        content: ['normal', ...getAlign(), 'baseline']\n      }],\n      /**\n       * Align Items\n       * @see https://tailwindcss.com/docs/align-items\n       */\n      'align-items': [{\n        items: ['start', 'end', 'center', 'baseline', 'stretch']\n      }],\n      /**\n       * Align Self\n       * @see https://tailwindcss.com/docs/align-self\n       */\n      'align-self': [{\n        self: ['auto', 'start', 'end', 'center', 'stretch', 'baseline']\n      }],\n      /**\n       * Place Content\n       * @see https://tailwindcss.com/docs/place-content\n       */\n      'place-content': [{\n        'place-content': [...getAlign(), 'baseline']\n      }],\n      /**\n       * Place Items\n       * @see https://tailwindcss.com/docs/place-items\n       */\n      'place-items': [{\n        'place-items': ['start', 'end', 'center', 'baseline', 'stretch']\n      }],\n      /**\n       * Place Self\n       * @see https://tailwindcss.com/docs/place-self\n       */\n      'place-self': [{\n        'place-self': ['auto', 'start', 'end', 'center', 'stretch']\n      }],\n      // Spacing\n      /**\n       * Padding\n       * @see https://tailwindcss.com/docs/padding\n       */\n      p: [{\n        p: [padding]\n      }],\n      /**\n       * Padding X\n       * @see https://tailwindcss.com/docs/padding\n       */\n      px: [{\n        px: [padding]\n      }],\n      /**\n       * Padding Y\n       * @see https://tailwindcss.com/docs/padding\n       */\n      py: [{\n        py: [padding]\n      }],\n      /**\n       * Padding Start\n       * @see https://tailwindcss.com/docs/padding\n       */\n      ps: [{\n        ps: [padding]\n      }],\n      /**\n       * Padding End\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pe: [{\n        pe: [padding]\n      }],\n      /**\n       * Padding Top\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pt: [{\n        pt: [padding]\n      }],\n      /**\n       * Padding Right\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pr: [{\n        pr: [padding]\n      }],\n      /**\n       * Padding Bottom\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pb: [{\n        pb: [padding]\n      }],\n      /**\n       * Padding Left\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pl: [{\n        pl: [padding]\n      }],\n      /**\n       * Margin\n       * @see https://tailwindcss.com/docs/margin\n       */\n      m: [{\n        m: [margin]\n      }],\n      /**\n       * Margin X\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mx: [{\n        mx: [margin]\n      }],\n      /**\n       * Margin Y\n       * @see https://tailwindcss.com/docs/margin\n       */\n      my: [{\n        my: [margin]\n      }],\n      /**\n       * Margin Start\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ms: [{\n        ms: [margin]\n      }],\n      /**\n       * Margin End\n       * @see https://tailwindcss.com/docs/margin\n       */\n      me: [{\n        me: [margin]\n      }],\n      /**\n       * Margin Top\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mt: [{\n        mt: [margin]\n      }],\n      /**\n       * Margin Right\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mr: [{\n        mr: [margin]\n      }],\n      /**\n       * Margin Bottom\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mb: [{\n        mb: [margin]\n      }],\n      /**\n       * Margin Left\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ml: [{\n        ml: [margin]\n      }],\n      /**\n       * Space Between X\n       * @see https://tailwindcss.com/docs/space\n       */\n      'space-x': [{\n        'space-x': [space]\n      }],\n      /**\n       * Space Between X Reverse\n       * @see https://tailwindcss.com/docs/space\n       */\n      'space-x-reverse': ['space-x-reverse'],\n      /**\n       * Space Between Y\n       * @see https://tailwindcss.com/docs/space\n       */\n      'space-y': [{\n        'space-y': [space]\n      }],\n      /**\n       * Space Between Y Reverse\n       * @see https://tailwindcss.com/docs/space\n       */\n      'space-y-reverse': ['space-y-reverse'],\n      // Sizing\n      /**\n       * Width\n       * @see https://tailwindcss.com/docs/width\n       */\n      w: [{\n        w: ['auto', 'min', 'max', 'fit', 'svw', 'lvw', 'dvw', isArbitraryValue, spacing]\n      }],\n      /**\n       * Min-Width\n       * @see https://tailwindcss.com/docs/min-width\n       */\n      'min-w': [{\n        'min-w': [isArbitraryValue, spacing, 'min', 'max', 'fit']\n      }],\n      /**\n       * Max-Width\n       * @see https://tailwindcss.com/docs/max-width\n       */\n      'max-w': [{\n        'max-w': [isArbitraryValue, spacing, 'none', 'full', 'min', 'max', 'fit', 'prose', {\n          screen: [isTshirtSize]\n        }, isTshirtSize]\n      }],\n      /**\n       * Height\n       * @see https://tailwindcss.com/docs/height\n       */\n      h: [{\n        h: [isArbitraryValue, spacing, 'auto', 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']\n      }],\n      /**\n       * Min-Height\n       * @see https://tailwindcss.com/docs/min-height\n       */\n      'min-h': [{\n        'min-h': [isArbitraryValue, spacing, 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']\n      }],\n      /**\n       * Max-Height\n       * @see https://tailwindcss.com/docs/max-height\n       */\n      'max-h': [{\n        'max-h': [isArbitraryValue, spacing, 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']\n      }],\n      /**\n       * Size\n       * @see https://tailwindcss.com/docs/size\n       */\n      size: [{\n        size: [isArbitraryValue, spacing, 'auto', 'min', 'max', 'fit']\n      }],\n      // Typography\n      /**\n       * Font Size\n       * @see https://tailwindcss.com/docs/font-size\n       */\n      'font-size': [{\n        text: ['base', isTshirtSize, isArbitraryLength]\n      }],\n      /**\n       * Font Smoothing\n       * @see https://tailwindcss.com/docs/font-smoothing\n       */\n      'font-smoothing': ['antialiased', 'subpixel-antialiased'],\n      /**\n       * Font Style\n       * @see https://tailwindcss.com/docs/font-style\n       */\n      'font-style': ['italic', 'not-italic'],\n      /**\n       * Font Weight\n       * @see https://tailwindcss.com/docs/font-weight\n       */\n      'font-weight': [{\n        font: ['thin', 'extralight', 'light', 'normal', 'medium', 'semibold', 'bold', 'extrabold', 'black', isArbitraryNumber]\n      }],\n      /**\n       * Font Family\n       * @see https://tailwindcss.com/docs/font-family\n       */\n      'font-family': [{\n        font: [isAny]\n      }],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-normal': ['normal-nums'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-ordinal': ['ordinal'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-slashed-zero': ['slashed-zero'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-figure': ['lining-nums', 'oldstyle-nums'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-spacing': ['proportional-nums', 'tabular-nums'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-fraction': ['diagonal-fractions', 'stacked-fractons'],\n      /**\n       * Letter Spacing\n       * @see https://tailwindcss.com/docs/letter-spacing\n       */\n      tracking: [{\n        tracking: ['tighter', 'tight', 'normal', 'wide', 'wider', 'widest', isArbitraryValue]\n      }],\n      /**\n       * Line Clamp\n       * @see https://tailwindcss.com/docs/line-clamp\n       */\n      'line-clamp': [{\n        'line-clamp': ['none', isNumber, isArbitraryNumber]\n      }],\n      /**\n       * Line Height\n       * @see https://tailwindcss.com/docs/line-height\n       */\n      leading: [{\n        leading: ['none', 'tight', 'snug', 'normal', 'relaxed', 'loose', isLength, isArbitraryValue]\n      }],\n      /**\n       * List Style Image\n       * @see https://tailwindcss.com/docs/list-style-image\n       */\n      'list-image': [{\n        'list-image': ['none', isArbitraryValue]\n      }],\n      /**\n       * List Style Type\n       * @see https://tailwindcss.com/docs/list-style-type\n       */\n      'list-style-type': [{\n        list: ['none', 'disc', 'decimal', isArbitraryValue]\n      }],\n      /**\n       * List Style Position\n       * @see https://tailwindcss.com/docs/list-style-position\n       */\n      'list-style-position': [{\n        list: ['inside', 'outside']\n      }],\n      /**\n       * Placeholder Color\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/placeholder-color\n       */\n      'placeholder-color': [{\n        placeholder: [colors]\n      }],\n      /**\n       * Placeholder Opacity\n       * @see https://tailwindcss.com/docs/placeholder-opacity\n       */\n      'placeholder-opacity': [{\n        'placeholder-opacity': [opacity]\n      }],\n      /**\n       * Text Alignment\n       * @see https://tailwindcss.com/docs/text-align\n       */\n      'text-alignment': [{\n        text: ['left', 'center', 'right', 'justify', 'start', 'end']\n      }],\n      /**\n       * Text Color\n       * @see https://tailwindcss.com/docs/text-color\n       */\n      'text-color': [{\n        text: [colors]\n      }],\n      /**\n       * Text Opacity\n       * @see https://tailwindcss.com/docs/text-opacity\n       */\n      'text-opacity': [{\n        'text-opacity': [opacity]\n      }],\n      /**\n       * Text Decoration\n       * @see https://tailwindcss.com/docs/text-decoration\n       */\n      'text-decoration': ['underline', 'overline', 'line-through', 'no-underline'],\n      /**\n       * Text Decoration Style\n       * @see https://tailwindcss.com/docs/text-decoration-style\n       */\n      'text-decoration-style': [{\n        decoration: [...getLineStyles(), 'wavy']\n      }],\n      /**\n       * Text Decoration Thickness\n       * @see https://tailwindcss.com/docs/text-decoration-thickness\n       */\n      'text-decoration-thickness': [{\n        decoration: ['auto', 'from-font', isLength, isArbitraryLength]\n      }],\n      /**\n       * Text Underline Offset\n       * @see https://tailwindcss.com/docs/text-underline-offset\n       */\n      'underline-offset': [{\n        'underline-offset': ['auto', isLength, isArbitraryValue]\n      }],\n      /**\n       * Text Decoration Color\n       * @see https://tailwindcss.com/docs/text-decoration-color\n       */\n      'text-decoration-color': [{\n        decoration: [colors]\n      }],\n      /**\n       * Text Transform\n       * @see https://tailwindcss.com/docs/text-transform\n       */\n      'text-transform': ['uppercase', 'lowercase', 'capitalize', 'normal-case'],\n      /**\n       * Text Overflow\n       * @see https://tailwindcss.com/docs/text-overflow\n       */\n      'text-overflow': ['truncate', 'text-ellipsis', 'text-clip'],\n      /**\n       * Text Wrap\n       * @see https://tailwindcss.com/docs/text-wrap\n       */\n      'text-wrap': [{\n        text: ['wrap', 'nowrap', 'balance', 'pretty']\n      }],\n      /**\n       * Text Indent\n       * @see https://tailwindcss.com/docs/text-indent\n       */\n      indent: [{\n        indent: getSpacingWithArbitrary()\n      }],\n      /**\n       * Vertical Alignment\n       * @see https://tailwindcss.com/docs/vertical-align\n       */\n      'vertical-align': [{\n        align: ['baseline', 'top', 'middle', 'bottom', 'text-top', 'text-bottom', 'sub', 'super', isArbitraryValue]\n      }],\n      /**\n       * Whitespace\n       * @see https://tailwindcss.com/docs/whitespace\n       */\n      whitespace: [{\n        whitespace: ['normal', 'nowrap', 'pre', 'pre-line', 'pre-wrap', 'break-spaces']\n      }],\n      /**\n       * Word Break\n       * @see https://tailwindcss.com/docs/word-break\n       */\n      break: [{\n        break: ['normal', 'words', 'all', 'keep']\n      }],\n      /**\n       * Hyphens\n       * @see https://tailwindcss.com/docs/hyphens\n       */\n      hyphens: [{\n        hyphens: ['none', 'manual', 'auto']\n      }],\n      /**\n       * Content\n       * @see https://tailwindcss.com/docs/content\n       */\n      content: [{\n        content: ['none', isArbitraryValue]\n      }],\n      // Backgrounds\n      /**\n       * Background Attachment\n       * @see https://tailwindcss.com/docs/background-attachment\n       */\n      'bg-attachment': [{\n        bg: ['fixed', 'local', 'scroll']\n      }],\n      /**\n       * Background Clip\n       * @see https://tailwindcss.com/docs/background-clip\n       */\n      'bg-clip': [{\n        'bg-clip': ['border', 'padding', 'content', 'text']\n      }],\n      /**\n       * Background Opacity\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/background-opacity\n       */\n      'bg-opacity': [{\n        'bg-opacity': [opacity]\n      }],\n      /**\n       * Background Origin\n       * @see https://tailwindcss.com/docs/background-origin\n       */\n      'bg-origin': [{\n        'bg-origin': ['border', 'padding', 'content']\n      }],\n      /**\n       * Background Position\n       * @see https://tailwindcss.com/docs/background-position\n       */\n      'bg-position': [{\n        bg: [...getPositions(), isArbitraryPosition]\n      }],\n      /**\n       * Background Repeat\n       * @see https://tailwindcss.com/docs/background-repeat\n       */\n      'bg-repeat': [{\n        bg: ['no-repeat', {\n          repeat: ['', 'x', 'y', 'round', 'space']\n        }]\n      }],\n      /**\n       * Background Size\n       * @see https://tailwindcss.com/docs/background-size\n       */\n      'bg-size': [{\n        bg: ['auto', 'cover', 'contain', isArbitrarySize]\n      }],\n      /**\n       * Background Image\n       * @see https://tailwindcss.com/docs/background-image\n       */\n      'bg-image': [{\n        bg: ['none', {\n          'gradient-to': ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl']\n        }, isArbitraryImage]\n      }],\n      /**\n       * Background Color\n       * @see https://tailwindcss.com/docs/background-color\n       */\n      'bg-color': [{\n        bg: [colors]\n      }],\n      /**\n       * Gradient Color Stops From Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-from-pos': [{\n        from: [gradientColorStopPositions]\n      }],\n      /**\n       * Gradient Color Stops Via Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-via-pos': [{\n        via: [gradientColorStopPositions]\n      }],\n      /**\n       * Gradient Color Stops To Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-to-pos': [{\n        to: [gradientColorStopPositions]\n      }],\n      /**\n       * Gradient Color Stops From\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-from': [{\n        from: [gradientColorStops]\n      }],\n      /**\n       * Gradient Color Stops Via\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-via': [{\n        via: [gradientColorStops]\n      }],\n      /**\n       * Gradient Color Stops To\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-to': [{\n        to: [gradientColorStops]\n      }],\n      // Borders\n      /**\n       * Border Radius\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      rounded: [{\n        rounded: [borderRadius]\n      }],\n      /**\n       * Border Radius Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-s': [{\n        'rounded-s': [borderRadius]\n      }],\n      /**\n       * Border Radius End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-e': [{\n        'rounded-e': [borderRadius]\n      }],\n      /**\n       * Border Radius Top\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-t': [{\n        'rounded-t': [borderRadius]\n      }],\n      /**\n       * Border Radius Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-r': [{\n        'rounded-r': [borderRadius]\n      }],\n      /**\n       * Border Radius Bottom\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-b': [{\n        'rounded-b': [borderRadius]\n      }],\n      /**\n       * Border Radius Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-l': [{\n        'rounded-l': [borderRadius]\n      }],\n      /**\n       * Border Radius Start Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-ss': [{\n        'rounded-ss': [borderRadius]\n      }],\n      /**\n       * Border Radius Start End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-se': [{\n        'rounded-se': [borderRadius]\n      }],\n      /**\n       * Border Radius End End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-ee': [{\n        'rounded-ee': [borderRadius]\n      }],\n      /**\n       * Border Radius End Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-es': [{\n        'rounded-es': [borderRadius]\n      }],\n      /**\n       * Border Radius Top Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-tl': [{\n        'rounded-tl': [borderRadius]\n      }],\n      /**\n       * Border Radius Top Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-tr': [{\n        'rounded-tr': [borderRadius]\n      }],\n      /**\n       * Border Radius Bottom Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-br': [{\n        'rounded-br': [borderRadius]\n      }],\n      /**\n       * Border Radius Bottom Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-bl': [{\n        'rounded-bl': [borderRadius]\n      }],\n      /**\n       * Border Width\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w': [{\n        border: [borderWidth]\n      }],\n      /**\n       * Border Width X\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-x': [{\n        'border-x': [borderWidth]\n      }],\n      /**\n       * Border Width Y\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-y': [{\n        'border-y': [borderWidth]\n      }],\n      /**\n       * Border Width Start\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-s': [{\n        'border-s': [borderWidth]\n      }],\n      /**\n       * Border Width End\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-e': [{\n        'border-e': [borderWidth]\n      }],\n      /**\n       * Border Width Top\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-t': [{\n        'border-t': [borderWidth]\n      }],\n      /**\n       * Border Width Right\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-r': [{\n        'border-r': [borderWidth]\n      }],\n      /**\n       * Border Width Bottom\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-b': [{\n        'border-b': [borderWidth]\n      }],\n      /**\n       * Border Width Left\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-l': [{\n        'border-l': [borderWidth]\n      }],\n      /**\n       * Border Opacity\n       * @see https://tailwindcss.com/docs/border-opacity\n       */\n      'border-opacity': [{\n        'border-opacity': [opacity]\n      }],\n      /**\n       * Border Style\n       * @see https://tailwindcss.com/docs/border-style\n       */\n      'border-style': [{\n        border: [...getLineStyles(), 'hidden']\n      }],\n      /**\n       * Divide Width X\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      'divide-x': [{\n        'divide-x': [borderWidth]\n      }],\n      /**\n       * Divide Width X Reverse\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      'divide-x-reverse': ['divide-x-reverse'],\n      /**\n       * Divide Width Y\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      'divide-y': [{\n        'divide-y': [borderWidth]\n      }],\n      /**\n       * Divide Width Y Reverse\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      'divide-y-reverse': ['divide-y-reverse'],\n      /**\n       * Divide Opacity\n       * @see https://tailwindcss.com/docs/divide-opacity\n       */\n      'divide-opacity': [{\n        'divide-opacity': [opacity]\n      }],\n      /**\n       * Divide Style\n       * @see https://tailwindcss.com/docs/divide-style\n       */\n      'divide-style': [{\n        divide: getLineStyles()\n      }],\n      /**\n       * Border Color\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color': [{\n        border: [borderColor]\n      }],\n      /**\n       * Border Color X\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-x': [{\n        'border-x': [borderColor]\n      }],\n      /**\n       * Border Color Y\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-y': [{\n        'border-y': [borderColor]\n      }],\n      /**\n       * Border Color Top\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-t': [{\n        'border-t': [borderColor]\n      }],\n      /**\n       * Border Color Right\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-r': [{\n        'border-r': [borderColor]\n      }],\n      /**\n       * Border Color Bottom\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-b': [{\n        'border-b': [borderColor]\n      }],\n      /**\n       * Border Color Left\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-l': [{\n        'border-l': [borderColor]\n      }],\n      /**\n       * Divide Color\n       * @see https://tailwindcss.com/docs/divide-color\n       */\n      'divide-color': [{\n        divide: [borderColor]\n      }],\n      /**\n       * Outline Style\n       * @see https://tailwindcss.com/docs/outline-style\n       */\n      'outline-style': [{\n        outline: ['', ...getLineStyles()]\n      }],\n      /**\n       * Outline Offset\n       * @see https://tailwindcss.com/docs/outline-offset\n       */\n      'outline-offset': [{\n        'outline-offset': [isLength, isArbitraryValue]\n      }],\n      /**\n       * Outline Width\n       * @see https://tailwindcss.com/docs/outline-width\n       */\n      'outline-w': [{\n        outline: [isLength, isArbitraryLength]\n      }],\n      /**\n       * Outline Color\n       * @see https://tailwindcss.com/docs/outline-color\n       */\n      'outline-color': [{\n        outline: [colors]\n      }],\n      /**\n       * Ring Width\n       * @see https://tailwindcss.com/docs/ring-width\n       */\n      'ring-w': [{\n        ring: getLengthWithEmptyAndArbitrary()\n      }],\n      /**\n       * Ring Width Inset\n       * @see https://tailwindcss.com/docs/ring-width\n       */\n      'ring-w-inset': ['ring-inset'],\n      /**\n       * Ring Color\n       * @see https://tailwindcss.com/docs/ring-color\n       */\n      'ring-color': [{\n        ring: [colors]\n      }],\n      /**\n       * Ring Opacity\n       * @see https://tailwindcss.com/docs/ring-opacity\n       */\n      'ring-opacity': [{\n        'ring-opacity': [opacity]\n      }],\n      /**\n       * Ring Offset Width\n       * @see https://tailwindcss.com/docs/ring-offset-width\n       */\n      'ring-offset-w': [{\n        'ring-offset': [isLength, isArbitraryLength]\n      }],\n      /**\n       * Ring Offset Color\n       * @see https://tailwindcss.com/docs/ring-offset-color\n       */\n      'ring-offset-color': [{\n        'ring-offset': [colors]\n      }],\n      // Effects\n      /**\n       * Box Shadow\n       * @see https://tailwindcss.com/docs/box-shadow\n       */\n      shadow: [{\n        shadow: ['', 'inner', 'none', isTshirtSize, isArbitraryShadow]\n      }],\n      /**\n       * Box Shadow Color\n       * @see https://tailwindcss.com/docs/box-shadow-color\n       */\n      'shadow-color': [{\n        shadow: [isAny]\n      }],\n      /**\n       * Opacity\n       * @see https://tailwindcss.com/docs/opacity\n       */\n      opacity: [{\n        opacity: [opacity]\n      }],\n      /**\n       * Mix Blend Mode\n       * @see https://tailwindcss.com/docs/mix-blend-mode\n       */\n      'mix-blend': [{\n        'mix-blend': getBlendModes()\n      }],\n      /**\n       * Background Blend Mode\n       * @see https://tailwindcss.com/docs/background-blend-mode\n       */\n      'bg-blend': [{\n        'bg-blend': getBlendModes()\n      }],\n      // Filters\n      /**\n       * Filter\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/filter\n       */\n      filter: [{\n        filter: ['', 'none']\n      }],\n      /**\n       * Blur\n       * @see https://tailwindcss.com/docs/blur\n       */\n      blur: [{\n        blur: [blur]\n      }],\n      /**\n       * Brightness\n       * @see https://tailwindcss.com/docs/brightness\n       */\n      brightness: [{\n        brightness: [brightness]\n      }],\n      /**\n       * Contrast\n       * @see https://tailwindcss.com/docs/contrast\n       */\n      contrast: [{\n        contrast: [contrast]\n      }],\n      /**\n       * Drop Shadow\n       * @see https://tailwindcss.com/docs/drop-shadow\n       */\n      'drop-shadow': [{\n        'drop-shadow': ['', 'none', isTshirtSize, isArbitraryValue]\n      }],\n      /**\n       * Grayscale\n       * @see https://tailwindcss.com/docs/grayscale\n       */\n      grayscale: [{\n        grayscale: [grayscale]\n      }],\n      /**\n       * Hue Rotate\n       * @see https://tailwindcss.com/docs/hue-rotate\n       */\n      'hue-rotate': [{\n        'hue-rotate': [hueRotate]\n      }],\n      /**\n       * Invert\n       * @see https://tailwindcss.com/docs/invert\n       */\n      invert: [{\n        invert: [invert]\n      }],\n      /**\n       * Saturate\n       * @see https://tailwindcss.com/docs/saturate\n       */\n      saturate: [{\n        saturate: [saturate]\n      }],\n      /**\n       * Sepia\n       * @see https://tailwindcss.com/docs/sepia\n       */\n      sepia: [{\n        sepia: [sepia]\n      }],\n      /**\n       * Backdrop Filter\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/backdrop-filter\n       */\n      'backdrop-filter': [{\n        'backdrop-filter': ['', 'none']\n      }],\n      /**\n       * Backdrop Blur\n       * @see https://tailwindcss.com/docs/backdrop-blur\n       */\n      'backdrop-blur': [{\n        'backdrop-blur': [blur]\n      }],\n      /**\n       * Backdrop Brightness\n       * @see https://tailwindcss.com/docs/backdrop-brightness\n       */\n      'backdrop-brightness': [{\n        'backdrop-brightness': [brightness]\n      }],\n      /**\n       * Backdrop Contrast\n       * @see https://tailwindcss.com/docs/backdrop-contrast\n       */\n      'backdrop-contrast': [{\n        'backdrop-contrast': [contrast]\n      }],\n      /**\n       * Backdrop Grayscale\n       * @see https://tailwindcss.com/docs/backdrop-grayscale\n       */\n      'backdrop-grayscale': [{\n        'backdrop-grayscale': [grayscale]\n      }],\n      /**\n       * Backdrop Hue Rotate\n       * @see https://tailwindcss.com/docs/backdrop-hue-rotate\n       */\n      'backdrop-hue-rotate': [{\n        'backdrop-hue-rotate': [hueRotate]\n      }],\n      /**\n       * Backdrop Invert\n       * @see https://tailwindcss.com/docs/backdrop-invert\n       */\n      'backdrop-invert': [{\n        'backdrop-invert': [invert]\n      }],\n      /**\n       * Backdrop Opacity\n       * @see https://tailwindcss.com/docs/backdrop-opacity\n       */\n      'backdrop-opacity': [{\n        'backdrop-opacity': [opacity]\n      }],\n      /**\n       * Backdrop Saturate\n       * @see https://tailwindcss.com/docs/backdrop-saturate\n       */\n      'backdrop-saturate': [{\n        'backdrop-saturate': [saturate]\n      }],\n      /**\n       * Backdrop Sepia\n       * @see https://tailwindcss.com/docs/backdrop-sepia\n       */\n      'backdrop-sepia': [{\n        'backdrop-sepia': [sepia]\n      }],\n      // Tables\n      /**\n       * Border Collapse\n       * @see https://tailwindcss.com/docs/border-collapse\n       */\n      'border-collapse': [{\n        border: ['collapse', 'separate']\n      }],\n      /**\n       * Border Spacing\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      'border-spacing': [{\n        'border-spacing': [borderSpacing]\n      }],\n      /**\n       * Border Spacing X\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      'border-spacing-x': [{\n        'border-spacing-x': [borderSpacing]\n      }],\n      /**\n       * Border Spacing Y\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      'border-spacing-y': [{\n        'border-spacing-y': [borderSpacing]\n      }],\n      /**\n       * Table Layout\n       * @see https://tailwindcss.com/docs/table-layout\n       */\n      'table-layout': [{\n        table: ['auto', 'fixed']\n      }],\n      /**\n       * Caption Side\n       * @see https://tailwindcss.com/docs/caption-side\n       */\n      caption: [{\n        caption: ['top', 'bottom']\n      }],\n      // Transitions and Animation\n      /**\n       * Tranisition Property\n       * @see https://tailwindcss.com/docs/transition-property\n       */\n      transition: [{\n        transition: ['none', 'all', '', 'colors', 'opacity', 'shadow', 'transform', isArbitraryValue]\n      }],\n      /**\n       * Transition Duration\n       * @see https://tailwindcss.com/docs/transition-duration\n       */\n      duration: [{\n        duration: getNumberAndArbitrary()\n      }],\n      /**\n       * Transition Timing Function\n       * @see https://tailwindcss.com/docs/transition-timing-function\n       */\n      ease: [{\n        ease: ['linear', 'in', 'out', 'in-out', isArbitraryValue]\n      }],\n      /**\n       * Transition Delay\n       * @see https://tailwindcss.com/docs/transition-delay\n       */\n      delay: [{\n        delay: getNumberAndArbitrary()\n      }],\n      /**\n       * Animation\n       * @see https://tailwindcss.com/docs/animation\n       */\n      animate: [{\n        animate: ['none', 'spin', 'ping', 'pulse', 'bounce', isArbitraryValue]\n      }],\n      // Transforms\n      /**\n       * Transform\n       * @see https://tailwindcss.com/docs/transform\n       */\n      transform: [{\n        transform: ['', 'gpu', 'none']\n      }],\n      /**\n       * Scale\n       * @see https://tailwindcss.com/docs/scale\n       */\n      scale: [{\n        scale: [scale]\n      }],\n      /**\n       * Scale X\n       * @see https://tailwindcss.com/docs/scale\n       */\n      'scale-x': [{\n        'scale-x': [scale]\n      }],\n      /**\n       * Scale Y\n       * @see https://tailwindcss.com/docs/scale\n       */\n      'scale-y': [{\n        'scale-y': [scale]\n      }],\n      /**\n       * Rotate\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      rotate: [{\n        rotate: [isInteger, isArbitraryValue]\n      }],\n      /**\n       * Translate X\n       * @see https://tailwindcss.com/docs/translate\n       */\n      'translate-x': [{\n        'translate-x': [translate]\n      }],\n      /**\n       * Translate Y\n       * @see https://tailwindcss.com/docs/translate\n       */\n      'translate-y': [{\n        'translate-y': [translate]\n      }],\n      /**\n       * Skew X\n       * @see https://tailwindcss.com/docs/skew\n       */\n      'skew-x': [{\n        'skew-x': [skew]\n      }],\n      /**\n       * Skew Y\n       * @see https://tailwindcss.com/docs/skew\n       */\n      'skew-y': [{\n        'skew-y': [skew]\n      }],\n      /**\n       * Transform Origin\n       * @see https://tailwindcss.com/docs/transform-origin\n       */\n      'transform-origin': [{\n        origin: ['center', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left', isArbitraryValue]\n      }],\n      // Interactivity\n      /**\n       * Accent Color\n       * @see https://tailwindcss.com/docs/accent-color\n       */\n      accent: [{\n        accent: ['auto', colors]\n      }],\n      /**\n       * Appearance\n       * @see https://tailwindcss.com/docs/appearance\n       */\n      appearance: [{\n        appearance: ['none', 'auto']\n      }],\n      /**\n       * Cursor\n       * @see https://tailwindcss.com/docs/cursor\n       */\n      cursor: [{\n        cursor: ['auto', 'default', 'pointer', 'wait', 'text', 'move', 'help', 'not-allowed', 'none', 'context-menu', 'progress', 'cell', 'crosshair', 'vertical-text', 'alias', 'copy', 'no-drop', 'grab', 'grabbing', 'all-scroll', 'col-resize', 'row-resize', 'n-resize', 'e-resize', 's-resize', 'w-resize', 'ne-resize', 'nw-resize', 'se-resize', 'sw-resize', 'ew-resize', 'ns-resize', 'nesw-resize', 'nwse-resize', 'zoom-in', 'zoom-out', isArbitraryValue]\n      }],\n      /**\n       * Caret Color\n       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities\n       */\n      'caret-color': [{\n        caret: [colors]\n      }],\n      /**\n       * Pointer Events\n       * @see https://tailwindcss.com/docs/pointer-events\n       */\n      'pointer-events': [{\n        'pointer-events': ['none', 'auto']\n      }],\n      /**\n       * Resize\n       * @see https://tailwindcss.com/docs/resize\n       */\n      resize: [{\n        resize: ['none', 'y', 'x', '']\n      }],\n      /**\n       * Scroll Behavior\n       * @see https://tailwindcss.com/docs/scroll-behavior\n       */\n      'scroll-behavior': [{\n        scroll: ['auto', 'smooth']\n      }],\n      /**\n       * Scroll Margin\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-m': [{\n        'scroll-m': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin X\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mx': [{\n        'scroll-mx': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Y\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-my': [{\n        'scroll-my': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Start\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-ms': [{\n        'scroll-ms': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin End\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-me': [{\n        'scroll-me': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Top\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mt': [{\n        'scroll-mt': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Right\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mr': [{\n        'scroll-mr': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Bottom\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mb': [{\n        'scroll-mb': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Left\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-ml': [{\n        'scroll-ml': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-p': [{\n        'scroll-p': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding X\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-px': [{\n        'scroll-px': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Y\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-py': [{\n        'scroll-py': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Start\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-ps': [{\n        'scroll-ps': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding End\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pe': [{\n        'scroll-pe': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Top\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pt': [{\n        'scroll-pt': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Right\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pr': [{\n        'scroll-pr': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Bottom\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pb': [{\n        'scroll-pb': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Left\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pl': [{\n        'scroll-pl': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Snap Align\n       * @see https://tailwindcss.com/docs/scroll-snap-align\n       */\n      'snap-align': [{\n        snap: ['start', 'end', 'center', 'align-none']\n      }],\n      /**\n       * Scroll Snap Stop\n       * @see https://tailwindcss.com/docs/scroll-snap-stop\n       */\n      'snap-stop': [{\n        snap: ['normal', 'always']\n      }],\n      /**\n       * Scroll Snap Type\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      'snap-type': [{\n        snap: ['none', 'x', 'y', 'both']\n      }],\n      /**\n       * Scroll Snap Type Strictness\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      'snap-strictness': [{\n        snap: ['mandatory', 'proximity']\n      }],\n      /**\n       * Touch Action\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      touch: [{\n        touch: ['auto', 'none', 'manipulation']\n      }],\n      /**\n       * Touch Action X\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      'touch-x': [{\n        'touch-pan': ['x', 'left', 'right']\n      }],\n      /**\n       * Touch Action Y\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      'touch-y': [{\n        'touch-pan': ['y', 'up', 'down']\n      }],\n      /**\n       * Touch Action Pinch Zoom\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      'touch-pz': ['touch-pinch-zoom'],\n      /**\n       * User Select\n       * @see https://tailwindcss.com/docs/user-select\n       */\n      select: [{\n        select: ['none', 'text', 'all', 'auto']\n      }],\n      /**\n       * Will Change\n       * @see https://tailwindcss.com/docs/will-change\n       */\n      'will-change': [{\n        'will-change': ['auto', 'scroll', 'contents', 'transform', isArbitraryValue]\n      }],\n      // SVG\n      /**\n       * Fill\n       * @see https://tailwindcss.com/docs/fill\n       */\n      fill: [{\n        fill: [colors, 'none']\n      }],\n      /**\n       * Stroke Width\n       * @see https://tailwindcss.com/docs/stroke-width\n       */\n      'stroke-w': [{\n        stroke: [isLength, isArbitraryLength, isArbitraryNumber]\n      }],\n      /**\n       * Stroke\n       * @see https://tailwindcss.com/docs/stroke\n       */\n      stroke: [{\n        stroke: [colors, 'none']\n      }],\n      // Accessibility\n      /**\n       * Screen Readers\n       * @see https://tailwindcss.com/docs/screen-readers\n       */\n      sr: ['sr-only', 'not-sr-only'],\n      /**\n       * Forced Color Adjust\n       * @see https://tailwindcss.com/docs/forced-color-adjust\n       */\n      'forced-color-adjust': [{\n        'forced-color-adjust': ['auto', 'none']\n      }]\n    },\n    conflictingClassGroups: {\n      overflow: ['overflow-x', 'overflow-y'],\n      overscroll: ['overscroll-x', 'overscroll-y'],\n      inset: ['inset-x', 'inset-y', 'start', 'end', 'top', 'right', 'bottom', 'left'],\n      'inset-x': ['right', 'left'],\n      'inset-y': ['top', 'bottom'],\n      flex: ['basis', 'grow', 'shrink'],\n      gap: ['gap-x', 'gap-y'],\n      p: ['px', 'py', 'ps', 'pe', 'pt', 'pr', 'pb', 'pl'],\n      px: ['pr', 'pl'],\n      py: ['pt', 'pb'],\n      m: ['mx', 'my', 'ms', 'me', 'mt', 'mr', 'mb', 'ml'],\n      mx: ['mr', 'ml'],\n      my: ['mt', 'mb'],\n      size: ['w', 'h'],\n      'font-size': ['leading'],\n      'fvn-normal': ['fvn-ordinal', 'fvn-slashed-zero', 'fvn-figure', 'fvn-spacing', 'fvn-fraction'],\n      'fvn-ordinal': ['fvn-normal'],\n      'fvn-slashed-zero': ['fvn-normal'],\n      'fvn-figure': ['fvn-normal'],\n      'fvn-spacing': ['fvn-normal'],\n      'fvn-fraction': ['fvn-normal'],\n      'line-clamp': ['display', 'overflow'],\n      rounded: ['rounded-s', 'rounded-e', 'rounded-t', 'rounded-r', 'rounded-b', 'rounded-l', 'rounded-ss', 'rounded-se', 'rounded-ee', 'rounded-es', 'rounded-tl', 'rounded-tr', 'rounded-br', 'rounded-bl'],\n      'rounded-s': ['rounded-ss', 'rounded-es'],\n      'rounded-e': ['rounded-se', 'rounded-ee'],\n      'rounded-t': ['rounded-tl', 'rounded-tr'],\n      'rounded-r': ['rounded-tr', 'rounded-br'],\n      'rounded-b': ['rounded-br', 'rounded-bl'],\n      'rounded-l': ['rounded-tl', 'rounded-bl'],\n      'border-spacing': ['border-spacing-x', 'border-spacing-y'],\n      'border-w': ['border-w-s', 'border-w-e', 'border-w-t', 'border-w-r', 'border-w-b', 'border-w-l'],\n      'border-w-x': ['border-w-r', 'border-w-l'],\n      'border-w-y': ['border-w-t', 'border-w-b'],\n      'border-color': ['border-color-t', 'border-color-r', 'border-color-b', 'border-color-l'],\n      'border-color-x': ['border-color-r', 'border-color-l'],\n      'border-color-y': ['border-color-t', 'border-color-b'],\n      'scroll-m': ['scroll-mx', 'scroll-my', 'scroll-ms', 'scroll-me', 'scroll-mt', 'scroll-mr', 'scroll-mb', 'scroll-ml'],\n      'scroll-mx': ['scroll-mr', 'scroll-ml'],\n      'scroll-my': ['scroll-mt', 'scroll-mb'],\n      'scroll-p': ['scroll-px', 'scroll-py', 'scroll-ps', 'scroll-pe', 'scroll-pt', 'scroll-pr', 'scroll-pb', 'scroll-pl'],\n      'scroll-px': ['scroll-pr', 'scroll-pl'],\n      'scroll-py': ['scroll-pt', 'scroll-pb'],\n      touch: ['touch-x', 'touch-y', 'touch-pz'],\n      'touch-x': ['touch'],\n      'touch-y': ['touch'],\n      'touch-pz': ['touch']\n    },\n    conflictingClassGroupModifiers: {\n      'font-size': ['leading']\n    }\n  };\n}\n\n/**\n * @param baseConfig Config where other config will be merged into. This object will be mutated.\n * @param configExtension Partial config to merge into the `baseConfig`.\n */\nfunction mergeConfigs(baseConfig, {\n  cacheSize,\n  prefix,\n  separator,\n  extend = {},\n  override = {}\n}) {\n  overrideProperty(baseConfig, 'cacheSize', cacheSize);\n  overrideProperty(baseConfig, 'prefix', prefix);\n  overrideProperty(baseConfig, 'separator', separator);\n  for (const configKey in override) {\n    overrideConfigProperties(baseConfig[configKey], override[configKey]);\n  }\n  for (const key in extend) {\n    mergeConfigProperties(baseConfig[key], extend[key]);\n  }\n  return baseConfig;\n}\nfunction overrideProperty(baseObject, overrideKey, overrideValue) {\n  if (overrideValue !== undefined) {\n    baseObject[overrideKey] = overrideValue;\n  }\n}\nfunction overrideConfigProperties(baseObject, overrideObject) {\n  if (overrideObject) {\n    for (const key in overrideObject) {\n      overrideProperty(baseObject, key, overrideObject[key]);\n    }\n  }\n}\nfunction mergeConfigProperties(baseObject, mergeObject) {\n  if (mergeObject) {\n    for (const key in mergeObject) {\n      const mergeValue = mergeObject[key];\n      if (mergeValue !== undefined) {\n        baseObject[key] = (baseObject[key] || []).concat(mergeValue);\n      }\n    }\n  }\n}\nfunction extendTailwindMerge(configExtension, ...createConfig) {\n  return typeof configExtension === 'function' ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);\n}\nconst twMerge = /*#__PURE__*/createTailwindMerge(getDefaultConfig);\n\n//# sourceMappingURL=bundle-mjs.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90YWlsd2luZC1tZXJnZS9kaXN0L2J1bmRsZS1tanMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxPQUFPLG1CQUFtQixrQkFBa0IsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzRIO0FBQzVIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90YWlsd2luZC1tZXJnZS9kaXN0L2J1bmRsZS1tanMubWpzP2EyMTciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ0xBU1NfUEFSVF9TRVBBUkFUT1IgPSAnLSc7XG5mdW5jdGlvbiBjcmVhdGVDbGFzc1V0aWxzKGNvbmZpZykge1xuICBjb25zdCBjbGFzc01hcCA9IGNyZWF0ZUNsYXNzTWFwKGNvbmZpZyk7XG4gIGNvbnN0IHtcbiAgICBjb25mbGljdGluZ0NsYXNzR3JvdXBzLFxuICAgIGNvbmZsaWN0aW5nQ2xhc3NHcm91cE1vZGlmaWVyc1xuICB9ID0gY29uZmlnO1xuICBmdW5jdGlvbiBnZXRDbGFzc0dyb3VwSWQoY2xhc3NOYW1lKSB7XG4gICAgY29uc3QgY2xhc3NQYXJ0cyA9IGNsYXNzTmFtZS5zcGxpdChDTEFTU19QQVJUX1NFUEFSQVRPUik7XG4gICAgLy8gQ2xhc3NlcyBsaWtlIGAtaW5zZXQtMWAgcHJvZHVjZSBhbiBlbXB0eSBzdHJpbmcgYXMgZmlyc3QgY2xhc3NQYXJ0LiBXZSBhc3N1bWUgdGhhdCBjbGFzc2VzIGZvciBuZWdhdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgY29ycmVjdGx5IGFuZCByZW1vdmUgaXQgZnJvbSBjbGFzc1BhcnRzLlxuICAgIGlmIChjbGFzc1BhcnRzWzBdID09PSAnJyAmJiBjbGFzc1BhcnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgY2xhc3NQYXJ0cy5zaGlmdCgpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0R3JvdXBSZWN1cnNpdmUoY2xhc3NQYXJ0cywgY2xhc3NNYXApIHx8IGdldEdyb3VwSWRGb3JBcmJpdHJhcnlQcm9wZXJ0eShjbGFzc05hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIGdldENvbmZsaWN0aW5nQ2xhc3NHcm91cElkcyhjbGFzc0dyb3VwSWQsIGhhc1Bvc3RmaXhNb2RpZmllcikge1xuICAgIGNvbnN0IGNvbmZsaWN0cyA9IGNvbmZsaWN0aW5nQ2xhc3NHcm91cHNbY2xhc3NHcm91cElkXSB8fCBbXTtcbiAgICBpZiAoaGFzUG9zdGZpeE1vZGlmaWVyICYmIGNvbmZsaWN0aW5nQ2xhc3NHcm91cE1vZGlmaWVyc1tjbGFzc0dyb3VwSWRdKSB7XG4gICAgICByZXR1cm4gWy4uLmNvbmZsaWN0cywgLi4uY29uZmxpY3RpbmdDbGFzc0dyb3VwTW9kaWZpZXJzW2NsYXNzR3JvdXBJZF1dO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmxpY3RzO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0Q2xhc3NHcm91cElkLFxuICAgIGdldENvbmZsaWN0aW5nQ2xhc3NHcm91cElkc1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0R3JvdXBSZWN1cnNpdmUoY2xhc3NQYXJ0cywgY2xhc3NQYXJ0T2JqZWN0KSB7XG4gIGlmIChjbGFzc1BhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjbGFzc1BhcnRPYmplY3QuY2xhc3NHcm91cElkO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRDbGFzc1BhcnQgPSBjbGFzc1BhcnRzWzBdO1xuICBjb25zdCBuZXh0Q2xhc3NQYXJ0T2JqZWN0ID0gY2xhc3NQYXJ0T2JqZWN0Lm5leHRQYXJ0LmdldChjdXJyZW50Q2xhc3NQYXJ0KTtcbiAgY29uc3QgY2xhc3NHcm91cEZyb21OZXh0Q2xhc3NQYXJ0ID0gbmV4dENsYXNzUGFydE9iamVjdCA/IGdldEdyb3VwUmVjdXJzaXZlKGNsYXNzUGFydHMuc2xpY2UoMSksIG5leHRDbGFzc1BhcnRPYmplY3QpIDogdW5kZWZpbmVkO1xuICBpZiAoY2xhc3NHcm91cEZyb21OZXh0Q2xhc3NQYXJ0KSB7XG4gICAgcmV0dXJuIGNsYXNzR3JvdXBGcm9tTmV4dENsYXNzUGFydDtcbiAgfVxuICBpZiAoY2xhc3NQYXJ0T2JqZWN0LnZhbGlkYXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBjbGFzc1Jlc3QgPSBjbGFzc1BhcnRzLmpvaW4oQ0xBU1NfUEFSVF9TRVBBUkFUT1IpO1xuICByZXR1cm4gY2xhc3NQYXJ0T2JqZWN0LnZhbGlkYXRvcnMuZmluZCgoe1xuICAgIHZhbGlkYXRvclxuICB9KSA9PiB2YWxpZGF0b3IoY2xhc3NSZXN0KSk/LmNsYXNzR3JvdXBJZDtcbn1cbmNvbnN0IGFyYml0cmFyeVByb3BlcnR5UmVnZXggPSAvXlxcWyguKylcXF0kLztcbmZ1bmN0aW9uIGdldEdyb3VwSWRGb3JBcmJpdHJhcnlQcm9wZXJ0eShjbGFzc05hbWUpIHtcbiAgaWYgKGFyYml0cmFyeVByb3BlcnR5UmVnZXgudGVzdChjbGFzc05hbWUpKSB7XG4gICAgY29uc3QgYXJiaXRyYXJ5UHJvcGVydHlDbGFzc05hbWUgPSBhcmJpdHJhcnlQcm9wZXJ0eVJlZ2V4LmV4ZWMoY2xhc3NOYW1lKVsxXTtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IGFyYml0cmFyeVByb3BlcnR5Q2xhc3NOYW1lPy5zdWJzdHJpbmcoMCwgYXJiaXRyYXJ5UHJvcGVydHlDbGFzc05hbWUuaW5kZXhPZignOicpKTtcbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIC8vIEkgdXNlIHR3byBkb3RzIGhlcmUgYmVjYXVzZSBvbmUgZG90IGlzIHVzZWQgYXMgcHJlZml4IGZvciBjbGFzcyBncm91cHMgaW4gcGx1Z2luc1xuICAgICAgcmV0dXJuICdhcmJpdHJhcnkuLicgKyBwcm9wZXJ0eTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRXhwb3J0ZWQgZm9yIHRlc3Rpbmcgb25seVxuICovXG5mdW5jdGlvbiBjcmVhdGVDbGFzc01hcChjb25maWcpIHtcbiAgY29uc3Qge1xuICAgIHRoZW1lLFxuICAgIHByZWZpeFxuICB9ID0gY29uZmlnO1xuICBjb25zdCBjbGFzc01hcCA9IHtcbiAgICBuZXh0UGFydDogbmV3IE1hcCgpLFxuICAgIHZhbGlkYXRvcnM6IFtdXG4gIH07XG4gIGNvbnN0IHByZWZpeGVkQ2xhc3NHcm91cEVudHJpZXMgPSBnZXRQcmVmaXhlZENsYXNzR3JvdXBFbnRyaWVzKE9iamVjdC5lbnRyaWVzKGNvbmZpZy5jbGFzc0dyb3VwcyksIHByZWZpeCk7XG4gIHByZWZpeGVkQ2xhc3NHcm91cEVudHJpZXMuZm9yRWFjaCgoW2NsYXNzR3JvdXBJZCwgY2xhc3NHcm91cF0pID0+IHtcbiAgICBwcm9jZXNzQ2xhc3Nlc1JlY3Vyc2l2ZWx5KGNsYXNzR3JvdXAsIGNsYXNzTWFwLCBjbGFzc0dyb3VwSWQsIHRoZW1lKTtcbiAgfSk7XG4gIHJldHVybiBjbGFzc01hcDtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NDbGFzc2VzUmVjdXJzaXZlbHkoY2xhc3NHcm91cCwgY2xhc3NQYXJ0T2JqZWN0LCBjbGFzc0dyb3VwSWQsIHRoZW1lKSB7XG4gIGNsYXNzR3JvdXAuZm9yRWFjaChjbGFzc0RlZmluaXRpb24gPT4ge1xuICAgIGlmICh0eXBlb2YgY2xhc3NEZWZpbml0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgY2xhc3NQYXJ0T2JqZWN0VG9FZGl0ID0gY2xhc3NEZWZpbml0aW9uID09PSAnJyA/IGNsYXNzUGFydE9iamVjdCA6IGdldFBhcnQoY2xhc3NQYXJ0T2JqZWN0LCBjbGFzc0RlZmluaXRpb24pO1xuICAgICAgY2xhc3NQYXJ0T2JqZWN0VG9FZGl0LmNsYXNzR3JvdXBJZCA9IGNsYXNzR3JvdXBJZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjbGFzc0RlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChpc1RoZW1lR2V0dGVyKGNsYXNzRGVmaW5pdGlvbikpIHtcbiAgICAgICAgcHJvY2Vzc0NsYXNzZXNSZWN1cnNpdmVseShjbGFzc0RlZmluaXRpb24odGhlbWUpLCBjbGFzc1BhcnRPYmplY3QsIGNsYXNzR3JvdXBJZCwgdGhlbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjbGFzc1BhcnRPYmplY3QudmFsaWRhdG9ycy5wdXNoKHtcbiAgICAgICAgdmFsaWRhdG9yOiBjbGFzc0RlZmluaXRpb24sXG4gICAgICAgIGNsYXNzR3JvdXBJZFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9iamVjdC5lbnRyaWVzKGNsYXNzRGVmaW5pdGlvbikuZm9yRWFjaCgoW2tleSwgY2xhc3NHcm91cF0pID0+IHtcbiAgICAgIHByb2Nlc3NDbGFzc2VzUmVjdXJzaXZlbHkoY2xhc3NHcm91cCwgZ2V0UGFydChjbGFzc1BhcnRPYmplY3QsIGtleSksIGNsYXNzR3JvdXBJZCwgdGhlbWUpO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFBhcnQoY2xhc3NQYXJ0T2JqZWN0LCBwYXRoKSB7XG4gIGxldCBjdXJyZW50Q2xhc3NQYXJ0T2JqZWN0ID0gY2xhc3NQYXJ0T2JqZWN0O1xuICBwYXRoLnNwbGl0KENMQVNTX1BBUlRfU0VQQVJBVE9SKS5mb3JFYWNoKHBhdGhQYXJ0ID0+IHtcbiAgICBpZiAoIWN1cnJlbnRDbGFzc1BhcnRPYmplY3QubmV4dFBhcnQuaGFzKHBhdGhQYXJ0KSkge1xuICAgICAgY3VycmVudENsYXNzUGFydE9iamVjdC5uZXh0UGFydC5zZXQocGF0aFBhcnQsIHtcbiAgICAgICAgbmV4dFBhcnQ6IG5ldyBNYXAoKSxcbiAgICAgICAgdmFsaWRhdG9yczogW11cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjdXJyZW50Q2xhc3NQYXJ0T2JqZWN0ID0gY3VycmVudENsYXNzUGFydE9iamVjdC5uZXh0UGFydC5nZXQocGF0aFBhcnQpO1xuICB9KTtcbiAgcmV0dXJuIGN1cnJlbnRDbGFzc1BhcnRPYmplY3Q7XG59XG5mdW5jdGlvbiBpc1RoZW1lR2V0dGVyKGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmMuaXNUaGVtZUdldHRlcjtcbn1cbmZ1bmN0aW9uIGdldFByZWZpeGVkQ2xhc3NHcm91cEVudHJpZXMoY2xhc3NHcm91cEVudHJpZXMsIHByZWZpeCkge1xuICBpZiAoIXByZWZpeCkge1xuICAgIHJldHVybiBjbGFzc0dyb3VwRW50cmllcztcbiAgfVxuICByZXR1cm4gY2xhc3NHcm91cEVudHJpZXMubWFwKChbY2xhc3NHcm91cElkLCBjbGFzc0dyb3VwXSkgPT4ge1xuICAgIGNvbnN0IHByZWZpeGVkQ2xhc3NHcm91cCA9IGNsYXNzR3JvdXAubWFwKGNsYXNzRGVmaW5pdGlvbiA9PiB7XG4gICAgICBpZiAodHlwZW9mIGNsYXNzRGVmaW5pdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIGNsYXNzRGVmaW5pdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY2xhc3NEZWZpbml0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGNsYXNzRGVmaW5pdGlvbikubWFwKChba2V5LCB2YWx1ZV0pID0+IFtwcmVmaXggKyBrZXksIHZhbHVlXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsYXNzRGVmaW5pdGlvbjtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NsYXNzR3JvdXBJZCwgcHJlZml4ZWRDbGFzc0dyb3VwXTtcbiAgfSk7XG59XG5cbi8vIExSVSBjYWNoZSBpbnNwaXJlZCBmcm9tIGhhc2hscnUgKGh0dHBzOi8vZ2l0aHViLmNvbS9kb21pbmljdGFyci9oYXNobHJ1L2Jsb2IvdjEuMC40L2luZGV4LmpzKSBidXQgb2JqZWN0IHJlcGxhY2VkIHdpdGggTWFwIHRvIGltcHJvdmUgcGVyZm9ybWFuY2VcbmZ1bmN0aW9uIGNyZWF0ZUxydUNhY2hlKG1heENhY2hlU2l6ZSkge1xuICBpZiAobWF4Q2FjaGVTaXplIDwgMSkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXQ6ICgpID0+IHVuZGVmaW5lZCxcbiAgICAgIHNldDogKCkgPT4ge31cbiAgICB9O1xuICB9XG4gIGxldCBjYWNoZVNpemUgPSAwO1xuICBsZXQgY2FjaGUgPSBuZXcgTWFwKCk7XG4gIGxldCBwcmV2aW91c0NhY2hlID0gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiB1cGRhdGUoa2V5LCB2YWx1ZSkge1xuICAgIGNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgICBjYWNoZVNpemUrKztcbiAgICBpZiAoY2FjaGVTaXplID4gbWF4Q2FjaGVTaXplKSB7XG4gICAgICBjYWNoZVNpemUgPSAwO1xuICAgICAgcHJldmlvdXNDYWNoZSA9IGNhY2hlO1xuICAgICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgbGV0IHZhbHVlID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoKHZhbHVlID0gcHJldmlvdXNDYWNoZS5nZXQoa2V5KSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cGRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmNvbnN0IElNUE9SVEFOVF9NT0RJRklFUiA9ICchJztcbmZ1bmN0aW9uIGNyZWF0ZVNwbGl0TW9kaWZpZXJzKGNvbmZpZykge1xuICBjb25zdCBzZXBhcmF0b3IgPSBjb25maWcuc2VwYXJhdG9yO1xuICBjb25zdCBpc1NlcGFyYXRvclNpbmdsZUNoYXJhY3RlciA9IHNlcGFyYXRvci5sZW5ndGggPT09IDE7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9yQ2hhcmFjdGVyID0gc2VwYXJhdG9yWzBdO1xuICBjb25zdCBzZXBhcmF0b3JMZW5ndGggPSBzZXBhcmF0b3IubGVuZ3RoO1xuICAvLyBzcGxpdE1vZGlmaWVycyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzL2Jsb2IvdjMuMi4yL3NyYy91dGlsL3NwbGl0QXRUb3BMZXZlbE9ubHkuanNcbiAgcmV0dXJuIGZ1bmN0aW9uIHNwbGl0TW9kaWZpZXJzKGNsYXNzTmFtZSkge1xuICAgIGNvbnN0IG1vZGlmaWVycyA9IFtdO1xuICAgIGxldCBicmFja2V0RGVwdGggPSAwO1xuICAgIGxldCBtb2RpZmllclN0YXJ0ID0gMDtcbiAgICBsZXQgcG9zdGZpeE1vZGlmaWVyUG9zaXRpb247XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNsYXNzTmFtZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGxldCBjdXJyZW50Q2hhcmFjdGVyID0gY2xhc3NOYW1lW2luZGV4XTtcbiAgICAgIGlmIChicmFja2V0RGVwdGggPT09IDApIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDaGFyYWN0ZXIgPT09IGZpcnN0U2VwYXJhdG9yQ2hhcmFjdGVyICYmIChpc1NlcGFyYXRvclNpbmdsZUNoYXJhY3RlciB8fCBjbGFzc05hbWUuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VwYXJhdG9yTGVuZ3RoKSA9PT0gc2VwYXJhdG9yKSkge1xuICAgICAgICAgIG1vZGlmaWVycy5wdXNoKGNsYXNzTmFtZS5zbGljZShtb2RpZmllclN0YXJ0LCBpbmRleCkpO1xuICAgICAgICAgIG1vZGlmaWVyU3RhcnQgPSBpbmRleCArIHNlcGFyYXRvckxlbmd0aDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudENoYXJhY3RlciA9PT0gJy8nKSB7XG4gICAgICAgICAgcG9zdGZpeE1vZGlmaWVyUG9zaXRpb24gPSBpbmRleDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRDaGFyYWN0ZXIgPT09ICdbJykge1xuICAgICAgICBicmFja2V0RGVwdGgrKztcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudENoYXJhY3RlciA9PT0gJ10nKSB7XG4gICAgICAgIGJyYWNrZXREZXB0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBiYXNlQ2xhc3NOYW1lV2l0aEltcG9ydGFudE1vZGlmaWVyID0gbW9kaWZpZXJzLmxlbmd0aCA9PT0gMCA/IGNsYXNzTmFtZSA6IGNsYXNzTmFtZS5zdWJzdHJpbmcobW9kaWZpZXJTdGFydCk7XG4gICAgY29uc3QgaGFzSW1wb3J0YW50TW9kaWZpZXIgPSBiYXNlQ2xhc3NOYW1lV2l0aEltcG9ydGFudE1vZGlmaWVyLnN0YXJ0c1dpdGgoSU1QT1JUQU5UX01PRElGSUVSKTtcbiAgICBjb25zdCBiYXNlQ2xhc3NOYW1lID0gaGFzSW1wb3J0YW50TW9kaWZpZXIgPyBiYXNlQ2xhc3NOYW1lV2l0aEltcG9ydGFudE1vZGlmaWVyLnN1YnN0cmluZygxKSA6IGJhc2VDbGFzc05hbWVXaXRoSW1wb3J0YW50TW9kaWZpZXI7XG4gICAgY29uc3QgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvbiA9IHBvc3RmaXhNb2RpZmllclBvc2l0aW9uICYmIHBvc3RmaXhNb2RpZmllclBvc2l0aW9uID4gbW9kaWZpZXJTdGFydCA/IHBvc3RmaXhNb2RpZmllclBvc2l0aW9uIC0gbW9kaWZpZXJTdGFydCA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZXJzLFxuICAgICAgaGFzSW1wb3J0YW50TW9kaWZpZXIsXG4gICAgICBiYXNlQ2xhc3NOYW1lLFxuICAgICAgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvblxuICAgIH07XG4gIH07XG59XG4vKipcbiAqIFNvcnRzIG1vZGlmaWVycyBhY2NvcmRpbmcgdG8gZm9sbG93aW5nIHNjaGVtYTpcbiAqIC0gUHJlZGVmaW5lZCBtb2RpZmllcnMgYXJlIHNvcnRlZCBhbHBoYWJldGljYWxseVxuICogLSBXaGVuIGFuIGFyYml0cmFyeSB2YXJpYW50IGFwcGVhcnMsIGl0IG11c3QgYmUgcHJlc2VydmVkIHdoaWNoIG1vZGlmaWVycyBhcmUgYmVmb3JlIGFuZCBhZnRlciBpdFxuICovXG5mdW5jdGlvbiBzb3J0TW9kaWZpZXJzKG1vZGlmaWVycykge1xuICBpZiAobW9kaWZpZXJzLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVycztcbiAgfVxuICBjb25zdCBzb3J0ZWRNb2RpZmllcnMgPSBbXTtcbiAgbGV0IHVuc29ydGVkTW9kaWZpZXJzID0gW107XG4gIG1vZGlmaWVycy5mb3JFYWNoKG1vZGlmaWVyID0+IHtcbiAgICBjb25zdCBpc0FyYml0cmFyeVZhcmlhbnQgPSBtb2RpZmllclswXSA9PT0gJ1snO1xuICAgIGlmIChpc0FyYml0cmFyeVZhcmlhbnQpIHtcbiAgICAgIHNvcnRlZE1vZGlmaWVycy5wdXNoKC4uLnVuc29ydGVkTW9kaWZpZXJzLnNvcnQoKSwgbW9kaWZpZXIpO1xuICAgICAgdW5zb3J0ZWRNb2RpZmllcnMgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5zb3J0ZWRNb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgc29ydGVkTW9kaWZpZXJzLnB1c2goLi4udW5zb3J0ZWRNb2RpZmllcnMuc29ydCgpKTtcbiAgcmV0dXJuIHNvcnRlZE1vZGlmaWVycztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbmZpZ1V0aWxzKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIGNhY2hlOiBjcmVhdGVMcnVDYWNoZShjb25maWcuY2FjaGVTaXplKSxcbiAgICBzcGxpdE1vZGlmaWVyczogY3JlYXRlU3BsaXRNb2RpZmllcnMoY29uZmlnKSxcbiAgICAuLi5jcmVhdGVDbGFzc1V0aWxzKGNvbmZpZylcbiAgfTtcbn1cbmNvbnN0IFNQTElUX0NMQVNTRVNfUkVHRVggPSAvXFxzKy87XG5mdW5jdGlvbiBtZXJnZUNsYXNzTGlzdChjbGFzc0xpc3QsIGNvbmZpZ1V0aWxzKSB7XG4gIGNvbnN0IHtcbiAgICBzcGxpdE1vZGlmaWVycyxcbiAgICBnZXRDbGFzc0dyb3VwSWQsXG4gICAgZ2V0Q29uZmxpY3RpbmdDbGFzc0dyb3VwSWRzXG4gIH0gPSBjb25maWdVdGlscztcbiAgLyoqXG4gICAqIFNldCBvZiBjbGFzc0dyb3VwSWRzIGluIGZvbGxvd2luZyBmb3JtYXQ6XG4gICAqIGB7aW1wb3J0YW50TW9kaWZpZXJ9e3ZhcmlhbnRNb2RpZmllcnN9e2NsYXNzR3JvdXBJZH1gXG4gICAqIEBleGFtcGxlICdmbG9hdCdcbiAgICogQGV4YW1wbGUgJ2hvdmVyOmZvY3VzOmJnLWNvbG9yJ1xuICAgKiBAZXhhbXBsZSAnbWQ6IXByJ1xuICAgKi9cbiAgY29uc3QgY2xhc3NHcm91cHNJbkNvbmZsaWN0ID0gbmV3IFNldCgpO1xuICByZXR1cm4gY2xhc3NMaXN0LnRyaW0oKS5zcGxpdChTUExJVF9DTEFTU0VTX1JFR0VYKS5tYXAob3JpZ2luYWxDbGFzc05hbWUgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG1vZGlmaWVycyxcbiAgICAgIGhhc0ltcG9ydGFudE1vZGlmaWVyLFxuICAgICAgYmFzZUNsYXNzTmFtZSxcbiAgICAgIG1heWJlUG9zdGZpeE1vZGlmaWVyUG9zaXRpb25cbiAgICB9ID0gc3BsaXRNb2RpZmllcnMob3JpZ2luYWxDbGFzc05hbWUpO1xuICAgIGxldCBjbGFzc0dyb3VwSWQgPSBnZXRDbGFzc0dyb3VwSWQobWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvbiA/IGJhc2VDbGFzc05hbWUuc3Vic3RyaW5nKDAsIG1heWJlUG9zdGZpeE1vZGlmaWVyUG9zaXRpb24pIDogYmFzZUNsYXNzTmFtZSk7XG4gICAgbGV0IGhhc1Bvc3RmaXhNb2RpZmllciA9IEJvb2xlYW4obWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvbik7XG4gICAgaWYgKCFjbGFzc0dyb3VwSWQpIHtcbiAgICAgIGlmICghbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGFpbHdpbmRDbGFzczogZmFsc2UsXG4gICAgICAgICAgb3JpZ2luYWxDbGFzc05hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNsYXNzR3JvdXBJZCA9IGdldENsYXNzR3JvdXBJZChiYXNlQ2xhc3NOYW1lKTtcbiAgICAgIGlmICghY2xhc3NHcm91cElkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUYWlsd2luZENsYXNzOiBmYWxzZSxcbiAgICAgICAgICBvcmlnaW5hbENsYXNzTmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaGFzUG9zdGZpeE1vZGlmaWVyID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHZhcmlhbnRNb2RpZmllciA9IHNvcnRNb2RpZmllcnMobW9kaWZpZXJzKS5qb2luKCc6Jyk7XG4gICAgY29uc3QgbW9kaWZpZXJJZCA9IGhhc0ltcG9ydGFudE1vZGlmaWVyID8gdmFyaWFudE1vZGlmaWVyICsgSU1QT1JUQU5UX01PRElGSUVSIDogdmFyaWFudE1vZGlmaWVyO1xuICAgIHJldHVybiB7XG4gICAgICBpc1RhaWx3aW5kQ2xhc3M6IHRydWUsXG4gICAgICBtb2RpZmllcklkLFxuICAgICAgY2xhc3NHcm91cElkLFxuICAgICAgb3JpZ2luYWxDbGFzc05hbWUsXG4gICAgICBoYXNQb3N0Zml4TW9kaWZpZXJcbiAgICB9O1xuICB9KS5yZXZlcnNlKClcbiAgLy8gTGFzdCBjbGFzcyBpbiBjb25mbGljdCB3aW5zLCBzbyB3ZSBuZWVkIHRvIGZpbHRlciBjb25mbGljdGluZyBjbGFzc2VzIGluIHJldmVyc2Ugb3JkZXIuXG4gIC5maWx0ZXIocGFyc2VkID0+IHtcbiAgICBpZiAoIXBhcnNlZC5pc1RhaWx3aW5kQ2xhc3MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBtb2RpZmllcklkLFxuICAgICAgY2xhc3NHcm91cElkLFxuICAgICAgaGFzUG9zdGZpeE1vZGlmaWVyXG4gICAgfSA9IHBhcnNlZDtcbiAgICBjb25zdCBjbGFzc0lkID0gbW9kaWZpZXJJZCArIGNsYXNzR3JvdXBJZDtcbiAgICBpZiAoY2xhc3NHcm91cHNJbkNvbmZsaWN0LmhhcyhjbGFzc0lkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjbGFzc0dyb3Vwc0luQ29uZmxpY3QuYWRkKGNsYXNzSWQpO1xuICAgIGdldENvbmZsaWN0aW5nQ2xhc3NHcm91cElkcyhjbGFzc0dyb3VwSWQsIGhhc1Bvc3RmaXhNb2RpZmllcikuZm9yRWFjaChncm91cCA9PiBjbGFzc0dyb3Vwc0luQ29uZmxpY3QuYWRkKG1vZGlmaWVySWQgKyBncm91cCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9KS5yZXZlcnNlKCkubWFwKHBhcnNlZCA9PiBwYXJzZWQub3JpZ2luYWxDbGFzc05hbWUpLmpvaW4oJyAnKTtcbn1cblxuLyoqXG4gKiBUaGUgY29kZSBpbiB0aGlzIGZpbGUgaXMgY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2x1a2VlZC9jbHN4IGFuZCBtb2RpZmllZCB0byBzdWl0IHRoZSBuZWVkcyBvZiB0YWlsd2luZC1tZXJnZSBiZXR0ZXIuXG4gKlxuICogU3BlY2lmaWNhbGx5OlxuICogLSBSdW50aW1lIGNvZGUgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbHVrZWVkL2Nsc3gvYmxvYi92MS4yLjEvc3JjL2luZGV4LmpzXG4gKiAtIFR5cGVTY3JpcHQgdHlwZXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbHVrZWVkL2Nsc3gvYmxvYi92MS4yLjEvY2xzeC5kLnRzXG4gKlxuICogT3JpZ2luYWwgY29kZSBoYXMgTUlUIGxpY2Vuc2U6IENvcHlyaWdodCAoYykgTHVrZSBFZHdhcmRzIDxsdWtlLmVkd2FyZHMwNUBnbWFpbC5jb20+IChsdWtlZWQuY29tKVxuICovXG5mdW5jdGlvbiB0d0pvaW4oKSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBhcmd1bWVudDtcbiAgbGV0IHJlc29sdmVkVmFsdWU7XG4gIGxldCBzdHJpbmcgPSAnJztcbiAgd2hpbGUgKGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGlmIChhcmd1bWVudCA9IGFyZ3VtZW50c1tpbmRleCsrXSkge1xuICAgICAgaWYgKHJlc29sdmVkVmFsdWUgPSB0b1ZhbHVlKGFyZ3VtZW50KSkge1xuICAgICAgICBzdHJpbmcgJiYgKHN0cmluZyArPSAnICcpO1xuICAgICAgICBzdHJpbmcgKz0gcmVzb2x2ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cmluZztcbn1cbmZ1bmN0aW9uIHRvVmFsdWUobWl4KSB7XG4gIGlmICh0eXBlb2YgbWl4ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtaXg7XG4gIH1cbiAgbGV0IHJlc29sdmVkVmFsdWU7XG4gIGxldCBzdHJpbmcgPSAnJztcbiAgZm9yIChsZXQgayA9IDA7IGsgPCBtaXgubGVuZ3RoOyBrKyspIHtcbiAgICBpZiAobWl4W2tdKSB7XG4gICAgICBpZiAocmVzb2x2ZWRWYWx1ZSA9IHRvVmFsdWUobWl4W2tdKSkge1xuICAgICAgICBzdHJpbmcgJiYgKHN0cmluZyArPSAnICcpO1xuICAgICAgICBzdHJpbmcgKz0gcmVzb2x2ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cmluZztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhaWx3aW5kTWVyZ2UoY3JlYXRlQ29uZmlnRmlyc3QsIC4uLmNyZWF0ZUNvbmZpZ1Jlc3QpIHtcbiAgbGV0IGNvbmZpZ1V0aWxzO1xuICBsZXQgY2FjaGVHZXQ7XG4gIGxldCBjYWNoZVNldDtcbiAgbGV0IGZ1bmN0aW9uVG9DYWxsID0gaW5pdFRhaWx3aW5kTWVyZ2U7XG4gIGZ1bmN0aW9uIGluaXRUYWlsd2luZE1lcmdlKGNsYXNzTGlzdCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGNyZWF0ZUNvbmZpZ1Jlc3QucmVkdWNlKChwcmV2aW91c0NvbmZpZywgY3JlYXRlQ29uZmlnQ3VycmVudCkgPT4gY3JlYXRlQ29uZmlnQ3VycmVudChwcmV2aW91c0NvbmZpZyksIGNyZWF0ZUNvbmZpZ0ZpcnN0KCkpO1xuICAgIGNvbmZpZ1V0aWxzID0gY3JlYXRlQ29uZmlnVXRpbHMoY29uZmlnKTtcbiAgICBjYWNoZUdldCA9IGNvbmZpZ1V0aWxzLmNhY2hlLmdldDtcbiAgICBjYWNoZVNldCA9IGNvbmZpZ1V0aWxzLmNhY2hlLnNldDtcbiAgICBmdW5jdGlvblRvQ2FsbCA9IHRhaWx3aW5kTWVyZ2U7XG4gICAgcmV0dXJuIHRhaWx3aW5kTWVyZ2UoY2xhc3NMaXN0KTtcbiAgfVxuICBmdW5jdGlvbiB0YWlsd2luZE1lcmdlKGNsYXNzTGlzdCkge1xuICAgIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGNhY2hlR2V0KGNsYXNzTGlzdCk7XG4gICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbWVyZ2VDbGFzc0xpc3QoY2xhc3NMaXN0LCBjb25maWdVdGlscyk7XG4gICAgY2FjaGVTZXQoY2xhc3NMaXN0LCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGNhbGxUYWlsd2luZE1lcmdlKCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvQ2FsbCh0d0pvaW4uYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gIH07XG59XG5mdW5jdGlvbiBmcm9tVGhlbWUoa2V5KSB7XG4gIGNvbnN0IHRoZW1lR2V0dGVyID0gdGhlbWUgPT4gdGhlbWVba2V5XSB8fCBbXTtcbiAgdGhlbWVHZXR0ZXIuaXNUaGVtZUdldHRlciA9IHRydWU7XG4gIHJldHVybiB0aGVtZUdldHRlcjtcbn1cbmNvbnN0IGFyYml0cmFyeVZhbHVlUmVnZXggPSAvXlxcWyg/OihbYS16LV0rKTopPyguKylcXF0kL2k7XG5jb25zdCBmcmFjdGlvblJlZ2V4ID0gL15cXGQrXFwvXFxkKyQvO1xuY29uc3Qgc3RyaW5nTGVuZ3RocyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KFsncHgnLCAnZnVsbCcsICdzY3JlZW4nXSk7XG5jb25zdCB0c2hpcnRVbml0UmVnZXggPSAvXihcXGQrKFxcLlxcZCspPyk/KHhzfHNtfG1kfGxnfHhsKSQvO1xuY29uc3QgbGVuZ3RoVW5pdFJlZ2V4ID0gL1xcZCsoJXxweHxyP2VtfFtzZGxdP3YoW2h3aWJdfG1pbnxtYXgpfHB0fHBjfGlufGNtfG1tfGNhcHxjaHxleHxyP2xofGNxKHd8aHxpfGJ8bWlufG1heCkpfFxcYihjYWxjfG1pbnxtYXh8Y2xhbXApXFwoLitcXCl8XjAkLztcbmNvbnN0IGNvbG9yRnVuY3Rpb25SZWdleCA9IC9eKHJnYmE/fGhzbGE/fGh3Ynwob2spPyhsYWJ8bGNoKSlcXCguK1xcKSQvO1xuLy8gU2hhZG93IGFsd2F5cyBiZWdpbnMgd2l0aCB4IGFuZCB5IG9mZnNldCBzZXBhcmF0ZWQgYnkgdW5kZXJzY29yZSBvcHRpb25hbGx5IHByZXBlbmRlZCBieSBpbnNldFxuY29uc3Qgc2hhZG93UmVnZXggPSAvXihpbnNldF8pPy0/KChcXGQrKT9cXC4/KFxcZCspW2Etel0rfDApXy0/KChcXGQrKT9cXC4/KFxcZCspW2Etel0rfDApLztcbmNvbnN0IGltYWdlUmVnZXggPSAvXih1cmx8aW1hZ2V8aW1hZ2Utc2V0fGNyb3NzLWZhZGV8ZWxlbWVudHwocmVwZWF0aW5nLSk/KGxpbmVhcnxyYWRpYWx8Y29uaWMpLWdyYWRpZW50KVxcKC4rXFwpJC87XG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gaXNOdW1iZXIodmFsdWUpIHx8IHN0cmluZ0xlbmd0aHMuaGFzKHZhbHVlKSB8fCBmcmFjdGlvblJlZ2V4LnRlc3QodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNBcmJpdHJhcnlMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIGdldElzQXJiaXRyYXJ5VmFsdWUodmFsdWUsICdsZW5ndGgnLCBpc0xlbmd0aE9ubHkpO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4odmFsdWUpICYmICFOdW1iZXIuaXNOYU4oTnVtYmVyKHZhbHVlKSk7XG59XG5mdW5jdGlvbiBpc0FyYml0cmFyeU51bWJlcih2YWx1ZSkge1xuICByZXR1cm4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgJ251bWJlcicsIGlzTnVtYmVyKTtcbn1cbmZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICByZXR1cm4gQm9vbGVhbih2YWx1ZSkgJiYgTnVtYmVyLmlzSW50ZWdlcihOdW1iZXIodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGlzUGVyY2VudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuZW5kc1dpdGgoJyUnKSAmJiBpc051bWJlcih2YWx1ZS5zbGljZSgwLCAtMSkpO1xufVxuZnVuY3Rpb24gaXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gYXJiaXRyYXJ5VmFsdWVSZWdleC50ZXN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzVHNoaXJ0U2l6ZSh2YWx1ZSkge1xuICByZXR1cm4gdHNoaXJ0VW5pdFJlZ2V4LnRlc3QodmFsdWUpO1xufVxuY29uc3Qgc2l6ZUxhYmVscyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KFsnbGVuZ3RoJywgJ3NpemUnLCAncGVyY2VudGFnZSddKTtcbmZ1bmN0aW9uIGlzQXJiaXRyYXJ5U2l6ZSh2YWx1ZSkge1xuICByZXR1cm4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgc2l6ZUxhYmVscywgaXNOZXZlcik7XG59XG5mdW5jdGlvbiBpc0FyYml0cmFyeVBvc2l0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBnZXRJc0FyYml0cmFyeVZhbHVlKHZhbHVlLCAncG9zaXRpb24nLCBpc05ldmVyKTtcbn1cbmNvbnN0IGltYWdlTGFiZWxzID0gLyojX19QVVJFX18qL25ldyBTZXQoWydpbWFnZScsICd1cmwnXSk7XG5mdW5jdGlvbiBpc0FyYml0cmFyeUltYWdlKHZhbHVlKSB7XG4gIHJldHVybiBnZXRJc0FyYml0cmFyeVZhbHVlKHZhbHVlLCBpbWFnZUxhYmVscywgaXNJbWFnZSk7XG59XG5mdW5jdGlvbiBpc0FyYml0cmFyeVNoYWRvdyh2YWx1ZSkge1xuICByZXR1cm4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgJycsIGlzU2hhZG93KTtcbn1cbmZ1bmN0aW9uIGlzQW55KCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldElzQXJiaXRyYXJ5VmFsdWUodmFsdWUsIGxhYmVsLCB0ZXN0VmFsdWUpIHtcbiAgY29uc3QgcmVzdWx0ID0gYXJiaXRyYXJ5VmFsdWVSZWdleC5leGVjKHZhbHVlKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHRbMV0pIHtcbiAgICAgIHJldHVybiB0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnID8gcmVzdWx0WzFdID09PSBsYWJlbCA6IGxhYmVsLmhhcyhyZXN1bHRbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGVzdFZhbHVlKHJlc3VsdFsyXSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNMZW5ndGhPbmx5KHZhbHVlKSB7XG4gIC8vIGBjb2xvckZ1bmN0aW9uUmVnZXhgIGNoZWNrIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGNvbG9yIGZ1bmN0aW9ucyBjYW4gaGF2ZSBwZXJjZW50YWdlcyBpbiB0aGVtIHdoaWNoIHdoaWNoIHdvdWxkIGJlIGluY29ycmVjdGx5IGNsYXNzaWZpZWQgYXMgbGVuZ3Rocy5cbiAgLy8gRm9yIGV4YW1wbGUsIGBoc2woMCAwJSAwJSlgIHdvdWxkIGJlIGNsYXNzaWZpZWQgYXMgYSBsZW5ndGggd2l0aG91dCB0aGlzIGNoZWNrLlxuICAvLyBJIGNvdWxkIGFsc28gdXNlIGxvb2tiZWhpbmQgYXNzZXJ0aW9uIGluIGBsZW5ndGhVbml0UmVnZXhgIGJ1dCB0aGF0IGlzbid0IHN1cHBvcnRlZCB3aWRlbHkgZW5vdWdoLlxuICByZXR1cm4gbGVuZ3RoVW5pdFJlZ2V4LnRlc3QodmFsdWUpICYmICFjb2xvckZ1bmN0aW9uUmVnZXgudGVzdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc05ldmVyKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NoYWRvdyh2YWx1ZSkge1xuICByZXR1cm4gc2hhZG93UmVnZXgudGVzdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0ltYWdlKHZhbHVlKSB7XG4gIHJldHVybiBpbWFnZVJlZ2V4LnRlc3QodmFsdWUpO1xufVxuY29uc3QgdmFsaWRhdG9ycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGlzQW55LFxuICBpc0FyYml0cmFyeUltYWdlLFxuICBpc0FyYml0cmFyeUxlbmd0aCxcbiAgaXNBcmJpdHJhcnlOdW1iZXIsXG4gIGlzQXJiaXRyYXJ5UG9zaXRpb24sXG4gIGlzQXJiaXRyYXJ5U2hhZG93LFxuICBpc0FyYml0cmFyeVNpemUsXG4gIGlzQXJiaXRyYXJ5VmFsdWUsXG4gIGlzSW50ZWdlcixcbiAgaXNMZW5ndGgsXG4gIGlzTnVtYmVyLFxuICBpc1BlcmNlbnQsXG4gIGlzVHNoaXJ0U2l6ZVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gIHZhbHVlOiAnTW9kdWxlJ1xufSk7XG5mdW5jdGlvbiBnZXREZWZhdWx0Q29uZmlnKCkge1xuICBjb25zdCBjb2xvcnMgPSBmcm9tVGhlbWUoJ2NvbG9ycycpO1xuICBjb25zdCBzcGFjaW5nID0gZnJvbVRoZW1lKCdzcGFjaW5nJyk7XG4gIGNvbnN0IGJsdXIgPSBmcm9tVGhlbWUoJ2JsdXInKTtcbiAgY29uc3QgYnJpZ2h0bmVzcyA9IGZyb21UaGVtZSgnYnJpZ2h0bmVzcycpO1xuICBjb25zdCBib3JkZXJDb2xvciA9IGZyb21UaGVtZSgnYm9yZGVyQ29sb3InKTtcbiAgY29uc3QgYm9yZGVyUmFkaXVzID0gZnJvbVRoZW1lKCdib3JkZXJSYWRpdXMnKTtcbiAgY29uc3QgYm9yZGVyU3BhY2luZyA9IGZyb21UaGVtZSgnYm9yZGVyU3BhY2luZycpO1xuICBjb25zdCBib3JkZXJXaWR0aCA9IGZyb21UaGVtZSgnYm9yZGVyV2lkdGgnKTtcbiAgY29uc3QgY29udHJhc3QgPSBmcm9tVGhlbWUoJ2NvbnRyYXN0Jyk7XG4gIGNvbnN0IGdyYXlzY2FsZSA9IGZyb21UaGVtZSgnZ3JheXNjYWxlJyk7XG4gIGNvbnN0IGh1ZVJvdGF0ZSA9IGZyb21UaGVtZSgnaHVlUm90YXRlJyk7XG4gIGNvbnN0IGludmVydCA9IGZyb21UaGVtZSgnaW52ZXJ0Jyk7XG4gIGNvbnN0IGdhcCA9IGZyb21UaGVtZSgnZ2FwJyk7XG4gIGNvbnN0IGdyYWRpZW50Q29sb3JTdG9wcyA9IGZyb21UaGVtZSgnZ3JhZGllbnRDb2xvclN0b3BzJyk7XG4gIGNvbnN0IGdyYWRpZW50Q29sb3JTdG9wUG9zaXRpb25zID0gZnJvbVRoZW1lKCdncmFkaWVudENvbG9yU3RvcFBvc2l0aW9ucycpO1xuICBjb25zdCBpbnNldCA9IGZyb21UaGVtZSgnaW5zZXQnKTtcbiAgY29uc3QgbWFyZ2luID0gZnJvbVRoZW1lKCdtYXJnaW4nKTtcbiAgY29uc3Qgb3BhY2l0eSA9IGZyb21UaGVtZSgnb3BhY2l0eScpO1xuICBjb25zdCBwYWRkaW5nID0gZnJvbVRoZW1lKCdwYWRkaW5nJyk7XG4gIGNvbnN0IHNhdHVyYXRlID0gZnJvbVRoZW1lKCdzYXR1cmF0ZScpO1xuICBjb25zdCBzY2FsZSA9IGZyb21UaGVtZSgnc2NhbGUnKTtcbiAgY29uc3Qgc2VwaWEgPSBmcm9tVGhlbWUoJ3NlcGlhJyk7XG4gIGNvbnN0IHNrZXcgPSBmcm9tVGhlbWUoJ3NrZXcnKTtcbiAgY29uc3Qgc3BhY2UgPSBmcm9tVGhlbWUoJ3NwYWNlJyk7XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IGZyb21UaGVtZSgndHJhbnNsYXRlJyk7XG4gIGNvbnN0IGdldE92ZXJzY3JvbGwgPSAoKSA9PiBbJ2F1dG8nLCAnY29udGFpbicsICdub25lJ107XG4gIGNvbnN0IGdldE92ZXJmbG93ID0gKCkgPT4gWydhdXRvJywgJ2hpZGRlbicsICdjbGlwJywgJ3Zpc2libGUnLCAnc2Nyb2xsJ107XG4gIGNvbnN0IGdldFNwYWNpbmdXaXRoQXV0b0FuZEFyYml0cmFyeSA9ICgpID0+IFsnYXV0bycsIGlzQXJiaXRyYXJ5VmFsdWUsIHNwYWNpbmddO1xuICBjb25zdCBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSA9ICgpID0+IFtpc0FyYml0cmFyeVZhbHVlLCBzcGFjaW5nXTtcbiAgY29uc3QgZ2V0TGVuZ3RoV2l0aEVtcHR5QW5kQXJiaXRyYXJ5ID0gKCkgPT4gWycnLCBpc0xlbmd0aCwgaXNBcmJpdHJhcnlMZW5ndGhdO1xuICBjb25zdCBnZXROdW1iZXJXaXRoQXV0b0FuZEFyYml0cmFyeSA9ICgpID0+IFsnYXV0bycsIGlzTnVtYmVyLCBpc0FyYml0cmFyeVZhbHVlXTtcbiAgY29uc3QgZ2V0UG9zaXRpb25zID0gKCkgPT4gWydib3R0b20nLCAnY2VudGVyJywgJ2xlZnQnLCAnbGVmdC1ib3R0b20nLCAnbGVmdC10b3AnLCAncmlnaHQnLCAncmlnaHQtYm90dG9tJywgJ3JpZ2h0LXRvcCcsICd0b3AnXTtcbiAgY29uc3QgZ2V0TGluZVN0eWxlcyA9ICgpID0+IFsnc29saWQnLCAnZGFzaGVkJywgJ2RvdHRlZCcsICdkb3VibGUnLCAnbm9uZSddO1xuICBjb25zdCBnZXRCbGVuZE1vZGVzID0gKCkgPT4gWydub3JtYWwnLCAnbXVsdGlwbHknLCAnc2NyZWVuJywgJ292ZXJsYXknLCAnZGFya2VuJywgJ2xpZ2h0ZW4nLCAnY29sb3ItZG9kZ2UnLCAnY29sb3ItYnVybicsICdoYXJkLWxpZ2h0JywgJ3NvZnQtbGlnaHQnLCAnZGlmZmVyZW5jZScsICdleGNsdXNpb24nLCAnaHVlJywgJ3NhdHVyYXRpb24nLCAnY29sb3InLCAnbHVtaW5vc2l0eScsICdwbHVzLWxpZ2h0ZXInXTtcbiAgY29uc3QgZ2V0QWxpZ24gPSAoKSA9PiBbJ3N0YXJ0JywgJ2VuZCcsICdjZW50ZXInLCAnYmV0d2VlbicsICdhcm91bmQnLCAnZXZlbmx5JywgJ3N0cmV0Y2gnXTtcbiAgY29uc3QgZ2V0WmVyb0FuZEVtcHR5ID0gKCkgPT4gWycnLCAnMCcsIGlzQXJiaXRyYXJ5VmFsdWVdO1xuICBjb25zdCBnZXRCcmVha3MgPSAoKSA9PiBbJ2F1dG8nLCAnYXZvaWQnLCAnYWxsJywgJ2F2b2lkLXBhZ2UnLCAncGFnZScsICdsZWZ0JywgJ3JpZ2h0JywgJ2NvbHVtbiddO1xuICBjb25zdCBnZXROdW1iZXIgPSAoKSA9PiBbaXNOdW1iZXIsIGlzQXJiaXRyYXJ5TnVtYmVyXTtcbiAgY29uc3QgZ2V0TnVtYmVyQW5kQXJiaXRyYXJ5ID0gKCkgPT4gW2lzTnVtYmVyLCBpc0FyYml0cmFyeVZhbHVlXTtcbiAgcmV0dXJuIHtcbiAgICBjYWNoZVNpemU6IDUwMCxcbiAgICBzZXBhcmF0b3I6ICc6JyxcbiAgICB0aGVtZToge1xuICAgICAgY29sb3JzOiBbaXNBbnldLFxuICAgICAgc3BhY2luZzogW2lzTGVuZ3RoLCBpc0FyYml0cmFyeUxlbmd0aF0sXG4gICAgICBibHVyOiBbJ25vbmUnLCAnJywgaXNUc2hpcnRTaXplLCBpc0FyYml0cmFyeVZhbHVlXSxcbiAgICAgIGJyaWdodG5lc3M6IGdldE51bWJlcigpLFxuICAgICAgYm9yZGVyQ29sb3I6IFtjb2xvcnNdLFxuICAgICAgYm9yZGVyUmFkaXVzOiBbJ25vbmUnLCAnJywgJ2Z1bGwnLCBpc1RzaGlydFNpemUsIGlzQXJiaXRyYXJ5VmFsdWVdLFxuICAgICAgYm9yZGVyU3BhY2luZzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKSxcbiAgICAgIGJvcmRlcldpZHRoOiBnZXRMZW5ndGhXaXRoRW1wdHlBbmRBcmJpdHJhcnkoKSxcbiAgICAgIGNvbnRyYXN0OiBnZXROdW1iZXIoKSxcbiAgICAgIGdyYXlzY2FsZTogZ2V0WmVyb0FuZEVtcHR5KCksXG4gICAgICBodWVSb3RhdGU6IGdldE51bWJlckFuZEFyYml0cmFyeSgpLFxuICAgICAgaW52ZXJ0OiBnZXRaZXJvQW5kRW1wdHkoKSxcbiAgICAgIGdhcDogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKSxcbiAgICAgIGdyYWRpZW50Q29sb3JTdG9wczogW2NvbG9yc10sXG4gICAgICBncmFkaWVudENvbG9yU3RvcFBvc2l0aW9uczogW2lzUGVyY2VudCwgaXNBcmJpdHJhcnlMZW5ndGhdLFxuICAgICAgaW5zZXQ6IGdldFNwYWNpbmdXaXRoQXV0b0FuZEFyYml0cmFyeSgpLFxuICAgICAgbWFyZ2luOiBnZXRTcGFjaW5nV2l0aEF1dG9BbmRBcmJpdHJhcnkoKSxcbiAgICAgIG9wYWNpdHk6IGdldE51bWJlcigpLFxuICAgICAgcGFkZGluZzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKSxcbiAgICAgIHNhdHVyYXRlOiBnZXROdW1iZXIoKSxcbiAgICAgIHNjYWxlOiBnZXROdW1iZXIoKSxcbiAgICAgIHNlcGlhOiBnZXRaZXJvQW5kRW1wdHkoKSxcbiAgICAgIHNrZXc6IGdldE51bWJlckFuZEFyYml0cmFyeSgpLFxuICAgICAgc3BhY2U6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KCksXG4gICAgICB0cmFuc2xhdGU6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICB9LFxuICAgIGNsYXNzR3JvdXBzOiB7XG4gICAgICAvLyBMYXlvdXRcbiAgICAgIC8qKlxuICAgICAgICogQXNwZWN0IFJhdGlvXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYXNwZWN0LXJhdGlvXG4gICAgICAgKi9cbiAgICAgIGFzcGVjdDogW3tcbiAgICAgICAgYXNwZWN0OiBbJ2F1dG8nLCAnc3F1YXJlJywgJ3ZpZGVvJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDb250YWluZXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jb250YWluZXJcbiAgICAgICAqL1xuICAgICAgY29udGFpbmVyOiBbJ2NvbnRhaW5lciddLFxuICAgICAgLyoqXG4gICAgICAgKiBDb2x1bW5zXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY29sdW1uc1xuICAgICAgICovXG4gICAgICBjb2x1bW5zOiBbe1xuICAgICAgICBjb2x1bW5zOiBbaXNUc2hpcnRTaXplXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJyZWFrIEFmdGVyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYnJlYWstYWZ0ZXJcbiAgICAgICAqL1xuICAgICAgJ2JyZWFrLWFmdGVyJzogW3tcbiAgICAgICAgJ2JyZWFrLWFmdGVyJzogZ2V0QnJlYWtzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCcmVhayBCZWZvcmVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9icmVhay1iZWZvcmVcbiAgICAgICAqL1xuICAgICAgJ2JyZWFrLWJlZm9yZSc6IFt7XG4gICAgICAgICdicmVhay1iZWZvcmUnOiBnZXRCcmVha3MoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJyZWFrIEluc2lkZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JyZWFrLWluc2lkZVxuICAgICAgICovXG4gICAgICAnYnJlYWstaW5zaWRlJzogW3tcbiAgICAgICAgJ2JyZWFrLWluc2lkZSc6IFsnYXV0bycsICdhdm9pZCcsICdhdm9pZC1wYWdlJywgJ2F2b2lkLWNvbHVtbiddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm94IERlY29yYXRpb24gQnJlYWtcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3gtZGVjb3JhdGlvbi1icmVha1xuICAgICAgICovXG4gICAgICAnYm94LWRlY29yYXRpb24nOiBbe1xuICAgICAgICAnYm94LWRlY29yYXRpb24nOiBbJ3NsaWNlJywgJ2Nsb25lJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3ggU2l6aW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm94LXNpemluZ1xuICAgICAgICovXG4gICAgICBib3g6IFt7XG4gICAgICAgIGJveDogWydib3JkZXInLCAnY29udGVudCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGlzcGxheVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2Rpc3BsYXlcbiAgICAgICAqL1xuICAgICAgZGlzcGxheTogWydibG9jaycsICdpbmxpbmUtYmxvY2snLCAnaW5saW5lJywgJ2ZsZXgnLCAnaW5saW5lLWZsZXgnLCAndGFibGUnLCAnaW5saW5lLXRhYmxlJywgJ3RhYmxlLWNhcHRpb24nLCAndGFibGUtY2VsbCcsICd0YWJsZS1jb2x1bW4nLCAndGFibGUtY29sdW1uLWdyb3VwJywgJ3RhYmxlLWZvb3Rlci1ncm91cCcsICd0YWJsZS1oZWFkZXItZ3JvdXAnLCAndGFibGUtcm93LWdyb3VwJywgJ3RhYmxlLXJvdycsICdmbG93LXJvb3QnLCAnZ3JpZCcsICdpbmxpbmUtZ3JpZCcsICdjb250ZW50cycsICdsaXN0LWl0ZW0nLCAnaGlkZGVuJ10sXG4gICAgICAvKipcbiAgICAgICAqIEZsb2F0c1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2Zsb2F0XG4gICAgICAgKi9cbiAgICAgIGZsb2F0OiBbe1xuICAgICAgICBmbG9hdDogWydyaWdodCcsICdsZWZ0JywgJ25vbmUnLCAnc3RhcnQnLCAnZW5kJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDbGVhclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NsZWFyXG4gICAgICAgKi9cbiAgICAgIGNsZWFyOiBbe1xuICAgICAgICBjbGVhcjogWydsZWZ0JywgJ3JpZ2h0JywgJ2JvdGgnLCAnbm9uZScsICdzdGFydCcsICdlbmQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIElzb2xhdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2lzb2xhdGlvblxuICAgICAgICovXG4gICAgICBpc29sYXRpb246IFsnaXNvbGF0ZScsICdpc29sYXRpb24tYXV0byddLFxuICAgICAgLyoqXG4gICAgICAgKiBPYmplY3QgRml0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb2JqZWN0LWZpdFxuICAgICAgICovXG4gICAgICAnb2JqZWN0LWZpdCc6IFt7XG4gICAgICAgIG9iamVjdDogWydjb250YWluJywgJ2NvdmVyJywgJ2ZpbGwnLCAnbm9uZScsICdzY2FsZS1kb3duJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPYmplY3QgUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vYmplY3QtcG9zaXRpb25cbiAgICAgICAqL1xuICAgICAgJ29iamVjdC1wb3NpdGlvbic6IFt7XG4gICAgICAgIG9iamVjdDogWy4uLmdldFBvc2l0aW9ucygpLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJmbG93XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcmZsb3dcbiAgICAgICAqL1xuICAgICAgb3ZlcmZsb3c6IFt7XG4gICAgICAgIG92ZXJmbG93OiBnZXRPdmVyZmxvdygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcmZsb3cgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJmbG93XG4gICAgICAgKi9cbiAgICAgICdvdmVyZmxvdy14JzogW3tcbiAgICAgICAgJ292ZXJmbG93LXgnOiBnZXRPdmVyZmxvdygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcmZsb3cgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJmbG93XG4gICAgICAgKi9cbiAgICAgICdvdmVyZmxvdy15JzogW3tcbiAgICAgICAgJ292ZXJmbG93LXknOiBnZXRPdmVyZmxvdygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnNjcm9sbCBCZWhhdmlvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJzY3JvbGwtYmVoYXZpb3JcbiAgICAgICAqL1xuICAgICAgb3ZlcnNjcm9sbDogW3tcbiAgICAgICAgb3ZlcnNjcm9sbDogZ2V0T3ZlcnNjcm9sbCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnNjcm9sbCBCZWhhdmlvciBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcnNjcm9sbC1iZWhhdmlvclxuICAgICAgICovXG4gICAgICAnb3ZlcnNjcm9sbC14JzogW3tcbiAgICAgICAgJ292ZXJzY3JvbGwteCc6IGdldE92ZXJzY3JvbGwoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJzY3JvbGwgQmVoYXZpb3IgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJzY3JvbGwtYmVoYXZpb3JcbiAgICAgICAqL1xuICAgICAgJ292ZXJzY3JvbGwteSc6IFt7XG4gICAgICAgICdvdmVyc2Nyb2xsLXknOiBnZXRPdmVyc2Nyb2xsKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Bvc2l0aW9uXG4gICAgICAgKi9cbiAgICAgIHBvc2l0aW9uOiBbJ3N0YXRpYycsICdmaXhlZCcsICdhYnNvbHV0ZScsICdyZWxhdGl2ZScsICdzdGlja3knXSxcbiAgICAgIC8qKlxuICAgICAgICogVG9wIC8gUmlnaHQgLyBCb3R0b20gLyBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIGluc2V0OiBbe1xuICAgICAgICBpbnNldDogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJpZ2h0IC8gTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICAnaW5zZXQteCc6IFt7XG4gICAgICAgICdpbnNldC14JzogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRvcCAvIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICAnaW5zZXQteSc6IFt7XG4gICAgICAgICdpbnNldC15JzogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIHN0YXJ0OiBbe1xuICAgICAgICBzdGFydDogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICBlbmQ6IFt7XG4gICAgICAgIGVuZDogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICB0b3A6IFt7XG4gICAgICAgIHRvcDogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIHJpZ2h0OiBbe1xuICAgICAgICByaWdodDogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICBib3R0b206IFt7XG4gICAgICAgIGJvdHRvbTogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgbGVmdDogW3tcbiAgICAgICAgbGVmdDogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFZpc2liaWxpdHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy92aXNpYmlsaXR5XG4gICAgICAgKi9cbiAgICAgIHZpc2liaWxpdHk6IFsndmlzaWJsZScsICdpbnZpc2libGUnLCAnY29sbGFwc2UnXSxcbiAgICAgIC8qKlxuICAgICAgICogWi1JbmRleFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3otaW5kZXhcbiAgICAgICAqL1xuICAgICAgejogW3tcbiAgICAgICAgejogWydhdXRvJywgaXNJbnRlZ2VyLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvLyBGbGV4Ym94IGFuZCBHcmlkXG4gICAgICAvKipcbiAgICAgICAqIEZsZXggQmFzaXNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbGV4LWJhc2lzXG4gICAgICAgKi9cbiAgICAgIGJhc2lzOiBbe1xuICAgICAgICBiYXNpczogZ2V0U3BhY2luZ1dpdGhBdXRvQW5kQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4IERpcmVjdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXgtZGlyZWN0aW9uXG4gICAgICAgKi9cbiAgICAgICdmbGV4LWRpcmVjdGlvbic6IFt7XG4gICAgICAgIGZsZXg6IFsncm93JywgJ3Jvdy1yZXZlcnNlJywgJ2NvbCcsICdjb2wtcmV2ZXJzZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRmxleCBXcmFwXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleC13cmFwXG4gICAgICAgKi9cbiAgICAgICdmbGV4LXdyYXAnOiBbe1xuICAgICAgICBmbGV4OiBbJ3dyYXAnLCAnd3JhcC1yZXZlcnNlJywgJ25vd3JhcCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRmxleFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXhcbiAgICAgICAqL1xuICAgICAgZmxleDogW3tcbiAgICAgICAgZmxleDogWycxJywgJ2F1dG8nLCAnaW5pdGlhbCcsICdub25lJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4IEdyb3dcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbGV4LWdyb3dcbiAgICAgICAqL1xuICAgICAgZ3JvdzogW3tcbiAgICAgICAgZ3JvdzogZ2V0WmVyb0FuZEVtcHR5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4IFNocmlua1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXgtc2hyaW5rXG4gICAgICAgKi9cbiAgICAgIHNocmluazogW3tcbiAgICAgICAgc2hyaW5rOiBnZXRaZXJvQW5kRW1wdHkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE9yZGVyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3JkZXJcbiAgICAgICAqL1xuICAgICAgb3JkZXI6IFt7XG4gICAgICAgIG9yZGVyOiBbJ2ZpcnN0JywgJ2xhc3QnLCAnbm9uZScsIGlzSW50ZWdlciwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIFRlbXBsYXRlIENvbHVtbnNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLXRlbXBsYXRlLWNvbHVtbnNcbiAgICAgICAqL1xuICAgICAgJ2dyaWQtY29scyc6IFt7XG4gICAgICAgICdncmlkLWNvbHMnOiBbaXNBbnldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBDb2x1bW4gU3RhcnQgLyBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLWNvbHVtblxuICAgICAgICovXG4gICAgICAnY29sLXN0YXJ0LWVuZCc6IFt7XG4gICAgICAgIGNvbDogWydhdXRvJywge1xuICAgICAgICAgIHNwYW46IFsnZnVsbCcsIGlzSW50ZWdlciwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgICAgfSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIENvbHVtbiBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtY29sdW1uXG4gICAgICAgKi9cbiAgICAgICdjb2wtc3RhcnQnOiBbe1xuICAgICAgICAnY29sLXN0YXJ0JzogZ2V0TnVtYmVyV2l0aEF1dG9BbmRBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgQ29sdW1uIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtY29sdW1uXG4gICAgICAgKi9cbiAgICAgICdjb2wtZW5kJzogW3tcbiAgICAgICAgJ2NvbC1lbmQnOiBnZXROdW1iZXJXaXRoQXV0b0FuZEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBUZW1wbGF0ZSBSb3dzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC10ZW1wbGF0ZS1yb3dzXG4gICAgICAgKi9cbiAgICAgICdncmlkLXJvd3MnOiBbe1xuICAgICAgICAnZ3JpZC1yb3dzJzogW2lzQW55XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgUm93IFN0YXJ0IC8gRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1yb3dcbiAgICAgICAqL1xuICAgICAgJ3Jvdy1zdGFydC1lbmQnOiBbe1xuICAgICAgICByb3c6IFsnYXV0bycsIHtcbiAgICAgICAgICBzcGFuOiBbaXNJbnRlZ2VyLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgICB9LCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgUm93IFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1yb3dcbiAgICAgICAqL1xuICAgICAgJ3Jvdy1zdGFydCc6IFt7XG4gICAgICAgICdyb3ctc3RhcnQnOiBnZXROdW1iZXJXaXRoQXV0b0FuZEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBSb3cgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1yb3dcbiAgICAgICAqL1xuICAgICAgJ3Jvdy1lbmQnOiBbe1xuICAgICAgICAncm93LWVuZCc6IGdldE51bWJlcldpdGhBdXRvQW5kQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIEF1dG8gRmxvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtYXV0by1mbG93XG4gICAgICAgKi9cbiAgICAgICdncmlkLWZsb3cnOiBbe1xuICAgICAgICAnZ3JpZC1mbG93JzogWydyb3cnLCAnY29sJywgJ2RlbnNlJywgJ3Jvdy1kZW5zZScsICdjb2wtZGVuc2UnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgQXV0byBDb2x1bW5zXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1hdXRvLWNvbHVtbnNcbiAgICAgICAqL1xuICAgICAgJ2F1dG8tY29scyc6IFt7XG4gICAgICAgICdhdXRvLWNvbHMnOiBbJ2F1dG8nLCAnbWluJywgJ21heCcsICdmcicsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBBdXRvIFJvd3NcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLWF1dG8tcm93c1xuICAgICAgICovXG4gICAgICAnYXV0by1yb3dzJzogW3tcbiAgICAgICAgJ2F1dG8tcm93cyc6IFsnYXV0bycsICdtaW4nLCAnbWF4JywgJ2ZyJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHYXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9nYXBcbiAgICAgICAqL1xuICAgICAgZ2FwOiBbe1xuICAgICAgICBnYXA6IFtnYXBdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR2FwIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9nYXBcbiAgICAgICAqL1xuICAgICAgJ2dhcC14JzogW3tcbiAgICAgICAgJ2dhcC14JzogW2dhcF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHYXAgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dhcFxuICAgICAgICovXG4gICAgICAnZ2FwLXknOiBbe1xuICAgICAgICAnZ2FwLXknOiBbZ2FwXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEp1c3RpZnkgQ29udGVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2p1c3RpZnktY29udGVudFxuICAgICAgICovXG4gICAgICAnanVzdGlmeS1jb250ZW50JzogW3tcbiAgICAgICAganVzdGlmeTogWydub3JtYWwnLCAuLi5nZXRBbGlnbigpXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEp1c3RpZnkgSXRlbXNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9qdXN0aWZ5LWl0ZW1zXG4gICAgICAgKi9cbiAgICAgICdqdXN0aWZ5LWl0ZW1zJzogW3tcbiAgICAgICAgJ2p1c3RpZnktaXRlbXMnOiBbJ3N0YXJ0JywgJ2VuZCcsICdjZW50ZXInLCAnc3RyZXRjaCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSnVzdGlmeSBTZWxmXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvanVzdGlmeS1zZWxmXG4gICAgICAgKi9cbiAgICAgICdqdXN0aWZ5LXNlbGYnOiBbe1xuICAgICAgICAnanVzdGlmeS1zZWxmJzogWydhdXRvJywgJ3N0YXJ0JywgJ2VuZCcsICdjZW50ZXInLCAnc3RyZXRjaCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQWxpZ24gQ29udGVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FsaWduLWNvbnRlbnRcbiAgICAgICAqL1xuICAgICAgJ2FsaWduLWNvbnRlbnQnOiBbe1xuICAgICAgICBjb250ZW50OiBbJ25vcm1hbCcsIC4uLmdldEFsaWduKCksICdiYXNlbGluZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQWxpZ24gSXRlbXNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hbGlnbi1pdGVtc1xuICAgICAgICovXG4gICAgICAnYWxpZ24taXRlbXMnOiBbe1xuICAgICAgICBpdGVtczogWydzdGFydCcsICdlbmQnLCAnY2VudGVyJywgJ2Jhc2VsaW5lJywgJ3N0cmV0Y2gnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEFsaWduIFNlbGZcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hbGlnbi1zZWxmXG4gICAgICAgKi9cbiAgICAgICdhbGlnbi1zZWxmJzogW3tcbiAgICAgICAgc2VsZjogWydhdXRvJywgJ3N0YXJ0JywgJ2VuZCcsICdjZW50ZXInLCAnc3RyZXRjaCcsICdiYXNlbGluZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGxhY2UgQ29udGVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BsYWNlLWNvbnRlbnRcbiAgICAgICAqL1xuICAgICAgJ3BsYWNlLWNvbnRlbnQnOiBbe1xuICAgICAgICAncGxhY2UtY29udGVudCc6IFsuLi5nZXRBbGlnbigpLCAnYmFzZWxpbmUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBsYWNlIEl0ZW1zXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGxhY2UtaXRlbXNcbiAgICAgICAqL1xuICAgICAgJ3BsYWNlLWl0ZW1zJzogW3tcbiAgICAgICAgJ3BsYWNlLWl0ZW1zJzogWydzdGFydCcsICdlbmQnLCAnY2VudGVyJywgJ2Jhc2VsaW5lJywgJ3N0cmV0Y2gnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBsYWNlIFNlbGZcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wbGFjZS1zZWxmXG4gICAgICAgKi9cbiAgICAgICdwbGFjZS1zZWxmJzogW3tcbiAgICAgICAgJ3BsYWNlLXNlbGYnOiBbJ2F1dG8nLCAnc3RhcnQnLCAnZW5kJywgJ2NlbnRlcicsICdzdHJldGNoJ11cbiAgICAgIH1dLFxuICAgICAgLy8gU3BhY2luZ1xuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBwOiBbe1xuICAgICAgICBwOiBbcGFkZGluZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHB4OiBbe1xuICAgICAgICBweDogW3BhZGRpbmddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBweTogW3tcbiAgICAgICAgcHk6IFtwYWRkaW5nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHBzOiBbe1xuICAgICAgICBwczogW3BhZGRpbmddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHBlOiBbe1xuICAgICAgICBwZTogW3BhZGRpbmddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHB0OiBbe1xuICAgICAgICBwdDogW3BhZGRpbmddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcHI6IFt7XG4gICAgICAgIHByOiBbcGFkZGluZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcGI6IFt7XG4gICAgICAgIHBiOiBbcGFkZGluZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHBsOiBbe1xuICAgICAgICBwbDogW3BhZGRpbmddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG06IFt7XG4gICAgICAgIG06IFttYXJnaW5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbXg6IFt7XG4gICAgICAgIG14OiBbbWFyZ2luXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG15OiBbe1xuICAgICAgICBteTogW21hcmdpbl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbXM6IFt7XG4gICAgICAgIG1zOiBbbWFyZ2luXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbWU6IFt7XG4gICAgICAgIG1lOiBbbWFyZ2luXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbXQ6IFt7XG4gICAgICAgIG10OiBbbWFyZ2luXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtcjogW3tcbiAgICAgICAgbXI6IFttYXJnaW5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtYjogW3tcbiAgICAgICAgbWI6IFttYXJnaW5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbWw6IFt7XG4gICAgICAgIG1sOiBbbWFyZ2luXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNwYWNlIEJldHdlZW4gWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NwYWNlXG4gICAgICAgKi9cbiAgICAgICdzcGFjZS14JzogW3tcbiAgICAgICAgJ3NwYWNlLXgnOiBbc3BhY2VdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU3BhY2UgQmV0d2VlbiBYIFJldmVyc2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zcGFjZVxuICAgICAgICovXG4gICAgICAnc3BhY2UteC1yZXZlcnNlJzogWydzcGFjZS14LXJldmVyc2UnXSxcbiAgICAgIC8qKlxuICAgICAgICogU3BhY2UgQmV0d2VlbiBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc3BhY2VcbiAgICAgICAqL1xuICAgICAgJ3NwYWNlLXknOiBbe1xuICAgICAgICAnc3BhY2UteSc6IFtzcGFjZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTcGFjZSBCZXR3ZWVuIFkgUmV2ZXJzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NwYWNlXG4gICAgICAgKi9cbiAgICAgICdzcGFjZS15LXJldmVyc2UnOiBbJ3NwYWNlLXktcmV2ZXJzZSddLFxuICAgICAgLy8gU2l6aW5nXG4gICAgICAvKipcbiAgICAgICAqIFdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvd2lkdGhcbiAgICAgICAqL1xuICAgICAgdzogW3tcbiAgICAgICAgdzogWydhdXRvJywgJ21pbicsICdtYXgnLCAnZml0JywgJ3N2dycsICdsdncnLCAnZHZ3JywgaXNBcmJpdHJhcnlWYWx1ZSwgc3BhY2luZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNaW4tV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9taW4td2lkdGhcbiAgICAgICAqL1xuICAgICAgJ21pbi13JzogW3tcbiAgICAgICAgJ21pbi13JzogW2lzQXJiaXRyYXJ5VmFsdWUsIHNwYWNpbmcsICdtaW4nLCAnbWF4JywgJ2ZpdCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWF4LVdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWF4LXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdtYXgtdyc6IFt7XG4gICAgICAgICdtYXgtdyc6IFtpc0FyYml0cmFyeVZhbHVlLCBzcGFjaW5nLCAnbm9uZScsICdmdWxsJywgJ21pbicsICdtYXgnLCAnZml0JywgJ3Byb3NlJywge1xuICAgICAgICAgIHNjcmVlbjogW2lzVHNoaXJ0U2l6ZV1cbiAgICAgICAgfSwgaXNUc2hpcnRTaXplXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEhlaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2hlaWdodFxuICAgICAgICovXG4gICAgICBoOiBbe1xuICAgICAgICBoOiBbaXNBcmJpdHJhcnlWYWx1ZSwgc3BhY2luZywgJ2F1dG8nLCAnbWluJywgJ21heCcsICdmaXQnLCAnc3ZoJywgJ2x2aCcsICdkdmgnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1pbi1IZWlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9taW4taGVpZ2h0XG4gICAgICAgKi9cbiAgICAgICdtaW4taCc6IFt7XG4gICAgICAgICdtaW4taCc6IFtpc0FyYml0cmFyeVZhbHVlLCBzcGFjaW5nLCAnbWluJywgJ21heCcsICdmaXQnLCAnc3ZoJywgJ2x2aCcsICdkdmgnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1heC1IZWlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXgtaGVpZ2h0XG4gICAgICAgKi9cbiAgICAgICdtYXgtaCc6IFt7XG4gICAgICAgICdtYXgtaCc6IFtpc0FyYml0cmFyeVZhbHVlLCBzcGFjaW5nLCAnbWluJywgJ21heCcsICdmaXQnLCAnc3ZoJywgJ2x2aCcsICdkdmgnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNpemVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zaXplXG4gICAgICAgKi9cbiAgICAgIHNpemU6IFt7XG4gICAgICAgIHNpemU6IFtpc0FyYml0cmFyeVZhbHVlLCBzcGFjaW5nLCAnYXV0bycsICdtaW4nLCAnbWF4JywgJ2ZpdCddXG4gICAgICB9XSxcbiAgICAgIC8vIFR5cG9ncmFwaHlcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBTaXplXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC1zaXplXG4gICAgICAgKi9cbiAgICAgICdmb250LXNpemUnOiBbe1xuICAgICAgICB0ZXh0OiBbJ2Jhc2UnLCBpc1RzaGlydFNpemUsIGlzQXJiaXRyYXJ5TGVuZ3RoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgU21vb3RoaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC1zbW9vdGhpbmdcbiAgICAgICAqL1xuICAgICAgJ2ZvbnQtc21vb3RoaW5nJzogWydhbnRpYWxpYXNlZCcsICdzdWJwaXhlbC1hbnRpYWxpYXNlZCddLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFN0eWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC1zdHlsZVxuICAgICAgICovXG4gICAgICAnZm9udC1zdHlsZSc6IFsnaXRhbGljJywgJ25vdC1pdGFsaWMnXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBXZWlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXdlaWdodFxuICAgICAgICovXG4gICAgICAnZm9udC13ZWlnaHQnOiBbe1xuICAgICAgICBmb250OiBbJ3RoaW4nLCAnZXh0cmFsaWdodCcsICdsaWdodCcsICdub3JtYWwnLCAnbWVkaXVtJywgJ3NlbWlib2xkJywgJ2JvbGQnLCAnZXh0cmFib2xkJywgJ2JsYWNrJywgaXNBcmJpdHJhcnlOdW1iZXJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBGYW1pbHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LWZhbWlseVxuICAgICAgICovXG4gICAgICAnZm9udC1mYW1pbHknOiBbe1xuICAgICAgICBmb250OiBbaXNBbnldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICAnZnZuLW5vcm1hbCc6IFsnbm9ybWFsLW51bXMnXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICAnZnZuLW9yZGluYWwnOiBbJ29yZGluYWwnXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICAnZnZuLXNsYXNoZWQtemVybyc6IFsnc2xhc2hlZC16ZXJvJ10sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgVmFyaWFudCBOdW1lcmljXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC12YXJpYW50LW51bWVyaWNcbiAgICAgICAqL1xuICAgICAgJ2Z2bi1maWd1cmUnOiBbJ2xpbmluZy1udW1zJywgJ29sZHN0eWxlLW51bXMnXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICAnZnZuLXNwYWNpbmcnOiBbJ3Byb3BvcnRpb25hbC1udW1zJywgJ3RhYnVsYXItbnVtcyddLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgKi9cbiAgICAgICdmdm4tZnJhY3Rpb24nOiBbJ2RpYWdvbmFsLWZyYWN0aW9ucycsICdzdGFja2VkLWZyYWN0b25zJ10sXG4gICAgICAvKipcbiAgICAgICAqIExldHRlciBTcGFjaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGV0dGVyLXNwYWNpbmdcbiAgICAgICAqL1xuICAgICAgdHJhY2tpbmc6IFt7XG4gICAgICAgIHRyYWNraW5nOiBbJ3RpZ2h0ZXInLCAndGlnaHQnLCAnbm9ybWFsJywgJ3dpZGUnLCAnd2lkZXInLCAnd2lkZXN0JywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaW5lIENsYW1wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGluZS1jbGFtcFxuICAgICAgICovXG4gICAgICAnbGluZS1jbGFtcCc6IFt7XG4gICAgICAgICdsaW5lLWNsYW1wJzogWydub25lJywgaXNOdW1iZXIsIGlzQXJiaXRyYXJ5TnVtYmVyXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExpbmUgSGVpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGluZS1oZWlnaHRcbiAgICAgICAqL1xuICAgICAgbGVhZGluZzogW3tcbiAgICAgICAgbGVhZGluZzogWydub25lJywgJ3RpZ2h0JywgJ3NudWcnLCAnbm9ybWFsJywgJ3JlbGF4ZWQnLCAnbG9vc2UnLCBpc0xlbmd0aCwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaXN0IFN0eWxlIEltYWdlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGlzdC1zdHlsZS1pbWFnZVxuICAgICAgICovXG4gICAgICAnbGlzdC1pbWFnZSc6IFt7XG4gICAgICAgICdsaXN0LWltYWdlJzogWydub25lJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaXN0IFN0eWxlIFR5cGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9saXN0LXN0eWxlLXR5cGVcbiAgICAgICAqL1xuICAgICAgJ2xpc3Qtc3R5bGUtdHlwZSc6IFt7XG4gICAgICAgIGxpc3Q6IFsnbm9uZScsICdkaXNjJywgJ2RlY2ltYWwnLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExpc3QgU3R5bGUgUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9saXN0LXN0eWxlLXBvc2l0aW9uXG4gICAgICAgKi9cbiAgICAgICdsaXN0LXN0eWxlLXBvc2l0aW9uJzogW3tcbiAgICAgICAgbGlzdDogWydpbnNpZGUnLCAnb3V0c2lkZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGxhY2Vob2xkZXIgQ29sb3JcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2My4wLjBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wbGFjZWhvbGRlci1jb2xvclxuICAgICAgICovXG4gICAgICAncGxhY2Vob2xkZXItY29sb3InOiBbe1xuICAgICAgICBwbGFjZWhvbGRlcjogW2NvbG9yc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQbGFjZWhvbGRlciBPcGFjaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGxhY2Vob2xkZXItb3BhY2l0eVxuICAgICAgICovXG4gICAgICAncGxhY2Vob2xkZXItb3BhY2l0eSc6IFt7XG4gICAgICAgICdwbGFjZWhvbGRlci1vcGFjaXR5JzogW29wYWNpdHldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBBbGlnbm1lbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWFsaWduXG4gICAgICAgKi9cbiAgICAgICd0ZXh0LWFsaWdubWVudCc6IFt7XG4gICAgICAgIHRleHQ6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnLCAnanVzdGlmeScsICdzdGFydCcsICdlbmQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWNvbG9yXG4gICAgICAgKi9cbiAgICAgICd0ZXh0LWNvbG9yJzogW3tcbiAgICAgICAgdGV4dDogW2NvbG9yc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IE9wYWNpdHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgJ3RleHQtb3BhY2l0eSc6IFt7XG4gICAgICAgICd0ZXh0LW9wYWNpdHknOiBbb3BhY2l0eV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IERlY29yYXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWRlY29yYXRpb25cbiAgICAgICAqL1xuICAgICAgJ3RleHQtZGVjb3JhdGlvbic6IFsndW5kZXJsaW5lJywgJ292ZXJsaW5lJywgJ2xpbmUtdGhyb3VnaCcsICduby11bmRlcmxpbmUnXSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBEZWNvcmF0aW9uIFN0eWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1kZWNvcmF0aW9uLXN0eWxlXG4gICAgICAgKi9cbiAgICAgICd0ZXh0LWRlY29yYXRpb24tc3R5bGUnOiBbe1xuICAgICAgICBkZWNvcmF0aW9uOiBbLi4uZ2V0TGluZVN0eWxlcygpLCAnd2F2eSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBEZWNvcmF0aW9uIFRoaWNrbmVzc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtZGVjb3JhdGlvbi10aGlja25lc3NcbiAgICAgICAqL1xuICAgICAgJ3RleHQtZGVjb3JhdGlvbi10aGlja25lc3MnOiBbe1xuICAgICAgICBkZWNvcmF0aW9uOiBbJ2F1dG8nLCAnZnJvbS1mb250JywgaXNMZW5ndGgsIGlzQXJiaXRyYXJ5TGVuZ3RoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgVW5kZXJsaW5lIE9mZnNldFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtdW5kZXJsaW5lLW9mZnNldFxuICAgICAgICovXG4gICAgICAndW5kZXJsaW5lLW9mZnNldCc6IFt7XG4gICAgICAgICd1bmRlcmxpbmUtb2Zmc2V0JzogWydhdXRvJywgaXNMZW5ndGgsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBEZWNvcmF0aW9uIENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1kZWNvcmF0aW9uLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICd0ZXh0LWRlY29yYXRpb24tY29sb3InOiBbe1xuICAgICAgICBkZWNvcmF0aW9uOiBbY29sb3JzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgVHJhbnNmb3JtXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC10cmFuc2Zvcm1cbiAgICAgICAqL1xuICAgICAgJ3RleHQtdHJhbnNmb3JtJzogWyd1cHBlcmNhc2UnLCAnbG93ZXJjYXNlJywgJ2NhcGl0YWxpemUnLCAnbm9ybWFsLWNhc2UnXSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBPdmVyZmxvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtb3ZlcmZsb3dcbiAgICAgICAqL1xuICAgICAgJ3RleHQtb3ZlcmZsb3cnOiBbJ3RydW5jYXRlJywgJ3RleHQtZWxsaXBzaXMnLCAndGV4dC1jbGlwJ10sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgV3JhcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtd3JhcFxuICAgICAgICovXG4gICAgICAndGV4dC13cmFwJzogW3tcbiAgICAgICAgdGV4dDogWyd3cmFwJywgJ25vd3JhcCcsICdiYWxhbmNlJywgJ3ByZXR0eSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBJbmRlbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWluZGVudFxuICAgICAgICovXG4gICAgICBpbmRlbnQ6IFt7XG4gICAgICAgIGluZGVudDogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFZlcnRpY2FsIEFsaWdubWVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3ZlcnRpY2FsLWFsaWduXG4gICAgICAgKi9cbiAgICAgICd2ZXJ0aWNhbC1hbGlnbic6IFt7XG4gICAgICAgIGFsaWduOiBbJ2Jhc2VsaW5lJywgJ3RvcCcsICdtaWRkbGUnLCAnYm90dG9tJywgJ3RleHQtdG9wJywgJ3RleHQtYm90dG9tJywgJ3N1YicsICdzdXBlcicsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogV2hpdGVzcGFjZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3doaXRlc3BhY2VcbiAgICAgICAqL1xuICAgICAgd2hpdGVzcGFjZTogW3tcbiAgICAgICAgd2hpdGVzcGFjZTogWydub3JtYWwnLCAnbm93cmFwJywgJ3ByZScsICdwcmUtbGluZScsICdwcmUtd3JhcCcsICdicmVhay1zcGFjZXMnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFdvcmQgQnJlYWtcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy93b3JkLWJyZWFrXG4gICAgICAgKi9cbiAgICAgIGJyZWFrOiBbe1xuICAgICAgICBicmVhazogWydub3JtYWwnLCAnd29yZHMnLCAnYWxsJywgJ2tlZXAnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEh5cGhlbnNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9oeXBoZW5zXG4gICAgICAgKi9cbiAgICAgIGh5cGhlbnM6IFt7XG4gICAgICAgIGh5cGhlbnM6IFsnbm9uZScsICdtYW51YWwnLCAnYXV0byddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ29udGVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NvbnRlbnRcbiAgICAgICAqL1xuICAgICAgY29udGVudDogW3tcbiAgICAgICAgY29udGVudDogWydub25lJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLy8gQmFja2dyb3VuZHNcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBBdHRhY2htZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1hdHRhY2htZW50XG4gICAgICAgKi9cbiAgICAgICdiZy1hdHRhY2htZW50JzogW3tcbiAgICAgICAgYmc6IFsnZml4ZWQnLCAnbG9jYWwnLCAnc2Nyb2xsJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIENsaXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLWNsaXBcbiAgICAgICAqL1xuICAgICAgJ2JnLWNsaXAnOiBbe1xuICAgICAgICAnYmctY2xpcCc6IFsnYm9yZGVyJywgJ3BhZGRpbmcnLCAnY29udGVudCcsICd0ZXh0J11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIE9wYWNpdHlcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2My4wLjBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgJ2JnLW9wYWNpdHknOiBbe1xuICAgICAgICAnYmctb3BhY2l0eSc6IFtvcGFjaXR5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgT3JpZ2luXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1vcmlnaW5cbiAgICAgICAqL1xuICAgICAgJ2JnLW9yaWdpbic6IFt7XG4gICAgICAgICdiZy1vcmlnaW4nOiBbJ2JvcmRlcicsICdwYWRkaW5nJywgJ2NvbnRlbnQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLXBvc2l0aW9uXG4gICAgICAgKi9cbiAgICAgICdiZy1wb3NpdGlvbic6IFt7XG4gICAgICAgIGJnOiBbLi4uZ2V0UG9zaXRpb25zKCksIGlzQXJiaXRyYXJ5UG9zaXRpb25dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBSZXBlYXRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLXJlcGVhdFxuICAgICAgICovXG4gICAgICAnYmctcmVwZWF0JzogW3tcbiAgICAgICAgYmc6IFsnbm8tcmVwZWF0Jywge1xuICAgICAgICAgIHJlcGVhdDogWycnLCAneCcsICd5JywgJ3JvdW5kJywgJ3NwYWNlJ11cbiAgICAgICAgfV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIFNpemVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLXNpemVcbiAgICAgICAqL1xuICAgICAgJ2JnLXNpemUnOiBbe1xuICAgICAgICBiZzogWydhdXRvJywgJ2NvdmVyJywgJ2NvbnRhaW4nLCBpc0FyYml0cmFyeVNpemVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBJbWFnZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtaW1hZ2VcbiAgICAgICAqL1xuICAgICAgJ2JnLWltYWdlJzogW3tcbiAgICAgICAgYmc6IFsnbm9uZScsIHtcbiAgICAgICAgICAnZ3JhZGllbnQtdG8nOiBbJ3QnLCAndHInLCAncicsICdicicsICdiJywgJ2JsJywgJ2wnLCAndGwnXVxuICAgICAgICB9LCBpc0FyYml0cmFyeUltYWdlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdiZy1jb2xvcic6IFt7XG4gICAgICAgIGJnOiBbY29sb3JzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyYWRpZW50IENvbG9yIFN0b3BzIEZyb20gUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmFkaWVudC1jb2xvci1zdG9wc1xuICAgICAgICovXG4gICAgICAnZ3JhZGllbnQtZnJvbS1wb3MnOiBbe1xuICAgICAgICBmcm9tOiBbZ3JhZGllbnRDb2xvclN0b3BQb3NpdGlvbnNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgVmlhIFBvc2l0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JhZGllbnQtY29sb3Itc3RvcHNcbiAgICAgICAqL1xuICAgICAgJ2dyYWRpZW50LXZpYS1wb3MnOiBbe1xuICAgICAgICB2aWE6IFtncmFkaWVudENvbG9yU3RvcFBvc2l0aW9uc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBUbyBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgICdncmFkaWVudC10by1wb3MnOiBbe1xuICAgICAgICB0bzogW2dyYWRpZW50Q29sb3JTdG9wUG9zaXRpb25zXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyYWRpZW50IENvbG9yIFN0b3BzIEZyb21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmFkaWVudC1jb2xvci1zdG9wc1xuICAgICAgICovXG4gICAgICAnZ3JhZGllbnQtZnJvbSc6IFt7XG4gICAgICAgIGZyb206IFtncmFkaWVudENvbG9yU3RvcHNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgVmlhXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JhZGllbnQtY29sb3Itc3RvcHNcbiAgICAgICAqL1xuICAgICAgJ2dyYWRpZW50LXZpYSc6IFt7XG4gICAgICAgIHZpYTogW2dyYWRpZW50Q29sb3JTdG9wc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBUb1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgICdncmFkaWVudC10byc6IFt7XG4gICAgICAgIHRvOiBbZ3JhZGllbnRDb2xvclN0b3BzXVxuICAgICAgfV0sXG4gICAgICAvLyBCb3JkZXJzXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgIHJvdW5kZWQ6IFt7XG4gICAgICAgIHJvdW5kZWQ6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtcyc6IFt7XG4gICAgICAgICdyb3VuZGVkLXMnOiBbYm9yZGVyUmFkaXVzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1lJzogW3tcbiAgICAgICAgJ3JvdW5kZWQtZSc6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLXQnOiBbe1xuICAgICAgICAncm91bmRlZC10JzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1yJzogW3tcbiAgICAgICAgJ3JvdW5kZWQtcic6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLWInOiBbe1xuICAgICAgICAncm91bmRlZC1iJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLWwnOiBbe1xuICAgICAgICAncm91bmRlZC1sJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFN0YXJ0IFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1zcyc6IFt7XG4gICAgICAgICdyb3VuZGVkLXNzJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFN0YXJ0IEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtc2UnOiBbe1xuICAgICAgICAncm91bmRlZC1zZSc6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBFbmQgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1lZSc6IFt7XG4gICAgICAgICdyb3VuZGVkLWVlJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIEVuZCBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtZXMnOiBbe1xuICAgICAgICAncm91bmRlZC1lcyc6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBUb3AgTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtdGwnOiBbe1xuICAgICAgICAncm91bmRlZC10bCc6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBUb3AgUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLXRyJzogW3tcbiAgICAgICAgJ3JvdW5kZWQtdHInOiBbYm9yZGVyUmFkaXVzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgQm90dG9tIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1icic6IFt7XG4gICAgICAgICdyb3VuZGVkLWJyJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIEJvdHRvbSBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1ibCc6IFt7XG4gICAgICAgICdyb3VuZGVkLWJsJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13JzogW3tcbiAgICAgICAgYm9yZGVyOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13LXgnOiBbe1xuICAgICAgICAnYm9yZGVyLXgnOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13LXknOiBbe1xuICAgICAgICAnYm9yZGVyLXknOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItdy1zJzogW3tcbiAgICAgICAgJ2JvcmRlci1zJzogW2JvcmRlcldpZHRoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13LWUnOiBbe1xuICAgICAgICAnYm9yZGVyLWUnOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXctdCc6IFt7XG4gICAgICAgICdib3JkZXItdCc6IFtib3JkZXJXaWR0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13LXInOiBbe1xuICAgICAgICAnYm9yZGVyLXInOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXctYic6IFt7XG4gICAgICAgICdib3JkZXItYic6IFtib3JkZXJXaWR0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXctbCc6IFt7XG4gICAgICAgICdib3JkZXItbCc6IFtib3JkZXJXaWR0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1vcGFjaXR5XG4gICAgICAgKi9cbiAgICAgICdib3JkZXItb3BhY2l0eSc6IFt7XG4gICAgICAgICdib3JkZXItb3BhY2l0eSc6IFtvcGFjaXR5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBTdHlsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1zdHlsZVxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXN0eWxlJzogW3tcbiAgICAgICAgYm9yZGVyOiBbLi4uZ2V0TGluZVN0eWxlcygpLCAnaGlkZGVuJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgV2lkdGggWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS13aWR0aFxuICAgICAgICovXG4gICAgICAnZGl2aWRlLXgnOiBbe1xuICAgICAgICAnZGl2aWRlLXgnOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIFdpZHRoIFggUmV2ZXJzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS13aWR0aFxuICAgICAgICovXG4gICAgICAnZGl2aWRlLXgtcmV2ZXJzZSc6IFsnZGl2aWRlLXgtcmV2ZXJzZSddLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgV2lkdGggWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS13aWR0aFxuICAgICAgICovXG4gICAgICAnZGl2aWRlLXknOiBbe1xuICAgICAgICAnZGl2aWRlLXknOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIFdpZHRoIFkgUmV2ZXJzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS13aWR0aFxuICAgICAgICovXG4gICAgICAnZGl2aWRlLXktcmV2ZXJzZSc6IFsnZGl2aWRlLXktcmV2ZXJzZSddLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS1vcGFjaXR5XG4gICAgICAgKi9cbiAgICAgICdkaXZpZGUtb3BhY2l0eSc6IFt7XG4gICAgICAgICdkaXZpZGUtb3BhY2l0eSc6IFtvcGFjaXR5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIERpdmlkZSBTdHlsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS1zdHlsZVxuICAgICAgICovXG4gICAgICAnZGl2aWRlLXN0eWxlJzogW3tcbiAgICAgICAgZGl2aWRlOiBnZXRMaW5lU3R5bGVzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1jb2xvcic6IFt7XG4gICAgICAgIGJvcmRlcjogW2JvcmRlckNvbG9yXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBDb2xvciBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItY29sb3IteCc6IFt7XG4gICAgICAgICdib3JkZXIteCc6IFtib3JkZXJDb2xvcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICAnYm9yZGVyLWNvbG9yLXknOiBbe1xuICAgICAgICAnYm9yZGVyLXknOiBbYm9yZGVyQ29sb3JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICAnYm9yZGVyLWNvbG9yLXQnOiBbe1xuICAgICAgICAnYm9yZGVyLXQnOiBbYm9yZGVyQ29sb3JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItY29sb3Itcic6IFt7XG4gICAgICAgICdib3JkZXItcic6IFtib3JkZXJDb2xvcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItY29sb3ItYic6IFt7XG4gICAgICAgICdib3JkZXItYic6IFtib3JkZXJDb2xvcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICAnYm9yZGVyLWNvbG9yLWwnOiBbe1xuICAgICAgICAnYm9yZGVyLWwnOiBbYm9yZGVyQ29sb3JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGl2aWRlLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdkaXZpZGUtY29sb3InOiBbe1xuICAgICAgICBkaXZpZGU6IFtib3JkZXJDb2xvcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdXRsaW5lIFN0eWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3V0bGluZS1zdHlsZVxuICAgICAgICovXG4gICAgICAnb3V0bGluZS1zdHlsZSc6IFt7XG4gICAgICAgIG91dGxpbmU6IFsnJywgLi4uZ2V0TGluZVN0eWxlcygpXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE91dGxpbmUgT2Zmc2V0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3V0bGluZS1vZmZzZXRcbiAgICAgICAqL1xuICAgICAgJ291dGxpbmUtb2Zmc2V0JzogW3tcbiAgICAgICAgJ291dGxpbmUtb2Zmc2V0JzogW2lzTGVuZ3RoLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE91dGxpbmUgV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdXRsaW5lLXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdvdXRsaW5lLXcnOiBbe1xuICAgICAgICBvdXRsaW5lOiBbaXNMZW5ndGgsIGlzQXJiaXRyYXJ5TGVuZ3RoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE91dGxpbmUgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdXRsaW5lLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdvdXRsaW5lLWNvbG9yJzogW3tcbiAgICAgICAgb3V0bGluZTogW2NvbG9yc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIFdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcmluZy13aWR0aFxuICAgICAgICovXG4gICAgICAncmluZy13JzogW3tcbiAgICAgICAgcmluZzogZ2V0TGVuZ3RoV2l0aEVtcHR5QW5kQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIFdpZHRoIEluc2V0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcmluZy13aWR0aFxuICAgICAgICovXG4gICAgICAncmluZy13LWluc2V0JzogWydyaW5nLWluc2V0J10sXG4gICAgICAvKipcbiAgICAgICAqIFJpbmcgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9yaW5nLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdyaW5nLWNvbG9yJzogW3tcbiAgICAgICAgcmluZzogW2NvbG9yc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIE9wYWNpdHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9yaW5nLW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgJ3Jpbmctb3BhY2l0eSc6IFt7XG4gICAgICAgICdyaW5nLW9wYWNpdHknOiBbb3BhY2l0eV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIE9mZnNldCBXaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Jpbmctb2Zmc2V0LXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdyaW5nLW9mZnNldC13JzogW3tcbiAgICAgICAgJ3Jpbmctb2Zmc2V0JzogW2lzTGVuZ3RoLCBpc0FyYml0cmFyeUxlbmd0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIE9mZnNldCBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Jpbmctb2Zmc2V0LWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdyaW5nLW9mZnNldC1jb2xvcic6IFt7XG4gICAgICAgICdyaW5nLW9mZnNldCc6IFtjb2xvcnNdXG4gICAgICB9XSxcbiAgICAgIC8vIEVmZmVjdHNcbiAgICAgIC8qKlxuICAgICAgICogQm94IFNoYWRvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaGFkb3dcbiAgICAgICAqL1xuICAgICAgc2hhZG93OiBbe1xuICAgICAgICBzaGFkb3c6IFsnJywgJ2lubmVyJywgJ25vbmUnLCBpc1RzaGlydFNpemUsIGlzQXJiaXRyYXJ5U2hhZG93XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJveCBTaGFkb3cgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3gtc2hhZG93LWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdzaGFkb3ctY29sb3InOiBbe1xuICAgICAgICBzaGFkb3c6IFtpc0FueV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPcGFjaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3BhY2l0eVxuICAgICAgICovXG4gICAgICBvcGFjaXR5OiBbe1xuICAgICAgICBvcGFjaXR5OiBbb3BhY2l0eV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNaXggQmxlbmQgTW9kZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21peC1ibGVuZC1tb2RlXG4gICAgICAgKi9cbiAgICAgICdtaXgtYmxlbmQnOiBbe1xuICAgICAgICAnbWl4LWJsZW5kJzogZ2V0QmxlbmRNb2RlcygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBCbGVuZCBNb2RlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1ibGVuZC1tb2RlXG4gICAgICAgKi9cbiAgICAgICdiZy1ibGVuZCc6IFt7XG4gICAgICAgICdiZy1ibGVuZCc6IGdldEJsZW5kTW9kZXMoKVxuICAgICAgfV0sXG4gICAgICAvLyBGaWx0ZXJzXG4gICAgICAvKipcbiAgICAgICAqIEZpbHRlclxuICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHYzLjAuMFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZpbHRlclxuICAgICAgICovXG4gICAgICBmaWx0ZXI6IFt7XG4gICAgICAgIGZpbHRlcjogWycnLCAnbm9uZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmx1clxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JsdXJcbiAgICAgICAqL1xuICAgICAgYmx1cjogW3tcbiAgICAgICAgYmx1cjogW2JsdXJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQnJpZ2h0bmVzc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JyaWdodG5lc3NcbiAgICAgICAqL1xuICAgICAgYnJpZ2h0bmVzczogW3tcbiAgICAgICAgYnJpZ2h0bmVzczogW2JyaWdodG5lc3NdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ29udHJhc3RcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jb250cmFzdFxuICAgICAgICovXG4gICAgICBjb250cmFzdDogW3tcbiAgICAgICAgY29udHJhc3Q6IFtjb250cmFzdF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEcm9wIFNoYWRvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2Ryb3Atc2hhZG93XG4gICAgICAgKi9cbiAgICAgICdkcm9wLXNoYWRvdyc6IFt7XG4gICAgICAgICdkcm9wLXNoYWRvdyc6IFsnJywgJ25vbmUnLCBpc1RzaGlydFNpemUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JheXNjYWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JheXNjYWxlXG4gICAgICAgKi9cbiAgICAgIGdyYXlzY2FsZTogW3tcbiAgICAgICAgZ3JheXNjYWxlOiBbZ3JheXNjYWxlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEh1ZSBSb3RhdGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9odWUtcm90YXRlXG4gICAgICAgKi9cbiAgICAgICdodWUtcm90YXRlJzogW3tcbiAgICAgICAgJ2h1ZS1yb3RhdGUnOiBbaHVlUm90YXRlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEludmVydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ludmVydFxuICAgICAgICovXG4gICAgICBpbnZlcnQ6IFt7XG4gICAgICAgIGludmVydDogW2ludmVydF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTYXR1cmF0ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NhdHVyYXRlXG4gICAgICAgKi9cbiAgICAgIHNhdHVyYXRlOiBbe1xuICAgICAgICBzYXR1cmF0ZTogW3NhdHVyYXRlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNlcGlhXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2VwaWFcbiAgICAgICAqL1xuICAgICAgc2VwaWE6IFt7XG4gICAgICAgIHNlcGlhOiBbc2VwaWFdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgRmlsdGVyXG4gICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjMuMC4wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3AtZmlsdGVyXG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1maWx0ZXInOiBbe1xuICAgICAgICAnYmFja2Ryb3AtZmlsdGVyJzogWycnLCAnbm9uZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgQmx1clxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWJsdXJcbiAgICAgICAqL1xuICAgICAgJ2JhY2tkcm9wLWJsdXInOiBbe1xuICAgICAgICAnYmFja2Ryb3AtYmx1cic6IFtibHVyXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEJyaWdodG5lc3NcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1icmlnaHRuZXNzXG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1icmlnaHRuZXNzJzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLWJyaWdodG5lc3MnOiBbYnJpZ2h0bmVzc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBDb250cmFzdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWNvbnRyYXN0XG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1jb250cmFzdCc6IFt7XG4gICAgICAgICdiYWNrZHJvcC1jb250cmFzdCc6IFtjb250cmFzdF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBHcmF5c2NhbGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1ncmF5c2NhbGVcbiAgICAgICAqL1xuICAgICAgJ2JhY2tkcm9wLWdyYXlzY2FsZSc6IFt7XG4gICAgICAgICdiYWNrZHJvcC1ncmF5c2NhbGUnOiBbZ3JheXNjYWxlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEh1ZSBSb3RhdGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1odWUtcm90YXRlXG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1odWUtcm90YXRlJzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLWh1ZS1yb3RhdGUnOiBbaHVlUm90YXRlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEludmVydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWludmVydFxuICAgICAgICovXG4gICAgICAnYmFja2Ryb3AtaW52ZXJ0JzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLWludmVydCc6IFtpbnZlcnRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgJ2JhY2tkcm9wLW9wYWNpdHknOiBbe1xuICAgICAgICAnYmFja2Ryb3Atb3BhY2l0eSc6IFtvcGFjaXR5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIFNhdHVyYXRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3Atc2F0dXJhdGVcbiAgICAgICAqL1xuICAgICAgJ2JhY2tkcm9wLXNhdHVyYXRlJzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLXNhdHVyYXRlJzogW3NhdHVyYXRlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIFNlcGlhXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3Atc2VwaWFcbiAgICAgICAqL1xuICAgICAgJ2JhY2tkcm9wLXNlcGlhJzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLXNlcGlhJzogW3NlcGlhXVxuICAgICAgfV0sXG4gICAgICAvLyBUYWJsZXNcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbGxhcHNlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbGxhcHNlXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItY29sbGFwc2UnOiBbe1xuICAgICAgICBib3JkZXI6IFsnY29sbGFwc2UnLCAnc2VwYXJhdGUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBTcGFjaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXNwYWNpbmdcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1zcGFjaW5nJzogW3tcbiAgICAgICAgJ2JvcmRlci1zcGFjaW5nJzogW2JvcmRlclNwYWNpbmddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFNwYWNpbmcgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1zcGFjaW5nXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItc3BhY2luZy14JzogW3tcbiAgICAgICAgJ2JvcmRlci1zcGFjaW5nLXgnOiBbYm9yZGVyU3BhY2luZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgU3BhY2luZyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXNwYWNpbmdcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1zcGFjaW5nLXknOiBbe1xuICAgICAgICAnYm9yZGVyLXNwYWNpbmcteSc6IFtib3JkZXJTcGFjaW5nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRhYmxlIExheW91dFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RhYmxlLWxheW91dFxuICAgICAgICovXG4gICAgICAndGFibGUtbGF5b3V0JzogW3tcbiAgICAgICAgdGFibGU6IFsnYXV0bycsICdmaXhlZCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ2FwdGlvbiBTaWRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY2FwdGlvbi1zaWRlXG4gICAgICAgKi9cbiAgICAgIGNhcHRpb246IFt7XG4gICAgICAgIGNhcHRpb246IFsndG9wJywgJ2JvdHRvbSddXG4gICAgICB9XSxcbiAgICAgIC8vIFRyYW5zaXRpb25zIGFuZCBBbmltYXRpb25cbiAgICAgIC8qKlxuICAgICAgICogVHJhbmlzaXRpb24gUHJvcGVydHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2l0aW9uLXByb3BlcnR5XG4gICAgICAgKi9cbiAgICAgIHRyYW5zaXRpb246IFt7XG4gICAgICAgIHRyYW5zaXRpb246IFsnbm9uZScsICdhbGwnLCAnJywgJ2NvbG9ycycsICdvcGFjaXR5JywgJ3NoYWRvdycsICd0cmFuc2Zvcm0nLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zaXRpb24gRHVyYXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2l0aW9uLWR1cmF0aW9uXG4gICAgICAgKi9cbiAgICAgIGR1cmF0aW9uOiBbe1xuICAgICAgICBkdXJhdGlvbjogZ2V0TnVtYmVyQW5kQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2l0aW9uIFRpbWluZyBGdW5jdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIGVhc2U6IFt7XG4gICAgICAgIGVhc2U6IFsnbGluZWFyJywgJ2luJywgJ291dCcsICdpbi1vdXQnLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zaXRpb24gRGVsYXlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2l0aW9uLWRlbGF5XG4gICAgICAgKi9cbiAgICAgIGRlbGF5OiBbe1xuICAgICAgICBkZWxheTogZ2V0TnVtYmVyQW5kQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBBbmltYXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hbmltYXRpb25cbiAgICAgICAqL1xuICAgICAgYW5pbWF0ZTogW3tcbiAgICAgICAgYW5pbWF0ZTogWydub25lJywgJ3NwaW4nLCAncGluZycsICdwdWxzZScsICdib3VuY2UnLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvLyBUcmFuc2Zvcm1zXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zZm9ybVxuICAgICAgICovXG4gICAgICB0cmFuc2Zvcm06IFt7XG4gICAgICAgIHRyYW5zZm9ybTogWycnLCAnZ3B1JywgJ25vbmUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjYWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2NhbGVcbiAgICAgICAqL1xuICAgICAgc2NhbGU6IFt7XG4gICAgICAgIHNjYWxlOiBbc2NhbGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2NhbGUgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NjYWxlXG4gICAgICAgKi9cbiAgICAgICdzY2FsZS14JzogW3tcbiAgICAgICAgJ3NjYWxlLXgnOiBbc2NhbGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2NhbGUgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NjYWxlXG4gICAgICAgKi9cbiAgICAgICdzY2FsZS15JzogW3tcbiAgICAgICAgJ3NjYWxlLXknOiBbc2NhbGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUm90YXRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvcm90YXRlXG4gICAgICAgKi9cbiAgICAgIHJvdGF0ZTogW3tcbiAgICAgICAgcm90YXRlOiBbaXNJbnRlZ2VyLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zbGF0ZSBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNsYXRlXG4gICAgICAgKi9cbiAgICAgICd0cmFuc2xhdGUteCc6IFt7XG4gICAgICAgICd0cmFuc2xhdGUteCc6IFt0cmFuc2xhdGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNsYXRlIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2xhdGVcbiAgICAgICAqL1xuICAgICAgJ3RyYW5zbGF0ZS15JzogW3tcbiAgICAgICAgJ3RyYW5zbGF0ZS15JzogW3RyYW5zbGF0ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTa2V3IFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9za2V3XG4gICAgICAgKi9cbiAgICAgICdza2V3LXgnOiBbe1xuICAgICAgICAnc2tldy14JzogW3NrZXddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2tldyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2tld1xuICAgICAgICovXG4gICAgICAnc2tldy15JzogW3tcbiAgICAgICAgJ3NrZXcteSc6IFtza2V3XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSBPcmlnaW5cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2Zvcm0tb3JpZ2luXG4gICAgICAgKi9cbiAgICAgICd0cmFuc2Zvcm0tb3JpZ2luJzogW3tcbiAgICAgICAgb3JpZ2luOiBbJ2NlbnRlcicsICd0b3AnLCAndG9wLXJpZ2h0JywgJ3JpZ2h0JywgJ2JvdHRvbS1yaWdodCcsICdib3R0b20nLCAnYm90dG9tLWxlZnQnLCAnbGVmdCcsICd0b3AtbGVmdCcsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8vIEludGVyYWN0aXZpdHlcbiAgICAgIC8qKlxuICAgICAgICogQWNjZW50IENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYWNjZW50LWNvbG9yXG4gICAgICAgKi9cbiAgICAgIGFjY2VudDogW3tcbiAgICAgICAgYWNjZW50OiBbJ2F1dG8nLCBjb2xvcnNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQXBwZWFyYW5jZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FwcGVhcmFuY2VcbiAgICAgICAqL1xuICAgICAgYXBwZWFyYW5jZTogW3tcbiAgICAgICAgYXBwZWFyYW5jZTogWydub25lJywgJ2F1dG8nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEN1cnNvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2N1cnNvclxuICAgICAgICovXG4gICAgICBjdXJzb3I6IFt7XG4gICAgICAgIGN1cnNvcjogWydhdXRvJywgJ2RlZmF1bHQnLCAncG9pbnRlcicsICd3YWl0JywgJ3RleHQnLCAnbW92ZScsICdoZWxwJywgJ25vdC1hbGxvd2VkJywgJ25vbmUnLCAnY29udGV4dC1tZW51JywgJ3Byb2dyZXNzJywgJ2NlbGwnLCAnY3Jvc3NoYWlyJywgJ3ZlcnRpY2FsLXRleHQnLCAnYWxpYXMnLCAnY29weScsICduby1kcm9wJywgJ2dyYWInLCAnZ3JhYmJpbmcnLCAnYWxsLXNjcm9sbCcsICdjb2wtcmVzaXplJywgJ3Jvdy1yZXNpemUnLCAnbi1yZXNpemUnLCAnZS1yZXNpemUnLCAncy1yZXNpemUnLCAndy1yZXNpemUnLCAnbmUtcmVzaXplJywgJ253LXJlc2l6ZScsICdzZS1yZXNpemUnLCAnc3ctcmVzaXplJywgJ2V3LXJlc2l6ZScsICducy1yZXNpemUnLCAnbmVzdy1yZXNpemUnLCAnbndzZS1yZXNpemUnLCAnem9vbS1pbicsICd6b29tLW91dCcsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ2FyZXQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9qdXN0LWluLXRpbWUtbW9kZSNjYXJldC1jb2xvci11dGlsaXRpZXNcbiAgICAgICAqL1xuICAgICAgJ2NhcmV0LWNvbG9yJzogW3tcbiAgICAgICAgY2FyZXQ6IFtjb2xvcnNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUG9pbnRlciBFdmVudHNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wb2ludGVyLWV2ZW50c1xuICAgICAgICovXG4gICAgICAncG9pbnRlci1ldmVudHMnOiBbe1xuICAgICAgICAncG9pbnRlci1ldmVudHMnOiBbJ25vbmUnLCAnYXV0byddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmVzaXplXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcmVzaXplXG4gICAgICAgKi9cbiAgICAgIHJlc2l6ZTogW3tcbiAgICAgICAgcmVzaXplOiBbJ25vbmUnLCAneScsICd4JywgJyddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIEJlaGF2aW9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLWJlaGF2aW9yXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtYmVoYXZpb3InOiBbe1xuICAgICAgICBzY3JvbGw6IFsnYXV0bycsICdzbW9vdGgnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW5cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtbSc6IFt7XG4gICAgICAgICdzY3JvbGwtbSc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtbXgnOiBbe1xuICAgICAgICAnc2Nyb2xsLW14JzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1teSc6IFt7XG4gICAgICAgICdzY3JvbGwtbXknOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1tcyc6IFt7XG4gICAgICAgICdzY3JvbGwtbXMnOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtbWUnOiBbe1xuICAgICAgICAnc2Nyb2xsLW1lJzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gVG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICAnc2Nyb2xsLW10JzogW3tcbiAgICAgICAgJ3Njcm9sbC1tdCc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICAnc2Nyb2xsLW1yJzogW3tcbiAgICAgICAgJ3Njcm9sbC1tcic6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1tYic6IFt7XG4gICAgICAgICdzY3JvbGwtbWInOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICAnc2Nyb2xsLW1sJzogW3tcbiAgICAgICAgJ3Njcm9sbC1tbCc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZ1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtcCc6IFt7XG4gICAgICAgICdzY3JvbGwtcCc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1weCc6IFt7XG4gICAgICAgICdzY3JvbGwtcHgnOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtcHknOiBbe1xuICAgICAgICAnc2Nyb2xsLXB5JzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1wcyc6IFt7XG4gICAgICAgICdzY3JvbGwtcHMnOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1wZSc6IFt7XG4gICAgICAgICdzY3JvbGwtcGUnOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgVG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1wdCc6IFt7XG4gICAgICAgICdzY3JvbGwtcHQnOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICAnc2Nyb2xsLXByJzogW3tcbiAgICAgICAgJ3Njcm9sbC1wcic6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICAnc2Nyb2xsLXBiJzogW3tcbiAgICAgICAgJ3Njcm9sbC1wYic6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1wbCc6IFt7XG4gICAgICAgICdzY3JvbGwtcGwnOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFNuYXAgQWxpZ25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtc25hcC1hbGlnblxuICAgICAgICovXG4gICAgICAnc25hcC1hbGlnbic6IFt7XG4gICAgICAgIHNuYXA6IFsnc3RhcnQnLCAnZW5kJywgJ2NlbnRlcicsICdhbGlnbi1ub25lJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgU25hcCBTdG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXNuYXAtc3RvcFxuICAgICAgICovXG4gICAgICAnc25hcC1zdG9wJzogW3tcbiAgICAgICAgc25hcDogWydub3JtYWwnLCAnYWx3YXlzJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgU25hcCBUeXBlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXNuYXAtdHlwZVxuICAgICAgICovXG4gICAgICAnc25hcC10eXBlJzogW3tcbiAgICAgICAgc25hcDogWydub25lJywgJ3gnLCAneScsICdib3RoJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgU25hcCBUeXBlIFN0cmljdG5lc3NcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtc25hcC10eXBlXG4gICAgICAgKi9cbiAgICAgICdzbmFwLXN0cmljdG5lc3MnOiBbe1xuICAgICAgICBzbmFwOiBbJ21hbmRhdG9yeScsICdwcm94aW1pdHknXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRvdWNoIEFjdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvdWNoLWFjdGlvblxuICAgICAgICovXG4gICAgICB0b3VjaDogW3tcbiAgICAgICAgdG91Y2g6IFsnYXV0bycsICdub25lJywgJ21hbmlwdWxhdGlvbiddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG91Y2ggQWN0aW9uIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3VjaC1hY3Rpb25cbiAgICAgICAqL1xuICAgICAgJ3RvdWNoLXgnOiBbe1xuICAgICAgICAndG91Y2gtcGFuJzogWyd4JywgJ2xlZnQnLCAncmlnaHQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRvdWNoIEFjdGlvbiBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG91Y2gtYWN0aW9uXG4gICAgICAgKi9cbiAgICAgICd0b3VjaC15JzogW3tcbiAgICAgICAgJ3RvdWNoLXBhbic6IFsneScsICd1cCcsICdkb3duJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUb3VjaCBBY3Rpb24gUGluY2ggWm9vbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvdWNoLWFjdGlvblxuICAgICAgICovXG4gICAgICAndG91Y2gtcHonOiBbJ3RvdWNoLXBpbmNoLXpvb20nXSxcbiAgICAgIC8qKlxuICAgICAgICogVXNlciBTZWxlY3RcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy91c2VyLXNlbGVjdFxuICAgICAgICovXG4gICAgICBzZWxlY3Q6IFt7XG4gICAgICAgIHNlbGVjdDogWydub25lJywgJ3RleHQnLCAnYWxsJywgJ2F1dG8nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFdpbGwgQ2hhbmdlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvd2lsbC1jaGFuZ2VcbiAgICAgICAqL1xuICAgICAgJ3dpbGwtY2hhbmdlJzogW3tcbiAgICAgICAgJ3dpbGwtY2hhbmdlJzogWydhdXRvJywgJ3Njcm9sbCcsICdjb250ZW50cycsICd0cmFuc2Zvcm0nLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvLyBTVkdcbiAgICAgIC8qKlxuICAgICAgICogRmlsbFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZpbGxcbiAgICAgICAqL1xuICAgICAgZmlsbDogW3tcbiAgICAgICAgZmlsbDogW2NvbG9ycywgJ25vbmUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFN0cm9rZSBXaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3N0cm9rZS13aWR0aFxuICAgICAgICovXG4gICAgICAnc3Ryb2tlLXcnOiBbe1xuICAgICAgICBzdHJva2U6IFtpc0xlbmd0aCwgaXNBcmJpdHJhcnlMZW5ndGgsIGlzQXJiaXRyYXJ5TnVtYmVyXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFN0cm9rZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3N0cm9rZVxuICAgICAgICovXG4gICAgICBzdHJva2U6IFt7XG4gICAgICAgIHN0cm9rZTogW2NvbG9ycywgJ25vbmUnXVxuICAgICAgfV0sXG4gICAgICAvLyBBY2Nlc3NpYmlsaXR5XG4gICAgICAvKipcbiAgICAgICAqIFNjcmVlbiBSZWFkZXJzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2NyZWVuLXJlYWRlcnNcbiAgICAgICAqL1xuICAgICAgc3I6IFsnc3Itb25seScsICdub3Qtc3Itb25seSddLFxuICAgICAgLyoqXG4gICAgICAgKiBGb3JjZWQgQ29sb3IgQWRqdXN0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9yY2VkLWNvbG9yLWFkanVzdFxuICAgICAgICovXG4gICAgICAnZm9yY2VkLWNvbG9yLWFkanVzdCc6IFt7XG4gICAgICAgICdmb3JjZWQtY29sb3ItYWRqdXN0JzogWydhdXRvJywgJ25vbmUnXVxuICAgICAgfV1cbiAgICB9LFxuICAgIGNvbmZsaWN0aW5nQ2xhc3NHcm91cHM6IHtcbiAgICAgIG92ZXJmbG93OiBbJ292ZXJmbG93LXgnLCAnb3ZlcmZsb3cteSddLFxuICAgICAgb3ZlcnNjcm9sbDogWydvdmVyc2Nyb2xsLXgnLCAnb3ZlcnNjcm9sbC15J10sXG4gICAgICBpbnNldDogWydpbnNldC14JywgJ2luc2V0LXknLCAnc3RhcnQnLCAnZW5kJywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLFxuICAgICAgJ2luc2V0LXgnOiBbJ3JpZ2h0JywgJ2xlZnQnXSxcbiAgICAgICdpbnNldC15JzogWyd0b3AnLCAnYm90dG9tJ10sXG4gICAgICBmbGV4OiBbJ2Jhc2lzJywgJ2dyb3cnLCAnc2hyaW5rJ10sXG4gICAgICBnYXA6IFsnZ2FwLXgnLCAnZ2FwLXknXSxcbiAgICAgIHA6IFsncHgnLCAncHknLCAncHMnLCAncGUnLCAncHQnLCAncHInLCAncGInLCAncGwnXSxcbiAgICAgIHB4OiBbJ3ByJywgJ3BsJ10sXG4gICAgICBweTogWydwdCcsICdwYiddLFxuICAgICAgbTogWydteCcsICdteScsICdtcycsICdtZScsICdtdCcsICdtcicsICdtYicsICdtbCddLFxuICAgICAgbXg6IFsnbXInLCAnbWwnXSxcbiAgICAgIG15OiBbJ210JywgJ21iJ10sXG4gICAgICBzaXplOiBbJ3cnLCAnaCddLFxuICAgICAgJ2ZvbnQtc2l6ZSc6IFsnbGVhZGluZyddLFxuICAgICAgJ2Z2bi1ub3JtYWwnOiBbJ2Z2bi1vcmRpbmFsJywgJ2Z2bi1zbGFzaGVkLXplcm8nLCAnZnZuLWZpZ3VyZScsICdmdm4tc3BhY2luZycsICdmdm4tZnJhY3Rpb24nXSxcbiAgICAgICdmdm4tb3JkaW5hbCc6IFsnZnZuLW5vcm1hbCddLFxuICAgICAgJ2Z2bi1zbGFzaGVkLXplcm8nOiBbJ2Z2bi1ub3JtYWwnXSxcbiAgICAgICdmdm4tZmlndXJlJzogWydmdm4tbm9ybWFsJ10sXG4gICAgICAnZnZuLXNwYWNpbmcnOiBbJ2Z2bi1ub3JtYWwnXSxcbiAgICAgICdmdm4tZnJhY3Rpb24nOiBbJ2Z2bi1ub3JtYWwnXSxcbiAgICAgICdsaW5lLWNsYW1wJzogWydkaXNwbGF5JywgJ292ZXJmbG93J10sXG4gICAgICByb3VuZGVkOiBbJ3JvdW5kZWQtcycsICdyb3VuZGVkLWUnLCAncm91bmRlZC10JywgJ3JvdW5kZWQtcicsICdyb3VuZGVkLWInLCAncm91bmRlZC1sJywgJ3JvdW5kZWQtc3MnLCAncm91bmRlZC1zZScsICdyb3VuZGVkLWVlJywgJ3JvdW5kZWQtZXMnLCAncm91bmRlZC10bCcsICdyb3VuZGVkLXRyJywgJ3JvdW5kZWQtYnInLCAncm91bmRlZC1ibCddLFxuICAgICAgJ3JvdW5kZWQtcyc6IFsncm91bmRlZC1zcycsICdyb3VuZGVkLWVzJ10sXG4gICAgICAncm91bmRlZC1lJzogWydyb3VuZGVkLXNlJywgJ3JvdW5kZWQtZWUnXSxcbiAgICAgICdyb3VuZGVkLXQnOiBbJ3JvdW5kZWQtdGwnLCAncm91bmRlZC10ciddLFxuICAgICAgJ3JvdW5kZWQtcic6IFsncm91bmRlZC10cicsICdyb3VuZGVkLWJyJ10sXG4gICAgICAncm91bmRlZC1iJzogWydyb3VuZGVkLWJyJywgJ3JvdW5kZWQtYmwnXSxcbiAgICAgICdyb3VuZGVkLWwnOiBbJ3JvdW5kZWQtdGwnLCAncm91bmRlZC1ibCddLFxuICAgICAgJ2JvcmRlci1zcGFjaW5nJzogWydib3JkZXItc3BhY2luZy14JywgJ2JvcmRlci1zcGFjaW5nLXknXSxcbiAgICAgICdib3JkZXItdyc6IFsnYm9yZGVyLXctcycsICdib3JkZXItdy1lJywgJ2JvcmRlci13LXQnLCAnYm9yZGVyLXctcicsICdib3JkZXItdy1iJywgJ2JvcmRlci13LWwnXSxcbiAgICAgICdib3JkZXItdy14JzogWydib3JkZXItdy1yJywgJ2JvcmRlci13LWwnXSxcbiAgICAgICdib3JkZXItdy15JzogWydib3JkZXItdy10JywgJ2JvcmRlci13LWInXSxcbiAgICAgICdib3JkZXItY29sb3InOiBbJ2JvcmRlci1jb2xvci10JywgJ2JvcmRlci1jb2xvci1yJywgJ2JvcmRlci1jb2xvci1iJywgJ2JvcmRlci1jb2xvci1sJ10sXG4gICAgICAnYm9yZGVyLWNvbG9yLXgnOiBbJ2JvcmRlci1jb2xvci1yJywgJ2JvcmRlci1jb2xvci1sJ10sXG4gICAgICAnYm9yZGVyLWNvbG9yLXknOiBbJ2JvcmRlci1jb2xvci10JywgJ2JvcmRlci1jb2xvci1iJ10sXG4gICAgICAnc2Nyb2xsLW0nOiBbJ3Njcm9sbC1teCcsICdzY3JvbGwtbXknLCAnc2Nyb2xsLW1zJywgJ3Njcm9sbC1tZScsICdzY3JvbGwtbXQnLCAnc2Nyb2xsLW1yJywgJ3Njcm9sbC1tYicsICdzY3JvbGwtbWwnXSxcbiAgICAgICdzY3JvbGwtbXgnOiBbJ3Njcm9sbC1tcicsICdzY3JvbGwtbWwnXSxcbiAgICAgICdzY3JvbGwtbXknOiBbJ3Njcm9sbC1tdCcsICdzY3JvbGwtbWInXSxcbiAgICAgICdzY3JvbGwtcCc6IFsnc2Nyb2xsLXB4JywgJ3Njcm9sbC1weScsICdzY3JvbGwtcHMnLCAnc2Nyb2xsLXBlJywgJ3Njcm9sbC1wdCcsICdzY3JvbGwtcHInLCAnc2Nyb2xsLXBiJywgJ3Njcm9sbC1wbCddLFxuICAgICAgJ3Njcm9sbC1weCc6IFsnc2Nyb2xsLXByJywgJ3Njcm9sbC1wbCddLFxuICAgICAgJ3Njcm9sbC1weSc6IFsnc2Nyb2xsLXB0JywgJ3Njcm9sbC1wYiddLFxuICAgICAgdG91Y2g6IFsndG91Y2gteCcsICd0b3VjaC15JywgJ3RvdWNoLXB6J10sXG4gICAgICAndG91Y2gteCc6IFsndG91Y2gnXSxcbiAgICAgICd0b3VjaC15JzogWyd0b3VjaCddLFxuICAgICAgJ3RvdWNoLXB6JzogWyd0b3VjaCddXG4gICAgfSxcbiAgICBjb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnM6IHtcbiAgICAgICdmb250LXNpemUnOiBbJ2xlYWRpbmcnXVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gYmFzZUNvbmZpZyBDb25maWcgd2hlcmUgb3RoZXIgY29uZmlnIHdpbGwgYmUgbWVyZ2VkIGludG8uIFRoaXMgb2JqZWN0IHdpbGwgYmUgbXV0YXRlZC5cbiAqIEBwYXJhbSBjb25maWdFeHRlbnNpb24gUGFydGlhbCBjb25maWcgdG8gbWVyZ2UgaW50byB0aGUgYGJhc2VDb25maWdgLlxuICovXG5mdW5jdGlvbiBtZXJnZUNvbmZpZ3MoYmFzZUNvbmZpZywge1xuICBjYWNoZVNpemUsXG4gIHByZWZpeCxcbiAgc2VwYXJhdG9yLFxuICBleHRlbmQgPSB7fSxcbiAgb3ZlcnJpZGUgPSB7fVxufSkge1xuICBvdmVycmlkZVByb3BlcnR5KGJhc2VDb25maWcsICdjYWNoZVNpemUnLCBjYWNoZVNpemUpO1xuICBvdmVycmlkZVByb3BlcnR5KGJhc2VDb25maWcsICdwcmVmaXgnLCBwcmVmaXgpO1xuICBvdmVycmlkZVByb3BlcnR5KGJhc2VDb25maWcsICdzZXBhcmF0b3InLCBzZXBhcmF0b3IpO1xuICBmb3IgKGNvbnN0IGNvbmZpZ0tleSBpbiBvdmVycmlkZSkge1xuICAgIG92ZXJyaWRlQ29uZmlnUHJvcGVydGllcyhiYXNlQ29uZmlnW2NvbmZpZ0tleV0sIG92ZXJyaWRlW2NvbmZpZ0tleV0pO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGV4dGVuZCkge1xuICAgIG1lcmdlQ29uZmlnUHJvcGVydGllcyhiYXNlQ29uZmlnW2tleV0sIGV4dGVuZFtrZXldKTtcbiAgfVxuICByZXR1cm4gYmFzZUNvbmZpZztcbn1cbmZ1bmN0aW9uIG92ZXJyaWRlUHJvcGVydHkoYmFzZU9iamVjdCwgb3ZlcnJpZGVLZXksIG92ZXJyaWRlVmFsdWUpIHtcbiAgaWYgKG92ZXJyaWRlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGJhc2VPYmplY3Rbb3ZlcnJpZGVLZXldID0gb3ZlcnJpZGVWYWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gb3ZlcnJpZGVDb25maWdQcm9wZXJ0aWVzKGJhc2VPYmplY3QsIG92ZXJyaWRlT2JqZWN0KSB7XG4gIGlmIChvdmVycmlkZU9iamVjdCkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG92ZXJyaWRlT2JqZWN0KSB7XG4gICAgICBvdmVycmlkZVByb3BlcnR5KGJhc2VPYmplY3QsIGtleSwgb3ZlcnJpZGVPYmplY3Rba2V5XSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtZXJnZUNvbmZpZ1Byb3BlcnRpZXMoYmFzZU9iamVjdCwgbWVyZ2VPYmplY3QpIHtcbiAgaWYgKG1lcmdlT2JqZWN0KSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWVyZ2VPYmplY3QpIHtcbiAgICAgIGNvbnN0IG1lcmdlVmFsdWUgPSBtZXJnZU9iamVjdFtrZXldO1xuICAgICAgaWYgKG1lcmdlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBiYXNlT2JqZWN0W2tleV0gPSAoYmFzZU9iamVjdFtrZXldIHx8IFtdKS5jb25jYXQobWVyZ2VWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBleHRlbmRUYWlsd2luZE1lcmdlKGNvbmZpZ0V4dGVuc2lvbiwgLi4uY3JlYXRlQ29uZmlnKSB7XG4gIHJldHVybiB0eXBlb2YgY29uZmlnRXh0ZW5zaW9uID09PSAnZnVuY3Rpb24nID8gY3JlYXRlVGFpbHdpbmRNZXJnZShnZXREZWZhdWx0Q29uZmlnLCBjb25maWdFeHRlbnNpb24sIC4uLmNyZWF0ZUNvbmZpZykgOiBjcmVhdGVUYWlsd2luZE1lcmdlKCgpID0+IG1lcmdlQ29uZmlncyhnZXREZWZhdWx0Q29uZmlnKCksIGNvbmZpZ0V4dGVuc2lvbiksIC4uLmNyZWF0ZUNvbmZpZyk7XG59XG5jb25zdCB0d01lcmdlID0gLyojX19QVVJFX18qL2NyZWF0ZVRhaWx3aW5kTWVyZ2UoZ2V0RGVmYXVsdENvbmZpZyk7XG5leHBvcnQgeyBjcmVhdGVUYWlsd2luZE1lcmdlLCBleHRlbmRUYWlsd2luZE1lcmdlLCBmcm9tVGhlbWUsIGdldERlZmF1bHRDb25maWcsIG1lcmdlQ29uZmlncywgdHdKb2luLCB0d01lcmdlLCB2YWxpZGF0b3JzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW5kbGUtbWpzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tailwind-merge/dist/bundle-mjs.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["css-src_app_components_App_css","main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fidilatmaca%2FDesktop%2Fuolu%2FYOLOv9-object-detection%2Fapp%2Fsrc%2Fapp%2Fcomponents%2FApp.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);